(function(){"use strict";var __webpack_modules__={"./node_modules/@toast-ui/editor/dist/esm/index.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: function() { return /* binding */ ToastUIEditor; },\n/* harmony export */   EditorCore: function() { return /* binding */ ToastUIEditorCore; },\n/* harmony export */   "default": function() { return /* binding */ ToastUIEditor; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.js");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.js");\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-commands */ "./node_modules/prosemirror-commands/dist/index.js");\n/* harmony import */ var prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.js");\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-history */ "./node_modules/prosemirror-history/dist/index.js");\n/**\n * @toast-ui/editor\n * @version 3.2.2 | Fri Feb 17 2023\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */\n\n\n\n\n\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics$1 = function(d, b) {\r\n    extendStatics$1 = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics$1(d, b);\r\n};\r\n\r\nfunction __extends$1(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics$1(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign$1 = function() {\r\n    __assign$1 = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$1.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray$1(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n}\n\n/**\n * @fileoverview Execute the provided callback once for each property of object which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Execute the provided callback once for each property of object which actually exist.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property\n *  2) The name of the property\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee  Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachOwnProperties from \'tui-code-snippet/collection/forEachOwnProperties\';\n * \n * // CommonJS\n * const forEachOwnProperties = require(\'tui-code-snippet/collection/forEachOwnProperties\'); \n *\n * let sum = 0;\n *\n * forEachOwnProperties({a:1,b:2,c:3}, function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachOwnProperties$2(obj, iteratee, context) {\n  var key;\n\n  context = context || null;\n\n  for (key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (iteratee.call(context, obj[key], key, obj) === false) {\n        break;\n      }\n    }\n  }\n}\n\nvar forEachOwnProperties_1 = forEachOwnProperties$2;\n\n/**\n * @fileoverview Extend the target object from other objects.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * @module object\n */\n\n/**\n * Extend the target object from other objects.\n * @param {object} target - Object that will be extended\n * @param {...object} objects - Objects as sources\n * @returns {object} Extended object\n * @memberof module:object\n */\nfunction extend(target, objects) { // eslint-disable-line no-unused-vars\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n  var source, prop, i, len;\n\n  for (i = 1, len = arguments.length; i < len; i += 1) {\n    source = arguments[i];\n    for (prop in source) {\n      if (hasOwnProp.call(source, prop)) {\n        target[prop] = source[prop];\n      }\n    }\n  }\n\n  return target;\n}\n\nvar extend_1 = extend;\n\n/**\n * @fileoverview Check whether the given variable is a string or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a string or not.\n * If the given variable is a string, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is string?\n * @memberof module:type\n */\nfunction isString$3(obj) {\n  return typeof obj === \'string\' || obj instanceof String;\n}\n\nvar isString_1 = isString$3;\n\n/**\n * @fileoverview Check whether the given variable is an instance of Array or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is an instance of Array or not.\n * If the given variable is an instance of Array, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is array instance?\n * @memberof module:type\n */\nfunction isArray$3(obj) {\n  return obj instanceof Array;\n}\n\nvar isArray_1 = isArray$3;\n\n/**\n * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Execute the provided callback once for each element present\n * in the array(or Array-like object) in ascending order.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the element\n *  2) The index of the element\n *  3) The array(or Array-like object) being traversed\n * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachArray from \'tui-code-snippet/collection/forEachArray\';\n * \n * // CommonJS\n * const forEachArray = require(\'tui-code-snippet/collection/forEachArray\'); \n *\n * let sum = 0;\n *\n * forEachArray([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachArray$3(arr, iteratee, context) {\n  var index = 0;\n  var len = arr.length;\n\n  context = context || null;\n\n  for (; index < len; index += 1) {\n    if (iteratee.call(context, arr[index], index, arr) === false) {\n      break;\n    }\n  }\n}\n\nvar forEachArray_1 = forEachArray$3;\n\n/**\n * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isArray$2 = isArray_1;\nvar forEachArray$2 = forEachArray_1;\nvar forEachOwnProperties$1 = forEachOwnProperties_1;\n\n/**\n * @module collection\n */\n\n/**\n * Execute the provided callback once for each property of object(or element of array) which actually exist.\n * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see \'ex2\' of example).\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property(or The value of the element)\n *  2) The name of the property(or The index of the element)\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEach from \'tui-code-snippet/collection/forEach\'; \n * \n * // CommonJS\n * const forEach = require(\'tui-code-snippet/collection/forEach\'); \n *\n * let sum = 0;\n *\n * forEach([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n *\n * // In case of Array-like object\n * const array = Array.prototype.slice.call(arrayLike); // change to array\n * forEach(array, function(value){\n *   sum += value;\n * });\n */\nfunction forEach$4(obj, iteratee, context) {\n  if (isArray$2(obj)) {\n    forEachArray$2(obj, iteratee, context);\n  } else {\n    forEachOwnProperties$1(obj, iteratee, context);\n  }\n}\n\nvar forEach_1 = forEach$4;\n\n/**\n * @fileoverview Setting element style\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString$2 = isString_1;\nvar forEach$3 = forEach_1;\n\n/**\n * Setting element style\n * @param {(HTMLElement|SVGElement)} element - element to setting style\n * @param {(string|object)} key - style prop name or {prop: value} pair object\n * @param {string} [value] - style value\n * @memberof module:domUtil\n */\nfunction css(element, key, value) {\n  var style = element.style;\n\n  if (isString$2(key)) {\n    style[key] = value;\n\n    return;\n  }\n\n  forEach$3(key, function(v, k) {\n    style[k] = v;\n  });\n}\n\nvar css_1 = css;\n\n/* eslint-disable complexity */\n\nvar isArray$1 = isArray_1;\n\n/**\n * @module array\n */\n\n/**\n * Returns the first index at which a given element can be found in the array\n * from start index(default 0), or -1 if it is not present.\n * It compares searchElement to elements of the Array using strict equality\n * (the same method used by the ===, or triple-equals, operator).\n * @param {*} searchElement Element to locate in the array\n * @param {Array} array Array that will be traversed.\n * @param {number} startIndex Start index in array for searching (default 0)\n * @returns {number} the First index at which a given element, or -1 if it is not present\n * @memberof module:array\n * @example\n * // ES6\n * import inArray from \'tui-code-snippet/array/inArray\';\n * \n * // CommonJS\n * const inArray = require(\'tui-code-snippet/array/inArray\');\n *\n * const arr = [\'one\', \'two\', \'three\', \'four\'];\n * const idx1 = inArray(\'one\', arr, 3); // -1\n * const idx2 = inArray(\'one\', arr); // 0\n */\nfunction inArray$4(searchElement, array, startIndex) {\n  var i;\n  var length;\n  startIndex = startIndex || 0;\n\n  if (!isArray$1(array)) {\n    return -1;\n  }\n\n  if (Array.prototype.indexOf) {\n    return Array.prototype.indexOf.call(array, searchElement, startIndex);\n  }\n\n  length = array.length;\n  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {\n    if (array[i] === searchElement) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nvar inArray_1 = inArray$4;\n\n/**\n * @fileoverview Check whether the given variable is undefined or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is undefined or not.\n * If the given variable is undefined, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is undefined?\n * @memberof module:type\n */\nfunction isUndefined$4(obj) {\n  return obj === undefined; // eslint-disable-line no-undefined\n}\n\nvar isUndefined_1 = isUndefined$4;\n\n/**\n * @fileoverview Get HTML element\'s design classes.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined$3 = isUndefined_1;\n\n/**\n * Get HTML element\'s design classes.\n * @param {(HTMLElement|SVGElement)} element target element\n * @returns {string} element css class name\n * @memberof module:domUtil\n */\nfunction getClass$3(element) {\n  if (!element || !element.className) {\n    return \'\';\n  }\n\n  if (isUndefined$3(element.className.baseVal)) {\n    return element.className;\n  }\n\n  return element.className.baseVal;\n}\n\nvar getClass_1 = getClass$3;\n\n/**\n * @fileoverview Set className value\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isArray = isArray_1;\nvar isUndefined$2 = isUndefined_1;\n\n/**\n * Set className value\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {(string|string[])} cssClass - class names\n * @private\n */\nfunction setClassName$2(element, cssClass) {\n  cssClass = isArray(cssClass) ? cssClass.join(\' \') : cssClass;\n\n  cssClass = cssClass.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \'\');\n\n  if (isUndefined$2(element.className.baseVal)) {\n    element.className = cssClass;\n\n    return;\n  }\n\n  element.className.baseVal = cssClass;\n}\n\nvar _setClassName = setClassName$2;\n\n/**\n * @fileoverview Add css class to element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEach$2 = forEach_1;\nvar inArray$3 = inArray_1;\nvar getClass$2 = getClass_1;\nvar setClassName$1 = _setClassName;\n\n/**\n * domUtil module\n * @module domUtil\n */\n\n/**\n * Add css class to element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to add\n * @memberof module:domUtil\n */\nfunction addClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var newClass = [];\n  var origin;\n\n  if (classList) {\n    forEach$2(cssClass, function(name) {\n      element.classList.add(name);\n    });\n\n    return;\n  }\n\n  origin = getClass$2(element);\n\n  if (origin) {\n    cssClass = [].concat(origin.split(/\\s+/), cssClass);\n  }\n\n  forEach$2(cssClass, function(cls) {\n    if (inArray$3(cls, newClass) < 0) {\n      newClass.push(cls);\n    }\n  });\n\n  setClassName$1(element, newClass);\n}\n\nvar addClass_1 = addClass;\n\n/**\n * @fileoverview Remove css class from element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachArray$1 = forEachArray_1;\nvar inArray$2 = inArray_1;\nvar getClass$1 = getClass_1;\nvar setClassName = _setClassName;\n\n/**\n * Remove css class from element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to remove\n * @memberof module:domUtil\n */\nfunction removeClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var origin, newClass;\n\n  if (classList) {\n    forEachArray$1(cssClass, function(name) {\n      classList.remove(name);\n    });\n\n    return;\n  }\n\n  origin = getClass$1(element).split(/\\s+/);\n  newClass = [];\n  forEachArray$1(origin, function(name) {\n    if (inArray$2(name, cssClass) < 0) {\n      newClass.push(name);\n    }\n  });\n\n  setClassName(element, newClass);\n}\n\nvar removeClass_1 = removeClass;\n\n/**\n * @fileoverview Check whether the given variable is a number or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a number or not.\n * If the given variable is a number, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is number?\n * @memberof module:type\n */\nfunction isNumber(obj) {\n  return typeof obj === \'number\' || obj instanceof Number;\n}\n\nvar isNumber_1 = isNumber;\n\n/**\n * @fileoverview Check whether the given variable is null or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is null or not.\n * If the given variable(arguments[0]) is null, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is null?\n * @memberof module:type\n */\nfunction isNull$1(obj) {\n  return obj === null;\n}\n\nvar isNull_1 = isNull$1;\n\n/**\n * @fileoverview Request image ping.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachOwnProperties = forEachOwnProperties_1;\n\n/**\n * @module request\n */\n\n/**\n * Request image ping.\n * @param {String} url url for ping request\n * @param {Object} trackingInfo infos for make query string\n * @returns {HTMLElement}\n * @memberof module:request\n * @example\n * // ES6\n * import imagePing from \'tui-code-snippet/request/imagePing\';\n * \n * // CommonJS\n * const imagePing = require(\'tui-code-snippet/request/imagePing\');\n *\n * imagePing(\'https://www.google-analytics.com/collect\', {\n *   v: 1,\n *   t: \'event\',\n *   tid: \'trackingid\',\n *   cid: \'cid\',\n *   dp: \'dp\',\n *   dh: \'dh\'\n * });\n */\nfunction imagePing$1(url, trackingInfo) {\n  var trackingElement = document.createElement(\'img\');\n  var queryString = \'\';\n  forEachOwnProperties(trackingInfo, function(value, key) {\n    queryString += \'&\' + key + \'=\' + value;\n  });\n  queryString = queryString.substring(1);\n\n  trackingElement.src = url + \'?\' + queryString;\n\n  trackingElement.style.display = \'none\';\n  document.body.appendChild(trackingElement);\n  document.body.removeChild(trackingElement);\n\n  return trackingElement;\n}\n\nvar imagePing_1 = imagePing$1;\n\n/**\n * @fileoverview Send hostname on DOMContentLoaded.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined$1 = isUndefined_1;\nvar imagePing = imagePing_1;\n\nvar ms7days = 7 * 24 * 60 * 60 * 1000;\n\n/**\n * Check if the date has passed 7 days\n * @param {number} date - milliseconds\n * @returns {boolean}\n * @private\n */\nfunction isExpired(date) {\n  var now = new Date().getTime();\n\n  return now - date > ms7days;\n}\n\n/**\n * Send hostname on DOMContentLoaded.\n * To prevent hostname set tui.usageStatistics to false.\n * @param {string} appName - application name\n * @param {string} trackingId - GA tracking ID\n * @ignore\n */\nfunction sendHostname(appName, trackingId) {\n  var url = \'https://www.google-analytics.com/collect\';\n  var hostname = location.hostname;\n  var hitType = \'event\';\n  var eventCategory = \'use\';\n  var applicationKeyForStorage = \'TOAST UI \' + appName + \' for \' + hostname + \': Statistics\';\n  var date = window.localStorage.getItem(applicationKeyForStorage);\n\n  // skip if the flag is defined and is set to false explicitly\n  if (!isUndefined$1(window.tui) && window.tui.usageStatistics === false) {\n    return;\n  }\n\n  // skip if not pass seven days old\n  if (date && !isExpired(date)) {\n    return;\n  }\n\n  window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());\n\n  setTimeout(function() {\n    if (document.readyState === \'interactive\' || document.readyState === \'complete\') {\n      imagePing(url, {\n        v: 1,\n        t: hitType,\n        tid: trackingId,\n        cid: hostname,\n        dp: hostname,\n        dh: appName,\n        el: appName,\n        ec: eventCategory\n      });\n    }\n  }, 1000);\n}\n\nvar sendHostname_1 = sendHostname;\n\n/Mac/.test(navigator.platform);\nvar reSpaceMoreThanOne = /[\\u0020]+/g;\nvar reEscapeChars$1 = /[>(){}[\\]+-.!#|]/g;\nvar reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\\-._]*)(\\s|[^\\\\>])*\\/?>|<(\\/)([a-zA-Z_][a-zA-Z0-9\\-._]*)\\s*\\/?>|\x3c!--[^-]+--\x3e|<([a-zA-Z_][a-zA-Z0-9\\-.:/]*)>/g;\nvar reEscapeBackSlash = /\\\\[!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~\\\\]/g;\nvar reEscapePairedChars = /[*_~`]/g;\nvar reMdImageSyntax = /!\\[.*\\]\\(.*\\)/g;\nvar reEscapedCharInLinkSyntax = /[[\\]]/g;\nvar reEscapeBackSlashInSentence = /(?:^|[^\\\\])\\\\(?!\\\\)/g;\nvar XMLSPECIAL$1 = \'[&<>"]\';\nvar reXmlSpecial$1 = new RegExp(XMLSPECIAL$1, \'g\');\nfunction replaceUnsafeChar$1(char) {\n    switch (char) {\n        case \'&\':\n            return \'&amp;\';\n        case \'<\':\n            return \'&lt;\';\n        case \'>\':\n            return \'&gt;\';\n        case \'"\':\n            return \'&quot;\';\n        default:\n            return char;\n    }\n}\nfunction escapeXml$1(text) {\n    if (reXmlSpecial$1.test(text)) {\n        return text.replace(reXmlSpecial$1, replaceUnsafeChar$1);\n    }\n    return text;\n}\nfunction sendHostName() {\n    sendHostname_1(\'editor\', \'UA-129966929-1\');\n}\nfunction includes(arr, targetItem) {\n    return arr.indexOf(targetItem) !== -1;\n}\nvar availableLinkAttributes = [\'rel\', \'target\', \'hreflang\', \'type\'];\nvar reMarkdownTextToEscapeMap = {\n    codeblock: /(^ {4}[^\\n]+\\n*)+/,\n    thematicBreak: /^ *((\\* *){3,}|(- *){3,} *|(_ *){3,}) */,\n    atxHeading: /^(#{1,6}) +[\\s\\S]+/,\n    seTextheading: /^([^\\n]+)\\n *(=|-){2,} */,\n    blockquote: /^( *>[^\\n]+.*)+/,\n    list: /^ *(\\*+|-+|\\d+\\.) [\\s\\S]+/,\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +["(]([^\\n]+)[")])? */,\n    link: /!?\\[.*\\]\\(.*\\)/,\n    reflink: /!?\\[.*\\]\\s*\\[([^\\]]*)\\]/,\n    verticalBar: /\\u007C/,\n    fencedCodeblock: /^((`|~){3,})/,\n};\nfunction sanitizeLinkAttribute(attribute) {\n    if (!attribute) {\n        return null;\n    }\n    var linkAttributes = {};\n    availableLinkAttributes.forEach(function (key) {\n        if (!isUndefined_1(attribute[key])) {\n            linkAttributes[key] = attribute[key];\n        }\n    });\n    return linkAttributes;\n}\nfunction repeat$1(text, count) {\n    var result = \'\';\n    for (var i = 0; i < count; i += 1) {\n        result += text;\n    }\n    return result;\n}\nfunction isNeedEscapeText(text) {\n    var needEscape = false;\n    forEachOwnProperties_1(reMarkdownTextToEscapeMap, function (reMarkdownTextToEscape) {\n        if (reMarkdownTextToEscape.test(text)) {\n            needEscape = true;\n        }\n        return !needEscape;\n    });\n    return needEscape;\n}\nfunction escapeTextForLink(text) {\n    var imageSyntaxRanges = [];\n    var result = reMdImageSyntax.exec(text);\n    while (result) {\n        imageSyntaxRanges.push([result.index, result.index + result[0].length]);\n        result = reMdImageSyntax.exec(text);\n    }\n    return text.replace(reEscapedCharInLinkSyntax, function (matched, offset) {\n        var isDelimiter = imageSyntaxRanges.some(function (range) { return offset > range[0] && offset < range[1]; });\n        return isDelimiter ? matched : "\\\\" + matched;\n    });\n}\nfunction escape$1(text) {\n    var aheadReplacer = function (matched) { return "\\\\" + matched; };\n    var behindReplacer = function (matched) { return matched + "\\\\"; };\n    var escapedText = text.replace(reSpaceMoreThanOne, \' \');\n    if (reEscapeBackSlash.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlash, aheadReplacer);\n    }\n    if (reEscapeBackSlashInSentence.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlashInSentence, behindReplacer);\n    }\n    escapedText = escapedText.replace(reEscapePairedChars, aheadReplacer);\n    if (reEscapeHTML.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeHTML, aheadReplacer);\n    }\n    if (isNeedEscapeText(escapedText)) {\n        escapedText = escapedText.replace(reEscapeChars$1, aheadReplacer);\n    }\n    return escapedText;\n}\nfunction quote(text) {\n    var result;\n    if (text.indexOf(\'"\') === -1) {\n        result = \'""\';\n    }\n    else {\n        result = text.indexOf("\'") === -1 ? "\'\'" : \'()\';\n    }\n    return result[0] + text + result[1];\n}\nfunction isNil(value) {\n    return isNull_1(value) || isUndefined_1(value);\n}\nfunction shallowEqual(o1, o2) {\n    if (o1 === null && o1 === o2) {\n        return true;\n    }\n    if (typeof o1 !== \'object\' || typeof o2 !== \'object\' || isNil(o1) || isNil(o2)) {\n        return o1 === o2;\n    }\n    for (var key in o1) {\n        if (o1[key] !== o2[key]) {\n            return false;\n        }\n    }\n    for (var key in o2) {\n        if (!(key in o1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction last$1(arr) {\n    return arr[arr.length - 1];\n}\nfunction between$1(value, min, max) {\n    return value >= min && value <= max;\n}\nfunction isObject$1(obj) {\n    return typeof obj === \'object\' && obj !== null;\n}\nfunction deepMergedCopy(targetObj, obj) {\n    var resultObj = __assign$1({}, targetObj);\n    if (targetObj && obj) {\n        Object.keys(obj).forEach(function (prop) {\n            if (isObject$1(resultObj[prop])) {\n                if (Array.isArray(obj[prop])) {\n                    resultObj[prop] = deepCopyArray(obj[prop]);\n                }\n                else if (resultObj.hasOwnProperty(prop)) {\n                    resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);\n                }\n                else {\n                    resultObj[prop] = deepCopy(obj[prop]);\n                }\n            }\n            else {\n                resultObj[prop] = obj[prop];\n            }\n        });\n    }\n    return resultObj;\n}\nfunction deepCopyArray(items) {\n    return items.map(function (item) {\n        if (isObject$1(item)) {\n            return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);\n        }\n        return item;\n    });\n}\nfunction deepCopy(obj) {\n    var keys = Object.keys(obj);\n    if (!keys.length) {\n        return obj;\n    }\n    return keys.reduce(function (acc, prop) {\n        if (isObject$1(obj[prop])) {\n            acc[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);\n        }\n        else {\n            acc[prop] = obj[prop];\n        }\n        return acc;\n    }, {});\n}\nfunction assign(targetObj, obj) {\n    if (obj === void 0) { obj = {}; }\n    Object.keys(obj).forEach(function (prop) {\n        if (targetObj.hasOwnProperty(prop) && typeof targetObj[prop] === \'object\') {\n            if (Array.isArray(obj[prop])) {\n                targetObj[prop] = obj[prop];\n            }\n            else {\n                assign(targetObj[prop], obj[prop]);\n            }\n        }\n        else {\n            targetObj[prop] = obj[prop];\n        }\n    });\n    return targetObj;\n}\nfunction getSortedNumPair(valueA, valueB) {\n    return valueA > valueB ? [valueB, valueA] : [valueA, valueB];\n}\n\n/**\n * @fileoverview Transform the Array-like object to Array.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachArray = forEachArray_1;\n\n/**\n * Transform the Array-like object to Array.\n * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.\n * @param {*} arrayLike Array-like object\n * @returns {Array} Array\n * @memberof module:collection\n * @example\n * // ES6\n * import toArray from \'tui-code-snippet/collection/toArray\'; \n * \n * // CommonJS\n * const toArray = require(\'tui-code-snippet/collection/toArray\'); \n *\n * const arrayLike = {\n *   0: \'one\',\n *   1: \'two\',\n *   2: \'three\',\n *   3: \'four\',\n *   length: 4\n * };\n * const result = toArray(arrayLike);\n *\n * alert(result instanceof Array); // true\n * alert(result); // one,two,three,four\n */\nfunction toArray$1(arrayLike) {\n  var arr;\n  try {\n    arr = Array.prototype.slice.call(arrayLike);\n  } catch (e) {\n    arr = [];\n    forEachArray(arrayLike, function(value) {\n      arr.push(value);\n    });\n  }\n\n  return arr;\n}\n\nvar toArray_1 = toArray$1;\n\nfunction createParagraph(schema, content) {\n    var paragraph = schema.nodes.paragraph;\n    if (!content) {\n        return paragraph.createAndFill();\n    }\n    return paragraph.create(null, isString_1(content) ? schema.text(content) : content);\n}\nfunction createTextNode$1(schema, text, marks) {\n    return schema.text(text, marks);\n}\nfunction createTextSelection(tr, from, to) {\n    if (to === void 0) { to = from; }\n    var contentSize = tr.doc.content.size;\n    var size = contentSize > 0 ? contentSize - 1 : 1;\n    return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, Math.min(from, size), Math.min(to, size));\n}\nfunction addParagraph(tr, _a, schema) {\n    var pos = _a.pos;\n    tr.replaceWith(pos, pos, createParagraph(schema));\n    return tr.setSelection(createTextSelection(tr, pos + 1));\n}\nfunction replaceTextNode(_a) {\n    var state = _a.state, from = _a.from, startIndex = _a.startIndex, endIndex = _a.endIndex, createText = _a.createText;\n    var tr = state.tr, doc = state.doc, schema = state.schema;\n    for (var i = startIndex; i <= endIndex; i += 1) {\n        var _b = doc.child(i), nodeSize = _b.nodeSize, textContent = _b.textContent, content = _b.content;\n        var text = createText(textContent);\n        var node = text ? createTextNode$1(schema, text) : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n        var mappedFrom = tr.mapping.map(from);\n        var mappedTo = mappedFrom + content.size;\n        tr.replaceWith(mappedFrom, mappedTo, node);\n        from += nodeSize;\n    }\n    return tr;\n}\nfunction splitAndExtendBlock(tr, pos, text, node) {\n    var textLen = text.length;\n    tr.split(pos)\n        .delete(pos - textLen, pos)\n        .insert(tr.mapping.map(pos), node)\n        .setSelection(createTextSelection(tr, tr.mapping.map(pos) - textLen));\n}\n\nfunction getMdStartLine(mdNode) {\n    return mdNode.sourcepos[0][0];\n}\nfunction getMdEndLine(mdNode) {\n    return mdNode.sourcepos[1][0];\n}\nfunction getMdStartCh(mdNode) {\n    return mdNode.sourcepos[0][1];\n}\nfunction getMdEndCh(mdNode) {\n    return mdNode.sourcepos[1][1];\n}\nfunction isHTMLNode(mdNode) {\n    var type = mdNode.type;\n    return type === \'htmlBlock\' || type === \'htmlInline\';\n}\nfunction isStyledInlineNode(mdNode) {\n    var type = mdNode.type;\n    return (type === \'strike\' ||\n        type === \'strong\' ||\n        type === \'emph\' ||\n        type === \'code\' ||\n        type === \'link\' ||\n        type === \'image\');\n}\nfunction isCodeBlockNode(mdNode) {\n    return mdNode && mdNode.type === \'codeBlock\';\n}\nfunction isListNode$1(mdNode) {\n    return mdNode && (mdNode.type === \'item\' || mdNode.type === \'list\');\n}\nfunction isOrderedListNode(mdNode) {\n    return isListNode$1(mdNode) && mdNode.listData.type === \'ordered\';\n}\nfunction isBulletListNode(mdNode) {\n    return isListNode$1(mdNode) && mdNode.listData.type !== \'ordered\';\n}\nfunction isTableCellNode(mdNode) {\n    return mdNode && (mdNode.type === \'tableCell\' || mdNode.type === \'tableDelimCell\');\n}\nfunction isInlineNode$1(mdNode) {\n    switch (mdNode.type) {\n        case \'code\':\n        case \'text\':\n        case \'emph\':\n        case \'strong\':\n        case \'strike\':\n        case \'link\':\n        case \'image\':\n        case \'htmlInline\':\n        case \'linebreak\':\n        case \'softbreak\':\n        case \'customInline\':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction findClosestNode(mdNode, condition, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== \'document\') {\n        if (condition(mdNode)) {\n            return mdNode;\n        }\n        mdNode = mdNode.parent;\n    }\n    return null;\n}\nfunction traverseParentNodes(mdNode, iteratee, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== \'document\') {\n        iteratee(mdNode);\n        mdNode = mdNode.parent;\n    }\n}\nfunction addOffsetPos(originPos, offset) {\n    return [originPos[0], originPos[1] + offset];\n}\nfunction setOffsetPos(originPos, newOffset) {\n    return [originPos[0], newOffset];\n}\nfunction getInlineMarkdownText(mdNode) {\n    var text = mdNode.firstChild.literal;\n    switch (mdNode.type) {\n        case \'emph\':\n            return "*" + text + "*";\n        case \'strong\':\n            return "**" + text + "**";\n        case \'strike\':\n            return "~~" + text + "~~";\n        case \'code\':\n            return "`" + text + "`";\n        case \'link\':\n        case \'image\':\n            /* eslint-disable no-case-declarations */\n            var _a = mdNode, destination = _a.destination, title = _a.title;\n            var delim = mdNode.type === \'link\' ? \'\' : \'!\';\n            return delim + "[" + text + "](" + destination + (title ? " \\"" + title + "\\"" : \'\') + ")";\n        default:\n            return null;\n    }\n}\nfunction isContainer$2(node) {\n    switch (node.type) {\n        case \'document\':\n        case \'blockQuote\':\n        case \'list\':\n        case \'item\':\n        case \'paragraph\':\n        case \'heading\':\n        case \'emph\':\n        case \'strong\':\n        case \'strike\':\n        case \'link\':\n        case \'image\':\n        case \'table\':\n        case \'tableHead\':\n        case \'tableBody\':\n        case \'tableRow\':\n        case \'tableCell\':\n        case \'tableDelimRow\':\n        case \'customInline\':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getChildrenText$1(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var childNode = event.node;\n        if (childNode.type === \'text\') {\n            buffer.push(childNode.literal);\n        }\n    }\n    return buffer.join(\'\');\n}\n\nvar widgetRules = [];\nvar widgetRuleMap = {};\nvar reWidgetPrefix = /\\$\\$widget\\d+\\s/;\nfunction unwrapWidgetSyntax(text) {\n    var index = text.search(reWidgetPrefix);\n    if (index !== -1) {\n        var rest = text.substring(index);\n        var replaced = rest.replace(reWidgetPrefix, \'\').replace(\'$$\', \'\');\n        text = text.substring(0, index);\n        text += unwrapWidgetSyntax(replaced);\n    }\n    return text;\n}\nfunction createWidgetContent(info, text) {\n    return "$$" + info + " " + text + "$$";\n}\nfunction widgetToDOM(info, text) {\n    var _a = widgetRuleMap[info], rule = _a.rule, toDOM = _a.toDOM;\n    var matches = unwrapWidgetSyntax(text).match(rule);\n    if (matches) {\n        text = matches[0];\n    }\n    return toDOM(text);\n}\nfunction getWidgetRules() {\n    return widgetRules;\n}\nfunction setWidgetRules(rules) {\n    widgetRules = rules;\n    widgetRules.forEach(function (rule, index) {\n        widgetRuleMap["widget" + index] = rule;\n    });\n}\nfunction mergeNodes(nodes, text, schema, ruleIndex) {\n    return nodes.concat(createNodesWithWidget(text, schema, ruleIndex));\n}\n/**\n * create nodes with plain text and replace text matched to the widget rules with the widget node\n * For example, in case the text and widget rules as below\n *\n * text: $test plain text #test\n * widget rules: [{ rule: /$.+/ }, { rule: /#.+/ }]\n *\n * The creating node process is recursive and is as follows.\n *\n * in first widget rule(/$.+/)\n *  $test -> widget node\n *  plain text -> match with next widget rule\n *  #test -> match with next widget rule\n *\n * in second widget rule(/#.+/)\n *  plain text -> text node(no rule for matching)\n *  #test -> widget node\n */\nfunction createNodesWithWidget(text, schema, ruleIndex) {\n    if (ruleIndex === void 0) { ruleIndex = 0; }\n    var nodes = [];\n    var rule = (widgetRules[ruleIndex] || {}).rule;\n    var nextRuleIndex = ruleIndex + 1;\n    text = unwrapWidgetSyntax(text);\n    if (rule && rule.test(text)) {\n        var index = void 0;\n        while ((index = text.search(rule)) !== -1) {\n            var prev = text.substring(0, index);\n            // get widget node on first splitted text using next widget rule\n            if (prev) {\n                nodes = mergeNodes(nodes, prev, schema, nextRuleIndex);\n            }\n            // build widget node using current widget rule\n            text = text.substring(index);\n            var literal = text.match(rule)[0];\n            var info = "widget" + ruleIndex;\n            nodes.push(schema.nodes.widget.create({ info: info }, schema.text(createWidgetContent(info, literal))));\n            text = text.substring(literal.length);\n        }\n        // get widget node on last splitted text using next widget rule\n        if (text) {\n            nodes = mergeNodes(nodes, text, schema, nextRuleIndex);\n        }\n    }\n    else if (text) {\n        nodes =\n            ruleIndex < widgetRules.length - 1\n                ? mergeNodes(nodes, text, schema, nextRuleIndex)\n                : [schema.text(text)];\n    }\n    return nodes;\n}\nfunction getWidgetContent(widgetNode) {\n    var event;\n    var text = \'\';\n    var walker = widgetNode.walker();\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            if (node !== widgetNode && node.type !== \'text\') {\n                text += getInlineMarkdownText(node);\n                // skip the children\n                walker.resumeAt(widgetNode, false);\n                walker.next();\n            }\n            else if (node.type === \'text\') {\n                text += node.literal;\n            }\n        }\n    }\n    return text;\n}\n\nfunction getDefaultCommands() {\n    return {\n        deleteSelection: function () { return prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.deleteSelection; },\n        selectAll: function () { return prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.selectAll; },\n        undo: function () { return prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo; },\n        redo: function () { return prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.redo; },\n    };\n}\n\nfunction placeholder(options) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            decorations: function (state) {\n                var doc = state.doc;\n                if (options.text &&\n                    doc.childCount === 1 &&\n                    doc.firstChild.isTextblock &&\n                    doc.firstChild.content.size === 0) {\n                    var placeHolder = document.createElement(\'span\');\n                    addClass_1(placeHolder, \'placeholder\');\n                    if (options.className) {\n                        addClass_1(placeHolder, options.className);\n                    }\n                    placeHolder.textContent = options.text;\n                    return prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet.create(doc, [prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.widget(1, placeHolder)]);\n                }\n                return null;\n            },\n        },\n    });\n}\n\n/**\n * @fileoverview Check element has specific css class\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar inArray$1 = inArray_1;\nvar getClass = getClass_1;\n\n/**\n * Check element has specific css class\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {string} cssClass - css class\n * @returns {boolean}\n * @memberof module:domUtil\n */\nfunction hasClass(element, cssClass) {\n  var origin;\n\n  if (element.classList) {\n    return element.classList.contains(cssClass);\n  }\n\n  origin = getClass(element).split(/\\s+/);\n\n  return inArray$1(cssClass, origin) > -1;\n}\n\nvar hasClass_1 = hasClass;\n\n/**\n * @fileoverview Check element match selector\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar inArray = inArray_1;\nvar toArray = toArray_1;\n\nvar elProto = Element.prototype;\nvar matchSelector = elProto.matches ||\n    elProto.webkitMatchesSelector ||\n    elProto.mozMatchesSelector ||\n    elProto.msMatchesSelector ||\n    function(selector) {\n      var doc = this.document || this.ownerDocument;\n\n      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;\n    };\n\n/**\n * Check element match selector\n * @param {HTMLElement} element - element to check\n * @param {string} selector - selector to check\n * @returns {boolean} is selector matched to element?\n * @memberof module:domUtil\n */\nfunction matches(element, selector) {\n  return matchSelector.call(element, selector);\n}\n\nvar matches_1 = matches;\n\nvar TAG_NAME = \'[A-Za-z][A-Za-z0-9-]*\';\nvar ATTRIBUTE_NAME = \'[a-zA-Z_:][a-zA-Z0-9:._-]*\';\nvar UNQUOTED_VALUE = \'[^"\\\'=<>`\\\\x00-\\\\x20]+\';\nvar SINGLE_QUOTED_VALUE = "\'[^\']*\'";\nvar DOUBLE_QUOTED_VALUE = \'"[^"]*"\';\nvar ATTRIBUTE_VALUE = "(?:" + UNQUOTED_VALUE + "|" + SINGLE_QUOTED_VALUE + "|" + DOUBLE_QUOTED_VALUE + ")";\nvar ATTRIBUTE_VALUE_SPEC = "" + \'(?:\\\\s*=\\\\s*\' + ATTRIBUTE_VALUE + ")";\nvar ATTRIBUTE$1 = "" + \'(?:\\\\s+\' + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + "?)";\nvar OPEN_TAG = "<(" + TAG_NAME + ")(" + ATTRIBUTE$1 + ")*\\\\s*/?>";\nvar CLOSE_TAG = "</(" + TAG_NAME + ")\\\\s*[>]";\nvar HTML_TAG = "(?:" + OPEN_TAG + "|" + CLOSE_TAG + ")";\nvar reHTMLTag = new RegExp("^" + HTML_TAG, \'i\');\nvar reBR = /<br\\s*\\/*>/i;\nvar reHTMLComment = /<! ----\x3e|\x3c!--(?:-?[^>-])(?:-?[^-])*--\x3e/;\nvar ALTERNATIVE_TAG_FOR_BR = \'</p><p>\';\n\nfunction isPositionInBox(style, offsetX, offsetY) {\n    var left = parseInt(style.left, 10);\n    var top = parseInt(style.top, 10);\n    var width = parseInt(style.width, 10) + parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);\n    var height = parseInt(style.height, 10) + parseInt(style.paddingTop, 10) + parseInt(style.paddingBottom, 10);\n    return offsetX >= left && offsetX <= left + width && offsetY >= top && offsetY <= top + height;\n}\nvar CLS_PREFIX = \'toastui-editor-\';\nfunction cls() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    var result = [];\n    for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {\n        var name_1 = names_1[_a];\n        var className = void 0;\n        if (Array.isArray(name_1)) {\n            className = name_1[0] ? name_1[1] : null;\n        }\n        else {\n            className = name_1;\n        }\n        if (className) {\n            result.push("" + CLS_PREFIX + className);\n        }\n    }\n    return result.join(\' \');\n}\nfunction clsWithMdPrefix() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    return names.map(function (className) { return CLS_PREFIX + "md-" + className; }).join(\' \');\n}\nfunction isTextNode(node) {\n    return (node === null || node === void 0 ? void 0 : node.nodeType) === Node.TEXT_NODE;\n}\nfunction isElemNode(node) {\n    return node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction findNodes(element, selector) {\n    var nodeList = toArray_1(element.querySelectorAll(selector));\n    if (nodeList.length) {\n        return nodeList;\n    }\n    return [];\n}\nfunction appendNodes(node, nodesToAppend) {\n    nodesToAppend = isArray_1(nodesToAppend) ? toArray_1(nodesToAppend) : [nodesToAppend];\n    nodesToAppend.forEach(function (nodeToAppend) {\n        node.appendChild(nodeToAppend);\n    });\n}\nfunction insertBeforeNode(insertedNode, node) {\n    if (node.parentNode) {\n        node.parentNode.insertBefore(insertedNode, node);\n    }\n}\nfunction removeNode$1(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction unwrapNode(node) {\n    var result = [];\n    while (node.firstChild) {\n        result.push(node.firstChild);\n        if (node.parentNode) {\n            node.parentNode.insertBefore(node.firstChild, node);\n        }\n    }\n    removeNode$1(node);\n    return result;\n}\nfunction toggleClass(element, className, state) {\n    if (isUndefined_1(state)) {\n        state = !hasClass_1(element, className);\n    }\n    var toggleFn = state ? addClass_1 : removeClass_1;\n    toggleFn(element, className);\n}\nfunction createElementWith(contents, target) {\n    var container = document.createElement(\'div\');\n    if (isString_1(contents)) {\n        container.innerHTML = contents;\n    }\n    else {\n        container.appendChild(contents);\n    }\n    var firstChild = container.firstChild;\n    if (target) {\n        target.appendChild(firstChild);\n    }\n    return firstChild;\n}\nfunction getOuterWidth(el) {\n    var computed = window.getComputedStyle(el);\n    return ([\'margin-left\', \'margin-right\'].reduce(function (acc, type) { return acc + parseInt(computed.getPropertyValue(type), 10); }, 0) + el.offsetWidth);\n}\nfunction closest(node, found) {\n    var condition;\n    if (isString_1(found)) {\n        condition = function (target) { return matches_1(target, found); };\n    }\n    else {\n        condition = function (target) { return target === found; };\n    }\n    while (node && node !== document) {\n        if (isElemNode(node) && condition(node)) {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nfunction getTotalOffset(el, root) {\n    var offsetTop = 0;\n    var offsetLeft = 0;\n    while (el && el !== root) {\n        var top_1 = el.offsetTop, left = el.offsetLeft, offsetParent = el.offsetParent;\n        offsetTop += top_1;\n        offsetLeft += left;\n        if (offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.offsetParent;\n    }\n    return { offsetTop: offsetTop, offsetLeft: offsetLeft };\n}\nfunction setAttributes(attributes, element) {\n    Object.keys(attributes).forEach(function (attrName) {\n        if (isNil(attributes[attrName])) {\n            element.removeAttribute(attrName);\n        }\n        else {\n            element.setAttribute(attrName, attributes[attrName]);\n        }\n    });\n}\nfunction replaceBRWithEmptyBlock(html) {\n    // remove br in paragraph to compatible with markdown\n    var replacedHTML = html.replace(/<p><br\\s*\\/*><\\/p>/gi, \'<p></p>\');\n    var reHTMLTag = new RegExp(HTML_TAG, \'ig\');\n    var htmlTagMatched = replacedHTML.match(reHTMLTag);\n    htmlTagMatched === null || htmlTagMatched === void 0 ? void 0 : htmlTagMatched.forEach(function (htmlTag, index) {\n        if (reBR.test(htmlTag)) {\n            var alternativeTag = ALTERNATIVE_TAG_FOR_BR;\n            if (index) {\n                var prevTag = htmlTagMatched[index - 1];\n                var openTagMatched = prevTag.match(OPEN_TAG);\n                if (openTagMatched && !/br/i.test(openTagMatched[1])) {\n                    var tagName = openTagMatched[1];\n                    alternativeTag = "</" + tagName + "><" + tagName + ">";\n                }\n            }\n            replacedHTML = replacedHTML.replace(reBR, alternativeTag);\n        }\n    });\n    return replacedHTML;\n}\nfunction removeProseMirrorHackNodes(html) {\n    var reProseMirrorImage = /<img class="ProseMirror-separator" alt="">/g;\n    var reProseMirrorTrailingBreak = / class="ProseMirror-trailingBreak"/g;\n    var resultHTML = html;\n    resultHTML = resultHTML.replace(reProseMirrorImage, \'\');\n    resultHTML = resultHTML.replace(reProseMirrorTrailingBreak, \'\');\n    return resultHTML;\n}\n\nvar pluginKey$1 = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\'widget\');\nvar MARGIN = 5;\nvar PopupWidget = /** @class */ (function () {\n    function PopupWidget(view, eventEmitter) {\n        var _this = this;\n        this.popup = null;\n        this.removeWidget = function () {\n            if (_this.popup) {\n                _this.rootEl.removeChild(_this.popup);\n                _this.popup = null;\n            }\n        };\n        this.rootEl = view.dom.parentElement;\n        this.eventEmitter = eventEmitter;\n        this.eventEmitter.listen(\'blur\', this.removeWidget);\n        this.eventEmitter.listen(\'loadUI\', function () {\n            _this.rootEl = closest(view.dom.parentElement, "." + cls(\'defaultUI\'));\n        });\n        this.eventEmitter.listen(\'removePopupWidget\', this.removeWidget);\n    }\n    PopupWidget.prototype.update = function (view) {\n        var widget = pluginKey$1.getState(view.state);\n        this.removeWidget();\n        if (widget) {\n            var node = widget.node, style = widget.style;\n            var _a = view.coordsAtPos(widget.pos), top_1 = _a.top, left = _a.left, bottom = _a.bottom;\n            var height = bottom - top_1;\n            var rect = this.rootEl.getBoundingClientRect();\n            var relTopPos = top_1 - rect.top;\n            css_1(node, { opacity: \'0\' });\n            this.rootEl.appendChild(node);\n            css_1(node, {\n                position: \'absolute\',\n                left: left - rect.left + MARGIN + "px",\n                top: (style === \'bottom\' ? relTopPos + height - MARGIN : relTopPos - height) + "px",\n                opacity: \'1\',\n            });\n            this.popup = node;\n            view.focus();\n        }\n    };\n    PopupWidget.prototype.destroy = function () {\n        this.eventEmitter.removeEventHandler(\'blur\', this.removeWidget);\n    };\n    return PopupWidget;\n}());\nfunction addWidget(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: pluginKey$1,\n        state: {\n            init: function () {\n                return null;\n            },\n            apply: function (tr) {\n                return tr.getMeta(\'widget\');\n            },\n        },\n        view: function (editorView) {\n            return new PopupWidget(editorView, eventEmitter);\n        },\n    });\n}\n\nfunction addDefaultImageBlobHook(eventEmitter) {\n    eventEmitter.listen(\'addImageBlobHook\', function (blob, callback) {\n        var reader = new FileReader();\n        reader.onload = function (_a) {\n            var target = _a.target;\n            return callback(target.result);\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nfunction emitImageBlobHook(eventEmitter, blob, type) {\n    var hook = function (imageUrl, altText) {\n        eventEmitter.emit(\'command\', \'addImage\', {\n            imageUrl: imageUrl,\n            altText: altText || blob.name || \'image\',\n        });\n    };\n    eventEmitter.emit(\'addImageBlobHook\', blob, hook, type);\n}\nfunction pasteImageOnly(items) {\n    var images = toArray_1(items).filter(function (_a) {\n        var type = _a.type;\n        return type.indexOf(\'image\') !== -1;\n    });\n    if (images.length === 1) {\n        var item = images[0];\n        if (item) {\n            return item.getAsFile();\n        }\n    }\n    return null;\n}\n\nfunction dropImage(_a) {\n    var eventEmitter = _a.eventEmitter;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                drop: function (_, ev) {\n                    var _a;\n                    var items = (_a = ev.dataTransfer) === null || _a === void 0 ? void 0 : _a.files;\n                    if (items) {\n                        forEachArray_1(items, function (item) {\n                            if (item.type.indexOf(\'image\') !== -1) {\n                                ev.preventDefault();\n                                ev.stopPropagation();\n                                emitImageBlobHook(eventEmitter, item, ev.type);\n                                return false;\n                            }\n                            return true;\n                        });\n                    }\n                    return true;\n                },\n            },\n        },\n    });\n}\n\nvar Node$2 = /** @class */ (function () {\n    function Node() {\n    }\n    Object.defineProperty(Node.prototype, "type", {\n        get: function () {\n            return \'node\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Node.prototype.setContext = function (context) {\n        this.context = context;\n    };\n    return Node;\n}());\n\nfunction widgetNodeView(pmNode) {\n    var dom = document.createElement(\'span\');\n    var node = widgetToDOM(pmNode.attrs.info, pmNode.textContent);\n    dom.className = \'tui-widget\';\n    dom.appendChild(node);\n    return { dom: dom };\n}\nfunction isWidgetNode(pmNode) {\n    return pmNode.type.name === \'widget\';\n}\nvar Widget = /** @class */ (function (_super) {\n    __extends$1(Widget, _super);\n    function Widget() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Widget.prototype, "name", {\n        get: function () {\n            return \'widget\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, "schema", {\n        get: function () {\n            return {\n                attrs: {\n                    info: { default: null },\n                },\n                group: \'inline\',\n                inline: true,\n                content: \'text*\',\n                selectable: false,\n                atom: true,\n                toDOM: function () {\n                    return [\'span\', { class: \'tui-widget\' }, 0];\n                },\n                parseDOM: [\n                    {\n                        tag: \'span.tui-widget\',\n                        getAttrs: function (dom) {\n                            var text = dom.textContent;\n                            var _a = text.match(/\\$\\$(widget\\d+)/), info = _a[1];\n                            return { info: info };\n                        },\n                    },\n                ],\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Widget;\n}(Node$2));\n\nvar EditorBase = /** @class */ (function () {\n    function EditorBase(eventEmitter) {\n        this.timer = null;\n        this.el = document.createElement(\'div\');\n        this.el.className = \'toastui-editor\';\n        this.eventEmitter = eventEmitter;\n        this.placeholder = { text: \'\' };\n    }\n    EditorBase.prototype.createState = function () {\n        return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n            schema: this.schema,\n            plugins: this.createPlugins(),\n        });\n    };\n    EditorBase.prototype.initEvent = function () {\n        var _a = this, eventEmitter = _a.eventEmitter, view = _a.view, editorType = _a.editorType;\n        view.dom.addEventListener(\'focus\', function () { return eventEmitter.emit(\'focus\', editorType); });\n        view.dom.addEventListener(\'blur\', function () { return eventEmitter.emit(\'blur\', editorType); });\n    };\n    EditorBase.prototype.emitChangeEvent = function (tr) {\n        this.eventEmitter.emit(\'caretChange\', this.editorType);\n        if (tr.docChanged) {\n            this.eventEmitter.emit(\'change\', this.editorType);\n        }\n    };\n    Object.defineProperty(EditorBase.prototype, "defaultPlugins", {\n        get: function () {\n            var rules = this.createInputRules();\n            var plugins = __spreadArray$1(__spreadArray$1([], this.keymaps), [\n                (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(__assign$1({ \'Shift-Enter\': prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.baseKeymap.Enter }, prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.baseKeymap)),\n                (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.history)(),\n                placeholder(this.placeholder),\n                addWidget(this.eventEmitter),\n                dropImage(this.context),\n            ]);\n            return rules ? plugins.concat(rules) : plugins;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EditorBase.prototype.createInputRules = function () {\n        var widgetRules = getWidgetRules();\n        var rules = widgetRules.map(function (_a) {\n            var rule = _a.rule;\n            return new prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.InputRule(rule, function (state, match, start, end) {\n                var schema = state.schema, tr = state.tr, doc = state.doc;\n                var allMatched = match.input.match(new RegExp(rule, \'g\'));\n                var pos = doc.resolve(start);\n                var parent = pos.parent;\n                var count = 0;\n                if (isWidgetNode(parent)) {\n                    parent = pos.node(pos.depth - 1);\n                }\n                parent.forEach(function (child) { return isWidgetNode(child) && (count += 1); });\n                // replace the content only if the count of matched rules in whole text is greater than current widget node count\n                if (allMatched.length > count) {\n                    var content = last$1(allMatched);\n                    var nodes = createNodesWithWidget(content, schema);\n                    // adjust start position based on widget content\n                    return tr.replaceWith(end - content.length + 1, end, nodes);\n                }\n                return null;\n            });\n        });\n        return rules.length ? (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.inputRules)({ rules: rules }) : null;\n    };\n    EditorBase.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    EditorBase.prototype.createSchema = function () {\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Schema({\n            nodes: this.specs.nodes,\n            marks: this.specs.marks,\n        });\n    };\n    EditorBase.prototype.createKeymaps = function (useCommandShortcut) {\n        var _a = getDefaultCommands(), undo = _a.undo, redo = _a.redo;\n        var allKeymaps = this.specs.keymaps(useCommandShortcut);\n        var historyKeymap = {\n            \'Mod-z\': undo(),\n            \'Shift-Mod-z\': redo(),\n        };\n        return useCommandShortcut ? allKeymaps.concat((0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(historyKeymap)) : allKeymaps;\n    };\n    EditorBase.prototype.createCommands = function () {\n        return this.specs.commands(this.view);\n    };\n    EditorBase.prototype.createPluginProps = function () {\n        var _this = this;\n        return this.extraPlugins.map(function (plugin) { return plugin(_this.eventEmitter); });\n    };\n    EditorBase.prototype.focus = function () {\n        var _this = this;\n        this.clearTimer();\n        // prevent the error for IE11\n        this.timer = setTimeout(function () {\n            _this.view.focus();\n            _this.view.dispatch(_this.view.state.tr.scrollIntoView());\n        });\n    };\n    EditorBase.prototype.blur = function () {\n        this.view.dom.blur();\n    };\n    EditorBase.prototype.destroy = function () {\n        var _this = this;\n        this.clearTimer();\n        this.view.destroy();\n        Object.keys(this).forEach(function (prop) {\n            delete _this[prop];\n        });\n    };\n    EditorBase.prototype.moveCursorToStart = function (focus) {\n        var tr = this.view.state.tr;\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, 1)).scrollIntoView());\n        if (focus) {\n            this.focus();\n        }\n    };\n    EditorBase.prototype.moveCursorToEnd = function (focus) {\n        var tr = this.view.state.tr;\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, tr.doc.content.size - 1)).scrollIntoView());\n        if (focus) {\n            this.focus();\n        }\n    };\n    EditorBase.prototype.setScrollTop = function (top) {\n        this.view.dom.scrollTop = top;\n    };\n    EditorBase.prototype.getScrollTop = function () {\n        return this.view.dom.scrollTop;\n    };\n    EditorBase.prototype.setPlaceholder = function (text) {\n        this.placeholder.text = text;\n        this.view.dispatch(this.view.state.tr.scrollIntoView());\n    };\n    EditorBase.prototype.setHeight = function (height) {\n        css_1(this.el, { height: height + "px" });\n    };\n    EditorBase.prototype.setMinHeight = function (minHeight) {\n        css_1(this.el, { minHeight: minHeight + "px" });\n    };\n    EditorBase.prototype.getElement = function () {\n        return this.el;\n    };\n    return EditorBase;\n}());\n\n/**\n * @fileoverview Check whether the given variable is a function or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a function or not.\n * If the given variable is a function, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is function?\n * @memberof module:type\n */\nfunction isFunction(obj) {\n  return obj instanceof Function;\n}\n\nvar isFunction_1 = isFunction;\n\nvar defaultCommandShortcuts = [\n    \'Enter\',\n    \'Shift-Enter\',\n    \'Mod-Enter\',\n    \'Tab\',\n    \'Shift-Tab\',\n    \'Delete\',\n    \'Backspace\',\n    \'Mod-Delete\',\n    \'Mod-Backspace\',\n    \'ArrowUp\',\n    \'ArrowDown\',\n    \'ArrowLeft\',\n    \'ArrowRight\',\n    \'Mod-d\',\n    \'Mod-D\',\n    \'Alt-ArrowUp\',\n    \'Alt-ArrowDown\',\n];\nfunction execCommand(view, command, payload) {\n    view.focus();\n    return command(payload)(view.state, view.dispatch, view);\n}\nvar SpecManager = /** @class */ (function () {\n    function SpecManager(specs) {\n        this.specs = specs;\n    }\n    Object.defineProperty(SpecManager.prototype, "nodes", {\n        get: function () {\n            return this.specs\n                .filter(function (spec) { return spec.type === \'node\'; })\n                .reduce(function (nodes, _a) {\n                var _b;\n                var name = _a.name, schema = _a.schema;\n                return __assign$1(__assign$1({}, nodes), (_b = {}, _b[name] = schema, _b));\n            }, {});\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpecManager.prototype, "marks", {\n        get: function () {\n            return this.specs\n                .filter(function (spec) { return spec.type === \'mark\'; })\n                .reduce(function (marks, _a) {\n                var _b;\n                var name = _a.name, schema = _a.schema;\n                return __assign$1(__assign$1({}, marks), (_b = {}, _b[name] = schema, _b));\n            }, {});\n        },\n        enumerable: false,\n        configurable: true\n    });\n    SpecManager.prototype.commands = function (view, addedCommands) {\n        var specCommands = this.specs\n            .filter(function (_a) {\n            var commands = _a.commands;\n            return commands;\n        })\n            .reduce(function (allCommands, spec) {\n            var commands = {};\n            var specCommand = spec.commands();\n            if (isFunction_1(specCommand)) {\n                commands[spec.name] = function (payload) { return execCommand(view, specCommand, payload); };\n            }\n            else {\n                Object.keys(specCommand).forEach(function (name) {\n                    commands[name] = function (payload) { return execCommand(view, specCommand[name], payload); };\n                });\n            }\n            return __assign$1(__assign$1({}, allCommands), commands);\n        }, {});\n        var defaultCommands = getDefaultCommands();\n        Object.keys(defaultCommands).forEach(function (name) {\n            specCommands[name] = function (payload) { return execCommand(view, defaultCommands[name], payload); };\n        });\n        if (addedCommands) {\n            Object.keys(addedCommands).forEach(function (name) {\n                specCommands[name] = function (payload) { return execCommand(view, addedCommands[name], payload); };\n            });\n        }\n        return specCommands;\n    };\n    SpecManager.prototype.keymaps = function (useCommandShortcut) {\n        var specKeymaps = this.specs.filter(function (spec) { return spec.keymaps; }).map(function (spec) { return spec.keymaps(); });\n        return specKeymaps.map(function (keys) {\n            if (!useCommandShortcut) {\n                Object.keys(keys).forEach(function (key) {\n                    if (!includes(defaultCommandShortcuts, key)) {\n                        delete keys[key];\n                    }\n                });\n            }\n            return (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(keys);\n        });\n    };\n    SpecManager.prototype.setContext = function (context) {\n        this.specs.forEach(function (spec) {\n            spec.setContext(context);\n        });\n    };\n    return SpecManager;\n}());\n\nfunction resolveSelectionPos(selection) {\n    var from = selection.from, to = selection.to;\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection) {\n        return [from + 1, to - 1];\n    }\n    return [from, to];\n}\nfunction getMdLine(resolvedPos) {\n    return resolvedPos.index(0) + 1;\n}\nfunction getWidgetNodePos(node, chPos, direction) {\n    if (direction === void 0) { direction = 1; }\n    var additionalPos = 0;\n    node.forEach(function (child, pos) {\n        // add or subtract widget node tag\n        if (isWidgetNode(child) && pos + 2 < chPos) {\n            additionalPos += 2 * direction;\n        }\n    });\n    return additionalPos;\n}\nfunction getEditorToMdPos(doc, from, to) {\n    if (to === void 0) { to = from; }\n    var collapsed = from === to;\n    var startResolvedPos = doc.resolve(from);\n    var startLine = getMdLine(startResolvedPos);\n    var endLine = startLine;\n    var startOffset = startResolvedPos.start(1);\n    var endOffset = startOffset;\n    if (!collapsed) {\n        // prevent the end offset from pointing to the root document position\n        var endResolvedPos = doc.resolve(to === doc.content.size ? to - 1 : to);\n        endOffset = endResolvedPos.start(1);\n        endLine = getMdLine(endResolvedPos);\n        // To resolve the end offset excluding document tag size\n        if (endResolvedPos.pos === doc.content.size) {\n            to = doc.content.size - 2;\n        }\n    }\n    var startCh = Math.max(from - startOffset + 1, 1);\n    var endCh = Math.max(to - endOffset + 1, 1);\n    return [\n        [startLine, startCh + getWidgetNodePos(doc.child(startLine - 1), startCh, -1)],\n        [endLine, endCh + getWidgetNodePos(doc.child(endLine - 1), endCh, -1)],\n    ];\n}\nfunction getStartPosListPerLine(doc, endIndex) {\n    var startPosListPerLine = [];\n    for (var i = 0, pos = 0; i < endIndex; i += 1) {\n        var child = doc.child(i);\n        startPosListPerLine[i] = pos;\n        pos += child.nodeSize;\n    }\n    return startPosListPerLine;\n}\nfunction getMdToEditorPos(doc, startPos, endPos) {\n    var startPosListPerLine = getStartPosListPerLine(doc, endPos[0]);\n    var startIndex = startPos[0] - 1;\n    var endIndex = endPos[0] - 1;\n    var startNode = doc.child(startIndex);\n    var endNode = doc.child(endIndex);\n    // calculate the position corresponding to the line\n    var from = startPosListPerLine[startIndex];\n    var to = startPosListPerLine[endIndex];\n    // calculate the position corresponding to the character offset of the line\n    from += startPos[1] + getWidgetNodePos(startNode, startPos[1] - 1);\n    to += endPos[1] + getWidgetNodePos(endNode, endPos[1] - 1);\n    return [from, Math.min(to, doc.content.size)];\n}\nfunction getRangeInfo(selection) {\n    var $from = selection.$from, $to = selection.$to;\n    var from = selection.from, to = selection.to;\n    var doc = $from.doc;\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection) {\n        $from = doc.resolve(from + 1);\n        $to = doc.resolve(to - 1);\n    }\n    if ($from.depth === 0) {\n        $from = doc.resolve(from - 1);\n        $to = $from;\n    }\n    return {\n        startFromOffset: $from.start(1),\n        endFromOffset: $to.start(1),\n        startToOffset: $from.end(1),\n        endToOffset: $to.end(1),\n        startIndex: $from.index(0),\n        endIndex: $to.index(0),\n        from: $from.pos,\n        to: $to.pos,\n    };\n}\nfunction getNodeContentOffsetRange(doc, targetIndex) {\n    var startOffset = 1;\n    var endOffset = 1;\n    for (var i = 0, offset = 0; i < doc.childCount; i += 1) {\n        var nodeSize = doc.child(i).nodeSize;\n        // calculate content start, end offset(not node offset)\n        startOffset = offset + 1;\n        endOffset = offset + nodeSize - 1;\n        if (i === targetIndex) {\n            break;\n        }\n        offset += nodeSize;\n    }\n    return { startOffset: startOffset, endOffset: endOffset };\n}\n\nvar HEADING = \'heading\';\nvar BLOCK_QUOTE = \'blockQuote\';\nvar LIST_ITEM = \'listItem\';\nvar TABLE = \'table\';\nvar TABLE_CELL = \'tableCell\';\nvar CODE_BLOCK = \'codeBlock\';\nvar THEMATIC_BREAK = \'thematicBreak\';\nvar LINK = \'link\';\nvar CODE = \'code\';\nvar META = \'meta\';\nvar DELIM = \'delimiter\';\nvar TASK_DELIM = \'taskDelimiter\';\nvar TEXT = \'markedText\';\nvar HTML = \'html\';\nvar CUSTOM_BLOCK = \'customBlock\';\nvar delimSize = {\n    strong: 2,\n    emph: 1,\n    strike: 2,\n};\nfunction markInfo(start, end, type, attrs) {\n    return { start: start, end: end, spec: { type: type, attrs: attrs } };\n}\nfunction heading$1(_a, start, end) {\n    var level = _a.level, headingType = _a.headingType;\n    var marks = [markInfo(start, end, HEADING, { level: level })];\n    if (headingType === \'atx\') {\n        marks.push(markInfo(start, addOffsetPos(start, level), DELIM));\n    }\n    else {\n        marks.push(markInfo(setOffsetPos(end, 0), end, HEADING, { seText: true }));\n    }\n    return marks;\n}\nfunction emphasisAndStrikethrough(_a, start, end) {\n    var type = _a.type;\n    var startDelimPos = addOffsetPos(start, delimSize[type]);\n    var endDelimPos = addOffsetPos(end, -delimSize[type]);\n    return [\n        markInfo(startDelimPos, endDelimPos, type),\n        markInfo(start, startDelimPos, DELIM),\n        markInfo(endDelimPos, end, DELIM),\n    ];\n}\nfunction markLink(start, end, linkTextStart, lastChildCh) {\n    return [\n        markInfo(start, end, LINK),\n        markInfo(setOffsetPos(start, linkTextStart[1] + 1), setOffsetPos(end, lastChildCh), LINK, {\n            desc: true,\n        }),\n        markInfo(setOffsetPos(end, lastChildCh + 2), addOffsetPos(end, -1), LINK, { url: true }),\n    ];\n}\nfunction image$1(_a, start, end) {\n    var lastChild = _a.lastChild;\n    var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 3; // 3: length of \'![]\'\n    var linkTextEnd = addOffsetPos(start, 1);\n    return __spreadArray$1([markInfo(start, linkTextEnd, META)], markLink(start, end, linkTextEnd, lastChildCh));\n}\nfunction link(_a, start, end) {\n    var lastChild = _a.lastChild, extendedAutolink = _a.extendedAutolink;\n    var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 2; // 2: length of \'[]\'\n    return extendedAutolink\n        ? [markInfo(start, end, LINK, { desc: true })]\n        : markLink(start, end, start, lastChildCh);\n}\nfunction code(_a, start, end) {\n    var tickCount = _a.tickCount;\n    var openDelimEnd = addOffsetPos(start, tickCount);\n    var closeDelimStart = addOffsetPos(end, -tickCount);\n    return [\n        markInfo(start, end, CODE),\n        markInfo(start, openDelimEnd, CODE, { start: true }),\n        markInfo(openDelimEnd, closeDelimStart, CODE, { marked: true }),\n        markInfo(closeDelimStart, end, CODE, { end: true }),\n    ];\n}\nfunction lineBackground(parent, start, end, prefix) {\n    var defaultBackground = {\n        start: start,\n        end: end,\n        spec: {\n            attrs: { className: prefix + "-line-background", codeStart: start[0], codeEnd: end[0] },\n        },\n        lineBackground: true,\n    };\n    return parent.type !== \'item\' && parent.type !== \'blockQuote\'\n        ? [\n            __assign$1(__assign$1({}, defaultBackground), { end: start, spec: { attrs: { className: prefix + "-line-background start" } } }),\n            __assign$1(__assign$1({}, defaultBackground), { start: [Math.min(start[0] + 1, end[0]), start[1]] }),\n        ]\n        : null;\n}\nfunction codeBlock$1(node, start, end, endLine) {\n    var fenceOffset = node.fenceOffset, fenceLength = node.fenceLength, fenceChar = node.fenceChar, info = node.info, infoPadding = node.infoPadding, parent = node.parent;\n    var fenceEnd = fenceOffset + fenceLength;\n    var marks = [markInfo(setOffsetPos(start, 1), end, CODE_BLOCK)];\n    if (fenceChar) {\n        marks.push(markInfo(start, addOffsetPos(start, fenceEnd), DELIM));\n    }\n    if (info) {\n        marks.push(markInfo(addOffsetPos(start, fenceLength), addOffsetPos(start, fenceLength + infoPadding + info.length), META));\n    }\n    var codeBlockEnd = "^(\\\\s{0,4})(" + fenceChar + "{" + fenceLength + ",})";\n    var reCodeBlockEnd = new RegExp(codeBlockEnd);\n    if (reCodeBlockEnd.test(endLine)) {\n        marks.push(markInfo(setOffsetPos(end, 1), end, DELIM));\n    }\n    var lineBackgroundMarkInfo = lineBackground(parent, start, end, \'code-block\');\n    return lineBackgroundMarkInfo ? marks.concat(lineBackgroundMarkInfo) : marks;\n}\nfunction customBlock$2(node, start, end) {\n    var _a = node, offset = _a.offset, syntaxLength = _a.syntaxLength, info = _a.info, parent = _a.parent;\n    var syntaxEnd = offset + syntaxLength;\n    var marks = [markInfo(setOffsetPos(start, 1), end, CUSTOM_BLOCK)];\n    marks.push(markInfo(start, addOffsetPos(start, syntaxEnd), DELIM));\n    if (info) {\n        marks.push(markInfo(addOffsetPos(start, syntaxEnd), addOffsetPos(start, syntaxLength + info.length), META));\n    }\n    marks.push(markInfo(setOffsetPos(end, 1), end, DELIM));\n    var lineBackgroundMarkInfo = lineBackground(parent, start, end, \'custom-block\');\n    return lineBackgroundMarkInfo ? marks.concat(lineBackgroundMarkInfo) : marks;\n}\nfunction markListItemChildren(node, markType) {\n    var marks = [];\n    while (node) {\n        var type = node.type;\n        if (type === \'paragraph\' || type === \'codeBlock\') {\n            marks.push(markInfo([getMdStartLine(node), getMdStartCh(node) - 1], [getMdEndLine(node), getMdEndCh(node) + 1], markType));\n        }\n        node = node.next;\n    }\n    return marks;\n}\nfunction markParagraphInBlockQuote(node) {\n    var marks = [];\n    while (node) {\n        marks.push(markInfo([getMdStartLine(node), getMdStartCh(node)], [getMdEndLine(node), getMdEndCh(node) + 1], TEXT));\n        node = node.next;\n    }\n    return marks;\n}\nfunction blockQuote$2(node, start, end) {\n    var marks = node.parent && node.parent.type !== \'blockQuote\' ? [markInfo(start, end, BLOCK_QUOTE)] : [];\n    if (node.firstChild) {\n        var childMarks = [];\n        if (node.firstChild.type === \'paragraph\') {\n            childMarks = markParagraphInBlockQuote(node.firstChild.firstChild);\n        }\n        else if (node.firstChild.type === \'list\') {\n            childMarks = markListItemChildren(node.firstChild, TEXT);\n        }\n        marks = __spreadArray$1(__spreadArray$1([], marks), childMarks);\n    }\n    return marks;\n}\nfunction getSpecOfListItemStyle(node) {\n    var depth = 0;\n    while (node.parent.parent && node.parent.parent.type === \'item\') {\n        node = node.parent.parent;\n        depth += 1;\n    }\n    var attrs = [{ odd: true }, { even: true }][depth % 2];\n    return [LIST_ITEM, __assign$1(__assign$1({}, attrs), { listStyle: true })];\n}\nfunction item$1(node, start) {\n    var _a = node.listData, padding = _a.padding, task = _a.task;\n    var spec = getSpecOfListItemStyle(node);\n    var marks = [markInfo.apply(void 0, __spreadArray$1([start, addOffsetPos(start, padding)], spec))];\n    if (task) {\n        marks.push(markInfo(addOffsetPos(start, padding), addOffsetPos(start, padding + 3), TASK_DELIM));\n        marks.push(markInfo(addOffsetPos(start, padding + 1), addOffsetPos(start, padding + 2), META));\n    }\n    return marks.concat(markListItemChildren(node.firstChild, TEXT));\n}\nvar markNodeFuncMap = {\n    heading: heading$1,\n    strong: emphasisAndStrikethrough,\n    emph: emphasisAndStrikethrough,\n    strike: emphasisAndStrikethrough,\n    link: link,\n    image: image$1,\n    code: code,\n    codeBlock: codeBlock$1,\n    blockQuote: blockQuote$2,\n    item: item$1,\n    customBlock: customBlock$2,\n};\nvar simpleMarkClassNameMap = {\n    thematicBreak: THEMATIC_BREAK,\n    table: TABLE,\n    tableCell: TABLE_CELL,\n    htmlInline: HTML,\n};\nfunction getMarkInfo(node, start, end, endLine) {\n    var type = node.type;\n    if (isFunction_1(markNodeFuncMap[type])) {\n        // @ts-ignore\n        return markNodeFuncMap[type](node, start, end, endLine);\n    }\n    if (simpleMarkClassNameMap[type]) {\n        return [markInfo(start, end, simpleMarkClassNameMap[type])];\n    }\n    return null;\n}\n\nvar removingBackgroundIndexMap = {};\nfunction syntaxHighlight(_a) {\n    var schema = _a.schema, toastMark = _a.toastMark;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        appendTransaction: function (transactions, _, newState) {\n            var tr = transactions[0];\n            var newTr = newState.tr;\n            if (tr.docChanged) {\n                var markInfo_1 = [];\n                var editResult = tr.getMeta(\'editResult\');\n                editResult.forEach(function (result) {\n                    var nodes = result.nodes, removedNodeRange = result.removedNodeRange;\n                    if (nodes.length) {\n                        markInfo_1 = markInfo_1.concat(getMarkForRemoving(newTr, nodes));\n                        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                            var parent_1 = nodes_1[_i];\n                            var walker = parent_1.walker();\n                            var event_1 = walker.next();\n                            while (event_1) {\n                                var node = event_1.node, entering = event_1.entering;\n                                if (entering) {\n                                    markInfo_1 = markInfo_1.concat(getMarkForAdding(node, toastMark));\n                                }\n                                event_1 = walker.next();\n                            }\n                        }\n                    }\n                    else if (removedNodeRange) {\n                        var maxIndex = newTr.doc.childCount - 1;\n                        var _a = removedNodeRange.line, startLine = _a[0], endLine = _a[1];\n                        var startIndex = Math.min(startLine, maxIndex);\n                        var endIndex = Math.min(endLine, maxIndex);\n                        // cache the index to remove code block, custom block background when there are no adding nodes\n                        for (var i = startIndex; i <= endIndex; i += 1) {\n                            removingBackgroundIndexMap[i] = true;\n                        }\n                    }\n                });\n                appendMarkTr(newTr, schema, markInfo_1);\n            }\n            return newTr.setMeta(\'widget\', tr.getMeta(\'widget\'));\n        },\n    });\n}\nfunction isDifferentBlock(doc, index, attrs) {\n    return Object.keys(attrs).some(function (name) { return attrs[name] !== doc.child(index).attrs[name]; });\n}\nfunction addLineBackground(tr, doc, paragraph, blockPosInfo, attrs) {\n    if (attrs === void 0) { attrs = {}; }\n    var startIndex = blockPosInfo.startIndex, endIndex = blockPosInfo.endIndex, from = blockPosInfo.from, to = blockPosInfo.to;\n    var shouldChangeBlockType = false;\n    for (var i = startIndex; i <= endIndex; i += 1) {\n        // prevent to remove background of the node that need to have background\n        delete removingBackgroundIndexMap[i];\n        shouldChangeBlockType = isDifferentBlock(doc, i, attrs);\n    }\n    if (shouldChangeBlockType) {\n        tr.setBlockType(from, to, paragraph, attrs);\n    }\n}\nfunction appendMarkTr(tr, schema, marks) {\n    var doc = tr.doc;\n    var paragraph = schema.nodes.paragraph;\n    // get start position per line for lazy calculation\n    var startPosListPerLine = getStartPosListPerLine(doc, doc.childCount);\n    marks.forEach(function (_a) {\n        var start = _a.start, end = _a.end, spec = _a.spec, lineBackground = _a.lineBackground;\n        var startIndex = Math.min(start[0], doc.childCount) - 1;\n        var endIndex = Math.min(end[0], doc.childCount) - 1;\n        var startNode = doc.child(startIndex);\n        var endNode = doc.child(endIndex);\n        // calculate the position corresponding to the line\n        var from = startPosListPerLine[startIndex];\n        var to = startPosListPerLine[endIndex];\n        // calculate the position corresponding to the character offset of the line\n        from += start[1] + getWidgetNodePos(startNode, start[1] - 1);\n        to += end[1] + getWidgetNodePos(endNode, end[1] - 1);\n        if (spec) {\n            if (lineBackground) {\n                var posInfo = { from: from, to: to, startIndex: startIndex, endIndex: endIndex };\n                addLineBackground(tr, doc, paragraph, posInfo, spec.attrs);\n            }\n            else {\n                tr.addMark(from, to, schema.mark(spec.type, spec.attrs));\n            }\n        }\n        else {\n            tr.removeMark(from, to);\n        }\n    });\n    removeBlockBackground(tr, startPosListPerLine, paragraph);\n}\nfunction removeBlockBackground(tr, startPosListPerLine, paragraph) {\n    Object.keys(removingBackgroundIndexMap).forEach(function (index) {\n        var startIndex = Number(index);\n        // get the end position of the current line with the next node start position.\n        var endIndex = Math.min(Number(index) + 1, tr.doc.childCount - 1);\n        var from = startPosListPerLine[startIndex];\n        // subtract \'1\' for getting end position of the line\n        var to = startPosListPerLine[endIndex] - 1;\n        if (startIndex === endIndex) {\n            to += 2;\n        }\n        tr.setBlockType(from, to, paragraph);\n    });\n}\nfunction cacheIndexToRemoveBackground(doc, start, end) {\n    var skipLines = [];\n    removingBackgroundIndexMap = {};\n    for (var i = start[0] - 1; i < end[0]; i += 1) {\n        var node = doc.child(i);\n        var codeEnd = node.attrs.codeEnd;\n        var codeStart = node.attrs.codeStart;\n        if (codeStart && codeEnd && !includes(skipLines, codeStart)) {\n            skipLines.push(codeStart);\n            codeEnd = Math.min(codeEnd, doc.childCount);\n            // should subtract \'1\' to markdown line position\n            // because markdown parser has \'1\'(not zero) as the start number\n            var startIndex = codeStart - 1;\n            var endIndex = end[0];\n            for (var index = startIndex; index < endIndex; index += 1) {\n                removingBackgroundIndexMap[index] = true;\n            }\n        }\n    }\n}\nfunction getMarkForRemoving(_a, nodes) {\n    var doc = _a.doc;\n    var start = nodes[0].sourcepos[0];\n    var _b = last$1(nodes).sourcepos, end = _b[1];\n    var startPos = [start[0], start[1]];\n    var endPos = [end[0], end[1] + 1];\n    var marks = [];\n    cacheIndexToRemoveBackground(doc, start, end);\n    marks.push({ start: startPos, end: endPos });\n    return marks;\n}\nfunction getMarkForAdding(node, toastMark) {\n    var lineTexts = toastMark.getLineTexts();\n    var startPos = [getMdStartLine(node), getMdStartCh(node)];\n    var endPos = [getMdEndLine(node), getMdEndCh(node) + 1];\n    var markInfo = getMarkInfo(node, startPos, endPos, lineTexts[endPos[0] - 1]);\n    return markInfo !== null && markInfo !== void 0 ? markInfo : [];\n}\n\nvar defaultToolbarStateKeys = [\n    \'taskList\',\n    \'orderedList\',\n    \'bulletList\',\n    \'table\',\n    \'strong\',\n    \'emph\',\n    \'strike\',\n    \'heading\',\n    \'thematicBreak\',\n    \'blockQuote\',\n    \'code\',\n    \'codeBlock\',\n    \'indent\',\n    \'outdent\',\n];\nfunction getToolbarStateType$1(mdNode) {\n    var type = mdNode.type;\n    if (isListNode$1(mdNode)) {\n        if (mdNode.listData.task) {\n            return \'taskList\';\n        }\n        return mdNode.listData.type === \'ordered\' ? \'orderedList\' : \'bulletList\';\n    }\n    if (type.indexOf(\'table\') !== -1) {\n        return \'table\';\n    }\n    if (!includes(defaultToolbarStateKeys, type)) {\n        return null;\n    }\n    return type;\n}\nfunction getToolbarState$1(targetNode) {\n    var toolbarState = {\n        indent: { active: false, disabled: true },\n        outdent: { active: false, disabled: true },\n    };\n    var listEnabled = true;\n    traverseParentNodes(targetNode, function (mdNode) {\n        var type = getToolbarStateType$1(mdNode);\n        if (!type) {\n            return;\n        }\n        if (type === \'bulletList\' || type === \'orderedList\') {\n            // to apply the nearlist list state in the nested list\n            if (listEnabled) {\n                toolbarState[type] = { active: true };\n                toolbarState.indent.disabled = false;\n                toolbarState.outdent.disabled = false;\n                listEnabled = false;\n            }\n        }\n        else {\n            toolbarState[type] = { active: true };\n        }\n    });\n    return toolbarState;\n}\nfunction previewHighlight(_a) {\n    var toastMark = _a.toastMark, eventEmitter = _a.eventEmitter;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        view: function () {\n            return {\n                update: function (view, prevState) {\n                    var state = view.state;\n                    var doc = state.doc, selection = state.selection;\n                    if (prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection)) {\n                        return;\n                    }\n                    var from = selection.from;\n                    var startChOffset = state.doc.resolve(from).start();\n                    var line = state.doc.content.findIndex(from).index + 1;\n                    var ch = from - startChOffset;\n                    if (from === startChOffset) {\n                        ch += 1;\n                    }\n                    var cursorPos = [line, ch];\n                    var mdNode = toastMark.findNodeAtPosition(cursorPos);\n                    var toolbarState = getToolbarState$1(mdNode);\n                    eventEmitter.emit(\'changeToolbarState\', {\n                        cursorPos: cursorPos,\n                        mdNode: mdNode,\n                        toolbarState: toolbarState,\n                    });\n                    eventEmitter.emit(\'setFocusedNode\', mdNode);\n                },\n            };\n        },\n    });\n}\n\nvar Doc$1 = /** @class */ (function (_super) {\n    __extends$1(Doc, _super);\n    function Doc() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Doc.prototype, "name", {\n        get: function () {\n            return \'doc\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Doc.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'block+\',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Doc;\n}(Node$2));\n\nvar Mark = /** @class */ (function () {\n    function Mark() {\n    }\n    Object.defineProperty(Mark.prototype, "type", {\n        get: function () {\n            return \'mark\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Mark.prototype.setContext = function (context) {\n        this.context = context;\n    };\n    return Mark;\n}());\n\nfunction getTextByMdLine(doc, mdLine) {\n    return getTextContent(doc, mdLine - 1);\n}\nfunction getTextContent(doc, index) {\n    return doc.child(index).textContent;\n}\n\nvar reBlockQuote = /^\\s*> ?/;\nvar BlockQuote$1 = /** @class */ (function (_super) {\n    __extends$1(BlockQuote, _super);\n    function BlockQuote() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BlockQuote.prototype, "name", {\n        get: function () {\n            return \'blockQuote\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BlockQuote.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'block-quote\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BlockQuote.prototype.createBlockQuoteText = function (text, isBlockQuote) {\n        return isBlockQuote ? text.replace(reBlockQuote, \'\').trim() : "> " + text.trim();\n    };\n    BlockQuote.prototype.extendBlockQuote = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, tr = _a.tr, schema = _a.schema;\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            var isBlockQuote = reBlockQuote.test(textContent);\n            if (isBlockQuote && to > endFromOffset && selection.empty) {\n                var isEmpty = !textContent.replace(reBlockQuote, \'\').trim();\n                if (isEmpty) {\n                    tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n                }\n                else {\n                    var slicedText = textContent.slice(to - endFromOffset).trim();\n                    var node = createTextNode$1(schema, _this.createBlockQuoteText(slicedText));\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    BlockQuote.prototype.commands = function () {\n        var _this = this;\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, doc = state.doc;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            var isBlockQuote = reBlockQuote.test(getTextContent(doc, startIndex));\n            var tr = replaceTextNode({\n                state: state,\n                startIndex: startIndex,\n                endIndex: endIndex,\n                from: startFromOffset,\n                createText: function (textContent) { return _this.createBlockQuoteText(textContent, isBlockQuote); },\n            });\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    BlockQuote.prototype.keymaps = function () {\n        var blockQuoteCommand = this.commands()();\n        return {\n            \'alt-q\': blockQuoteCommand,\n            \'alt-Q\': blockQuoteCommand,\n            Enter: this.extendBlockQuote(),\n        };\n    };\n    return BlockQuote;\n}(Mark));\n\nvar reList = /(^\\s*)([-*+] |[\\d]+\\. )/;\nvar reOrderedList = /(^\\s*)([\\d])+\\.( \\[[ xX]])? /;\nvar reOrderedListGroup = /^(\\s*)((\\d+)([.)]\\s(?:\\[(?:x|\\s)\\]\\s)?))(.*)/;\nvar reCanBeTaskList = /(^\\s*)([-*+]|[\\d]+\\.)( \\[[ xX]])? /;\nvar reBulletListGroup = /^(\\s*)([-*+]+(\\s(?:\\[(?:x|\\s)\\]\\s)?))(.*)/;\nvar reTaskList = /(^\\s*)([-*+] |[\\d]+\\. )(\\[[ xX]] )/;\nvar reBulletTaskList = /(^\\s*)([-*+])( \\[[ xX]]) /;\nfunction getListType(text) {\n    return reOrderedList.test(text) ? \'ordered\' : \'bullet\';\n}\nfunction getListDepth(mdNode) {\n    var depth = 0;\n    while (mdNode && mdNode.type !== \'document\') {\n        if (mdNode.type === \'list\') {\n            depth += 1;\n        }\n        mdNode = mdNode.parent;\n    }\n    return depth;\n}\nfunction findSameDepthList(toastMark, currentLine, depth, backward) {\n    var lineTexts = toastMark.getLineTexts();\n    var lineLen = lineTexts.length;\n    var result = [];\n    var line = currentLine;\n    while (backward ? line < lineLen : line > 1) {\n        line = backward ? line + 1 : line - 1;\n        var mdNode = toastMark.findFirstNodeAtLine(line);\n        var currentListDepth = getListDepth(mdNode);\n        if (currentListDepth === depth) {\n            result.push({ line: line, depth: depth, mdNode: mdNode });\n        }\n        else if (currentListDepth < depth) {\n            break;\n        }\n    }\n    return result;\n}\nfunction getSameDepthItems(_a) {\n    var toastMark = _a.toastMark, mdNode = _a.mdNode, line = _a.line;\n    var depth = getListDepth(mdNode);\n    var forwardList = findSameDepthList(toastMark, line, depth, false).reverse();\n    var backwardList = findSameDepthList(toastMark, line, depth, true);\n    return forwardList.concat([{ line: line, depth: depth, mdNode: mdNode }]).concat(backwardList);\n}\nfunction textToBullet(text) {\n    if (!reList.test(text)) {\n        return "* " + text;\n    }\n    var type = getListType(text);\n    if (type === \'bullet\' && reCanBeTaskList.test(text)) {\n        text = text.replace(reBulletTaskList, \'$1$2 \');\n    }\n    else if (type === \'ordered\') {\n        text = text.replace(reOrderedList, \'$1* \');\n    }\n    return text;\n}\nfunction textToOrdered(text, ordinalNum) {\n    if (!reList.test(text)) {\n        return ordinalNum + ". " + text;\n    }\n    var type = getListType(text);\n    if (type === \'bullet\' || (type === \'ordered\' && reCanBeTaskList.test(text))) {\n        text = text.replace(reCanBeTaskList, "$1" + ordinalNum + ". ");\n    }\n    else if (type === \'ordered\') {\n        // eslint-disable-next-line prefer-destructuring\n        var start = reOrderedListGroup.exec(text)[3];\n        if (Number(start) !== ordinalNum) {\n            text = text.replace(reOrderedList, "$1" + ordinalNum + ". ");\n        }\n    }\n    return text;\n}\nfunction getChangedInfo(doc, sameDepthItems, type, start) {\n    if (start === void 0) { start = 0; }\n    var firstIndex = Number.MAX_VALUE;\n    var lastIndex = 0;\n    var changedResults = sameDepthItems.map(function (_a, index) {\n        var line = _a.line;\n        firstIndex = Math.min(line - 1, firstIndex);\n        lastIndex = Math.max(line - 1, lastIndex);\n        var text = getTextByMdLine(doc, line);\n        text = type === \'bullet\' ? textToBullet(text) : textToOrdered(text, index + 1 + start);\n        return { text: text, line: line };\n    });\n    return { changedResults: changedResults, firstIndex: firstIndex, lastIndex: lastIndex };\n}\nfunction getBulletOrOrdered(type, context) {\n    var sameDepthListInfo = getSameDepthItems(context);\n    return getChangedInfo(context.doc, sameDepthListInfo, type);\n}\nvar otherListToList = {\n    bullet: function (context) {\n        return getBulletOrOrdered(\'bullet\', context);\n    },\n    ordered: function (context) {\n        return getBulletOrOrdered(\'ordered\', context);\n    },\n    task: function (_a) {\n        var mdNode = _a.mdNode, doc = _a.doc, line = _a.line;\n        var text = getTextByMdLine(doc, line);\n        if (mdNode.listData.task) {\n            text = text.replace(reTaskList, \'$1$2\');\n        }\n        else if (isListNode$1(mdNode)) {\n            text = text.replace(reList, \'$1$2[ ] \');\n        }\n        return { changedResults: [{ text: text, line: line }] };\n    },\n};\nvar otherNodeToList = {\n    bullet: function (_a) {\n        var doc = _a.doc, line = _a.line;\n        var lineText = getTextByMdLine(doc, line);\n        var changedResults = [{ text: "* " + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n    ordered: function (_a) {\n        var toastMark = _a.toastMark, doc = _a.doc, line = _a.line, startLine = _a.startLine;\n        var lineText = getTextByMdLine(doc, line);\n        var firstOrderedListNum = 1;\n        var firstOrderedListLine = startLine;\n        var skipped = 0;\n        for (var i = startLine - 1; i > 0; i -= 1) {\n            var mdNode = toastMark.findFirstNodeAtLine(i);\n            var text = getTextByMdLine(doc, i);\n            var canBeListNode = text && !!findClosestNode(mdNode, function (targetNode) { return isListNode$1(targetNode); });\n            var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc, i));\n            if (!searchResult && !canBeListNode) {\n                break;\n            }\n            if (!searchResult && canBeListNode) {\n                skipped += 1;\n                continue;\n            }\n            var _b = searchResult, indent = _b[1], start = _b[3];\n            // basis on one depth list\n            if (!indent) {\n                firstOrderedListNum = Number(start);\n                firstOrderedListLine = i;\n                break;\n            }\n        }\n        var ordinalNum = firstOrderedListNum + line - firstOrderedListLine - skipped;\n        var changedResults = [{ text: ordinalNum + ". " + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n    task: function (_a) {\n        var doc = _a.doc, line = _a.line;\n        var lineText = getTextByMdLine(doc, line);\n        var changedResults = [{ text: "* [ ] " + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n};\nvar extendList = {\n    bullet: function (_a) {\n        var line = _a.line, doc = _a.doc;\n        var lineText = getTextByMdLine(doc, line);\n        var _b = reBulletListGroup.exec(lineText), indent = _b[1], delimiter = _b[2];\n        return { listSyntax: "" + indent + delimiter };\n    },\n    ordered: function (_a) {\n        var toastMark = _a.toastMark, line = _a.line, mdNode = _a.mdNode, doc = _a.doc;\n        var depth = getListDepth(mdNode);\n        var lineText = getTextByMdLine(doc, line);\n        var _b = reOrderedListGroup.exec(lineText), indent = _b[1], start = _b[3], delimiter = _b[4];\n        var ordinalNum = Number(start) + 1;\n        var listSyntax = "" + indent + ordinalNum + delimiter;\n        var backwardList = findSameDepthList(toastMark, line, depth, true);\n        var filteredList = backwardList.filter(function (info) {\n            var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc, info.line));\n            return (searchResult &&\n                searchResult[1].length === indent.length &&\n                !!findClosestNode(info.mdNode, function (targetNode) { return isOrderedListNode(targetNode); }));\n        });\n        return __assign$1({ listSyntax: listSyntax }, getChangedInfo(doc, filteredList, \'ordered\', ordinalNum));\n    },\n};\nfunction getReorderedListInfo(doc, schema, line, ordinalNum, prevIndentLength) {\n    var nodes = [];\n    var lineText = getTextByMdLine(doc, line);\n    var searchResult = reOrderedListGroup.exec(lineText);\n    while (searchResult) {\n        var indent = searchResult[1], delimiter = searchResult[4], text = searchResult[5];\n        var indentLength = indent.length;\n        if (indentLength === prevIndentLength) {\n            nodes.push(createTextNode$1(schema, "" + indent + ordinalNum + delimiter + text));\n            ordinalNum += 1;\n            line += 1;\n        }\n        else if (indentLength > prevIndentLength) {\n            var nestedListInfo = getReorderedListInfo(doc, schema, line, 1, indentLength);\n            line = nestedListInfo.line;\n            nodes = nodes.concat(nestedListInfo.nodes);\n        }\n        if (indentLength < prevIndentLength || line > doc.childCount) {\n            break;\n        }\n        lineText = getTextByMdLine(doc, line);\n        searchResult = reOrderedListGroup.exec(lineText);\n    }\n    return { nodes: nodes, line: line };\n}\n\nvar reStartSpace = /(^\\s{1,4})(.*)/;\nfunction isBlockUnit(from, to, text) {\n    return from < to || reList.test(text) || reBlockQuote.test(text);\n}\nfunction isInTableCellNode(doc, schema, selection) {\n    var $pos = selection.$from;\n    if ($pos.depth === 0) {\n        $pos = doc.resolve($pos.pos - 1);\n    }\n    var node = $pos.node(1);\n    var startOffset = $pos.start(1);\n    var contentSize = node.content.size;\n    return (node.rangeHasMark(0, contentSize, schema.marks.table) &&\n        $pos.pos - startOffset !== contentSize &&\n        $pos.pos !== startOffset);\n}\nfunction createSelection(tr, posInfo) {\n    var from = posInfo.from, to = posInfo.to;\n    if (posInfo.type === \'indent\') {\n        var softTabLen = 4;\n        from += softTabLen;\n        to += (posInfo.lineLen + 1) * softTabLen;\n    }\n    else {\n        var spaceLenList = posInfo.spaceLenList;\n        from -= spaceLenList[0];\n        for (var i = 0; i < spaceLenList.length; i += 1) {\n            to -= spaceLenList[i];\n        }\n    }\n    return createTextSelection(tr, from, to);\n}\nvar Paragraph$1 = /** @class */ (function (_super) {\n    __extends$1(Paragraph, _super);\n    function Paragraph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Paragraph.prototype, "name", {\n        get: function () {\n            return \'paragraph\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Paragraph.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'inline*\',\n                attrs: {\n                    className: { default: null },\n                    codeStart: { default: null },\n                    codeEnd: { default: null },\n                },\n                selectable: false,\n                group: \'block\',\n                parseDOM: [{ tag: \'div\' }],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return attrs.className\n                        ? [\'div\', { class: clsWithMdPrefix(attrs.className) }, 0]\n                        : [\'div\', 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Paragraph.prototype.reorderList = function (startLine, endLine) {\n        var _a = this.context, view = _a.view, toastMark = _a.toastMark, schema = _a.schema;\n        var _b = view.state, tr = _b.tr, selection = _b.selection, doc = _b.doc;\n        var mdNode = toastMark.findFirstNodeAtLine(startLine);\n        var topListNode = mdNode;\n        while (mdNode && !isBulletListNode(mdNode) && mdNode.parent.type !== \'document\') {\n            mdNode = mdNode.parent;\n            if (isOrderedListNode(mdNode)) {\n                topListNode = mdNode;\n                break;\n            }\n        }\n        if (topListNode) {\n            startLine = topListNode.sourcepos[0][0];\n        }\n        var _c = reOrderedListGroup.exec(getTextByMdLine(doc, startLine)), indent = _c[1], start = _c[3];\n        var indentLen = indent.length;\n        var _d = getReorderedListInfo(doc, schema, startLine, Number(start), indentLen), line = _d.line, nodes = _d.nodes;\n        endLine = Math.max(endLine, line - 1);\n        var startOffset = getNodeContentOffsetRange(doc, startLine - 1).startOffset;\n        for (var i = startLine - 1; i <= endLine - 1; i += 1) {\n            var _e = doc.child(i), nodeSize = _e.nodeSize, content = _e.content;\n            var mappedFrom = tr.mapping.map(startOffset);\n            var mappedTo = mappedFrom + content.size;\n            tr.replaceWith(mappedFrom, mappedTo, nodes[i - startLine + 1]);\n            startOffset += nodeSize;\n        }\n        var newSelection = createTextSelection(tr, selection.from, selection.to);\n        view.dispatch(tr.setSelection(newSelection));\n    };\n    Paragraph.prototype.indent = function (tabKey) {\n        var _this = this;\n        if (tabKey === void 0) { tabKey = false; }\n        return function () { return function (state, dispatch) {\n            var schema = state.schema, selection = state.selection, doc = state.doc;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            if (tabKey && isInTableCellNode(doc, schema, selection)) {\n                return false;\n            }\n            var startLineText = getTextContent(doc, startIndex);\n            if ((tabKey && isBlockUnit(from, to, startLineText)) ||\n                (!tabKey && reList.test(startLineText))) {\n                var tr = replaceTextNode({\n                    state: state,\n                    from: startFromOffset,\n                    startIndex: startIndex,\n                    endIndex: endIndex,\n                    createText: function (textContent) { return "    " + textContent; },\n                });\n                var posInfo = {\n                    type: \'indent\',\n                    from: from,\n                    to: to,\n                    lineLen: endIndex - startIndex,\n                };\n                dispatch(tr.setSelection(createSelection(tr, posInfo)));\n                if (reOrderedListGroup.test(startLineText)) {\n                    _this.reorderList(startIndex + 1, endIndex + 1);\n                }\n            }\n            else if (tabKey) {\n                dispatch(state.tr.insert(to, createTextNode$1(schema, \'    \')));\n            }\n            return true;\n        }; };\n    };\n    Paragraph.prototype.outdent = function (tabKey) {\n        var _this = this;\n        if (tabKey === void 0) { tabKey = false; }\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, doc = state.doc, schema = state.schema;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            if (tabKey && isInTableCellNode(doc, schema, selection)) {\n                return false;\n            }\n            var startLineText = getTextContent(doc, startIndex);\n            if ((tabKey && isBlockUnit(from, to, startLineText)) ||\n                (!tabKey && reList.test(startLineText))) {\n                var spaceLenList_1 = [];\n                var tr = replaceTextNode({\n                    state: state,\n                    from: startFromOffset,\n                    startIndex: startIndex,\n                    endIndex: endIndex,\n                    createText: function (textContent) {\n                        var searchResult = reStartSpace.exec(textContent);\n                        spaceLenList_1.push(searchResult ? searchResult[1].length : 0);\n                        return textContent.replace(reStartSpace, \'$2\');\n                    },\n                });\n                var posInfo = { type: \'outdent\', from: from, to: to, spaceLenList: spaceLenList_1 };\n                dispatch(tr.setSelection(createSelection(tr, posInfo)));\n                if (reOrderedListGroup.test(startLineText)) {\n                    _this.reorderList(startIndex + 1, endIndex + 1);\n                }\n            }\n            else if (tabKey) {\n                var startText = startLineText.slice(0, to - startFromOffset);\n                var startTextWithoutSpace = startText.replace(/\\s{1,4}$/, \'\');\n                var deletStart = to - (startText.length - startTextWithoutSpace.length);\n                dispatch(state.tr.delete(deletStart, to));\n            }\n            return true;\n        }; };\n    };\n    Paragraph.prototype.deleteLines = function () {\n        var _this = this;\n        return function (state, dispatch) {\n            var view = _this.context.view;\n            var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            var deleteRange = function () {\n                dispatch(state.tr.deleteRange(startFromOffset, endToOffset));\n                return true;\n            };\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.chainCommands)(deleteRange, prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.joinForward)(state, dispatch, view);\n        };\n    };\n    Paragraph.prototype.moveDown = function () {\n        return function (state, dispatch) {\n            var doc = state.doc, tr = state.tr, selection = state.selection, schema = state.schema;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, endIndex = _a.endIndex;\n            if (endIndex < doc.content.childCount - 1) {\n                var _b = doc.child(endIndex + 1), nodeSize = _b.nodeSize, textContent = _b.textContent;\n                tr.delete(endToOffset, endToOffset + nodeSize)\n                    .split(startFromOffset)\n                    // subtract 2(start, end tag length) to insert prev line\n                    .insert(tr.mapping.map(startFromOffset) - 2, createTextNode$1(schema, textContent));\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Paragraph.prototype.moveUp = function () {\n        return function (state, dispatch) {\n            var tr = state.tr, doc = state.doc, selection = state.selection, schema = state.schema;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex;\n            if (startIndex > 0) {\n                var _b = doc.child(startIndex - 1), nodeSize = _b.nodeSize, textContent = _b.textContent;\n                tr.delete(startFromOffset - nodeSize, startFromOffset)\n                    .split(tr.mapping.map(endToOffset))\n                    .insert(tr.mapping.map(endToOffset), createTextNode$1(schema, textContent));\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Paragraph.prototype.commands = function () {\n        return {\n            indent: this.indent(),\n            outdent: this.outdent(),\n        };\n    };\n    Paragraph.prototype.keymaps = function () {\n        return {\n            Tab: this.indent(true)(),\n            \'Shift-Tab\': this.outdent(true)(),\n            \'Mod-d\': this.deleteLines(),\n            \'Mod-D\': this.deleteLines(),\n            \'Alt-ArrowUp\': this.moveUp(),\n            \'Alt-ArrowDown\': this.moveDown(),\n        };\n    };\n    return Paragraph;\n}(Node$2));\n\nvar Text$1 = /** @class */ (function (_super) {\n    __extends$1(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Text.prototype, "name", {\n        get: function () {\n            return \'text\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, "schema", {\n        get: function () {\n            return {\n                group: \'inline\',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Text;\n}(Node$2));\n\nvar reHeading = /^#{1,6}\\s/;\nvar Heading$1 = /** @class */ (function (_super) {\n    __extends$1(Heading, _super);\n    function Heading() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Heading.prototype, "name", {\n        get: function () {\n            return \'heading\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, "schema", {\n        get: function () {\n            return {\n                attrs: {\n                    level: { default: 1 },\n                    seText: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var level = attrs.level, seText = attrs.seText;\n                    var classNames = "heading|heading" + level;\n                    if (seText) {\n                        classNames += \'|delimiter|setext\';\n                    }\n                    return [\'span\', { class: clsWithMdPrefix.apply(void 0, classNames.split(\'|\')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Heading.prototype.createHeadingText = function (level, text, curHeadingSyntax) {\n        var textContent = text.replace(curHeadingSyntax, \'\').trim();\n        var headingText = \'\';\n        while (level > 0) {\n            headingText += \'#\';\n            level -= 1;\n        }\n        return headingText + " " + textContent;\n    };\n    Heading.prototype.commands = function () {\n        var _this = this;\n        return function (payload) { return function (state, dispatch) {\n            var level = payload.level;\n            var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            var tr = replaceTextNode({\n                state: state,\n                from: startFromOffset,\n                startIndex: startIndex,\n                endIndex: endIndex,\n                createText: function (textContent) {\n                    var matchedHeading = textContent.match(reHeading);\n                    var curHeadingSyntax = matchedHeading ? matchedHeading[0] : \'\';\n                    return _this.createHeadingText(level, textContent, curHeadingSyntax);\n                },\n            });\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    return Heading;\n}(Mark));\n\nvar fencedCodeBlockSyntax = \'```\';\nvar CodeBlock$1 = /** @class */ (function (_super) {\n    __extends$1(CodeBlock, _super);\n    function CodeBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CodeBlock.prototype, "name", {\n        get: function () {\n            return \'codeBlock\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CodeBlock.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'code-block\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CodeBlock.prototype.commands = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            var fencedNode = createTextNode$1(schema, fencedCodeBlockSyntax);\n            // add fenced start block\n            tr.insert(startFromOffset, fencedNode).split(startFromOffset + fencedCodeBlockSyntax.length);\n            // add fenced end block\n            tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), fencedNode);\n            dispatch(tr.setSelection(\n            // subtract fenced syntax length and open, close tag(2)\n            createTextSelection(tr, tr.mapping.map(endToOffset) - (fencedCodeBlockSyntax.length + 2))));\n            return true;\n        }; };\n    };\n    CodeBlock.prototype.keepIndentation = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), startFromOffset = _b.startFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, from = _b.from, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            if (from === to && textContent.trim()) {\n                var matched = textContent.match(/^\\s+/);\n                var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);\n                if (isCodeBlockNode(mdNode) && matched) {\n                    var spaces = matched[0];\n                    var slicedText = textContent.slice(to - startFromOffset);\n                    var node = createTextNode$1(schema, spaces + slicedText);\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                    dispatch(tr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    CodeBlock.prototype.keymaps = function () {\n        var codeBlockCommand = this.commands()();\n        return {\n            \'Shift-Mod-p\': codeBlockCommand,\n            \'Shift-Mod-P\': codeBlockCommand,\n            Enter: this.keepIndentation(),\n        };\n    };\n    return CodeBlock;\n}(Mark));\n\nvar reEmptyTable = /\\||\\s/g;\nfunction createTableHeader(columnCount) {\n    return [createTableRow(columnCount), createTableRow(columnCount, true)];\n}\nfunction createTableBody$1(columnCount, rowCount) {\n    var bodyRows = [];\n    for (var i = 0; i < rowCount; i += 1) {\n        bodyRows.push(createTableRow(columnCount));\n    }\n    return bodyRows;\n}\nfunction createTableRow(columnCount, delim) {\n    var row = \'|\';\n    for (var i = 0; i < columnCount; i += 1) {\n        row += delim ? \' --- |\' : \'  |\';\n    }\n    return row;\n}\nfunction createTargetTypes(moveNext) {\n    return moveNext\n        ? { type: \'next\', parentType: \'tableHead\', childType: \'firstChild\' }\n        : { type: \'prev\', parentType: \'tableBody\', childType: \'lastChild\' };\n}\nvar Table$1 = /** @class */ (function (_super) {\n    __extends$1(Table, _super);\n    function Table() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Table.prototype, "name", {\n        get: function () {\n            return \'table\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Table.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'table\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Table.prototype.extendTable = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, tr = _a.tr, schema = _a.schema;\n            if (!selection.empty) {\n                return false;\n            }\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            // should add `1` to line for the markdown parser\n            // because markdown parser has `1`(not zero) as the start number\n            var mdPos = [endIndex + 1, to - endFromOffset + 1];\n            var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);\n            var cellNode = findClosestNode(mdNode, function (node) {\n                return isTableCellNode(node) &&\n                    (node.parent.type === \'tableDelimRow\' || node.parent.parent.type === \'tableBody\');\n            });\n            if (cellNode) {\n                var isEmpty = !textContent.replace(reEmptyTable, \'\').trim();\n                var parent_1 = cellNode.parent;\n                var columnCount = parent_1.parent.parent.columns.length;\n                var row = createTableRow(columnCount);\n                if (isEmpty) {\n                    tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n                }\n                else {\n                    tr\n                        .split(endToOffset)\n                        .insert(tr.mapping.map(endToOffset), createTextNode$1(schema, row))\n                        // should subtract `2` to selection end position considering ` |` text\n                        .setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - 2));\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.moveTableCell = function (moveNext) {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, to = _b.to;\n            var mdPos = [endIndex + 1, to - endFromOffset];\n            var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);\n            var cellNode = findClosestNode(mdNode, function (node) { return isTableCellNode(node); });\n            if (cellNode) {\n                var parent_2 = cellNode.parent;\n                var _c = createTargetTypes(moveNext), type = _c.type, parentType = _c.parentType, childType = _c.childType;\n                var chOffset = getMdEndCh(cellNode);\n                if (cellNode[type]) {\n                    chOffset = getMdEndCh(cellNode[type]) - 1;\n                }\n                else {\n                    var row = !parent_2[type] && parent_2.parent.type === parentType\n                        ? parent_2.parent[type][childType]\n                        : parent_2[type];\n                    if (type === \'next\') {\n                        // if there is next row, the base offset would be end position of the next row\'s first child.\n                        // Otherwise, the base offset is zero.\n                        var baseOffset = row ? getMdEndCh(row[childType]) : 0;\n                        // calculate tag(open, close) position(\'2\') for selection\n                        chOffset += baseOffset + 2;\n                    }\n                    else if (type === \'prev\') {\n                        // if there is prev row, the target position would be \'-4\' for calculating \' |\' characters and tag(open, close)\n                        // Otherwise, the target position is zero.\n                        chOffset = row ? -4 : 0;\n                    }\n                }\n                dispatch(tr.setSelection(createTextSelection(tr, endFromOffset + chOffset)));\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.addTable = function () {\n        return function (payload) { return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n            var _b = payload, columnCount = _b.columnCount, rowCount = _b.rowCount;\n            var endToOffset = getRangeInfo(selection).endToOffset;\n            var headerRows = createTableHeader(columnCount);\n            var bodyRows = createTableBody$1(columnCount, rowCount - 1);\n            var rows = __spreadArray$1(__spreadArray$1([], headerRows), bodyRows);\n            rows.forEach(function (row) {\n                tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), createTextNode$1(schema, row));\n            });\n            // should add `4` to selection position considering `| ` text and start block tag length\n            dispatch(tr.setSelection(createTextSelection(tr, endToOffset + 4)));\n            return true;\n        }; };\n    };\n    Table.prototype.commands = function () {\n        return { addTable: this.addTable() };\n    };\n    Table.prototype.keymaps = function () {\n        return {\n            Enter: this.extendTable(),\n            Tab: this.moveTableCell(true),\n            \'Shift-Tab\': this.moveTableCell(false),\n        };\n    };\n    return Table;\n}(Mark));\n\nvar thematicBreakSyntax = \'***\';\nvar ThematicBreak$1 = /** @class */ (function (_super) {\n    __extends$1(ThematicBreak, _super);\n    function ThematicBreak() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ThematicBreak.prototype, "name", {\n        get: function () {\n            return \'thematicBreak\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThematicBreak.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'thematic-break\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ThematicBreak.prototype.hr = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, endToOffset = _a.endToOffset;\n            var node = createTextNode$1(schema, thematicBreakSyntax);\n            tr\n                .split(from)\n                .replaceWith(tr.mapping.map(from), tr.mapping.map(to), node)\n                .split(tr.mapping.map(to)).setSelection(createTextSelection(tr, tr.mapping.map(endToOffset)));\n            dispatch(tr);\n            return true;\n        }; };\n    };\n    ThematicBreak.prototype.commands = function () {\n        return { hr: this.hr() };\n    };\n    ThematicBreak.prototype.keymaps = function () {\n        var lineCommand = this.hr()();\n        return { \'Mod-l\': lineCommand, \'Mod-L\': lineCommand };\n    };\n    return ThematicBreak;\n}(Mark));\n\nfunction cannotBeListNode(_a, line) {\n    var type = _a.type, sourcepos = _a.sourcepos;\n    // eslint-disable-next-line prefer-destructuring\n    var startLine = sourcepos[0][0];\n    return line <= startLine && (type === \'codeBlock\' || type === \'heading\' || type.match(\'table\'));\n}\nvar ListItem$1 = /** @class */ (function (_super) {\n    __extends$1(ListItem, _super);\n    function ListItem() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ListItem.prototype, "name", {\n        get: function () {\n            return \'listItem\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ListItem.prototype, "schema", {\n        get: function () {\n            return {\n                attrs: {\n                    odd: { default: false },\n                    even: { default: false },\n                    listStyle: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var odd = attrs.odd, even = attrs.even, listStyle = attrs.listStyle;\n                    var classNames = \'list-item\';\n                    if (listStyle) {\n                        classNames += \'|list-item-style\';\n                    }\n                    if (odd) {\n                        classNames += \'|list-item-odd\';\n                    }\n                    if (even) {\n                        classNames += \'|list-item-even\';\n                    }\n                    return [\'span\', { class: clsWithMdPrefix.apply(void 0, classNames.split(\'|\')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ListItem.prototype.extendList = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, schema = _a.schema, tr = _a.tr;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), to = _b.to, startFromOffset = _b.startFromOffset, endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, endToOffset = _b.endToOffset;\n            var textContent = getTextContent(doc, endIndex);\n            var isList = reList.test(textContent);\n            if (!isList || selection.from === startFromOffset || !selection.empty) {\n                return false;\n            }\n            var isEmpty = !textContent.replace(reCanBeTaskList, \'\').trim();\n            if (isEmpty) {\n                tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n            }\n            else {\n                var commandType = getListType(textContent);\n                // should add `1` to line for the markdown parser\n                // because markdown parser has `1`(not zero) as the start number\n                var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);\n                var slicedText = textContent.slice(to - endFromOffset);\n                var context = { toastMark: toastMark, mdNode: mdNode, doc: doc, line: endIndex + 1 };\n                var _c = extendList[commandType](context), listSyntax = _c.listSyntax, changedResults = _c.changedResults;\n                // change ordinal number of backward ordered list\n                if (changedResults === null || changedResults === void 0 ? void 0 : changedResults.length) {\n                    // split the block\n                    tr.split(to);\n                    // set first ordered list info\n                    changedResults.unshift({ text: listSyntax + slicedText, line: endIndex + 1 });\n                    _this.changeToListPerLine(tr, changedResults, {\n                        from: to,\n                        // don\'t subtract 1 because the line has increased through \'split\' command.\n                        startLine: changedResults[0].line,\n                        endLine: last$1(changedResults).line,\n                    });\n                    var pos = tr.mapping.map(endToOffset) - slicedText.length;\n                    tr.setSelection(createTextSelection(tr, pos));\n                }\n                else {\n                    var node = createTextNode$1(schema, listSyntax + slicedText);\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                }\n            }\n            dispatch(tr);\n            return true;\n        };\n    };\n    ListItem.prototype.toList = function (commandType) {\n        var _this = this;\n        return function () { return function (_a, dispatch) {\n            var doc = _a.doc, tr = _a.tr, selection = _a.selection;\n            var toastMark = _this.context.toastMark;\n            var rangeInfo = getRangeInfo(selection);\n            // should add `1` to line for the markdown parser\n            // because markdown parser has `1`(not zero) as the start number\n            var startLine = rangeInfo.startIndex + 1;\n            var endLine = rangeInfo.endIndex + 1;\n            var endToOffset = rangeInfo.endToOffset;\n            var skipLines = [];\n            for (var line = startLine; line <= endLine; line += 1) {\n                var mdNode = toastMark.findFirstNodeAtLine(line);\n                if (mdNode && cannotBeListNode(mdNode, line)) {\n                    break;\n                }\n                // to skip unnecessary processing\n                if (skipLines.indexOf(line) !== -1) {\n                    continue;\n                }\n                var context = { toastMark: toastMark, mdNode: mdNode, doc: doc, line: line, startLine: startLine };\n                var changedResults = (isListNode$1(mdNode)\n                    ? otherListToList[commandType](context)\n                    : otherNodeToList[commandType](context)).changedResults;\n                var endOffset = _this.changeToListPerLine(tr, changedResults, {\n                    from: getNodeContentOffsetRange(doc, changedResults[0].line - 1).startOffset,\n                    startLine: changedResults[0].line,\n                    endLine: last$1(changedResults).line,\n                    indexDiff: 1,\n                });\n                endToOffset = Math.max(endOffset, endToOffset);\n                if (changedResults) {\n                    skipLines = skipLines.concat(changedResults.map(function (info) { return info.line; }));\n                }\n            }\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    ListItem.prototype.changeToListPerLine = function (tr, changedResults, _a) {\n        var from = _a.from, startLine = _a.startLine, endLine = _a.endLine, _b = _a.indexDiff, indexDiff = _b === void 0 ? 0 : _b;\n        var maxEndOffset = 0;\n        var _loop_1 = function (i) {\n            var _c = tr.doc.child(i), nodeSize = _c.nodeSize, content = _c.content;\n            var mappedFrom = tr.mapping.map(from);\n            var mappedTo = mappedFrom + content.size;\n            var changedResult = changedResults.filter(function (result) { return result.line - indexDiff === i; })[0];\n            if (changedResult) {\n                tr.replaceWith(mappedFrom, mappedTo, createTextNode$1(this_1.context.schema, changedResult.text));\n                maxEndOffset = Math.max(maxEndOffset, from + content.size);\n            }\n            from += nodeSize;\n        };\n        var this_1 = this;\n        for (var i = startLine - indexDiff; i <= endLine - indexDiff; i += 1) {\n            _loop_1(i);\n        }\n        return maxEndOffset;\n    };\n    ListItem.prototype.toggleTask = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), startIndex = _b.startIndex, endIndex = _b.endIndex;\n            var newTr = null;\n            for (var i = startIndex; i <= endIndex; i += 1) {\n                var mdNode = toastMark.findFirstNodeAtLine(i + 1);\n                if (isListNode$1(mdNode) && mdNode.listData.task) {\n                    var _c = mdNode.listData, checked = _c.checked, padding = _c.padding;\n                    var stateChar = checked ? \' \' : \'x\';\n                    var mdPos = mdNode.sourcepos[0];\n                    var startOffset = getNodeContentOffsetRange(doc, mdPos[0] - 1).startOffset;\n                    startOffset += mdPos[1] + padding;\n                    newTr = tr.replaceWith(startOffset, startOffset + 1, schema.text(stateChar));\n                }\n            }\n            if (newTr) {\n                dispatch(newTr);\n                return true;\n            }\n            return false;\n        };\n    };\n    ListItem.prototype.commands = function () {\n        return {\n            bulletList: this.toList(\'bullet\'),\n            orderedList: this.toList(\'ordered\'),\n            taskList: this.toList(\'task\'),\n        };\n    };\n    ListItem.prototype.keymaps = function () {\n        var bulletCommand = this.toList(\'bullet\')();\n        var orderedCommand = this.toList(\'ordered\')();\n        var taskCommand = this.toList(\'task\')();\n        var togleTaskCommand = this.toggleTask();\n        return {\n            \'Mod-u\': bulletCommand,\n            \'Mod-U\': bulletCommand,\n            \'Mod-o\': orderedCommand,\n            \'Mod-O\': orderedCommand,\n            \'alt-t\': taskCommand,\n            \'alt-T\': taskCommand,\n            \'Shift-Ctrl-x\': togleTaskCommand,\n            \'Shift-Ctrl-X\': togleTaskCommand,\n            Enter: this.extendList(),\n        };\n    };\n    return ListItem;\n}(Mark));\n\nfunction toggleMark(condition, syntax) {\n    return function () { return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var conditionFn = !isFunction_1(condition)\n            ? function (text) { return condition.test(text); }\n            : condition;\n        var syntaxLen = syntax.length;\n        var doc = tr.doc;\n        var _b = resolveSelectionPos(selection), from = _b[0], to = _b[1];\n        var prevPos = Math.max(from - syntaxLen, 1);\n        var nextPos = Math.min(to + syntaxLen, doc.content.size - 1);\n        var slice = selection.content();\n        var textContent = slice.content.textBetween(0, slice.content.size, \'\\n\');\n        var prevText = doc.textBetween(prevPos, from, \'\\n\');\n        var nextText = doc.textBetween(to, nextPos, \'\\n\');\n        textContent = "" + prevText + textContent + nextText;\n        if (prevText && nextText && conditionFn(textContent)) {\n            tr.delete(nextPos - syntaxLen, nextPos).delete(prevPos, prevPos + syntaxLen);\n        }\n        else {\n            tr.insertText(syntax, to).insertText(syntax, from);\n            var newSelection = selection.empty\n                ? createTextSelection(tr, from + syntaxLen)\n                : createTextSelection(tr, from + syntaxLen, to + syntaxLen);\n            tr.setSelection(newSelection);\n        }\n        dispatch(tr);\n        return true;\n    }; };\n}\n\nvar reStrong = /^(\\*{2}|_{2}).*([\\s\\S]*)\\1$/m;\nvar strongSyntax = \'**\';\nvar Strong$1 = /** @class */ (function (_super) {\n    __extends$1(Strong, _super);\n    function Strong() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strong.prototype, "name", {\n        get: function () {\n            return \'strong\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strong.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'strong\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strong.prototype.bold = function () {\n        return toggleMark(reStrong, strongSyntax);\n    };\n    Strong.prototype.commands = function () {\n        return { bold: this.bold() };\n    };\n    Strong.prototype.keymaps = function () {\n        var boldCommand = this.bold()();\n        return { \'Mod-b\': boldCommand, \'Mod-B\': boldCommand };\n    };\n    return Strong;\n}(Mark));\n\nvar reStrike = /^(~{2}).*([\\s\\S]*)\\1$/m;\nvar strikeSyntax = \'~~\';\nvar Strike$1 = /** @class */ (function (_super) {\n    __extends$1(Strike, _super);\n    function Strike() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strike.prototype, "name", {\n        get: function () {\n            return \'strike\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strike.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'strike\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strike.prototype.commands = function () {\n        return toggleMark(reStrike, strikeSyntax);\n    };\n    Strike.prototype.keymaps = function () {\n        var strikeCommand = this.commands()();\n        return { \'Mod-s\': strikeCommand, \'Mod-S\': strikeCommand };\n    };\n    return Strike;\n}(Mark));\n\nvar reEmph = /^(\\*|_).*([\\s\\S]*)\\1$/m;\nvar emphSyntax = \'*\';\nvar Emph$1 = /** @class */ (function (_super) {\n    __extends$1(Emph, _super);\n    function Emph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Emph.prototype, "name", {\n        get: function () {\n            return \'emph\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Emph.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'emph\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Emph.prototype.italic = function () {\n        return toggleMark(reEmph, emphSyntax);\n    };\n    Emph.prototype.commands = function () {\n        return { italic: this.italic() };\n    };\n    Emph.prototype.keymaps = function () {\n        var italicCommand = this.italic()();\n        return { \'Mod-i\': italicCommand, \'Mod-I\': italicCommand };\n    };\n    return Emph;\n}(Mark));\n\nvar reCode = /^(`).*([\\s\\S]*)\\1$/m;\nvar codeSyntax = \'`\';\nvar Code$1 = /** @class */ (function (_super) {\n    __extends$1(Code, _super);\n    function Code() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Code.prototype, "name", {\n        get: function () {\n            return \'code\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Code.prototype, "schema", {\n        get: function () {\n            return {\n                attrs: {\n                    start: { default: false },\n                    end: { default: false },\n                    marked: { default: false },\n                },\n                toDOM: function (mark) {\n                    var _a = mark.attrs, start = _a.start, end = _a.end, marked = _a.marked;\n                    var classNames = \'code\';\n                    if (start) {\n                        classNames += \'|delimiter|start\';\n                    }\n                    if (end) {\n                        classNames += \'|delimiter|end\';\n                    }\n                    if (marked) {\n                        classNames += \'|marked-text\';\n                    }\n                    return [\'span\', { class: clsWithMdPrefix.apply(void 0, classNames.split(\'|\')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Code.prototype.commands = function () {\n        return toggleMark(reCode, codeSyntax);\n    };\n    Code.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return { \'Shift-Mod-c\': codeCommand, \'Shift-Mod-C\': codeCommand };\n    };\n    return Code;\n}(Mark));\n\nvar Link$1 = /** @class */ (function (_super) {\n    __extends$1(Link, _super);\n    function Link() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Link.prototype, "name", {\n        get: function () {\n            return \'link\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Link.prototype, "schema", {\n        get: function () {\n            return {\n                attrs: {\n                    url: { default: false },\n                    desc: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var url = attrs.url, desc = attrs.desc;\n                    var classNames = \'link\';\n                    if (url) {\n                        classNames += \'|link-url|marked-text\';\n                    }\n                    if (desc) {\n                        classNames += \'|link-desc|marked-text\';\n                    }\n                    return [\'span\', { class: clsWithMdPrefix.apply(void 0, classNames.split(\'|\')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Link.prototype.addLinkOrImage = function (commandType) {\n        return function (payload) { return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n            var _b = resolveSelectionPos(selection), from = _b[0], to = _b[1];\n            var _c = payload, linkText = _c.linkText, altText = _c.altText, linkUrl = _c.linkUrl, imageUrl = _c.imageUrl;\n            var text = linkText;\n            var url = linkUrl;\n            var syntax = \'\';\n            if (commandType === \'image\') {\n                text = altText;\n                url = imageUrl;\n                syntax = \'!\';\n            }\n            text = escapeTextForLink(text);\n            syntax += "[" + text + "](" + url + ")";\n            dispatch(tr.replaceWith(from, to, createTextNode$1(schema, syntax)));\n            return true;\n        }; };\n    };\n    Link.prototype.commands = function () {\n        return {\n            addImage: this.addLinkOrImage(\'image\'),\n            addLink: this.addLinkOrImage(\'link\'),\n        };\n    };\n    return Link;\n}(Mark));\n\nvar TaskDelimiter = /** @class */ (function (_super) {\n    __extends$1(TaskDelimiter, _super);\n    function TaskDelimiter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TaskDelimiter.prototype, "name", {\n        get: function () {\n            return \'taskDelimiter\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TaskDelimiter.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'delimiter\', \'list-item\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TaskDelimiter;\n}(Mark));\nvar Delimiter = /** @class */ (function (_super) {\n    __extends$1(Delimiter, _super);\n    function Delimiter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Delimiter.prototype, "name", {\n        get: function () {\n            return \'delimiter\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Delimiter.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'delimiter\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Delimiter;\n}(Mark));\nvar Meta = /** @class */ (function (_super) {\n    __extends$1(Meta, _super);\n    function Meta() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Meta.prototype, "name", {\n        get: function () {\n            return \'meta\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Meta.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'meta\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Meta;\n}(Mark));\nvar MarkedText = /** @class */ (function (_super) {\n    __extends$1(MarkedText, _super);\n    function MarkedText() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(MarkedText.prototype, "name", {\n        get: function () {\n            return \'markedText\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MarkedText.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'marked-text\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return MarkedText;\n}(Mark));\nvar TableCell = /** @class */ (function (_super) {\n    __extends$1(TableCell, _super);\n    function TableCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableCell.prototype, "name", {\n        get: function () {\n            return \'tableCell\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableCell.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'table-cell\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableCell;\n}(Mark));\n\nvar Html = /** @class */ (function (_super) {\n    __extends$1(Html, _super);\n    function Html() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Html.prototype, "name", {\n        get: function () {\n            return \'html\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Html.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'html\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Html;\n}(Mark));\n\nvar customBlockSyntax = \'$$\';\nvar CustomBlock$1 = /** @class */ (function (_super) {\n    __extends$1(CustomBlock, _super);\n    function CustomBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CustomBlock.prototype, "name", {\n        get: function () {\n            return \'customBlock\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CustomBlock.prototype, "schema", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return [\'span\', { class: clsWithMdPrefix(\'custom-block\') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CustomBlock.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            if (!(payload === null || payload === void 0 ? void 0 : payload.info)) {\n                return false;\n            }\n            var customBlock = "" + customBlockSyntax + payload.info;\n            var startNode = createTextNode$1(schema, customBlock);\n            var endNode = createTextNode$1(schema, customBlockSyntax);\n            tr.insert(startFromOffset, startNode).split(startFromOffset + customBlock.length);\n            tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), endNode);\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - (customBlockSyntax.length + 2))));\n            return true;\n        }; };\n    };\n    return CustomBlock;\n}(Mark));\n\nvar reTaskMarkerKey = /x|backspace/i;\nvar reTaskMarker = /^\\[(\\s*)(x?)(\\s*)\\](?:\\s+)/i;\nfunction smartTask(_a) {\n    var schema = _a.schema, toastMark = _a.toastMark;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                keyup: function (view, ev) {\n                    var _a;\n                    var _b = view.state, doc = _b.doc, tr = _b.tr, selection = _b.selection;\n                    if (selection.empty && reTaskMarkerKey.test(ev.key)) {\n                        var _c = getRangeInfo(selection), startIndex = _c.startIndex, startFromOffset = _c.startFromOffset, from = _c.from;\n                        // should add `1` to line for the markdown parser\n                        // because markdown parser has `1`(not zero) as the start number\n                        var mdPos = [startIndex + 1, from - startFromOffset + 1];\n                        var mdNode = toastMark.findNodeAtPosition(mdPos);\n                        var paraNode = findClosestNode(mdNode, function (node) { var _a; return node.type === \'paragraph\' && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === \'item\'; });\n                        if ((_a = paraNode === null || paraNode === void 0 ? void 0 : paraNode.firstChild) === null || _a === void 0 ? void 0 : _a.literal) {\n                            var firstChild = paraNode.firstChild;\n                            var matched = firstChild.literal.match(reTaskMarker);\n                            if (matched) {\n                                var startMdPos = firstChild.sourcepos[0];\n                                var startSpaces = matched[1], stateChar = matched[2], lastSpaces = matched[3];\n                                var spaces = startSpaces.length + lastSpaces.length;\n                                var startOffset = getNodeContentOffsetRange(doc, startMdPos[0] - 1).startOffset;\n                                var startPos = startMdPos[1] + startOffset;\n                                if (stateChar) {\n                                    var addedPos = spaces ? spaces + 1 : 0;\n                                    tr.replaceWith(startPos, addedPos + startPos, schema.text(stateChar));\n                                    view.dispatch(tr);\n                                }\n                                else if (!spaces) {\n                                    tr.insertText(\' \', startPos);\n                                    view.dispatch(tr);\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nvar EVENT_TYPE = \'cut\';\nvar reLineEnding$2 = /\\r\\n|\\n|\\r/;\nvar MdEditor = /** @class */ (function (_super) {\n    __extends$1(MdEditor, _super);\n    function MdEditor(eventEmitter, options) {\n        var _this = _super.call(this, eventEmitter) || this;\n        var toastMark = options.toastMark, _a = options.useCommandShortcut, useCommandShortcut = _a === void 0 ? true : _a, _b = options.mdPlugins, mdPlugins = _b === void 0 ? [] : _b;\n        _this.editorType = \'markdown\';\n        _this.el.classList.add(\'md-mode\');\n        _this.toastMark = toastMark;\n        _this.extraPlugins = mdPlugins;\n        _this.specs = _this.createSpecs();\n        _this.schema = _this.createSchema();\n        _this.context = _this.createContext();\n        _this.keymaps = _this.createKeymaps(useCommandShortcut);\n        _this.view = _this.createView();\n        _this.commands = _this.createCommands();\n        _this.specs.setContext(__assign$1(__assign$1({}, _this.context), { view: _this.view }));\n        _this.createClipboard();\n        // To prevent unnecessary focus setting during initial rendering\n        _this.eventEmitter.listen(\'changePreviewTabWrite\', function (isMarkdownTabMounted) {\n            return _this.toggleActive(true, isMarkdownTabMounted);\n        });\n        _this.eventEmitter.listen(\'changePreviewTabPreview\', function () { return _this.toggleActive(false); });\n        _this.initEvent();\n        return _this;\n    }\n    MdEditor.prototype.toggleActive = function (active, isMarkdownTabMounted) {\n        toggleClass(this.el, \'active\', active);\n        if (active) {\n            if (!isMarkdownTabMounted) {\n                this.focus();\n            }\n        }\n        else {\n            this.blur();\n        }\n    };\n    MdEditor.prototype.createClipboard = function () {\n        var _this = this;\n        this.clipboard = document.createElement(\'textarea\');\n        this.clipboard.className = cls(\'pseudo-clipboard\');\n        this.clipboard.addEventListener(\'paste\', function (ev) {\n            var clipboardData = ev.clipboardData || window.clipboardData;\n            var items = clipboardData && clipboardData.items;\n            if (items) {\n                var containRtfItem = toArray_1(items).some(function (item) { return item.kind === \'string\' && item.type === \'text/rtf\'; });\n                // if it contains rtf, it\'s most likely copy paste from office -> no image\n                if (!containRtfItem) {\n                    var imageBlob = pasteImageOnly(items);\n                    if (imageBlob) {\n                        ev.preventDefault();\n                        emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);\n                    }\n                }\n            }\n        });\n        // process the pasted data in input event for IE11\n        this.clipboard.addEventListener(\'input\', function (ev) {\n            var text = ev.target.value;\n            _this.replaceSelection(text);\n            ev.preventDefault();\n            ev.target.value = \'\';\n        });\n        this.el.insertBefore(this.clipboard, this.view.dom);\n    };\n    MdEditor.prototype.createContext = function () {\n        return {\n            toastMark: this.toastMark,\n            schema: this.schema,\n            eventEmitter: this.eventEmitter,\n        };\n    };\n    MdEditor.prototype.createSpecs = function () {\n        return new SpecManager([\n            new Doc$1(),\n            new Paragraph$1(),\n            new Widget(),\n            new Text$1(),\n            new Heading$1(),\n            new BlockQuote$1(),\n            new CodeBlock$1(),\n            new CustomBlock$1(),\n            new Table$1(),\n            new TableCell(),\n            new ThematicBreak$1(),\n            new ListItem$1(),\n            new Strong$1(),\n            new Strike$1(),\n            new Emph$1(),\n            new Code$1(),\n            new Link$1(),\n            new Delimiter(),\n            new TaskDelimiter(),\n            new MarkedText(),\n            new Meta(),\n            new Html(),\n        ]);\n    };\n    MdEditor.prototype.createPlugins = function () {\n        return __spreadArray$1([\n            syntaxHighlight(this.context),\n            previewHighlight(this.context),\n            smartTask(this.context)\n        ], this.createPluginProps()).concat(this.defaultPlugins);\n    };\n    MdEditor.prototype.createView = function () {\n        var _this = this;\n        return new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(this.el, {\n            state: this.createState(),\n            dispatchTransaction: function (tr) {\n                _this.updateMarkdown(tr);\n                var state = _this.view.state.applyTransaction(tr).state;\n                _this.view.updateState(state);\n                _this.emitChangeEvent(tr);\n            },\n            handleKeyDown: function (_, ev) {\n                if ((ev.metaKey || ev.ctrlKey) && ev.key.toUpperCase() === \'V\') {\n                    _this.clipboard.focus();\n                }\n                _this.eventEmitter.emit(\'keydown\', _this.editorType, ev);\n                return false;\n            },\n            handleDOMEvents: {\n                copy: function (_, ev) { return _this.captureCopy(ev); },\n                cut: function (_, ev) { return _this.captureCopy(ev, EVENT_TYPE); },\n                scroll: function () {\n                    _this.eventEmitter.emit(\'scroll\', \'editor\');\n                    return true;\n                },\n                keyup: function (_, ev) {\n                    _this.eventEmitter.emit(\'keyup\', _this.editorType, ev);\n                    return false;\n                },\n            },\n            nodeViews: {\n                widget: widgetNodeView,\n            },\n        });\n    };\n    MdEditor.prototype.createCommands = function () {\n        return this.specs.commands(this.view);\n    };\n    MdEditor.prototype.captureCopy = function (ev, type) {\n        ev.preventDefault();\n        var _a = this.view.state, selection = _a.selection, tr = _a.tr;\n        if (selection.empty) {\n            return true;\n        }\n        var text = this.getChanged(selection.content());\n        if (ev.clipboardData) {\n            ev.clipboardData.setData(\'text/plain\', text);\n        }\n        else {\n            window.clipboardData.setData(\'Text\', text);\n        }\n        if (type === EVENT_TYPE) {\n            this.view.dispatch(tr.deleteSelection().scrollIntoView().setMeta(\'uiEvent\', EVENT_TYPE));\n        }\n        return true;\n    };\n    MdEditor.prototype.updateMarkdown = function (tr) {\n        var _this = this;\n        if (tr.docChanged) {\n            tr.steps.forEach(function (step, index) {\n                if (step.slice && !(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep)) {\n                    var doc = tr.docs[index];\n                    var _a = [step.from, step.to], from = _a[0], to = _a[1];\n                    var _b = getEditorToMdPos(doc, from, to), startPos = _b[0], endPos = _b[1];\n                    var changed = _this.getChanged(step.slice);\n                    if (startPos[0] === endPos[0] && startPos[1] === endPos[1] && changed === \'\') {\n                        changed = \'\\n\';\n                    }\n                    var editResult = _this.toastMark.editMarkdown(startPos, endPos, changed);\n                    _this.eventEmitter.emit(\'updatePreview\', editResult);\n                    tr.setMeta(\'editResult\', editResult).scrollIntoView();\n                }\n            });\n        }\n    };\n    MdEditor.prototype.getChanged = function (slice) {\n        var changed = \'\';\n        var from = 0;\n        var to = slice.content.size;\n        slice.content.nodesBetween(from, to, function (node, pos) {\n            if (node.isText) {\n                changed += node.text.slice(Math.max(from, pos) - pos, to - pos);\n            }\n            else if (node.isBlock && pos > 0) {\n                changed += \'\\n\';\n            }\n        });\n        return changed;\n    };\n    MdEditor.prototype.setSelection = function (start, end) {\n        if (end === void 0) { end = start; }\n        var tr = this.view.state.tr;\n        var _a = getMdToEditorPos(tr.doc, start, end), from = _a[0], to = _a[1];\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, from, to)).scrollIntoView());\n    };\n    MdEditor.prototype.replaceSelection = function (text, start, end) {\n        var newTr;\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc = _a.doc;\n        var lineTexts = text.split(reLineEnding$2);\n        var nodes = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(nodes), 1, 1);\n        this.focus();\n        if (start && end) {\n            var _b = getMdToEditorPos(doc, start, end), from = _b[0], to = _b[1];\n            newTr = tr.replaceRange(from, to, slice);\n        }\n        else {\n            newTr = tr.replaceSelection(slice);\n        }\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    MdEditor.prototype.deleteSelection = function (start, end) {\n        var newTr;\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc;\n        if (start && end) {\n            var _b = getMdToEditorPos(doc, start, end), from = _b[0], to = _b[1];\n            newTr = tr.deleteRange(from, to);\n        }\n        else {\n            newTr = tr.deleteSelection();\n        }\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    MdEditor.prototype.getSelectedText = function (start, end) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var from = selection.from, to = selection.to;\n        if (start && end) {\n            var pos = getMdToEditorPos(doc, start, end);\n            from = pos[0];\n            to = pos[1];\n        }\n        return doc.textBetween(from, to, \'\\n\');\n    };\n    MdEditor.prototype.getSelection = function () {\n        var _a = this.view.state.selection, from = _a.from, to = _a.to;\n        return getEditorToMdPos(this.view.state.tr.doc, from, to);\n    };\n    MdEditor.prototype.setMarkdown = function (markdown, cursorToEnd) {\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        var lineTexts = markdown.split(reLineEnding$2);\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n        var nodes = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        this.view.dispatch(tr.replaceWith(0, doc.content.size, nodes));\n        if (cursorToEnd) {\n            this.moveCursorToEnd(true);\n        }\n    };\n    MdEditor.prototype.addWidget = function (node, style, mdPos) {\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc, selection = _a.selection;\n        var pos = mdPos ? getMdToEditorPos(doc, mdPos, mdPos)[0] : selection.to;\n        this.view.dispatch(tr.setMeta(\'widget\', { pos: pos, node: node, style: style }));\n    };\n    MdEditor.prototype.replaceWithWidget = function (start, end, text) {\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc = _a.doc;\n        var pos = getMdToEditorPos(doc, start, end);\n        var nodes = createNodesWithWidget(text, schema);\n        this.view.dispatch(tr.replaceWith(pos[0], pos[1], nodes));\n    };\n    MdEditor.prototype.getRangeInfoOfNode = function (pos) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var mdPos = pos || getEditorToMdPos(doc, selection.from)[0];\n        var mdNode = this.toastMark.findNodeAtPosition(mdPos);\n        if (mdNode.type === \'text\' && mdNode.parent.type !== \'paragraph\') {\n            mdNode = mdNode.parent;\n        }\n        // add 1 sync for prosemirror position\n        mdNode.sourcepos[1][1] += 1;\n        return { range: mdNode.sourcepos, type: mdNode.type };\n    };\n    MdEditor.prototype.getMarkdown = function () {\n        return this.toastMark\n            .getLineTexts()\n            .map(function (lineText) { return unwrapWidgetSyntax(lineText); })\n            .join(\'\\n\');\n    };\n    MdEditor.prototype.getToastMark = function () {\n        return this.toastMark;\n    };\n    return MdEditor;\n}(EditorBase));\n\n/**\n * @fileoverview Get event collection for specific HTML element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar EVENT_KEY = \'_feEventKey\';\n\n/**\n * Get event collection for specific HTML element\n * @param {HTMLElement} element - HTML element\n * @param {string} type - event type\n * @returns {array}\n * @private\n */\nfunction safeEvent$2(element, type) {\n  var events = element[EVENT_KEY];\n  var handlers;\n\n  if (!events) {\n    events = element[EVENT_KEY] = {};\n  }\n\n  handlers = events[type];\n  if (!handlers) {\n    handlers = events[type] = [];\n  }\n\n  return handlers;\n}\n\nvar _safeEvent = safeEvent$2;\n\n/**\n * @fileoverview Unbind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString$1 = isString_1;\nvar forEach$1 = forEach_1;\n\nvar safeEvent$1 = _safeEvent;\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {function} [handler] - handler function\n * @memberof module:domEvent\n * @example\n * // Following the example of domEvent#on\n * \n * // Unbind one event from an element.\n * off(div, \'click\', toggle);\n * \n * // Unbind multiple events with a same handler from multiple elements at once.\n * // Use event names splitted by a space.\n * off(element, \'mouseenter mouseleave\', changeColor);\n * \n * // Unbind multiple events with different handlers from an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * off(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Unbind events without handlers.\n * off(div, \'drag\');\n */\nfunction off(element, types, handler) {\n  if (isString$1(types)) {\n    forEach$1(types.split(/\\s+/g), function(type) {\n      unbindEvent(element, type, handler);\n    });\n\n    return;\n  }\n\n  forEach$1(types, function(func, type) {\n    unbindEvent(element, type, func);\n  });\n}\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {string} type - events name\n * @param {function} [handler] - handler function\n * @private\n */\nfunction unbindEvent(element, type, handler) {\n  var events = safeEvent$1(element, type);\n  var index;\n\n  if (!handler) {\n    forEach$1(events, function(item) {\n      removeHandler(element, type, item.wrappedHandler);\n    });\n    events.splice(0, events.length);\n  } else {\n    forEach$1(events, function(item, idx) {\n      if (handler === item.handler) {\n        removeHandler(element, type, item.wrappedHandler);\n        index = idx;\n\n        return false;\n      }\n\n      return true;\n    });\n    events.splice(index, 1);\n  }\n}\n\n/**\n * Remove an event handler\n * @param {HTMLElement} element - An element to remove an event\n * @param {string} type - event type\n * @param {function} handler - event handler\n * @private\n */\nfunction removeHandler(element, type, handler) {\n  if (\'removeEventListener\' in element) {\n    element.removeEventListener(type, handler);\n  } else if (\'detachEvent\' in element) {\n    element.detachEvent(\'on\' + type, handler);\n  }\n}\n\nvar off_1 = off;\n\n/**\n * @fileoverview Bind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString = isString_1;\nvar forEach = forEach_1;\n\nvar safeEvent = _safeEvent;\n\n/**\n * Bind DOM events.\n * @param {HTMLElement} element - element to bind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {(function|object)} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @memberof module:domEvent\n * @example\n * const div = document.querySelector(\'div\');\n * \n * // Bind one event to an element.\n * on(div, \'click\', toggle);\n * \n * // Bind multiple events with a same handler to multiple elements at once.\n * // Use event names splitted by a space.\n * on(div, \'mouseenter mouseleave\', changeColor);\n * \n * // Bind multiple events with different handlers to an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * on(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Set a context for handler method.\n * const name = \'global\';\n * const repository = {name: \'CodeSnippet\'};\n * on(div, \'drag\', function() {\n *   console.log(this.name);\n * }, repository);\n * // Result when you drag a div: "CodeSnippet"\n */\nfunction on(element, types, handler, context) {\n  if (isString(types)) {\n    forEach(types.split(/\\s+/g), function(type) {\n      bindEvent(element, type, handler, context);\n    });\n\n    return;\n  }\n\n  forEach(types, function(func, type) {\n    bindEvent(element, type, func, handler);\n  });\n}\n\n/**\n * Bind DOM events\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @private\n */\nfunction bindEvent(element, type, handler, context) {\n  /**\n     * Event handler\n     * @param {Event} e - event object\n     */\n  function eventHandler(e) {\n    handler.call(context || element, e || window.event);\n  }\n\n  if (\'addEventListener\' in element) {\n    element.addEventListener(type, eventHandler);\n  } else if (\'attachEvent\' in element) {\n    element.attachEvent(\'on\' + type, eventHandler);\n  }\n  memorizeHandler(element, type, handler, eventHandler);\n}\n\n/**\n * Memorize DOM event handler for unbinding.\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function that user passed at on() use\n * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features\n * @private\n */\nfunction memorizeHandler(element, type, handler, wrappedHandler) {\n  var events = safeEvent(element, type);\n  var existInEvents = false;\n\n  forEach(events, function(obj) {\n    if (obj.handler === handler) {\n      existInEvents = true;\n\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!existInEvents) {\n    events.push({\n      handler: handler,\n      wrappedHandler: wrappedHandler\n    });\n  }\n}\n\nvar on_1 = on;\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nvar commonjsGlobal = typeof globalThis !== \'undefined\' ? globalThis : typeof window !== \'undefined\' ? window : typeof __webpack_require__.g !== \'undefined\' ? __webpack_require__.g : typeof self !== \'undefined\' ? self : {};\n\nvar encodeCache = {};\n\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n  var i, ch, cache = encodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = encodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push(\'%\' + (\'0\' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache;\n}\n\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don\'t encode \'%\' in a correct escape sequence (default: true)\n//\nfunction encode$1(string, exclude, keepEscaped) {\n  var i, l, code, nextCode, cache,\n      result = \'\';\n\n  if (typeof exclude !== \'string\') {\n    // encode(string, keepEscaped)\n    keepEscaped  = exclude;\n    exclude = encode$1.defaultChars;\n  }\n\n  if (typeof keepEscaped === \'undefined\') {\n    keepEscaped = true;\n  }\n\n  cache = getEncodeCache(exclude);\n\n  for (i = 0, l = string.length; i < l; i++) {\n    code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result += \'%EF%BF%BD\';\n      continue;\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result;\n}\n\nencode$1.defaultChars   = ";/?:@&=+$,-_.!~*\'()#";\nencode$1.componentChars = "-_.!~*\'()";\n\n\nvar encode_1 = encode$1;\n\nvar lib = {};\n\nvar decode = {};\n\nvar Aacute$1 = "Á";\nvar aacute$1 = "á";\nvar Abreve = "Ă";\nvar abreve = "ă";\nvar ac = "∾";\nvar acd = "∿";\nvar acE = "∾̳";\nvar Acirc$1 = "Â";\nvar acirc$1 = "â";\nvar acute$1 = "´";\nvar Acy = "А";\nvar acy = "а";\nvar AElig$1 = "Æ";\nvar aelig$1 = "æ";\nvar af = "⁡";\nvar Afr = "𝔄";\nvar afr = "𝔞";\nvar Agrave$1 = "À";\nvar agrave$1 = "à";\nvar alefsym = "ℵ";\nvar aleph = "ℵ";\nvar Alpha = "Α";\nvar alpha = "α";\nvar Amacr = "Ā";\nvar amacr = "ā";\nvar amalg = "⨿";\nvar amp$2 = "&";\nvar AMP$1 = "&";\nvar andand = "⩕";\nvar And = "⩓";\nvar and = "∧";\nvar andd = "⩜";\nvar andslope = "⩘";\nvar andv = "⩚";\nvar ang = "∠";\nvar ange = "⦤";\nvar angle = "∠";\nvar angmsdaa = "⦨";\nvar angmsdab = "⦩";\nvar angmsdac = "⦪";\nvar angmsdad = "⦫";\nvar angmsdae = "⦬";\nvar angmsdaf = "⦭";\nvar angmsdag = "⦮";\nvar angmsdah = "⦯";\nvar angmsd = "∡";\nvar angrt = "∟";\nvar angrtvb = "⊾";\nvar angrtvbd = "⦝";\nvar angsph = "∢";\nvar angst = "Å";\nvar angzarr = "⍼";\nvar Aogon = "Ą";\nvar aogon = "ą";\nvar Aopf = "𝔸";\nvar aopf = "𝕒";\nvar apacir = "⩯";\nvar ap = "≈";\nvar apE = "⩰";\nvar ape = "≊";\nvar apid = "≋";\nvar apos$1 = "\'";\nvar ApplyFunction = "⁡";\nvar approx = "≈";\nvar approxeq = "≊";\nvar Aring$1 = "Å";\nvar aring$1 = "å";\nvar Ascr = "𝒜";\nvar ascr = "𝒶";\nvar Assign = "≔";\nvar ast = "*";\nvar asymp = "≈";\nvar asympeq = "≍";\nvar Atilde$1 = "Ã";\nvar atilde$1 = "ã";\nvar Auml$1 = "Ä";\nvar auml$1 = "ä";\nvar awconint = "∳";\nvar awint = "⨑";\nvar backcong = "≌";\nvar backepsilon = "϶";\nvar backprime = "‵";\nvar backsim = "∽";\nvar backsimeq = "⋍";\nvar Backslash = "∖";\nvar Barv = "⫧";\nvar barvee = "⊽";\nvar barwed = "⌅";\nvar Barwed = "⌆";\nvar barwedge = "⌅";\nvar bbrk = "⎵";\nvar bbrktbrk = "⎶";\nvar bcong = "≌";\nvar Bcy = "Б";\nvar bcy = "б";\nvar bdquo = "„";\nvar becaus = "∵";\nvar because = "∵";\nvar Because = "∵";\nvar bemptyv = "⦰";\nvar bepsi = "϶";\nvar bernou = "ℬ";\nvar Bernoullis = "ℬ";\nvar Beta = "Β";\nvar beta = "β";\nvar beth = "ℶ";\nvar between = "≬";\nvar Bfr = "𝔅";\nvar bfr = "𝔟";\nvar bigcap = "⋂";\nvar bigcirc = "◯";\nvar bigcup = "⋃";\nvar bigodot = "⨀";\nvar bigoplus = "⨁";\nvar bigotimes = "⨂";\nvar bigsqcup = "⨆";\nvar bigstar = "★";\nvar bigtriangledown = "▽";\nvar bigtriangleup = "△";\nvar biguplus = "⨄";\nvar bigvee = "⋁";\nvar bigwedge = "⋀";\nvar bkarow = "⤍";\nvar blacklozenge = "⧫";\nvar blacksquare = "▪";\nvar blacktriangle = "▴";\nvar blacktriangledown = "▾";\nvar blacktriangleleft = "◂";\nvar blacktriangleright = "▸";\nvar blank = "␣";\nvar blk12 = "▒";\nvar blk14 = "░";\nvar blk34 = "▓";\nvar block = "█";\nvar bne = "=⃥";\nvar bnequiv = "≡⃥";\nvar bNot = "⫭";\nvar bnot = "⌐";\nvar Bopf = "𝔹";\nvar bopf = "𝕓";\nvar bot = "⊥";\nvar bottom = "⊥";\nvar bowtie = "⋈";\nvar boxbox = "⧉";\nvar boxdl = "┐";\nvar boxdL = "╕";\nvar boxDl = "╖";\nvar boxDL = "╗";\nvar boxdr = "┌";\nvar boxdR = "╒";\nvar boxDr = "╓";\nvar boxDR = "╔";\nvar boxh = "─";\nvar boxH = "═";\nvar boxhd = "┬";\nvar boxHd = "╤";\nvar boxhD = "╥";\nvar boxHD = "╦";\nvar boxhu = "┴";\nvar boxHu = "╧";\nvar boxhU = "╨";\nvar boxHU = "╩";\nvar boxminus = "⊟";\nvar boxplus = "⊞";\nvar boxtimes = "⊠";\nvar boxul = "┘";\nvar boxuL = "╛";\nvar boxUl = "╜";\nvar boxUL = "╝";\nvar boxur = "└";\nvar boxuR = "╘";\nvar boxUr = "╙";\nvar boxUR = "╚";\nvar boxv = "│";\nvar boxV = "║";\nvar boxvh = "┼";\nvar boxvH = "╪";\nvar boxVh = "╫";\nvar boxVH = "╬";\nvar boxvl = "┤";\nvar boxvL = "╡";\nvar boxVl = "╢";\nvar boxVL = "╣";\nvar boxvr = "├";\nvar boxvR = "╞";\nvar boxVr = "╟";\nvar boxVR = "╠";\nvar bprime = "‵";\nvar breve = "˘";\nvar Breve = "˘";\nvar brvbar$1 = "¦";\nvar bscr = "𝒷";\nvar Bscr = "ℬ";\nvar bsemi = "⁏";\nvar bsim = "∽";\nvar bsime = "⋍";\nvar bsolb = "⧅";\nvar bsol = "\\\\";\nvar bsolhsub = "⟈";\nvar bull = "•";\nvar bullet = "•";\nvar bump = "≎";\nvar bumpE = "⪮";\nvar bumpe = "≏";\nvar Bumpeq = "≎";\nvar bumpeq = "≏";\nvar Cacute = "Ć";\nvar cacute = "ć";\nvar capand = "⩄";\nvar capbrcup = "⩉";\nvar capcap = "⩋";\nvar cap = "∩";\nvar Cap = "⋒";\nvar capcup = "⩇";\nvar capdot = "⩀";\nvar CapitalDifferentialD = "ⅅ";\nvar caps = "∩︀";\nvar caret = "⁁";\nvar caron = "ˇ";\nvar Cayleys = "ℭ";\nvar ccaps = "⩍";\nvar Ccaron = "Č";\nvar ccaron = "č";\nvar Ccedil$1 = "Ç";\nvar ccedil$1 = "ç";\nvar Ccirc = "Ĉ";\nvar ccirc = "ĉ";\nvar Cconint = "∰";\nvar ccups = "⩌";\nvar ccupssm = "⩐";\nvar Cdot = "Ċ";\nvar cdot = "ċ";\nvar cedil$1 = "¸";\nvar Cedilla = "¸";\nvar cemptyv = "⦲";\nvar cent$1 = "¢";\nvar centerdot = "·";\nvar CenterDot = "·";\nvar cfr = "𝔠";\nvar Cfr = "ℭ";\nvar CHcy = "Ч";\nvar chcy = "ч";\nvar check = "✓";\nvar checkmark = "✓";\nvar Chi = "Χ";\nvar chi = "χ";\nvar circ = "ˆ";\nvar circeq = "≗";\nvar circlearrowleft = "↺";\nvar circlearrowright = "↻";\nvar circledast = "⊛";\nvar circledcirc = "⊚";\nvar circleddash = "⊝";\nvar CircleDot = "⊙";\nvar circledR = "®";\nvar circledS = "Ⓢ";\nvar CircleMinus = "⊖";\nvar CirclePlus = "⊕";\nvar CircleTimes = "⊗";\nvar cir = "○";\nvar cirE = "⧃";\nvar cire = "≗";\nvar cirfnint = "⨐";\nvar cirmid = "⫯";\nvar cirscir = "⧂";\nvar ClockwiseContourIntegral = "∲";\nvar CloseCurlyDoubleQuote = "”";\nvar CloseCurlyQuote = "’";\nvar clubs = "♣";\nvar clubsuit = "♣";\nvar colon = ":";\nvar Colon = "∷";\nvar Colone = "⩴";\nvar colone = "≔";\nvar coloneq = "≔";\nvar comma = ",";\nvar commat = "@";\nvar comp = "∁";\nvar compfn = "∘";\nvar complement = "∁";\nvar complexes = "ℂ";\nvar cong = "≅";\nvar congdot = "⩭";\nvar Congruent = "≡";\nvar conint = "∮";\nvar Conint = "∯";\nvar ContourIntegral = "∮";\nvar copf = "𝕔";\nvar Copf = "ℂ";\nvar coprod = "∐";\nvar Coproduct = "∐";\nvar copy$1 = "©";\nvar COPY$1 = "©";\nvar copysr = "℗";\nvar CounterClockwiseContourIntegral = "∳";\nvar crarr = "↵";\nvar cross = "✗";\nvar Cross = "⨯";\nvar Cscr = "𝒞";\nvar cscr = "𝒸";\nvar csub = "⫏";\nvar csube = "⫑";\nvar csup = "⫐";\nvar csupe = "⫒";\nvar ctdot = "⋯";\nvar cudarrl = "⤸";\nvar cudarrr = "⤵";\nvar cuepr = "⋞";\nvar cuesc = "⋟";\nvar cularr = "↶";\nvar cularrp = "⤽";\nvar cupbrcap = "⩈";\nvar cupcap = "⩆";\nvar CupCap = "≍";\nvar cup = "∪";\nvar Cup = "⋓";\nvar cupcup = "⩊";\nvar cupdot = "⊍";\nvar cupor = "⩅";\nvar cups = "∪︀";\nvar curarr = "↷";\nvar curarrm = "⤼";\nvar curlyeqprec = "⋞";\nvar curlyeqsucc = "⋟";\nvar curlyvee = "⋎";\nvar curlywedge = "⋏";\nvar curren$1 = "¤";\nvar curvearrowleft = "↶";\nvar curvearrowright = "↷";\nvar cuvee = "⋎";\nvar cuwed = "⋏";\nvar cwconint = "∲";\nvar cwint = "∱";\nvar cylcty = "⌭";\nvar dagger = "†";\nvar Dagger = "‡";\nvar daleth = "ℸ";\nvar darr = "↓";\nvar Darr = "↡";\nvar dArr = "⇓";\nvar dash = "‐";\nvar Dashv = "⫤";\nvar dashv = "⊣";\nvar dbkarow = "⤏";\nvar dblac = "˝";\nvar Dcaron = "Ď";\nvar dcaron = "ď";\nvar Dcy = "Д";\nvar dcy = "д";\nvar ddagger = "‡";\nvar ddarr = "⇊";\nvar DD = "ⅅ";\nvar dd = "ⅆ";\nvar DDotrahd = "⤑";\nvar ddotseq = "⩷";\nvar deg$1 = "°";\nvar Del = "∇";\nvar Delta = "Δ";\nvar delta = "δ";\nvar demptyv = "⦱";\nvar dfisht = "⥿";\nvar Dfr = "𝔇";\nvar dfr = "𝔡";\nvar dHar = "⥥";\nvar dharl = "⇃";\nvar dharr = "⇂";\nvar DiacriticalAcute = "´";\nvar DiacriticalDot = "˙";\nvar DiacriticalDoubleAcute = "˝";\nvar DiacriticalGrave = "`";\nvar DiacriticalTilde = "˜";\nvar diam = "⋄";\nvar diamond = "⋄";\nvar Diamond = "⋄";\nvar diamondsuit = "♦";\nvar diams = "♦";\nvar die = "¨";\nvar DifferentialD = "ⅆ";\nvar digamma = "ϝ";\nvar disin = "⋲";\nvar div = "÷";\nvar divide$1 = "÷";\nvar divideontimes = "⋇";\nvar divonx = "⋇";\nvar DJcy = "Ђ";\nvar djcy = "ђ";\nvar dlcorn = "⌞";\nvar dlcrop = "⌍";\nvar dollar = "$";\nvar Dopf = "𝔻";\nvar dopf = "𝕕";\nvar Dot = "¨";\nvar dot = "˙";\nvar DotDot = "⃜";\nvar doteq = "≐";\nvar doteqdot = "≑";\nvar DotEqual = "≐";\nvar dotminus = "∸";\nvar dotplus = "∔";\nvar dotsquare = "⊡";\nvar doublebarwedge = "⌆";\nvar DoubleContourIntegral = "∯";\nvar DoubleDot = "¨";\nvar DoubleDownArrow = "⇓";\nvar DoubleLeftArrow = "⇐";\nvar DoubleLeftRightArrow = "⇔";\nvar DoubleLeftTee = "⫤";\nvar DoubleLongLeftArrow = "⟸";\nvar DoubleLongLeftRightArrow = "⟺";\nvar DoubleLongRightArrow = "⟹";\nvar DoubleRightArrow = "⇒";\nvar DoubleRightTee = "⊨";\nvar DoubleUpArrow = "⇑";\nvar DoubleUpDownArrow = "⇕";\nvar DoubleVerticalBar = "∥";\nvar DownArrowBar = "⤓";\nvar downarrow = "↓";\nvar DownArrow = "↓";\nvar Downarrow = "⇓";\nvar DownArrowUpArrow = "⇵";\nvar DownBreve = "̑";\nvar downdownarrows = "⇊";\nvar downharpoonleft = "⇃";\nvar downharpoonright = "⇂";\nvar DownLeftRightVector = "⥐";\nvar DownLeftTeeVector = "⥞";\nvar DownLeftVectorBar = "⥖";\nvar DownLeftVector = "↽";\nvar DownRightTeeVector = "⥟";\nvar DownRightVectorBar = "⥗";\nvar DownRightVector = "⇁";\nvar DownTeeArrow = "↧";\nvar DownTee = "⊤";\nvar drbkarow = "⤐";\nvar drcorn = "⌟";\nvar drcrop = "⌌";\nvar Dscr = "𝒟";\nvar dscr = "𝒹";\nvar DScy = "Ѕ";\nvar dscy = "ѕ";\nvar dsol = "⧶";\nvar Dstrok = "Đ";\nvar dstrok = "đ";\nvar dtdot = "⋱";\nvar dtri = "▿";\nvar dtrif = "▾";\nvar duarr = "⇵";\nvar duhar = "⥯";\nvar dwangle = "⦦";\nvar DZcy = "Џ";\nvar dzcy = "џ";\nvar dzigrarr = "⟿";\nvar Eacute$1 = "É";\nvar eacute$1 = "é";\nvar easter = "⩮";\nvar Ecaron = "Ě";\nvar ecaron = "ě";\nvar Ecirc$1 = "Ê";\nvar ecirc$1 = "ê";\nvar ecir = "≖";\nvar ecolon = "≕";\nvar Ecy = "Э";\nvar ecy = "э";\nvar eDDot = "⩷";\nvar Edot = "Ė";\nvar edot = "ė";\nvar eDot = "≑";\nvar ee = "ⅇ";\nvar efDot = "≒";\nvar Efr = "𝔈";\nvar efr = "𝔢";\nvar eg = "⪚";\nvar Egrave$1 = "È";\nvar egrave$1 = "è";\nvar egs = "⪖";\nvar egsdot = "⪘";\nvar el = "⪙";\nvar Element$1 = "∈";\nvar elinters = "⏧";\nvar ell = "ℓ";\nvar els = "⪕";\nvar elsdot = "⪗";\nvar Emacr = "Ē";\nvar emacr = "ē";\nvar empty = "∅";\nvar emptyset = "∅";\nvar EmptySmallSquare = "◻";\nvar emptyv = "∅";\nvar EmptyVerySmallSquare = "▫";\nvar emsp13 = " ";\nvar emsp14 = " ";\nvar emsp = " ";\nvar ENG = "Ŋ";\nvar eng = "ŋ";\nvar ensp = " ";\nvar Eogon = "Ę";\nvar eogon = "ę";\nvar Eopf = "𝔼";\nvar eopf = "𝕖";\nvar epar = "⋕";\nvar eparsl = "⧣";\nvar eplus = "⩱";\nvar epsi = "ε";\nvar Epsilon = "Ε";\nvar epsilon = "ε";\nvar epsiv = "ϵ";\nvar eqcirc = "≖";\nvar eqcolon = "≕";\nvar eqsim = "≂";\nvar eqslantgtr = "⪖";\nvar eqslantless = "⪕";\nvar Equal = "⩵";\nvar equals = "=";\nvar EqualTilde = "≂";\nvar equest = "≟";\nvar Equilibrium = "⇌";\nvar equiv = "≡";\nvar equivDD = "⩸";\nvar eqvparsl = "⧥";\nvar erarr = "⥱";\nvar erDot = "≓";\nvar escr = "ℯ";\nvar Escr = "ℰ";\nvar esdot = "≐";\nvar Esim = "⩳";\nvar esim = "≂";\nvar Eta = "Η";\nvar eta = "η";\nvar ETH$1 = "Ð";\nvar eth$1 = "ð";\nvar Euml$1 = "Ë";\nvar euml$1 = "ë";\nvar euro = "€";\nvar excl = "!";\nvar exist = "∃";\nvar Exists = "∃";\nvar expectation = "ℰ";\nvar exponentiale = "ⅇ";\nvar ExponentialE = "ⅇ";\nvar fallingdotseq = "≒";\nvar Fcy = "Ф";\nvar fcy = "ф";\nvar female = "♀";\nvar ffilig = "ﬃ";\nvar fflig = "ﬀ";\nvar ffllig = "ﬄ";\nvar Ffr = "𝔉";\nvar ffr = "𝔣";\nvar filig = "ﬁ";\nvar FilledSmallSquare = "◼";\nvar FilledVerySmallSquare = "▪";\nvar fjlig = "fj";\nvar flat = "♭";\nvar fllig = "ﬂ";\nvar fltns = "▱";\nvar fnof = "ƒ";\nvar Fopf = "𝔽";\nvar fopf = "𝕗";\nvar forall = "∀";\nvar ForAll = "∀";\nvar fork = "⋔";\nvar forkv = "⫙";\nvar Fouriertrf = "ℱ";\nvar fpartint = "⨍";\nvar frac12$1 = "½";\nvar frac13 = "⅓";\nvar frac14$1 = "¼";\nvar frac15 = "⅕";\nvar frac16 = "⅙";\nvar frac18 = "⅛";\nvar frac23 = "⅔";\nvar frac25 = "⅖";\nvar frac34$1 = "¾";\nvar frac35 = "⅗";\nvar frac38 = "⅜";\nvar frac45 = "⅘";\nvar frac56 = "⅚";\nvar frac58 = "⅝";\nvar frac78 = "⅞";\nvar frasl = "⁄";\nvar frown = "⌢";\nvar fscr = "𝒻";\nvar Fscr = "ℱ";\nvar gacute = "ǵ";\nvar Gamma = "Γ";\nvar gamma = "γ";\nvar Gammad = "Ϝ";\nvar gammad = "ϝ";\nvar gap = "⪆";\nvar Gbreve = "Ğ";\nvar gbreve = "ğ";\nvar Gcedil = "Ģ";\nvar Gcirc = "Ĝ";\nvar gcirc = "ĝ";\nvar Gcy = "Г";\nvar gcy = "г";\nvar Gdot = "Ġ";\nvar gdot = "ġ";\nvar ge = "≥";\nvar gE = "≧";\nvar gEl = "⪌";\nvar gel = "⋛";\nvar geq = "≥";\nvar geqq = "≧";\nvar geqslant = "⩾";\nvar gescc = "⪩";\nvar ges = "⩾";\nvar gesdot = "⪀";\nvar gesdoto = "⪂";\nvar gesdotol = "⪄";\nvar gesl = "⋛︀";\nvar gesles = "⪔";\nvar Gfr = "𝔊";\nvar gfr = "𝔤";\nvar gg = "≫";\nvar Gg = "⋙";\nvar ggg = "⋙";\nvar gimel = "ℷ";\nvar GJcy = "Ѓ";\nvar gjcy = "ѓ";\nvar gla = "⪥";\nvar gl = "≷";\nvar glE = "⪒";\nvar glj = "⪤";\nvar gnap = "⪊";\nvar gnapprox = "⪊";\nvar gne = "⪈";\nvar gnE = "≩";\nvar gneq = "⪈";\nvar gneqq = "≩";\nvar gnsim = "⋧";\nvar Gopf = "𝔾";\nvar gopf = "𝕘";\nvar grave = "`";\nvar GreaterEqual = "≥";\nvar GreaterEqualLess = "⋛";\nvar GreaterFullEqual = "≧";\nvar GreaterGreater = "⪢";\nvar GreaterLess = "≷";\nvar GreaterSlantEqual = "⩾";\nvar GreaterTilde = "≳";\nvar Gscr = "𝒢";\nvar gscr = "ℊ";\nvar gsim = "≳";\nvar gsime = "⪎";\nvar gsiml = "⪐";\nvar gtcc = "⪧";\nvar gtcir = "⩺";\nvar gt$2 = ">";\nvar GT$1 = ">";\nvar Gt = "≫";\nvar gtdot = "⋗";\nvar gtlPar = "⦕";\nvar gtquest = "⩼";\nvar gtrapprox = "⪆";\nvar gtrarr = "⥸";\nvar gtrdot = "⋗";\nvar gtreqless = "⋛";\nvar gtreqqless = "⪌";\nvar gtrless = "≷";\nvar gtrsim = "≳";\nvar gvertneqq = "≩︀";\nvar gvnE = "≩︀";\nvar Hacek = "ˇ";\nvar hairsp = " ";\nvar half = "½";\nvar hamilt = "ℋ";\nvar HARDcy = "Ъ";\nvar hardcy = "ъ";\nvar harrcir = "⥈";\nvar harr = "↔";\nvar hArr = "⇔";\nvar harrw = "↭";\nvar Hat = "^";\nvar hbar = "ℏ";\nvar Hcirc = "Ĥ";\nvar hcirc = "ĥ";\nvar hearts = "♥";\nvar heartsuit = "♥";\nvar hellip = "…";\nvar hercon = "⊹";\nvar hfr = "𝔥";\nvar Hfr = "ℌ";\nvar HilbertSpace = "ℋ";\nvar hksearow = "⤥";\nvar hkswarow = "⤦";\nvar hoarr = "⇿";\nvar homtht = "∻";\nvar hookleftarrow = "↩";\nvar hookrightarrow = "↪";\nvar hopf = "𝕙";\nvar Hopf = "ℍ";\nvar horbar = "―";\nvar HorizontalLine = "─";\nvar hscr = "𝒽";\nvar Hscr = "ℋ";\nvar hslash = "ℏ";\nvar Hstrok = "Ħ";\nvar hstrok = "ħ";\nvar HumpDownHump = "≎";\nvar HumpEqual = "≏";\nvar hybull = "⁃";\nvar hyphen = "‐";\nvar Iacute$1 = "Í";\nvar iacute$1 = "í";\nvar ic = "⁣";\nvar Icirc$1 = "Î";\nvar icirc$1 = "î";\nvar Icy = "И";\nvar icy = "и";\nvar Idot = "İ";\nvar IEcy = "Е";\nvar iecy = "е";\nvar iexcl$1 = "¡";\nvar iff = "⇔";\nvar ifr = "𝔦";\nvar Ifr = "ℑ";\nvar Igrave$1 = "Ì";\nvar igrave$1 = "ì";\nvar ii = "ⅈ";\nvar iiiint = "⨌";\nvar iiint = "∭";\nvar iinfin = "⧜";\nvar iiota = "℩";\nvar IJlig = "Ĳ";\nvar ijlig = "ĳ";\nvar Imacr = "Ī";\nvar imacr = "ī";\nvar image = "ℑ";\nvar ImaginaryI = "ⅈ";\nvar imagline = "ℐ";\nvar imagpart = "ℑ";\nvar imath = "ı";\nvar Im = "ℑ";\nvar imof = "⊷";\nvar imped = "Ƶ";\nvar Implies = "⇒";\nvar incare = "℅";\nvar infin = "∞";\nvar infintie = "⧝";\nvar inodot = "ı";\nvar intcal = "⊺";\nvar int = "∫";\nvar Int = "∬";\nvar integers = "ℤ";\nvar Integral = "∫";\nvar intercal = "⊺";\nvar Intersection = "⋂";\nvar intlarhk = "⨗";\nvar intprod = "⨼";\nvar InvisibleComma = "⁣";\nvar InvisibleTimes = "⁢";\nvar IOcy = "Ё";\nvar iocy = "ё";\nvar Iogon = "Į";\nvar iogon = "į";\nvar Iopf = "𝕀";\nvar iopf = "𝕚";\nvar Iota = "Ι";\nvar iota = "ι";\nvar iprod = "⨼";\nvar iquest$1 = "¿";\nvar iscr = "𝒾";\nvar Iscr = "ℐ";\nvar isin = "∈";\nvar isindot = "⋵";\nvar isinE = "⋹";\nvar isins = "⋴";\nvar isinsv = "⋳";\nvar isinv = "∈";\nvar it = "⁢";\nvar Itilde = "Ĩ";\nvar itilde = "ĩ";\nvar Iukcy = "І";\nvar iukcy = "і";\nvar Iuml$1 = "Ï";\nvar iuml$1 = "ï";\nvar Jcirc = "Ĵ";\nvar jcirc = "ĵ";\nvar Jcy = "Й";\nvar jcy = "й";\nvar Jfr = "𝔍";\nvar jfr = "𝔧";\nvar jmath = "ȷ";\nvar Jopf = "𝕁";\nvar jopf = "𝕛";\nvar Jscr = "𝒥";\nvar jscr = "𝒿";\nvar Jsercy = "Ј";\nvar jsercy = "ј";\nvar Jukcy = "Є";\nvar jukcy = "є";\nvar Kappa = "Κ";\nvar kappa = "κ";\nvar kappav = "ϰ";\nvar Kcedil = "Ķ";\nvar kcedil = "ķ";\nvar Kcy = "К";\nvar kcy = "к";\nvar Kfr = "𝔎";\nvar kfr = "𝔨";\nvar kgreen = "ĸ";\nvar KHcy = "Х";\nvar khcy = "х";\nvar KJcy = "Ќ";\nvar kjcy = "ќ";\nvar Kopf = "𝕂";\nvar kopf = "𝕜";\nvar Kscr = "𝒦";\nvar kscr = "𝓀";\nvar lAarr = "⇚";\nvar Lacute = "Ĺ";\nvar lacute = "ĺ";\nvar laemptyv = "⦴";\nvar lagran = "ℒ";\nvar Lambda = "Λ";\nvar lambda = "λ";\nvar lang = "⟨";\nvar Lang = "⟪";\nvar langd = "⦑";\nvar langle = "⟨";\nvar lap = "⪅";\nvar Laplacetrf = "ℒ";\nvar laquo$1 = "«";\nvar larrb = "⇤";\nvar larrbfs = "⤟";\nvar larr = "←";\nvar Larr = "↞";\nvar lArr = "⇐";\nvar larrfs = "⤝";\nvar larrhk = "↩";\nvar larrlp = "↫";\nvar larrpl = "⤹";\nvar larrsim = "⥳";\nvar larrtl = "↢";\nvar latail = "⤙";\nvar lAtail = "⤛";\nvar lat = "⪫";\nvar late = "⪭";\nvar lates = "⪭︀";\nvar lbarr = "⤌";\nvar lBarr = "⤎";\nvar lbbrk = "❲";\nvar lbrace = "{";\nvar lbrack = "[";\nvar lbrke = "⦋";\nvar lbrksld = "⦏";\nvar lbrkslu = "⦍";\nvar Lcaron = "Ľ";\nvar lcaron = "ľ";\nvar Lcedil = "Ļ";\nvar lcedil = "ļ";\nvar lceil = "⌈";\nvar lcub = "{";\nvar Lcy = "Л";\nvar lcy = "л";\nvar ldca = "⤶";\nvar ldquo = "“";\nvar ldquor = "„";\nvar ldrdhar = "⥧";\nvar ldrushar = "⥋";\nvar ldsh = "↲";\nvar le = "≤";\nvar lE = "≦";\nvar LeftAngleBracket = "⟨";\nvar LeftArrowBar = "⇤";\nvar leftarrow = "←";\nvar LeftArrow = "←";\nvar Leftarrow = "⇐";\nvar LeftArrowRightArrow = "⇆";\nvar leftarrowtail = "↢";\nvar LeftCeiling = "⌈";\nvar LeftDoubleBracket = "⟦";\nvar LeftDownTeeVector = "⥡";\nvar LeftDownVectorBar = "⥙";\nvar LeftDownVector = "⇃";\nvar LeftFloor = "⌊";\nvar leftharpoondown = "↽";\nvar leftharpoonup = "↼";\nvar leftleftarrows = "⇇";\nvar leftrightarrow = "↔";\nvar LeftRightArrow = "↔";\nvar Leftrightarrow = "⇔";\nvar leftrightarrows = "⇆";\nvar leftrightharpoons = "⇋";\nvar leftrightsquigarrow = "↭";\nvar LeftRightVector = "⥎";\nvar LeftTeeArrow = "↤";\nvar LeftTee = "⊣";\nvar LeftTeeVector = "⥚";\nvar leftthreetimes = "⋋";\nvar LeftTriangleBar = "⧏";\nvar LeftTriangle = "⊲";\nvar LeftTriangleEqual = "⊴";\nvar LeftUpDownVector = "⥑";\nvar LeftUpTeeVector = "⥠";\nvar LeftUpVectorBar = "⥘";\nvar LeftUpVector = "↿";\nvar LeftVectorBar = "⥒";\nvar LeftVector = "↼";\nvar lEg = "⪋";\nvar leg = "⋚";\nvar leq = "≤";\nvar leqq = "≦";\nvar leqslant = "⩽";\nvar lescc = "⪨";\nvar les = "⩽";\nvar lesdot = "⩿";\nvar lesdoto = "⪁";\nvar lesdotor = "⪃";\nvar lesg = "⋚︀";\nvar lesges = "⪓";\nvar lessapprox = "⪅";\nvar lessdot = "⋖";\nvar lesseqgtr = "⋚";\nvar lesseqqgtr = "⪋";\nvar LessEqualGreater = "⋚";\nvar LessFullEqual = "≦";\nvar LessGreater = "≶";\nvar lessgtr = "≶";\nvar LessLess = "⪡";\nvar lesssim = "≲";\nvar LessSlantEqual = "⩽";\nvar LessTilde = "≲";\nvar lfisht = "⥼";\nvar lfloor = "⌊";\nvar Lfr = "𝔏";\nvar lfr = "𝔩";\nvar lg = "≶";\nvar lgE = "⪑";\nvar lHar = "⥢";\nvar lhard = "↽";\nvar lharu = "↼";\nvar lharul = "⥪";\nvar lhblk = "▄";\nvar LJcy = "Љ";\nvar ljcy = "љ";\nvar llarr = "⇇";\nvar ll = "≪";\nvar Ll = "⋘";\nvar llcorner = "⌞";\nvar Lleftarrow = "⇚";\nvar llhard = "⥫";\nvar lltri = "◺";\nvar Lmidot = "Ŀ";\nvar lmidot = "ŀ";\nvar lmoustache = "⎰";\nvar lmoust = "⎰";\nvar lnap = "⪉";\nvar lnapprox = "⪉";\nvar lne = "⪇";\nvar lnE = "≨";\nvar lneq = "⪇";\nvar lneqq = "≨";\nvar lnsim = "⋦";\nvar loang = "⟬";\nvar loarr = "⇽";\nvar lobrk = "⟦";\nvar longleftarrow = "⟵";\nvar LongLeftArrow = "⟵";\nvar Longleftarrow = "⟸";\nvar longleftrightarrow = "⟷";\nvar LongLeftRightArrow = "⟷";\nvar Longleftrightarrow = "⟺";\nvar longmapsto = "⟼";\nvar longrightarrow = "⟶";\nvar LongRightArrow = "⟶";\nvar Longrightarrow = "⟹";\nvar looparrowleft = "↫";\nvar looparrowright = "↬";\nvar lopar = "⦅";\nvar Lopf = "𝕃";\nvar lopf = "𝕝";\nvar loplus = "⨭";\nvar lotimes = "⨴";\nvar lowast = "∗";\nvar lowbar = "_";\nvar LowerLeftArrow = "↙";\nvar LowerRightArrow = "↘";\nvar loz = "◊";\nvar lozenge = "◊";\nvar lozf = "⧫";\nvar lpar = "(";\nvar lparlt = "⦓";\nvar lrarr = "⇆";\nvar lrcorner = "⌟";\nvar lrhar = "⇋";\nvar lrhard = "⥭";\nvar lrm = "‎";\nvar lrtri = "⊿";\nvar lsaquo = "‹";\nvar lscr = "𝓁";\nvar Lscr = "ℒ";\nvar lsh = "↰";\nvar Lsh = "↰";\nvar lsim = "≲";\nvar lsime = "⪍";\nvar lsimg = "⪏";\nvar lsqb = "[";\nvar lsquo = "‘";\nvar lsquor = "‚";\nvar Lstrok = "Ł";\nvar lstrok = "ł";\nvar ltcc = "⪦";\nvar ltcir = "⩹";\nvar lt$2 = "<";\nvar LT$1 = "<";\nvar Lt = "≪";\nvar ltdot = "⋖";\nvar lthree = "⋋";\nvar ltimes = "⋉";\nvar ltlarr = "⥶";\nvar ltquest = "⩻";\nvar ltri = "◃";\nvar ltrie = "⊴";\nvar ltrif = "◂";\nvar ltrPar = "⦖";\nvar lurdshar = "⥊";\nvar luruhar = "⥦";\nvar lvertneqq = "≨︀";\nvar lvnE = "≨︀";\nvar macr$1 = "¯";\nvar male = "♂";\nvar malt = "✠";\nvar maltese = "✠";\nvar map = "↦";\nvar mapsto = "↦";\nvar mapstodown = "↧";\nvar mapstoleft = "↤";\nvar mapstoup = "↥";\nvar marker = "▮";\nvar mcomma = "⨩";\nvar Mcy = "М";\nvar mcy = "м";\nvar mdash = "—";\nvar mDDot = "∺";\nvar measuredangle = "∡";\nvar MediumSpace = " ";\nvar Mellintrf = "ℳ";\nvar Mfr = "𝔐";\nvar mfr = "𝔪";\nvar mho = "℧";\nvar micro$1 = "µ";\nvar midast = "*";\nvar midcir = "⫰";\nvar mid = "∣";\nvar middot$1 = "·";\nvar minusb = "⊟";\nvar minus = "−";\nvar minusd = "∸";\nvar minusdu = "⨪";\nvar MinusPlus = "∓";\nvar mlcp = "⫛";\nvar mldr = "…";\nvar mnplus = "∓";\nvar models = "⊧";\nvar Mopf = "𝕄";\nvar mopf = "𝕞";\nvar mp = "∓";\nvar mscr = "𝓂";\nvar Mscr = "ℳ";\nvar mstpos = "∾";\nvar Mu = "Μ";\nvar mu = "μ";\nvar multimap = "⊸";\nvar mumap = "⊸";\nvar nabla = "∇";\nvar Nacute = "Ń";\nvar nacute = "ń";\nvar nang = "∠⃒";\nvar nap = "≉";\nvar napE = "⩰̸";\nvar napid = "≋̸";\nvar napos = "ŉ";\nvar napprox = "≉";\nvar natural = "♮";\nvar naturals = "ℕ";\nvar natur = "♮";\nvar nbsp$1 = " ";\nvar nbump = "≎̸";\nvar nbumpe = "≏̸";\nvar ncap = "⩃";\nvar Ncaron = "Ň";\nvar ncaron = "ň";\nvar Ncedil = "Ņ";\nvar ncedil = "ņ";\nvar ncong = "≇";\nvar ncongdot = "⩭̸";\nvar ncup = "⩂";\nvar Ncy = "Н";\nvar ncy = "н";\nvar ndash = "–";\nvar nearhk = "⤤";\nvar nearr = "↗";\nvar neArr = "⇗";\nvar nearrow = "↗";\nvar ne = "≠";\nvar nedot = "≐̸";\nvar NegativeMediumSpace = "​";\nvar NegativeThickSpace = "​";\nvar NegativeThinSpace = "​";\nvar NegativeVeryThinSpace = "​";\nvar nequiv = "≢";\nvar nesear = "⤨";\nvar nesim = "≂̸";\nvar NestedGreaterGreater = "≫";\nvar NestedLessLess = "≪";\nvar NewLine = "\\n";\nvar nexist = "∄";\nvar nexists = "∄";\nvar Nfr = "𝔑";\nvar nfr = "𝔫";\nvar ngE = "≧̸";\nvar nge = "≱";\nvar ngeq = "≱";\nvar ngeqq = "≧̸";\nvar ngeqslant = "⩾̸";\nvar nges = "⩾̸";\nvar nGg = "⋙̸";\nvar ngsim = "≵";\nvar nGt = "≫⃒";\nvar ngt = "≯";\nvar ngtr = "≯";\nvar nGtv = "≫̸";\nvar nharr = "↮";\nvar nhArr = "⇎";\nvar nhpar = "⫲";\nvar ni = "∋";\nvar nis = "⋼";\nvar nisd = "⋺";\nvar niv = "∋";\nvar NJcy = "Њ";\nvar njcy = "њ";\nvar nlarr = "↚";\nvar nlArr = "⇍";\nvar nldr = "‥";\nvar nlE = "≦̸";\nvar nle = "≰";\nvar nleftarrow = "↚";\nvar nLeftarrow = "⇍";\nvar nleftrightarrow = "↮";\nvar nLeftrightarrow = "⇎";\nvar nleq = "≰";\nvar nleqq = "≦̸";\nvar nleqslant = "⩽̸";\nvar nles = "⩽̸";\nvar nless = "≮";\nvar nLl = "⋘̸";\nvar nlsim = "≴";\nvar nLt = "≪⃒";\nvar nlt = "≮";\nvar nltri = "⋪";\nvar nltrie = "⋬";\nvar nLtv = "≪̸";\nvar nmid = "∤";\nvar NoBreak = "⁠";\nvar NonBreakingSpace = " ";\nvar nopf = "𝕟";\nvar Nopf = "ℕ";\nvar Not = "⫬";\nvar not$1 = "¬";\nvar NotCongruent = "≢";\nvar NotCupCap = "≭";\nvar NotDoubleVerticalBar = "∦";\nvar NotElement = "∉";\nvar NotEqual = "≠";\nvar NotEqualTilde = "≂̸";\nvar NotExists = "∄";\nvar NotGreater = "≯";\nvar NotGreaterEqual = "≱";\nvar NotGreaterFullEqual = "≧̸";\nvar NotGreaterGreater = "≫̸";\nvar NotGreaterLess = "≹";\nvar NotGreaterSlantEqual = "⩾̸";\nvar NotGreaterTilde = "≵";\nvar NotHumpDownHump = "≎̸";\nvar NotHumpEqual = "≏̸";\nvar notin = "∉";\nvar notindot = "⋵̸";\nvar notinE = "⋹̸";\nvar notinva = "∉";\nvar notinvb = "⋷";\nvar notinvc = "⋶";\nvar NotLeftTriangleBar = "⧏̸";\nvar NotLeftTriangle = "⋪";\nvar NotLeftTriangleEqual = "⋬";\nvar NotLess = "≮";\nvar NotLessEqual = "≰";\nvar NotLessGreater = "≸";\nvar NotLessLess = "≪̸";\nvar NotLessSlantEqual = "⩽̸";\nvar NotLessTilde = "≴";\nvar NotNestedGreaterGreater = "⪢̸";\nvar NotNestedLessLess = "⪡̸";\nvar notni = "∌";\nvar notniva = "∌";\nvar notnivb = "⋾";\nvar notnivc = "⋽";\nvar NotPrecedes = "⊀";\nvar NotPrecedesEqual = "⪯̸";\nvar NotPrecedesSlantEqual = "⋠";\nvar NotReverseElement = "∌";\nvar NotRightTriangleBar = "⧐̸";\nvar NotRightTriangle = "⋫";\nvar NotRightTriangleEqual = "⋭";\nvar NotSquareSubset = "⊏̸";\nvar NotSquareSubsetEqual = "⋢";\nvar NotSquareSuperset = "⊐̸";\nvar NotSquareSupersetEqual = "⋣";\nvar NotSubset = "⊂⃒";\nvar NotSubsetEqual = "⊈";\nvar NotSucceeds = "⊁";\nvar NotSucceedsEqual = "⪰̸";\nvar NotSucceedsSlantEqual = "⋡";\nvar NotSucceedsTilde = "≿̸";\nvar NotSuperset = "⊃⃒";\nvar NotSupersetEqual = "⊉";\nvar NotTilde = "≁";\nvar NotTildeEqual = "≄";\nvar NotTildeFullEqual = "≇";\nvar NotTildeTilde = "≉";\nvar NotVerticalBar = "∤";\nvar nparallel = "∦";\nvar npar = "∦";\nvar nparsl = "⫽⃥";\nvar npart = "∂̸";\nvar npolint = "⨔";\nvar npr = "⊀";\nvar nprcue = "⋠";\nvar nprec = "⊀";\nvar npreceq = "⪯̸";\nvar npre = "⪯̸";\nvar nrarrc = "⤳̸";\nvar nrarr = "↛";\nvar nrArr = "⇏";\nvar nrarrw = "↝̸";\nvar nrightarrow = "↛";\nvar nRightarrow = "⇏";\nvar nrtri = "⋫";\nvar nrtrie = "⋭";\nvar nsc = "⊁";\nvar nsccue = "⋡";\nvar nsce = "⪰̸";\nvar Nscr = "𝒩";\nvar nscr = "𝓃";\nvar nshortmid = "∤";\nvar nshortparallel = "∦";\nvar nsim = "≁";\nvar nsime = "≄";\nvar nsimeq = "≄";\nvar nsmid = "∤";\nvar nspar = "∦";\nvar nsqsube = "⋢";\nvar nsqsupe = "⋣";\nvar nsub = "⊄";\nvar nsubE = "⫅̸";\nvar nsube = "⊈";\nvar nsubset = "⊂⃒";\nvar nsubseteq = "⊈";\nvar nsubseteqq = "⫅̸";\nvar nsucc = "⊁";\nvar nsucceq = "⪰̸";\nvar nsup = "⊅";\nvar nsupE = "⫆̸";\nvar nsupe = "⊉";\nvar nsupset = "⊃⃒";\nvar nsupseteq = "⊉";\nvar nsupseteqq = "⫆̸";\nvar ntgl = "≹";\nvar Ntilde$1 = "Ñ";\nvar ntilde$1 = "ñ";\nvar ntlg = "≸";\nvar ntriangleleft = "⋪";\nvar ntrianglelefteq = "⋬";\nvar ntriangleright = "⋫";\nvar ntrianglerighteq = "⋭";\nvar Nu = "Ν";\nvar nu = "ν";\nvar num = "#";\nvar numero = "№";\nvar numsp = " ";\nvar nvap = "≍⃒";\nvar nvdash = "⊬";\nvar nvDash = "⊭";\nvar nVdash = "⊮";\nvar nVDash = "⊯";\nvar nvge = "≥⃒";\nvar nvgt = ">⃒";\nvar nvHarr = "⤄";\nvar nvinfin = "⧞";\nvar nvlArr = "⤂";\nvar nvle = "≤⃒";\nvar nvlt = "<⃒";\nvar nvltrie = "⊴⃒";\nvar nvrArr = "⤃";\nvar nvrtrie = "⊵⃒";\nvar nvsim = "∼⃒";\nvar nwarhk = "⤣";\nvar nwarr = "↖";\nvar nwArr = "⇖";\nvar nwarrow = "↖";\nvar nwnear = "⤧";\nvar Oacute$1 = "Ó";\nvar oacute$1 = "ó";\nvar oast = "⊛";\nvar Ocirc$1 = "Ô";\nvar ocirc$1 = "ô";\nvar ocir = "⊚";\nvar Ocy = "О";\nvar ocy = "о";\nvar odash = "⊝";\nvar Odblac = "Ő";\nvar odblac = "ő";\nvar odiv = "⨸";\nvar odot = "⊙";\nvar odsold = "⦼";\nvar OElig = "Œ";\nvar oelig = "œ";\nvar ofcir = "⦿";\nvar Ofr = "𝔒";\nvar ofr = "𝔬";\nvar ogon = "˛";\nvar Ograve$1 = "Ò";\nvar ograve$1 = "ò";\nvar ogt = "⧁";\nvar ohbar = "⦵";\nvar ohm = "Ω";\nvar oint = "∮";\nvar olarr = "↺";\nvar olcir = "⦾";\nvar olcross = "⦻";\nvar oline = "‾";\nvar olt = "⧀";\nvar Omacr = "Ō";\nvar omacr = "ō";\nvar Omega = "Ω";\nvar omega = "ω";\nvar Omicron = "Ο";\nvar omicron = "ο";\nvar omid = "⦶";\nvar ominus = "⊖";\nvar Oopf = "𝕆";\nvar oopf = "𝕠";\nvar opar = "⦷";\nvar OpenCurlyDoubleQuote = "“";\nvar OpenCurlyQuote = "‘";\nvar operp = "⦹";\nvar oplus = "⊕";\nvar orarr = "↻";\nvar Or = "⩔";\nvar or = "∨";\nvar ord = "⩝";\nvar order = "ℴ";\nvar orderof = "ℴ";\nvar ordf$1 = "ª";\nvar ordm$1 = "º";\nvar origof = "⊶";\nvar oror = "⩖";\nvar orslope = "⩗";\nvar orv = "⩛";\nvar oS = "Ⓢ";\nvar Oscr = "𝒪";\nvar oscr = "ℴ";\nvar Oslash$1 = "Ø";\nvar oslash$1 = "ø";\nvar osol = "⊘";\nvar Otilde$1 = "Õ";\nvar otilde$1 = "õ";\nvar otimesas = "⨶";\nvar Otimes = "⨷";\nvar otimes = "⊗";\nvar Ouml$1 = "Ö";\nvar ouml$1 = "ö";\nvar ovbar = "⌽";\nvar OverBar = "‾";\nvar OverBrace = "⏞";\nvar OverBracket = "⎴";\nvar OverParenthesis = "⏜";\nvar para$1 = "¶";\nvar parallel = "∥";\nvar par = "∥";\nvar parsim = "⫳";\nvar parsl = "⫽";\nvar part = "∂";\nvar PartialD = "∂";\nvar Pcy = "П";\nvar pcy = "п";\nvar percnt = "%";\nvar period = ".";\nvar permil = "‰";\nvar perp = "⊥";\nvar pertenk = "‱";\nvar Pfr = "𝔓";\nvar pfr = "𝔭";\nvar Phi = "Φ";\nvar phi = "φ";\nvar phiv = "ϕ";\nvar phmmat = "ℳ";\nvar phone = "☎";\nvar Pi = "Π";\nvar pi = "π";\nvar pitchfork = "⋔";\nvar piv = "ϖ";\nvar planck = "ℏ";\nvar planckh = "ℎ";\nvar plankv = "ℏ";\nvar plusacir = "⨣";\nvar plusb = "⊞";\nvar pluscir = "⨢";\nvar plus = "+";\nvar plusdo = "∔";\nvar plusdu = "⨥";\nvar pluse = "⩲";\nvar PlusMinus = "±";\nvar plusmn$1 = "±";\nvar plussim = "⨦";\nvar plustwo = "⨧";\nvar pm = "±";\nvar Poincareplane = "ℌ";\nvar pointint = "⨕";\nvar popf = "𝕡";\nvar Popf = "ℙ";\nvar pound$1 = "£";\nvar prap = "⪷";\nvar Pr = "⪻";\nvar pr = "≺";\nvar prcue = "≼";\nvar precapprox = "⪷";\nvar prec = "≺";\nvar preccurlyeq = "≼";\nvar Precedes = "≺";\nvar PrecedesEqual = "⪯";\nvar PrecedesSlantEqual = "≼";\nvar PrecedesTilde = "≾";\nvar preceq = "⪯";\nvar precnapprox = "⪹";\nvar precneqq = "⪵";\nvar precnsim = "⋨";\nvar pre = "⪯";\nvar prE = "⪳";\nvar precsim = "≾";\nvar prime = "′";\nvar Prime = "″";\nvar primes = "ℙ";\nvar prnap = "⪹";\nvar prnE = "⪵";\nvar prnsim = "⋨";\nvar prod = "∏";\nvar Product = "∏";\nvar profalar = "⌮";\nvar profline = "⌒";\nvar profsurf = "⌓";\nvar prop = "∝";\nvar Proportional = "∝";\nvar Proportion = "∷";\nvar propto = "∝";\nvar prsim = "≾";\nvar prurel = "⊰";\nvar Pscr = "𝒫";\nvar pscr = "𝓅";\nvar Psi = "Ψ";\nvar psi = "ψ";\nvar puncsp = " ";\nvar Qfr = "𝔔";\nvar qfr = "𝔮";\nvar qint = "⨌";\nvar qopf = "𝕢";\nvar Qopf = "ℚ";\nvar qprime = "⁗";\nvar Qscr = "𝒬";\nvar qscr = "𝓆";\nvar quaternions = "ℍ";\nvar quatint = "⨖";\nvar quest = "?";\nvar questeq = "≟";\nvar quot$2 = "\\"";\nvar QUOT$1 = "\\"";\nvar rAarr = "⇛";\nvar race = "∽̱";\nvar Racute = "Ŕ";\nvar racute = "ŕ";\nvar radic = "√";\nvar raemptyv = "⦳";\nvar rang = "⟩";\nvar Rang = "⟫";\nvar rangd = "⦒";\nvar range = "⦥";\nvar rangle = "⟩";\nvar raquo$1 = "»";\nvar rarrap = "⥵";\nvar rarrb = "⇥";\nvar rarrbfs = "⤠";\nvar rarrc = "⤳";\nvar rarr = "→";\nvar Rarr = "↠";\nvar rArr = "⇒";\nvar rarrfs = "⤞";\nvar rarrhk = "↪";\nvar rarrlp = "↬";\nvar rarrpl = "⥅";\nvar rarrsim = "⥴";\nvar Rarrtl = "⤖";\nvar rarrtl = "↣";\nvar rarrw = "↝";\nvar ratail = "⤚";\nvar rAtail = "⤜";\nvar ratio = "∶";\nvar rationals = "ℚ";\nvar rbarr = "⤍";\nvar rBarr = "⤏";\nvar RBarr = "⤐";\nvar rbbrk = "❳";\nvar rbrace = "}";\nvar rbrack = "]";\nvar rbrke = "⦌";\nvar rbrksld = "⦎";\nvar rbrkslu = "⦐";\nvar Rcaron = "Ř";\nvar rcaron = "ř";\nvar Rcedil = "Ŗ";\nvar rcedil = "ŗ";\nvar rceil = "⌉";\nvar rcub = "}";\nvar Rcy = "Р";\nvar rcy = "р";\nvar rdca = "⤷";\nvar rdldhar = "⥩";\nvar rdquo = "”";\nvar rdquor = "”";\nvar rdsh = "↳";\nvar real = "ℜ";\nvar realine = "ℛ";\nvar realpart = "ℜ";\nvar reals = "ℝ";\nvar Re = "ℜ";\nvar rect = "▭";\nvar reg$1 = "®";\nvar REG$1 = "®";\nvar ReverseElement = "∋";\nvar ReverseEquilibrium = "⇋";\nvar ReverseUpEquilibrium = "⥯";\nvar rfisht = "⥽";\nvar rfloor = "⌋";\nvar rfr = "𝔯";\nvar Rfr = "ℜ";\nvar rHar = "⥤";\nvar rhard = "⇁";\nvar rharu = "⇀";\nvar rharul = "⥬";\nvar Rho = "Ρ";\nvar rho = "ρ";\nvar rhov = "ϱ";\nvar RightAngleBracket = "⟩";\nvar RightArrowBar = "⇥";\nvar rightarrow = "→";\nvar RightArrow = "→";\nvar Rightarrow = "⇒";\nvar RightArrowLeftArrow = "⇄";\nvar rightarrowtail = "↣";\nvar RightCeiling = "⌉";\nvar RightDoubleBracket = "⟧";\nvar RightDownTeeVector = "⥝";\nvar RightDownVectorBar = "⥕";\nvar RightDownVector = "⇂";\nvar RightFloor = "⌋";\nvar rightharpoondown = "⇁";\nvar rightharpoonup = "⇀";\nvar rightleftarrows = "⇄";\nvar rightleftharpoons = "⇌";\nvar rightrightarrows = "⇉";\nvar rightsquigarrow = "↝";\nvar RightTeeArrow = "↦";\nvar RightTee = "⊢";\nvar RightTeeVector = "⥛";\nvar rightthreetimes = "⋌";\nvar RightTriangleBar = "⧐";\nvar RightTriangle = "⊳";\nvar RightTriangleEqual = "⊵";\nvar RightUpDownVector = "⥏";\nvar RightUpTeeVector = "⥜";\nvar RightUpVectorBar = "⥔";\nvar RightUpVector = "↾";\nvar RightVectorBar = "⥓";\nvar RightVector = "⇀";\nvar ring = "˚";\nvar risingdotseq = "≓";\nvar rlarr = "⇄";\nvar rlhar = "⇌";\nvar rlm = "‏";\nvar rmoustache = "⎱";\nvar rmoust = "⎱";\nvar rnmid = "⫮";\nvar roang = "⟭";\nvar roarr = "⇾";\nvar robrk = "⟧";\nvar ropar = "⦆";\nvar ropf = "𝕣";\nvar Ropf = "ℝ";\nvar roplus = "⨮";\nvar rotimes = "⨵";\nvar RoundImplies = "⥰";\nvar rpar = ")";\nvar rpargt = "⦔";\nvar rppolint = "⨒";\nvar rrarr = "⇉";\nvar Rrightarrow = "⇛";\nvar rsaquo = "›";\nvar rscr = "𝓇";\nvar Rscr = "ℛ";\nvar rsh = "↱";\nvar Rsh = "↱";\nvar rsqb = "]";\nvar rsquo = "’";\nvar rsquor = "’";\nvar rthree = "⋌";\nvar rtimes = "⋊";\nvar rtri = "▹";\nvar rtrie = "⊵";\nvar rtrif = "▸";\nvar rtriltri = "⧎";\nvar RuleDelayed = "⧴";\nvar ruluhar = "⥨";\nvar rx = "℞";\nvar Sacute = "Ś";\nvar sacute = "ś";\nvar sbquo = "‚";\nvar scap = "⪸";\nvar Scaron = "Š";\nvar scaron = "š";\nvar Sc = "⪼";\nvar sc = "≻";\nvar sccue = "≽";\nvar sce = "⪰";\nvar scE = "⪴";\nvar Scedil = "Ş";\nvar scedil = "ş";\nvar Scirc = "Ŝ";\nvar scirc = "ŝ";\nvar scnap = "⪺";\nvar scnE = "⪶";\nvar scnsim = "⋩";\nvar scpolint = "⨓";\nvar scsim = "≿";\nvar Scy = "С";\nvar scy = "с";\nvar sdotb = "⊡";\nvar sdot = "⋅";\nvar sdote = "⩦";\nvar searhk = "⤥";\nvar searr = "↘";\nvar seArr = "⇘";\nvar searrow = "↘";\nvar sect$1 = "§";\nvar semi = ";";\nvar seswar = "⤩";\nvar setminus = "∖";\nvar setmn = "∖";\nvar sext = "✶";\nvar Sfr = "𝔖";\nvar sfr = "𝔰";\nvar sfrown = "⌢";\nvar sharp = "♯";\nvar SHCHcy = "Щ";\nvar shchcy = "щ";\nvar SHcy = "Ш";\nvar shcy = "ш";\nvar ShortDownArrow = "↓";\nvar ShortLeftArrow = "←";\nvar shortmid = "∣";\nvar shortparallel = "∥";\nvar ShortRightArrow = "→";\nvar ShortUpArrow = "↑";\nvar shy$1 = "­";\nvar Sigma = "Σ";\nvar sigma = "σ";\nvar sigmaf = "ς";\nvar sigmav = "ς";\nvar sim = "∼";\nvar simdot = "⩪";\nvar sime = "≃";\nvar simeq = "≃";\nvar simg = "⪞";\nvar simgE = "⪠";\nvar siml = "⪝";\nvar simlE = "⪟";\nvar simne = "≆";\nvar simplus = "⨤";\nvar simrarr = "⥲";\nvar slarr = "←";\nvar SmallCircle = "∘";\nvar smallsetminus = "∖";\nvar smashp = "⨳";\nvar smeparsl = "⧤";\nvar smid = "∣";\nvar smile = "⌣";\nvar smt = "⪪";\nvar smte = "⪬";\nvar smtes = "⪬︀";\nvar SOFTcy = "Ь";\nvar softcy = "ь";\nvar solbar = "⌿";\nvar solb = "⧄";\nvar sol = "/";\nvar Sopf = "𝕊";\nvar sopf = "𝕤";\nvar spades = "♠";\nvar spadesuit = "♠";\nvar spar = "∥";\nvar sqcap = "⊓";\nvar sqcaps = "⊓︀";\nvar sqcup = "⊔";\nvar sqcups = "⊔︀";\nvar Sqrt = "√";\nvar sqsub = "⊏";\nvar sqsube = "⊑";\nvar sqsubset = "⊏";\nvar sqsubseteq = "⊑";\nvar sqsup = "⊐";\nvar sqsupe = "⊒";\nvar sqsupset = "⊐";\nvar sqsupseteq = "⊒";\nvar square = "□";\nvar Square = "□";\nvar SquareIntersection = "⊓";\nvar SquareSubset = "⊏";\nvar SquareSubsetEqual = "⊑";\nvar SquareSuperset = "⊐";\nvar SquareSupersetEqual = "⊒";\nvar SquareUnion = "⊔";\nvar squarf = "▪";\nvar squ = "□";\nvar squf = "▪";\nvar srarr = "→";\nvar Sscr = "𝒮";\nvar sscr = "𝓈";\nvar ssetmn = "∖";\nvar ssmile = "⌣";\nvar sstarf = "⋆";\nvar Star = "⋆";\nvar star = "☆";\nvar starf = "★";\nvar straightepsilon = "ϵ";\nvar straightphi = "ϕ";\nvar strns = "¯";\nvar sub = "⊂";\nvar Sub = "⋐";\nvar subdot = "⪽";\nvar subE = "⫅";\nvar sube = "⊆";\nvar subedot = "⫃";\nvar submult = "⫁";\nvar subnE = "⫋";\nvar subne = "⊊";\nvar subplus = "⪿";\nvar subrarr = "⥹";\nvar subset = "⊂";\nvar Subset = "⋐";\nvar subseteq = "⊆";\nvar subseteqq = "⫅";\nvar SubsetEqual = "⊆";\nvar subsetneq = "⊊";\nvar subsetneqq = "⫋";\nvar subsim = "⫇";\nvar subsub = "⫕";\nvar subsup = "⫓";\nvar succapprox = "⪸";\nvar succ = "≻";\nvar succcurlyeq = "≽";\nvar Succeeds = "≻";\nvar SucceedsEqual = "⪰";\nvar SucceedsSlantEqual = "≽";\nvar SucceedsTilde = "≿";\nvar succeq = "⪰";\nvar succnapprox = "⪺";\nvar succneqq = "⪶";\nvar succnsim = "⋩";\nvar succsim = "≿";\nvar SuchThat = "∋";\nvar sum = "∑";\nvar Sum = "∑";\nvar sung = "♪";\nvar sup1$1 = "¹";\nvar sup2$1 = "²";\nvar sup3$1 = "³";\nvar sup = "⊃";\nvar Sup = "⋑";\nvar supdot = "⪾";\nvar supdsub = "⫘";\nvar supE = "⫆";\nvar supe = "⊇";\nvar supedot = "⫄";\nvar Superset = "⊃";\nvar SupersetEqual = "⊇";\nvar suphsol = "⟉";\nvar suphsub = "⫗";\nvar suplarr = "⥻";\nvar supmult = "⫂";\nvar supnE = "⫌";\nvar supne = "⊋";\nvar supplus = "⫀";\nvar supset = "⊃";\nvar Supset = "⋑";\nvar supseteq = "⊇";\nvar supseteqq = "⫆";\nvar supsetneq = "⊋";\nvar supsetneqq = "⫌";\nvar supsim = "⫈";\nvar supsub = "⫔";\nvar supsup = "⫖";\nvar swarhk = "⤦";\nvar swarr = "↙";\nvar swArr = "⇙";\nvar swarrow = "↙";\nvar swnwar = "⤪";\nvar szlig$1 = "ß";\nvar Tab = "\\t";\nvar target = "⌖";\nvar Tau = "Τ";\nvar tau = "τ";\nvar tbrk = "⎴";\nvar Tcaron = "Ť";\nvar tcaron = "ť";\nvar Tcedil = "Ţ";\nvar tcedil = "ţ";\nvar Tcy = "Т";\nvar tcy = "т";\nvar tdot = "⃛";\nvar telrec = "⌕";\nvar Tfr = "𝔗";\nvar tfr = "𝔱";\nvar there4 = "∴";\nvar therefore = "∴";\nvar Therefore = "∴";\nvar Theta = "Θ";\nvar theta = "θ";\nvar thetasym = "ϑ";\nvar thetav = "ϑ";\nvar thickapprox = "≈";\nvar thicksim = "∼";\nvar ThickSpace = "  ";\nvar ThinSpace = " ";\nvar thinsp = " ";\nvar thkap = "≈";\nvar thksim = "∼";\nvar THORN$1 = "Þ";\nvar thorn$1 = "þ";\nvar tilde = "˜";\nvar Tilde = "∼";\nvar TildeEqual = "≃";\nvar TildeFullEqual = "≅";\nvar TildeTilde = "≈";\nvar timesbar = "⨱";\nvar timesb = "⊠";\nvar times$1 = "×";\nvar timesd = "⨰";\nvar tint = "∭";\nvar toea = "⤨";\nvar topbot = "⌶";\nvar topcir = "⫱";\nvar top = "⊤";\nvar Topf = "𝕋";\nvar topf = "𝕥";\nvar topfork = "⫚";\nvar tosa = "⤩";\nvar tprime = "‴";\nvar trade = "™";\nvar TRADE = "™";\nvar triangle = "▵";\nvar triangledown = "▿";\nvar triangleleft = "◃";\nvar trianglelefteq = "⊴";\nvar triangleq = "≜";\nvar triangleright = "▹";\nvar trianglerighteq = "⊵";\nvar tridot = "◬";\nvar trie = "≜";\nvar triminus = "⨺";\nvar TripleDot = "⃛";\nvar triplus = "⨹";\nvar trisb = "⧍";\nvar tritime = "⨻";\nvar trpezium = "⏢";\nvar Tscr = "𝒯";\nvar tscr = "𝓉";\nvar TScy = "Ц";\nvar tscy = "ц";\nvar TSHcy = "Ћ";\nvar tshcy = "ћ";\nvar Tstrok = "Ŧ";\nvar tstrok = "ŧ";\nvar twixt = "≬";\nvar twoheadleftarrow = "↞";\nvar twoheadrightarrow = "↠";\nvar Uacute$1 = "Ú";\nvar uacute$1 = "ú";\nvar uarr = "↑";\nvar Uarr = "↟";\nvar uArr = "⇑";\nvar Uarrocir = "⥉";\nvar Ubrcy = "Ў";\nvar ubrcy = "ў";\nvar Ubreve = "Ŭ";\nvar ubreve = "ŭ";\nvar Ucirc$1 = "Û";\nvar ucirc$1 = "û";\nvar Ucy = "У";\nvar ucy = "у";\nvar udarr = "⇅";\nvar Udblac = "Ű";\nvar udblac = "ű";\nvar udhar = "⥮";\nvar ufisht = "⥾";\nvar Ufr = "𝔘";\nvar ufr = "𝔲";\nvar Ugrave$1 = "Ù";\nvar ugrave$1 = "ù";\nvar uHar = "⥣";\nvar uharl = "↿";\nvar uharr = "↾";\nvar uhblk = "▀";\nvar ulcorn = "⌜";\nvar ulcorner = "⌜";\nvar ulcrop = "⌏";\nvar ultri = "◸";\nvar Umacr = "Ū";\nvar umacr = "ū";\nvar uml$1 = "¨";\nvar UnderBar = "_";\nvar UnderBrace = "⏟";\nvar UnderBracket = "⎵";\nvar UnderParenthesis = "⏝";\nvar Union = "⋃";\nvar UnionPlus = "⊎";\nvar Uogon = "Ų";\nvar uogon = "ų";\nvar Uopf = "𝕌";\nvar uopf = "𝕦";\nvar UpArrowBar = "⤒";\nvar uparrow = "↑";\nvar UpArrow = "↑";\nvar Uparrow = "⇑";\nvar UpArrowDownArrow = "⇅";\nvar updownarrow = "↕";\nvar UpDownArrow = "↕";\nvar Updownarrow = "⇕";\nvar UpEquilibrium = "⥮";\nvar upharpoonleft = "↿";\nvar upharpoonright = "↾";\nvar uplus = "⊎";\nvar UpperLeftArrow = "↖";\nvar UpperRightArrow = "↗";\nvar upsi = "υ";\nvar Upsi = "ϒ";\nvar upsih = "ϒ";\nvar Upsilon = "Υ";\nvar upsilon = "υ";\nvar UpTeeArrow = "↥";\nvar UpTee = "⊥";\nvar upuparrows = "⇈";\nvar urcorn = "⌝";\nvar urcorner = "⌝";\nvar urcrop = "⌎";\nvar Uring = "Ů";\nvar uring = "ů";\nvar urtri = "◹";\nvar Uscr = "𝒰";\nvar uscr = "𝓊";\nvar utdot = "⋰";\nvar Utilde = "Ũ";\nvar utilde = "ũ";\nvar utri = "▵";\nvar utrif = "▴";\nvar uuarr = "⇈";\nvar Uuml$1 = "Ü";\nvar uuml$1 = "ü";\nvar uwangle = "⦧";\nvar vangrt = "⦜";\nvar varepsilon = "ϵ";\nvar varkappa = "ϰ";\nvar varnothing = "∅";\nvar varphi = "ϕ";\nvar varpi = "ϖ";\nvar varpropto = "∝";\nvar varr = "↕";\nvar vArr = "⇕";\nvar varrho = "ϱ";\nvar varsigma = "ς";\nvar varsubsetneq = "⊊︀";\nvar varsubsetneqq = "⫋︀";\nvar varsupsetneq = "⊋︀";\nvar varsupsetneqq = "⫌︀";\nvar vartheta = "ϑ";\nvar vartriangleleft = "⊲";\nvar vartriangleright = "⊳";\nvar vBar = "⫨";\nvar Vbar = "⫫";\nvar vBarv = "⫩";\nvar Vcy = "В";\nvar vcy = "в";\nvar vdash = "⊢";\nvar vDash = "⊨";\nvar Vdash = "⊩";\nvar VDash = "⊫";\nvar Vdashl = "⫦";\nvar veebar = "⊻";\nvar vee = "∨";\nvar Vee = "⋁";\nvar veeeq = "≚";\nvar vellip = "⋮";\nvar verbar = "|";\nvar Verbar = "‖";\nvar vert = "|";\nvar Vert = "‖";\nvar VerticalBar = "∣";\nvar VerticalLine = "|";\nvar VerticalSeparator = "❘";\nvar VerticalTilde = "≀";\nvar VeryThinSpace = " ";\nvar Vfr = "𝔙";\nvar vfr = "𝔳";\nvar vltri = "⊲";\nvar vnsub = "⊂⃒";\nvar vnsup = "⊃⃒";\nvar Vopf = "𝕍";\nvar vopf = "𝕧";\nvar vprop = "∝";\nvar vrtri = "⊳";\nvar Vscr = "𝒱";\nvar vscr = "𝓋";\nvar vsubnE = "⫋︀";\nvar vsubne = "⊊︀";\nvar vsupnE = "⫌︀";\nvar vsupne = "⊋︀";\nvar Vvdash = "⊪";\nvar vzigzag = "⦚";\nvar Wcirc = "Ŵ";\nvar wcirc = "ŵ";\nvar wedbar = "⩟";\nvar wedge = "∧";\nvar Wedge = "⋀";\nvar wedgeq = "≙";\nvar weierp = "℘";\nvar Wfr = "𝔚";\nvar wfr = "𝔴";\nvar Wopf = "𝕎";\nvar wopf = "𝕨";\nvar wp = "℘";\nvar wr = "≀";\nvar wreath = "≀";\nvar Wscr = "𝒲";\nvar wscr = "𝓌";\nvar xcap = "⋂";\nvar xcirc = "◯";\nvar xcup = "⋃";\nvar xdtri = "▽";\nvar Xfr = "𝔛";\nvar xfr = "𝔵";\nvar xharr = "⟷";\nvar xhArr = "⟺";\nvar Xi = "Ξ";\nvar xi = "ξ";\nvar xlarr = "⟵";\nvar xlArr = "⟸";\nvar xmap = "⟼";\nvar xnis = "⋻";\nvar xodot = "⨀";\nvar Xopf = "𝕏";\nvar xopf = "𝕩";\nvar xoplus = "⨁";\nvar xotime = "⨂";\nvar xrarr = "⟶";\nvar xrArr = "⟹";\nvar Xscr = "𝒳";\nvar xscr = "𝓍";\nvar xsqcup = "⨆";\nvar xuplus = "⨄";\nvar xutri = "△";\nvar xvee = "⋁";\nvar xwedge = "⋀";\nvar Yacute$1 = "Ý";\nvar yacute$1 = "ý";\nvar YAcy = "Я";\nvar yacy = "я";\nvar Ycirc = "Ŷ";\nvar ycirc = "ŷ";\nvar Ycy = "Ы";\nvar ycy = "ы";\nvar yen$1 = "¥";\nvar Yfr = "𝔜";\nvar yfr = "𝔶";\nvar YIcy = "Ї";\nvar yicy = "ї";\nvar Yopf = "𝕐";\nvar yopf = "𝕪";\nvar Yscr = "𝒴";\nvar yscr = "𝓎";\nvar YUcy = "Ю";\nvar yucy = "ю";\nvar yuml$1 = "ÿ";\nvar Yuml = "Ÿ";\nvar Zacute = "Ź";\nvar zacute = "ź";\nvar Zcaron = "Ž";\nvar zcaron = "ž";\nvar Zcy = "З";\nvar zcy = "з";\nvar Zdot = "Ż";\nvar zdot = "ż";\nvar zeetrf = "ℨ";\nvar ZeroWidthSpace = "​";\nvar Zeta = "Ζ";\nvar zeta = "ζ";\nvar zfr = "𝔷";\nvar Zfr = "ℨ";\nvar ZHcy = "Ж";\nvar zhcy = "ж";\nvar zigrarr = "⇝";\nvar zopf = "𝕫";\nvar Zopf = "ℤ";\nvar Zscr = "𝒵";\nvar zscr = "𝓏";\nvar zwj = "‍";\nvar zwnj = "‌";\nvar require$$1$1 = {\n\tAacute: Aacute$1,\n\taacute: aacute$1,\n\tAbreve: Abreve,\n\tabreve: abreve,\n\tac: ac,\n\tacd: acd,\n\tacE: acE,\n\tAcirc: Acirc$1,\n\tacirc: acirc$1,\n\tacute: acute$1,\n\tAcy: Acy,\n\tacy: acy,\n\tAElig: AElig$1,\n\taelig: aelig$1,\n\taf: af,\n\tAfr: Afr,\n\tafr: afr,\n\tAgrave: Agrave$1,\n\tagrave: agrave$1,\n\talefsym: alefsym,\n\taleph: aleph,\n\tAlpha: Alpha,\n\talpha: alpha,\n\tAmacr: Amacr,\n\tamacr: amacr,\n\tamalg: amalg,\n\tamp: amp$2,\n\tAMP: AMP$1,\n\tandand: andand,\n\tAnd: And,\n\tand: and,\n\tandd: andd,\n\tandslope: andslope,\n\tandv: andv,\n\tang: ang,\n\tange: ange,\n\tangle: angle,\n\tangmsdaa: angmsdaa,\n\tangmsdab: angmsdab,\n\tangmsdac: angmsdac,\n\tangmsdad: angmsdad,\n\tangmsdae: angmsdae,\n\tangmsdaf: angmsdaf,\n\tangmsdag: angmsdag,\n\tangmsdah: angmsdah,\n\tangmsd: angmsd,\n\tangrt: angrt,\n\tangrtvb: angrtvb,\n\tangrtvbd: angrtvbd,\n\tangsph: angsph,\n\tangst: angst,\n\tangzarr: angzarr,\n\tAogon: Aogon,\n\taogon: aogon,\n\tAopf: Aopf,\n\taopf: aopf,\n\tapacir: apacir,\n\tap: ap,\n\tapE: apE,\n\tape: ape,\n\tapid: apid,\n\tapos: apos$1,\n\tApplyFunction: ApplyFunction,\n\tapprox: approx,\n\tapproxeq: approxeq,\n\tAring: Aring$1,\n\taring: aring$1,\n\tAscr: Ascr,\n\tascr: ascr,\n\tAssign: Assign,\n\tast: ast,\n\tasymp: asymp,\n\tasympeq: asympeq,\n\tAtilde: Atilde$1,\n\tatilde: atilde$1,\n\tAuml: Auml$1,\n\tauml: auml$1,\n\tawconint: awconint,\n\tawint: awint,\n\tbackcong: backcong,\n\tbackepsilon: backepsilon,\n\tbackprime: backprime,\n\tbacksim: backsim,\n\tbacksimeq: backsimeq,\n\tBackslash: Backslash,\n\tBarv: Barv,\n\tbarvee: barvee,\n\tbarwed: barwed,\n\tBarwed: Barwed,\n\tbarwedge: barwedge,\n\tbbrk: bbrk,\n\tbbrktbrk: bbrktbrk,\n\tbcong: bcong,\n\tBcy: Bcy,\n\tbcy: bcy,\n\tbdquo: bdquo,\n\tbecaus: becaus,\n\tbecause: because,\n\tBecause: Because,\n\tbemptyv: bemptyv,\n\tbepsi: bepsi,\n\tbernou: bernou,\n\tBernoullis: Bernoullis,\n\tBeta: Beta,\n\tbeta: beta,\n\tbeth: beth,\n\tbetween: between,\n\tBfr: Bfr,\n\tbfr: bfr,\n\tbigcap: bigcap,\n\tbigcirc: bigcirc,\n\tbigcup: bigcup,\n\tbigodot: bigodot,\n\tbigoplus: bigoplus,\n\tbigotimes: bigotimes,\n\tbigsqcup: bigsqcup,\n\tbigstar: bigstar,\n\tbigtriangledown: bigtriangledown,\n\tbigtriangleup: bigtriangleup,\n\tbiguplus: biguplus,\n\tbigvee: bigvee,\n\tbigwedge: bigwedge,\n\tbkarow: bkarow,\n\tblacklozenge: blacklozenge,\n\tblacksquare: blacksquare,\n\tblacktriangle: blacktriangle,\n\tblacktriangledown: blacktriangledown,\n\tblacktriangleleft: blacktriangleleft,\n\tblacktriangleright: blacktriangleright,\n\tblank: blank,\n\tblk12: blk12,\n\tblk14: blk14,\n\tblk34: blk34,\n\tblock: block,\n\tbne: bne,\n\tbnequiv: bnequiv,\n\tbNot: bNot,\n\tbnot: bnot,\n\tBopf: Bopf,\n\tbopf: bopf,\n\tbot: bot,\n\tbottom: bottom,\n\tbowtie: bowtie,\n\tboxbox: boxbox,\n\tboxdl: boxdl,\n\tboxdL: boxdL,\n\tboxDl: boxDl,\n\tboxDL: boxDL,\n\tboxdr: boxdr,\n\tboxdR: boxdR,\n\tboxDr: boxDr,\n\tboxDR: boxDR,\n\tboxh: boxh,\n\tboxH: boxH,\n\tboxhd: boxhd,\n\tboxHd: boxHd,\n\tboxhD: boxhD,\n\tboxHD: boxHD,\n\tboxhu: boxhu,\n\tboxHu: boxHu,\n\tboxhU: boxhU,\n\tboxHU: boxHU,\n\tboxminus: boxminus,\n\tboxplus: boxplus,\n\tboxtimes: boxtimes,\n\tboxul: boxul,\n\tboxuL: boxuL,\n\tboxUl: boxUl,\n\tboxUL: boxUL,\n\tboxur: boxur,\n\tboxuR: boxuR,\n\tboxUr: boxUr,\n\tboxUR: boxUR,\n\tboxv: boxv,\n\tboxV: boxV,\n\tboxvh: boxvh,\n\tboxvH: boxvH,\n\tboxVh: boxVh,\n\tboxVH: boxVH,\n\tboxvl: boxvl,\n\tboxvL: boxvL,\n\tboxVl: boxVl,\n\tboxVL: boxVL,\n\tboxvr: boxvr,\n\tboxvR: boxvR,\n\tboxVr: boxVr,\n\tboxVR: boxVR,\n\tbprime: bprime,\n\tbreve: breve,\n\tBreve: Breve,\n\tbrvbar: brvbar$1,\n\tbscr: bscr,\n\tBscr: Bscr,\n\tbsemi: bsemi,\n\tbsim: bsim,\n\tbsime: bsime,\n\tbsolb: bsolb,\n\tbsol: bsol,\n\tbsolhsub: bsolhsub,\n\tbull: bull,\n\tbullet: bullet,\n\tbump: bump,\n\tbumpE: bumpE,\n\tbumpe: bumpe,\n\tBumpeq: Bumpeq,\n\tbumpeq: bumpeq,\n\tCacute: Cacute,\n\tcacute: cacute,\n\tcapand: capand,\n\tcapbrcup: capbrcup,\n\tcapcap: capcap,\n\tcap: cap,\n\tCap: Cap,\n\tcapcup: capcup,\n\tcapdot: capdot,\n\tCapitalDifferentialD: CapitalDifferentialD,\n\tcaps: caps,\n\tcaret: caret,\n\tcaron: caron,\n\tCayleys: Cayleys,\n\tccaps: ccaps,\n\tCcaron: Ccaron,\n\tccaron: ccaron,\n\tCcedil: Ccedil$1,\n\tccedil: ccedil$1,\n\tCcirc: Ccirc,\n\tccirc: ccirc,\n\tCconint: Cconint,\n\tccups: ccups,\n\tccupssm: ccupssm,\n\tCdot: Cdot,\n\tcdot: cdot,\n\tcedil: cedil$1,\n\tCedilla: Cedilla,\n\tcemptyv: cemptyv,\n\tcent: cent$1,\n\tcenterdot: centerdot,\n\tCenterDot: CenterDot,\n\tcfr: cfr,\n\tCfr: Cfr,\n\tCHcy: CHcy,\n\tchcy: chcy,\n\tcheck: check,\n\tcheckmark: checkmark,\n\tChi: Chi,\n\tchi: chi,\n\tcirc: circ,\n\tcirceq: circeq,\n\tcirclearrowleft: circlearrowleft,\n\tcirclearrowright: circlearrowright,\n\tcircledast: circledast,\n\tcircledcirc: circledcirc,\n\tcircleddash: circleddash,\n\tCircleDot: CircleDot,\n\tcircledR: circledR,\n\tcircledS: circledS,\n\tCircleMinus: CircleMinus,\n\tCirclePlus: CirclePlus,\n\tCircleTimes: CircleTimes,\n\tcir: cir,\n\tcirE: cirE,\n\tcire: cire,\n\tcirfnint: cirfnint,\n\tcirmid: cirmid,\n\tcirscir: cirscir,\n\tClockwiseContourIntegral: ClockwiseContourIntegral,\n\tCloseCurlyDoubleQuote: CloseCurlyDoubleQuote,\n\tCloseCurlyQuote: CloseCurlyQuote,\n\tclubs: clubs,\n\tclubsuit: clubsuit,\n\tcolon: colon,\n\tColon: Colon,\n\tColone: Colone,\n\tcolone: colone,\n\tcoloneq: coloneq,\n\tcomma: comma,\n\tcommat: commat,\n\tcomp: comp,\n\tcompfn: compfn,\n\tcomplement: complement,\n\tcomplexes: complexes,\n\tcong: cong,\n\tcongdot: congdot,\n\tCongruent: Congruent,\n\tconint: conint,\n\tConint: Conint,\n\tContourIntegral: ContourIntegral,\n\tcopf: copf,\n\tCopf: Copf,\n\tcoprod: coprod,\n\tCoproduct: Coproduct,\n\tcopy: copy$1,\n\tCOPY: COPY$1,\n\tcopysr: copysr,\n\tCounterClockwiseContourIntegral: CounterClockwiseContourIntegral,\n\tcrarr: crarr,\n\tcross: cross,\n\tCross: Cross,\n\tCscr: Cscr,\n\tcscr: cscr,\n\tcsub: csub,\n\tcsube: csube,\n\tcsup: csup,\n\tcsupe: csupe,\n\tctdot: ctdot,\n\tcudarrl: cudarrl,\n\tcudarrr: cudarrr,\n\tcuepr: cuepr,\n\tcuesc: cuesc,\n\tcularr: cularr,\n\tcularrp: cularrp,\n\tcupbrcap: cupbrcap,\n\tcupcap: cupcap,\n\tCupCap: CupCap,\n\tcup: cup,\n\tCup: Cup,\n\tcupcup: cupcup,\n\tcupdot: cupdot,\n\tcupor: cupor,\n\tcups: cups,\n\tcurarr: curarr,\n\tcurarrm: curarrm,\n\tcurlyeqprec: curlyeqprec,\n\tcurlyeqsucc: curlyeqsucc,\n\tcurlyvee: curlyvee,\n\tcurlywedge: curlywedge,\n\tcurren: curren$1,\n\tcurvearrowleft: curvearrowleft,\n\tcurvearrowright: curvearrowright,\n\tcuvee: cuvee,\n\tcuwed: cuwed,\n\tcwconint: cwconint,\n\tcwint: cwint,\n\tcylcty: cylcty,\n\tdagger: dagger,\n\tDagger: Dagger,\n\tdaleth: daleth,\n\tdarr: darr,\n\tDarr: Darr,\n\tdArr: dArr,\n\tdash: dash,\n\tDashv: Dashv,\n\tdashv: dashv,\n\tdbkarow: dbkarow,\n\tdblac: dblac,\n\tDcaron: Dcaron,\n\tdcaron: dcaron,\n\tDcy: Dcy,\n\tdcy: dcy,\n\tddagger: ddagger,\n\tddarr: ddarr,\n\tDD: DD,\n\tdd: dd,\n\tDDotrahd: DDotrahd,\n\tddotseq: ddotseq,\n\tdeg: deg$1,\n\tDel: Del,\n\tDelta: Delta,\n\tdelta: delta,\n\tdemptyv: demptyv,\n\tdfisht: dfisht,\n\tDfr: Dfr,\n\tdfr: dfr,\n\tdHar: dHar,\n\tdharl: dharl,\n\tdharr: dharr,\n\tDiacriticalAcute: DiacriticalAcute,\n\tDiacriticalDot: DiacriticalDot,\n\tDiacriticalDoubleAcute: DiacriticalDoubleAcute,\n\tDiacriticalGrave: DiacriticalGrave,\n\tDiacriticalTilde: DiacriticalTilde,\n\tdiam: diam,\n\tdiamond: diamond,\n\tDiamond: Diamond,\n\tdiamondsuit: diamondsuit,\n\tdiams: diams,\n\tdie: die,\n\tDifferentialD: DifferentialD,\n\tdigamma: digamma,\n\tdisin: disin,\n\tdiv: div,\n\tdivide: divide$1,\n\tdivideontimes: divideontimes,\n\tdivonx: divonx,\n\tDJcy: DJcy,\n\tdjcy: djcy,\n\tdlcorn: dlcorn,\n\tdlcrop: dlcrop,\n\tdollar: dollar,\n\tDopf: Dopf,\n\tdopf: dopf,\n\tDot: Dot,\n\tdot: dot,\n\tDotDot: DotDot,\n\tdoteq: doteq,\n\tdoteqdot: doteqdot,\n\tDotEqual: DotEqual,\n\tdotminus: dotminus,\n\tdotplus: dotplus,\n\tdotsquare: dotsquare,\n\tdoublebarwedge: doublebarwedge,\n\tDoubleContourIntegral: DoubleContourIntegral,\n\tDoubleDot: DoubleDot,\n\tDoubleDownArrow: DoubleDownArrow,\n\tDoubleLeftArrow: DoubleLeftArrow,\n\tDoubleLeftRightArrow: DoubleLeftRightArrow,\n\tDoubleLeftTee: DoubleLeftTee,\n\tDoubleLongLeftArrow: DoubleLongLeftArrow,\n\tDoubleLongLeftRightArrow: DoubleLongLeftRightArrow,\n\tDoubleLongRightArrow: DoubleLongRightArrow,\n\tDoubleRightArrow: DoubleRightArrow,\n\tDoubleRightTee: DoubleRightTee,\n\tDoubleUpArrow: DoubleUpArrow,\n\tDoubleUpDownArrow: DoubleUpDownArrow,\n\tDoubleVerticalBar: DoubleVerticalBar,\n\tDownArrowBar: DownArrowBar,\n\tdownarrow: downarrow,\n\tDownArrow: DownArrow,\n\tDownarrow: Downarrow,\n\tDownArrowUpArrow: DownArrowUpArrow,\n\tDownBreve: DownBreve,\n\tdowndownarrows: downdownarrows,\n\tdownharpoonleft: downharpoonleft,\n\tdownharpoonright: downharpoonright,\n\tDownLeftRightVector: DownLeftRightVector,\n\tDownLeftTeeVector: DownLeftTeeVector,\n\tDownLeftVectorBar: DownLeftVectorBar,\n\tDownLeftVector: DownLeftVector,\n\tDownRightTeeVector: DownRightTeeVector,\n\tDownRightVectorBar: DownRightVectorBar,\n\tDownRightVector: DownRightVector,\n\tDownTeeArrow: DownTeeArrow,\n\tDownTee: DownTee,\n\tdrbkarow: drbkarow,\n\tdrcorn: drcorn,\n\tdrcrop: drcrop,\n\tDscr: Dscr,\n\tdscr: dscr,\n\tDScy: DScy,\n\tdscy: dscy,\n\tdsol: dsol,\n\tDstrok: Dstrok,\n\tdstrok: dstrok,\n\tdtdot: dtdot,\n\tdtri: dtri,\n\tdtrif: dtrif,\n\tduarr: duarr,\n\tduhar: duhar,\n\tdwangle: dwangle,\n\tDZcy: DZcy,\n\tdzcy: dzcy,\n\tdzigrarr: dzigrarr,\n\tEacute: Eacute$1,\n\teacute: eacute$1,\n\teaster: easter,\n\tEcaron: Ecaron,\n\tecaron: ecaron,\n\tEcirc: Ecirc$1,\n\tecirc: ecirc$1,\n\tecir: ecir,\n\tecolon: ecolon,\n\tEcy: Ecy,\n\tecy: ecy,\n\teDDot: eDDot,\n\tEdot: Edot,\n\tedot: edot,\n\teDot: eDot,\n\tee: ee,\n\tefDot: efDot,\n\tEfr: Efr,\n\tefr: efr,\n\teg: eg,\n\tEgrave: Egrave$1,\n\tegrave: egrave$1,\n\tegs: egs,\n\tegsdot: egsdot,\n\tel: el,\n\tElement: Element$1,\n\telinters: elinters,\n\tell: ell,\n\tels: els,\n\telsdot: elsdot,\n\tEmacr: Emacr,\n\temacr: emacr,\n\tempty: empty,\n\temptyset: emptyset,\n\tEmptySmallSquare: EmptySmallSquare,\n\temptyv: emptyv,\n\tEmptyVerySmallSquare: EmptyVerySmallSquare,\n\temsp13: emsp13,\n\temsp14: emsp14,\n\temsp: emsp,\n\tENG: ENG,\n\teng: eng,\n\tensp: ensp,\n\tEogon: Eogon,\n\teogon: eogon,\n\tEopf: Eopf,\n\teopf: eopf,\n\tepar: epar,\n\teparsl: eparsl,\n\teplus: eplus,\n\tepsi: epsi,\n\tEpsilon: Epsilon,\n\tepsilon: epsilon,\n\tepsiv: epsiv,\n\teqcirc: eqcirc,\n\teqcolon: eqcolon,\n\teqsim: eqsim,\n\teqslantgtr: eqslantgtr,\n\teqslantless: eqslantless,\n\tEqual: Equal,\n\tequals: equals,\n\tEqualTilde: EqualTilde,\n\tequest: equest,\n\tEquilibrium: Equilibrium,\n\tequiv: equiv,\n\tequivDD: equivDD,\n\teqvparsl: eqvparsl,\n\terarr: erarr,\n\terDot: erDot,\n\tescr: escr,\n\tEscr: Escr,\n\tesdot: esdot,\n\tEsim: Esim,\n\tesim: esim,\n\tEta: Eta,\n\teta: eta,\n\tETH: ETH$1,\n\teth: eth$1,\n\tEuml: Euml$1,\n\teuml: euml$1,\n\teuro: euro,\n\texcl: excl,\n\texist: exist,\n\tExists: Exists,\n\texpectation: expectation,\n\texponentiale: exponentiale,\n\tExponentialE: ExponentialE,\n\tfallingdotseq: fallingdotseq,\n\tFcy: Fcy,\n\tfcy: fcy,\n\tfemale: female,\n\tffilig: ffilig,\n\tfflig: fflig,\n\tffllig: ffllig,\n\tFfr: Ffr,\n\tffr: ffr,\n\tfilig: filig,\n\tFilledSmallSquare: FilledSmallSquare,\n\tFilledVerySmallSquare: FilledVerySmallSquare,\n\tfjlig: fjlig,\n\tflat: flat,\n\tfllig: fllig,\n\tfltns: fltns,\n\tfnof: fnof,\n\tFopf: Fopf,\n\tfopf: fopf,\n\tforall: forall,\n\tForAll: ForAll,\n\tfork: fork,\n\tforkv: forkv,\n\tFouriertrf: Fouriertrf,\n\tfpartint: fpartint,\n\tfrac12: frac12$1,\n\tfrac13: frac13,\n\tfrac14: frac14$1,\n\tfrac15: frac15,\n\tfrac16: frac16,\n\tfrac18: frac18,\n\tfrac23: frac23,\n\tfrac25: frac25,\n\tfrac34: frac34$1,\n\tfrac35: frac35,\n\tfrac38: frac38,\n\tfrac45: frac45,\n\tfrac56: frac56,\n\tfrac58: frac58,\n\tfrac78: frac78,\n\tfrasl: frasl,\n\tfrown: frown,\n\tfscr: fscr,\n\tFscr: Fscr,\n\tgacute: gacute,\n\tGamma: Gamma,\n\tgamma: gamma,\n\tGammad: Gammad,\n\tgammad: gammad,\n\tgap: gap,\n\tGbreve: Gbreve,\n\tgbreve: gbreve,\n\tGcedil: Gcedil,\n\tGcirc: Gcirc,\n\tgcirc: gcirc,\n\tGcy: Gcy,\n\tgcy: gcy,\n\tGdot: Gdot,\n\tgdot: gdot,\n\tge: ge,\n\tgE: gE,\n\tgEl: gEl,\n\tgel: gel,\n\tgeq: geq,\n\tgeqq: geqq,\n\tgeqslant: geqslant,\n\tgescc: gescc,\n\tges: ges,\n\tgesdot: gesdot,\n\tgesdoto: gesdoto,\n\tgesdotol: gesdotol,\n\tgesl: gesl,\n\tgesles: gesles,\n\tGfr: Gfr,\n\tgfr: gfr,\n\tgg: gg,\n\tGg: Gg,\n\tggg: ggg,\n\tgimel: gimel,\n\tGJcy: GJcy,\n\tgjcy: gjcy,\n\tgla: gla,\n\tgl: gl,\n\tglE: glE,\n\tglj: glj,\n\tgnap: gnap,\n\tgnapprox: gnapprox,\n\tgne: gne,\n\tgnE: gnE,\n\tgneq: gneq,\n\tgneqq: gneqq,\n\tgnsim: gnsim,\n\tGopf: Gopf,\n\tgopf: gopf,\n\tgrave: grave,\n\tGreaterEqual: GreaterEqual,\n\tGreaterEqualLess: GreaterEqualLess,\n\tGreaterFullEqual: GreaterFullEqual,\n\tGreaterGreater: GreaterGreater,\n\tGreaterLess: GreaterLess,\n\tGreaterSlantEqual: GreaterSlantEqual,\n\tGreaterTilde: GreaterTilde,\n\tGscr: Gscr,\n\tgscr: gscr,\n\tgsim: gsim,\n\tgsime: gsime,\n\tgsiml: gsiml,\n\tgtcc: gtcc,\n\tgtcir: gtcir,\n\tgt: gt$2,\n\tGT: GT$1,\n\tGt: Gt,\n\tgtdot: gtdot,\n\tgtlPar: gtlPar,\n\tgtquest: gtquest,\n\tgtrapprox: gtrapprox,\n\tgtrarr: gtrarr,\n\tgtrdot: gtrdot,\n\tgtreqless: gtreqless,\n\tgtreqqless: gtreqqless,\n\tgtrless: gtrless,\n\tgtrsim: gtrsim,\n\tgvertneqq: gvertneqq,\n\tgvnE: gvnE,\n\tHacek: Hacek,\n\thairsp: hairsp,\n\thalf: half,\n\thamilt: hamilt,\n\tHARDcy: HARDcy,\n\thardcy: hardcy,\n\tharrcir: harrcir,\n\tharr: harr,\n\thArr: hArr,\n\tharrw: harrw,\n\tHat: Hat,\n\thbar: hbar,\n\tHcirc: Hcirc,\n\thcirc: hcirc,\n\thearts: hearts,\n\theartsuit: heartsuit,\n\thellip: hellip,\n\thercon: hercon,\n\thfr: hfr,\n\tHfr: Hfr,\n\tHilbertSpace: HilbertSpace,\n\thksearow: hksearow,\n\thkswarow: hkswarow,\n\thoarr: hoarr,\n\thomtht: homtht,\n\thookleftarrow: hookleftarrow,\n\thookrightarrow: hookrightarrow,\n\thopf: hopf,\n\tHopf: Hopf,\n\thorbar: horbar,\n\tHorizontalLine: HorizontalLine,\n\thscr: hscr,\n\tHscr: Hscr,\n\thslash: hslash,\n\tHstrok: Hstrok,\n\thstrok: hstrok,\n\tHumpDownHump: HumpDownHump,\n\tHumpEqual: HumpEqual,\n\thybull: hybull,\n\thyphen: hyphen,\n\tIacute: Iacute$1,\n\tiacute: iacute$1,\n\tic: ic,\n\tIcirc: Icirc$1,\n\ticirc: icirc$1,\n\tIcy: Icy,\n\ticy: icy,\n\tIdot: Idot,\n\tIEcy: IEcy,\n\tiecy: iecy,\n\tiexcl: iexcl$1,\n\tiff: iff,\n\tifr: ifr,\n\tIfr: Ifr,\n\tIgrave: Igrave$1,\n\tigrave: igrave$1,\n\tii: ii,\n\tiiiint: iiiint,\n\tiiint: iiint,\n\tiinfin: iinfin,\n\tiiota: iiota,\n\tIJlig: IJlig,\n\tijlig: ijlig,\n\tImacr: Imacr,\n\timacr: imacr,\n\timage: image,\n\tImaginaryI: ImaginaryI,\n\timagline: imagline,\n\timagpart: imagpart,\n\timath: imath,\n\tIm: Im,\n\timof: imof,\n\timped: imped,\n\tImplies: Implies,\n\tincare: incare,\n\t"in": "∈",\n\tinfin: infin,\n\tinfintie: infintie,\n\tinodot: inodot,\n\tintcal: intcal,\n\tint: int,\n\tInt: Int,\n\tintegers: integers,\n\tIntegral: Integral,\n\tintercal: intercal,\n\tIntersection: Intersection,\n\tintlarhk: intlarhk,\n\tintprod: intprod,\n\tInvisibleComma: InvisibleComma,\n\tInvisibleTimes: InvisibleTimes,\n\tIOcy: IOcy,\n\tiocy: iocy,\n\tIogon: Iogon,\n\tiogon: iogon,\n\tIopf: Iopf,\n\tiopf: iopf,\n\tIota: Iota,\n\tiota: iota,\n\tiprod: iprod,\n\tiquest: iquest$1,\n\tiscr: iscr,\n\tIscr: Iscr,\n\tisin: isin,\n\tisindot: isindot,\n\tisinE: isinE,\n\tisins: isins,\n\tisinsv: isinsv,\n\tisinv: isinv,\n\tit: it,\n\tItilde: Itilde,\n\titilde: itilde,\n\tIukcy: Iukcy,\n\tiukcy: iukcy,\n\tIuml: Iuml$1,\n\tiuml: iuml$1,\n\tJcirc: Jcirc,\n\tjcirc: jcirc,\n\tJcy: Jcy,\n\tjcy: jcy,\n\tJfr: Jfr,\n\tjfr: jfr,\n\tjmath: jmath,\n\tJopf: Jopf,\n\tjopf: jopf,\n\tJscr: Jscr,\n\tjscr: jscr,\n\tJsercy: Jsercy,\n\tjsercy: jsercy,\n\tJukcy: Jukcy,\n\tjukcy: jukcy,\n\tKappa: Kappa,\n\tkappa: kappa,\n\tkappav: kappav,\n\tKcedil: Kcedil,\n\tkcedil: kcedil,\n\tKcy: Kcy,\n\tkcy: kcy,\n\tKfr: Kfr,\n\tkfr: kfr,\n\tkgreen: kgreen,\n\tKHcy: KHcy,\n\tkhcy: khcy,\n\tKJcy: KJcy,\n\tkjcy: kjcy,\n\tKopf: Kopf,\n\tkopf: kopf,\n\tKscr: Kscr,\n\tkscr: kscr,\n\tlAarr: lAarr,\n\tLacute: Lacute,\n\tlacute: lacute,\n\tlaemptyv: laemptyv,\n\tlagran: lagran,\n\tLambda: Lambda,\n\tlambda: lambda,\n\tlang: lang,\n\tLang: Lang,\n\tlangd: langd,\n\tlangle: langle,\n\tlap: lap,\n\tLaplacetrf: Laplacetrf,\n\tlaquo: laquo$1,\n\tlarrb: larrb,\n\tlarrbfs: larrbfs,\n\tlarr: larr,\n\tLarr: Larr,\n\tlArr: lArr,\n\tlarrfs: larrfs,\n\tlarrhk: larrhk,\n\tlarrlp: larrlp,\n\tlarrpl: larrpl,\n\tlarrsim: larrsim,\n\tlarrtl: larrtl,\n\tlatail: latail,\n\tlAtail: lAtail,\n\tlat: lat,\n\tlate: late,\n\tlates: lates,\n\tlbarr: lbarr,\n\tlBarr: lBarr,\n\tlbbrk: lbbrk,\n\tlbrace: lbrace,\n\tlbrack: lbrack,\n\tlbrke: lbrke,\n\tlbrksld: lbrksld,\n\tlbrkslu: lbrkslu,\n\tLcaron: Lcaron,\n\tlcaron: lcaron,\n\tLcedil: Lcedil,\n\tlcedil: lcedil,\n\tlceil: lceil,\n\tlcub: lcub,\n\tLcy: Lcy,\n\tlcy: lcy,\n\tldca: ldca,\n\tldquo: ldquo,\n\tldquor: ldquor,\n\tldrdhar: ldrdhar,\n\tldrushar: ldrushar,\n\tldsh: ldsh,\n\tle: le,\n\tlE: lE,\n\tLeftAngleBracket: LeftAngleBracket,\n\tLeftArrowBar: LeftArrowBar,\n\tleftarrow: leftarrow,\n\tLeftArrow: LeftArrow,\n\tLeftarrow: Leftarrow,\n\tLeftArrowRightArrow: LeftArrowRightArrow,\n\tleftarrowtail: leftarrowtail,\n\tLeftCeiling: LeftCeiling,\n\tLeftDoubleBracket: LeftDoubleBracket,\n\tLeftDownTeeVector: LeftDownTeeVector,\n\tLeftDownVectorBar: LeftDownVectorBar,\n\tLeftDownVector: LeftDownVector,\n\tLeftFloor: LeftFloor,\n\tleftharpoondown: leftharpoondown,\n\tleftharpoonup: leftharpoonup,\n\tleftleftarrows: leftleftarrows,\n\tleftrightarrow: leftrightarrow,\n\tLeftRightArrow: LeftRightArrow,\n\tLeftrightarrow: Leftrightarrow,\n\tleftrightarrows: leftrightarrows,\n\tleftrightharpoons: leftrightharpoons,\n\tleftrightsquigarrow: leftrightsquigarrow,\n\tLeftRightVector: LeftRightVector,\n\tLeftTeeArrow: LeftTeeArrow,\n\tLeftTee: LeftTee,\n\tLeftTeeVector: LeftTeeVector,\n\tleftthreetimes: leftthreetimes,\n\tLeftTriangleBar: LeftTriangleBar,\n\tLeftTriangle: LeftTriangle,\n\tLeftTriangleEqual: LeftTriangleEqual,\n\tLeftUpDownVector: LeftUpDownVector,\n\tLeftUpTeeVector: LeftUpTeeVector,\n\tLeftUpVectorBar: LeftUpVectorBar,\n\tLeftUpVector: LeftUpVector,\n\tLeftVectorBar: LeftVectorBar,\n\tLeftVector: LeftVector,\n\tlEg: lEg,\n\tleg: leg,\n\tleq: leq,\n\tleqq: leqq,\n\tleqslant: leqslant,\n\tlescc: lescc,\n\tles: les,\n\tlesdot: lesdot,\n\tlesdoto: lesdoto,\n\tlesdotor: lesdotor,\n\tlesg: lesg,\n\tlesges: lesges,\n\tlessapprox: lessapprox,\n\tlessdot: lessdot,\n\tlesseqgtr: lesseqgtr,\n\tlesseqqgtr: lesseqqgtr,\n\tLessEqualGreater: LessEqualGreater,\n\tLessFullEqual: LessFullEqual,\n\tLessGreater: LessGreater,\n\tlessgtr: lessgtr,\n\tLessLess: LessLess,\n\tlesssim: lesssim,\n\tLessSlantEqual: LessSlantEqual,\n\tLessTilde: LessTilde,\n\tlfisht: lfisht,\n\tlfloor: lfloor,\n\tLfr: Lfr,\n\tlfr: lfr,\n\tlg: lg,\n\tlgE: lgE,\n\tlHar: lHar,\n\tlhard: lhard,\n\tlharu: lharu,\n\tlharul: lharul,\n\tlhblk: lhblk,\n\tLJcy: LJcy,\n\tljcy: ljcy,\n\tllarr: llarr,\n\tll: ll,\n\tLl: Ll,\n\tllcorner: llcorner,\n\tLleftarrow: Lleftarrow,\n\tllhard: llhard,\n\tlltri: lltri,\n\tLmidot: Lmidot,\n\tlmidot: lmidot,\n\tlmoustache: lmoustache,\n\tlmoust: lmoust,\n\tlnap: lnap,\n\tlnapprox: lnapprox,\n\tlne: lne,\n\tlnE: lnE,\n\tlneq: lneq,\n\tlneqq: lneqq,\n\tlnsim: lnsim,\n\tloang: loang,\n\tloarr: loarr,\n\tlobrk: lobrk,\n\tlongleftarrow: longleftarrow,\n\tLongLeftArrow: LongLeftArrow,\n\tLongleftarrow: Longleftarrow,\n\tlongleftrightarrow: longleftrightarrow,\n\tLongLeftRightArrow: LongLeftRightArrow,\n\tLongleftrightarrow: Longleftrightarrow,\n\tlongmapsto: longmapsto,\n\tlongrightarrow: longrightarrow,\n\tLongRightArrow: LongRightArrow,\n\tLongrightarrow: Longrightarrow,\n\tlooparrowleft: looparrowleft,\n\tlooparrowright: looparrowright,\n\tlopar: lopar,\n\tLopf: Lopf,\n\tlopf: lopf,\n\tloplus: loplus,\n\tlotimes: lotimes,\n\tlowast: lowast,\n\tlowbar: lowbar,\n\tLowerLeftArrow: LowerLeftArrow,\n\tLowerRightArrow: LowerRightArrow,\n\tloz: loz,\n\tlozenge: lozenge,\n\tlozf: lozf,\n\tlpar: lpar,\n\tlparlt: lparlt,\n\tlrarr: lrarr,\n\tlrcorner: lrcorner,\n\tlrhar: lrhar,\n\tlrhard: lrhard,\n\tlrm: lrm,\n\tlrtri: lrtri,\n\tlsaquo: lsaquo,\n\tlscr: lscr,\n\tLscr: Lscr,\n\tlsh: lsh,\n\tLsh: Lsh,\n\tlsim: lsim,\n\tlsime: lsime,\n\tlsimg: lsimg,\n\tlsqb: lsqb,\n\tlsquo: lsquo,\n\tlsquor: lsquor,\n\tLstrok: Lstrok,\n\tlstrok: lstrok,\n\tltcc: ltcc,\n\tltcir: ltcir,\n\tlt: lt$2,\n\tLT: LT$1,\n\tLt: Lt,\n\tltdot: ltdot,\n\tlthree: lthree,\n\tltimes: ltimes,\n\tltlarr: ltlarr,\n\tltquest: ltquest,\n\tltri: ltri,\n\tltrie: ltrie,\n\tltrif: ltrif,\n\tltrPar: ltrPar,\n\tlurdshar: lurdshar,\n\tluruhar: luruhar,\n\tlvertneqq: lvertneqq,\n\tlvnE: lvnE,\n\tmacr: macr$1,\n\tmale: male,\n\tmalt: malt,\n\tmaltese: maltese,\n\t"Map": "⤅",\n\tmap: map,\n\tmapsto: mapsto,\n\tmapstodown: mapstodown,\n\tmapstoleft: mapstoleft,\n\tmapstoup: mapstoup,\n\tmarker: marker,\n\tmcomma: mcomma,\n\tMcy: Mcy,\n\tmcy: mcy,\n\tmdash: mdash,\n\tmDDot: mDDot,\n\tmeasuredangle: measuredangle,\n\tMediumSpace: MediumSpace,\n\tMellintrf: Mellintrf,\n\tMfr: Mfr,\n\tmfr: mfr,\n\tmho: mho,\n\tmicro: micro$1,\n\tmidast: midast,\n\tmidcir: midcir,\n\tmid: mid,\n\tmiddot: middot$1,\n\tminusb: minusb,\n\tminus: minus,\n\tminusd: minusd,\n\tminusdu: minusdu,\n\tMinusPlus: MinusPlus,\n\tmlcp: mlcp,\n\tmldr: mldr,\n\tmnplus: mnplus,\n\tmodels: models,\n\tMopf: Mopf,\n\tmopf: mopf,\n\tmp: mp,\n\tmscr: mscr,\n\tMscr: Mscr,\n\tmstpos: mstpos,\n\tMu: Mu,\n\tmu: mu,\n\tmultimap: multimap,\n\tmumap: mumap,\n\tnabla: nabla,\n\tNacute: Nacute,\n\tnacute: nacute,\n\tnang: nang,\n\tnap: nap,\n\tnapE: napE,\n\tnapid: napid,\n\tnapos: napos,\n\tnapprox: napprox,\n\tnatural: natural,\n\tnaturals: naturals,\n\tnatur: natur,\n\tnbsp: nbsp$1,\n\tnbump: nbump,\n\tnbumpe: nbumpe,\n\tncap: ncap,\n\tNcaron: Ncaron,\n\tncaron: ncaron,\n\tNcedil: Ncedil,\n\tncedil: ncedil,\n\tncong: ncong,\n\tncongdot: ncongdot,\n\tncup: ncup,\n\tNcy: Ncy,\n\tncy: ncy,\n\tndash: ndash,\n\tnearhk: nearhk,\n\tnearr: nearr,\n\tneArr: neArr,\n\tnearrow: nearrow,\n\tne: ne,\n\tnedot: nedot,\n\tNegativeMediumSpace: NegativeMediumSpace,\n\tNegativeThickSpace: NegativeThickSpace,\n\tNegativeThinSpace: NegativeThinSpace,\n\tNegativeVeryThinSpace: NegativeVeryThinSpace,\n\tnequiv: nequiv,\n\tnesear: nesear,\n\tnesim: nesim,\n\tNestedGreaterGreater: NestedGreaterGreater,\n\tNestedLessLess: NestedLessLess,\n\tNewLine: NewLine,\n\tnexist: nexist,\n\tnexists: nexists,\n\tNfr: Nfr,\n\tnfr: nfr,\n\tngE: ngE,\n\tnge: nge,\n\tngeq: ngeq,\n\tngeqq: ngeqq,\n\tngeqslant: ngeqslant,\n\tnges: nges,\n\tnGg: nGg,\n\tngsim: ngsim,\n\tnGt: nGt,\n\tngt: ngt,\n\tngtr: ngtr,\n\tnGtv: nGtv,\n\tnharr: nharr,\n\tnhArr: nhArr,\n\tnhpar: nhpar,\n\tni: ni,\n\tnis: nis,\n\tnisd: nisd,\n\tniv: niv,\n\tNJcy: NJcy,\n\tnjcy: njcy,\n\tnlarr: nlarr,\n\tnlArr: nlArr,\n\tnldr: nldr,\n\tnlE: nlE,\n\tnle: nle,\n\tnleftarrow: nleftarrow,\n\tnLeftarrow: nLeftarrow,\n\tnleftrightarrow: nleftrightarrow,\n\tnLeftrightarrow: nLeftrightarrow,\n\tnleq: nleq,\n\tnleqq: nleqq,\n\tnleqslant: nleqslant,\n\tnles: nles,\n\tnless: nless,\n\tnLl: nLl,\n\tnlsim: nlsim,\n\tnLt: nLt,\n\tnlt: nlt,\n\tnltri: nltri,\n\tnltrie: nltrie,\n\tnLtv: nLtv,\n\tnmid: nmid,\n\tNoBreak: NoBreak,\n\tNonBreakingSpace: NonBreakingSpace,\n\tnopf: nopf,\n\tNopf: Nopf,\n\tNot: Not,\n\tnot: not$1,\n\tNotCongruent: NotCongruent,\n\tNotCupCap: NotCupCap,\n\tNotDoubleVerticalBar: NotDoubleVerticalBar,\n\tNotElement: NotElement,\n\tNotEqual: NotEqual,\n\tNotEqualTilde: NotEqualTilde,\n\tNotExists: NotExists,\n\tNotGreater: NotGreater,\n\tNotGreaterEqual: NotGreaterEqual,\n\tNotGreaterFullEqual: NotGreaterFullEqual,\n\tNotGreaterGreater: NotGreaterGreater,\n\tNotGreaterLess: NotGreaterLess,\n\tNotGreaterSlantEqual: NotGreaterSlantEqual,\n\tNotGreaterTilde: NotGreaterTilde,\n\tNotHumpDownHump: NotHumpDownHump,\n\tNotHumpEqual: NotHumpEqual,\n\tnotin: notin,\n\tnotindot: notindot,\n\tnotinE: notinE,\n\tnotinva: notinva,\n\tnotinvb: notinvb,\n\tnotinvc: notinvc,\n\tNotLeftTriangleBar: NotLeftTriangleBar,\n\tNotLeftTriangle: NotLeftTriangle,\n\tNotLeftTriangleEqual: NotLeftTriangleEqual,\n\tNotLess: NotLess,\n\tNotLessEqual: NotLessEqual,\n\tNotLessGreater: NotLessGreater,\n\tNotLessLess: NotLessLess,\n\tNotLessSlantEqual: NotLessSlantEqual,\n\tNotLessTilde: NotLessTilde,\n\tNotNestedGreaterGreater: NotNestedGreaterGreater,\n\tNotNestedLessLess: NotNestedLessLess,\n\tnotni: notni,\n\tnotniva: notniva,\n\tnotnivb: notnivb,\n\tnotnivc: notnivc,\n\tNotPrecedes: NotPrecedes,\n\tNotPrecedesEqual: NotPrecedesEqual,\n\tNotPrecedesSlantEqual: NotPrecedesSlantEqual,\n\tNotReverseElement: NotReverseElement,\n\tNotRightTriangleBar: NotRightTriangleBar,\n\tNotRightTriangle: NotRightTriangle,\n\tNotRightTriangleEqual: NotRightTriangleEqual,\n\tNotSquareSubset: NotSquareSubset,\n\tNotSquareSubsetEqual: NotSquareSubsetEqual,\n\tNotSquareSuperset: NotSquareSuperset,\n\tNotSquareSupersetEqual: NotSquareSupersetEqual,\n\tNotSubset: NotSubset,\n\tNotSubsetEqual: NotSubsetEqual,\n\tNotSucceeds: NotSucceeds,\n\tNotSucceedsEqual: NotSucceedsEqual,\n\tNotSucceedsSlantEqual: NotSucceedsSlantEqual,\n\tNotSucceedsTilde: NotSucceedsTilde,\n\tNotSuperset: NotSuperset,\n\tNotSupersetEqual: NotSupersetEqual,\n\tNotTilde: NotTilde,\n\tNotTildeEqual: NotTildeEqual,\n\tNotTildeFullEqual: NotTildeFullEqual,\n\tNotTildeTilde: NotTildeTilde,\n\tNotVerticalBar: NotVerticalBar,\n\tnparallel: nparallel,\n\tnpar: npar,\n\tnparsl: nparsl,\n\tnpart: npart,\n\tnpolint: npolint,\n\tnpr: npr,\n\tnprcue: nprcue,\n\tnprec: nprec,\n\tnpreceq: npreceq,\n\tnpre: npre,\n\tnrarrc: nrarrc,\n\tnrarr: nrarr,\n\tnrArr: nrArr,\n\tnrarrw: nrarrw,\n\tnrightarrow: nrightarrow,\n\tnRightarrow: nRightarrow,\n\tnrtri: nrtri,\n\tnrtrie: nrtrie,\n\tnsc: nsc,\n\tnsccue: nsccue,\n\tnsce: nsce,\n\tNscr: Nscr,\n\tnscr: nscr,\n\tnshortmid: nshortmid,\n\tnshortparallel: nshortparallel,\n\tnsim: nsim,\n\tnsime: nsime,\n\tnsimeq: nsimeq,\n\tnsmid: nsmid,\n\tnspar: nspar,\n\tnsqsube: nsqsube,\n\tnsqsupe: nsqsupe,\n\tnsub: nsub,\n\tnsubE: nsubE,\n\tnsube: nsube,\n\tnsubset: nsubset,\n\tnsubseteq: nsubseteq,\n\tnsubseteqq: nsubseteqq,\n\tnsucc: nsucc,\n\tnsucceq: nsucceq,\n\tnsup: nsup,\n\tnsupE: nsupE,\n\tnsupe: nsupe,\n\tnsupset: nsupset,\n\tnsupseteq: nsupseteq,\n\tnsupseteqq: nsupseteqq,\n\tntgl: ntgl,\n\tNtilde: Ntilde$1,\n\tntilde: ntilde$1,\n\tntlg: ntlg,\n\tntriangleleft: ntriangleleft,\n\tntrianglelefteq: ntrianglelefteq,\n\tntriangleright: ntriangleright,\n\tntrianglerighteq: ntrianglerighteq,\n\tNu: Nu,\n\tnu: nu,\n\tnum: num,\n\tnumero: numero,\n\tnumsp: numsp,\n\tnvap: nvap,\n\tnvdash: nvdash,\n\tnvDash: nvDash,\n\tnVdash: nVdash,\n\tnVDash: nVDash,\n\tnvge: nvge,\n\tnvgt: nvgt,\n\tnvHarr: nvHarr,\n\tnvinfin: nvinfin,\n\tnvlArr: nvlArr,\n\tnvle: nvle,\n\tnvlt: nvlt,\n\tnvltrie: nvltrie,\n\tnvrArr: nvrArr,\n\tnvrtrie: nvrtrie,\n\tnvsim: nvsim,\n\tnwarhk: nwarhk,\n\tnwarr: nwarr,\n\tnwArr: nwArr,\n\tnwarrow: nwarrow,\n\tnwnear: nwnear,\n\tOacute: Oacute$1,\n\toacute: oacute$1,\n\toast: oast,\n\tOcirc: Ocirc$1,\n\tocirc: ocirc$1,\n\tocir: ocir,\n\tOcy: Ocy,\n\tocy: ocy,\n\todash: odash,\n\tOdblac: Odblac,\n\todblac: odblac,\n\todiv: odiv,\n\todot: odot,\n\todsold: odsold,\n\tOElig: OElig,\n\toelig: oelig,\n\tofcir: ofcir,\n\tOfr: Ofr,\n\tofr: ofr,\n\togon: ogon,\n\tOgrave: Ograve$1,\n\tograve: ograve$1,\n\togt: ogt,\n\tohbar: ohbar,\n\tohm: ohm,\n\toint: oint,\n\tolarr: olarr,\n\tolcir: olcir,\n\tolcross: olcross,\n\toline: oline,\n\tolt: olt,\n\tOmacr: Omacr,\n\tomacr: omacr,\n\tOmega: Omega,\n\tomega: omega,\n\tOmicron: Omicron,\n\tomicron: omicron,\n\tomid: omid,\n\tominus: ominus,\n\tOopf: Oopf,\n\toopf: oopf,\n\topar: opar,\n\tOpenCurlyDoubleQuote: OpenCurlyDoubleQuote,\n\tOpenCurlyQuote: OpenCurlyQuote,\n\toperp: operp,\n\toplus: oplus,\n\torarr: orarr,\n\tOr: Or,\n\tor: or,\n\tord: ord,\n\torder: order,\n\torderof: orderof,\n\tordf: ordf$1,\n\tordm: ordm$1,\n\torigof: origof,\n\toror: oror,\n\torslope: orslope,\n\torv: orv,\n\toS: oS,\n\tOscr: Oscr,\n\toscr: oscr,\n\tOslash: Oslash$1,\n\toslash: oslash$1,\n\tosol: osol,\n\tOtilde: Otilde$1,\n\totilde: otilde$1,\n\totimesas: otimesas,\n\tOtimes: Otimes,\n\totimes: otimes,\n\tOuml: Ouml$1,\n\touml: ouml$1,\n\tovbar: ovbar,\n\tOverBar: OverBar,\n\tOverBrace: OverBrace,\n\tOverBracket: OverBracket,\n\tOverParenthesis: OverParenthesis,\n\tpara: para$1,\n\tparallel: parallel,\n\tpar: par,\n\tparsim: parsim,\n\tparsl: parsl,\n\tpart: part,\n\tPartialD: PartialD,\n\tPcy: Pcy,\n\tpcy: pcy,\n\tpercnt: percnt,\n\tperiod: period,\n\tpermil: permil,\n\tperp: perp,\n\tpertenk: pertenk,\n\tPfr: Pfr,\n\tpfr: pfr,\n\tPhi: Phi,\n\tphi: phi,\n\tphiv: phiv,\n\tphmmat: phmmat,\n\tphone: phone,\n\tPi: Pi,\n\tpi: pi,\n\tpitchfork: pitchfork,\n\tpiv: piv,\n\tplanck: planck,\n\tplanckh: planckh,\n\tplankv: plankv,\n\tplusacir: plusacir,\n\tplusb: plusb,\n\tpluscir: pluscir,\n\tplus: plus,\n\tplusdo: plusdo,\n\tplusdu: plusdu,\n\tpluse: pluse,\n\tPlusMinus: PlusMinus,\n\tplusmn: plusmn$1,\n\tplussim: plussim,\n\tplustwo: plustwo,\n\tpm: pm,\n\tPoincareplane: Poincareplane,\n\tpointint: pointint,\n\tpopf: popf,\n\tPopf: Popf,\n\tpound: pound$1,\n\tprap: prap,\n\tPr: Pr,\n\tpr: pr,\n\tprcue: prcue,\n\tprecapprox: precapprox,\n\tprec: prec,\n\tpreccurlyeq: preccurlyeq,\n\tPrecedes: Precedes,\n\tPrecedesEqual: PrecedesEqual,\n\tPrecedesSlantEqual: PrecedesSlantEqual,\n\tPrecedesTilde: PrecedesTilde,\n\tpreceq: preceq,\n\tprecnapprox: precnapprox,\n\tprecneqq: precneqq,\n\tprecnsim: precnsim,\n\tpre: pre,\n\tprE: prE,\n\tprecsim: precsim,\n\tprime: prime,\n\tPrime: Prime,\n\tprimes: primes,\n\tprnap: prnap,\n\tprnE: prnE,\n\tprnsim: prnsim,\n\tprod: prod,\n\tProduct: Product,\n\tprofalar: profalar,\n\tprofline: profline,\n\tprofsurf: profsurf,\n\tprop: prop,\n\tProportional: Proportional,\n\tProportion: Proportion,\n\tpropto: propto,\n\tprsim: prsim,\n\tprurel: prurel,\n\tPscr: Pscr,\n\tpscr: pscr,\n\tPsi: Psi,\n\tpsi: psi,\n\tpuncsp: puncsp,\n\tQfr: Qfr,\n\tqfr: qfr,\n\tqint: qint,\n\tqopf: qopf,\n\tQopf: Qopf,\n\tqprime: qprime,\n\tQscr: Qscr,\n\tqscr: qscr,\n\tquaternions: quaternions,\n\tquatint: quatint,\n\tquest: quest,\n\tquesteq: questeq,\n\tquot: quot$2,\n\tQUOT: QUOT$1,\n\trAarr: rAarr,\n\trace: race,\n\tRacute: Racute,\n\tracute: racute,\n\tradic: radic,\n\traemptyv: raemptyv,\n\trang: rang,\n\tRang: Rang,\n\trangd: rangd,\n\trange: range,\n\trangle: rangle,\n\traquo: raquo$1,\n\trarrap: rarrap,\n\trarrb: rarrb,\n\trarrbfs: rarrbfs,\n\trarrc: rarrc,\n\trarr: rarr,\n\tRarr: Rarr,\n\trArr: rArr,\n\trarrfs: rarrfs,\n\trarrhk: rarrhk,\n\trarrlp: rarrlp,\n\trarrpl: rarrpl,\n\trarrsim: rarrsim,\n\tRarrtl: Rarrtl,\n\trarrtl: rarrtl,\n\trarrw: rarrw,\n\tratail: ratail,\n\trAtail: rAtail,\n\tratio: ratio,\n\trationals: rationals,\n\trbarr: rbarr,\n\trBarr: rBarr,\n\tRBarr: RBarr,\n\trbbrk: rbbrk,\n\trbrace: rbrace,\n\trbrack: rbrack,\n\trbrke: rbrke,\n\trbrksld: rbrksld,\n\trbrkslu: rbrkslu,\n\tRcaron: Rcaron,\n\trcaron: rcaron,\n\tRcedil: Rcedil,\n\trcedil: rcedil,\n\trceil: rceil,\n\trcub: rcub,\n\tRcy: Rcy,\n\trcy: rcy,\n\trdca: rdca,\n\trdldhar: rdldhar,\n\trdquo: rdquo,\n\trdquor: rdquor,\n\trdsh: rdsh,\n\treal: real,\n\trealine: realine,\n\trealpart: realpart,\n\treals: reals,\n\tRe: Re,\n\trect: rect,\n\treg: reg$1,\n\tREG: REG$1,\n\tReverseElement: ReverseElement,\n\tReverseEquilibrium: ReverseEquilibrium,\n\tReverseUpEquilibrium: ReverseUpEquilibrium,\n\trfisht: rfisht,\n\trfloor: rfloor,\n\trfr: rfr,\n\tRfr: Rfr,\n\trHar: rHar,\n\trhard: rhard,\n\trharu: rharu,\n\trharul: rharul,\n\tRho: Rho,\n\trho: rho,\n\trhov: rhov,\n\tRightAngleBracket: RightAngleBracket,\n\tRightArrowBar: RightArrowBar,\n\trightarrow: rightarrow,\n\tRightArrow: RightArrow,\n\tRightarrow: Rightarrow,\n\tRightArrowLeftArrow: RightArrowLeftArrow,\n\trightarrowtail: rightarrowtail,\n\tRightCeiling: RightCeiling,\n\tRightDoubleBracket: RightDoubleBracket,\n\tRightDownTeeVector: RightDownTeeVector,\n\tRightDownVectorBar: RightDownVectorBar,\n\tRightDownVector: RightDownVector,\n\tRightFloor: RightFloor,\n\trightharpoondown: rightharpoondown,\n\trightharpoonup: rightharpoonup,\n\trightleftarrows: rightleftarrows,\n\trightleftharpoons: rightleftharpoons,\n\trightrightarrows: rightrightarrows,\n\trightsquigarrow: rightsquigarrow,\n\tRightTeeArrow: RightTeeArrow,\n\tRightTee: RightTee,\n\tRightTeeVector: RightTeeVector,\n\trightthreetimes: rightthreetimes,\n\tRightTriangleBar: RightTriangleBar,\n\tRightTriangle: RightTriangle,\n\tRightTriangleEqual: RightTriangleEqual,\n\tRightUpDownVector: RightUpDownVector,\n\tRightUpTeeVector: RightUpTeeVector,\n\tRightUpVectorBar: RightUpVectorBar,\n\tRightUpVector: RightUpVector,\n\tRightVectorBar: RightVectorBar,\n\tRightVector: RightVector,\n\tring: ring,\n\trisingdotseq: risingdotseq,\n\trlarr: rlarr,\n\trlhar: rlhar,\n\trlm: rlm,\n\trmoustache: rmoustache,\n\trmoust: rmoust,\n\trnmid: rnmid,\n\troang: roang,\n\troarr: roarr,\n\trobrk: robrk,\n\tropar: ropar,\n\tropf: ropf,\n\tRopf: Ropf,\n\troplus: roplus,\n\trotimes: rotimes,\n\tRoundImplies: RoundImplies,\n\trpar: rpar,\n\trpargt: rpargt,\n\trppolint: rppolint,\n\trrarr: rrarr,\n\tRrightarrow: Rrightarrow,\n\trsaquo: rsaquo,\n\trscr: rscr,\n\tRscr: Rscr,\n\trsh: rsh,\n\tRsh: Rsh,\n\trsqb: rsqb,\n\trsquo: rsquo,\n\trsquor: rsquor,\n\trthree: rthree,\n\trtimes: rtimes,\n\trtri: rtri,\n\trtrie: rtrie,\n\trtrif: rtrif,\n\trtriltri: rtriltri,\n\tRuleDelayed: RuleDelayed,\n\truluhar: ruluhar,\n\trx: rx,\n\tSacute: Sacute,\n\tsacute: sacute,\n\tsbquo: sbquo,\n\tscap: scap,\n\tScaron: Scaron,\n\tscaron: scaron,\n\tSc: Sc,\n\tsc: sc,\n\tsccue: sccue,\n\tsce: sce,\n\tscE: scE,\n\tScedil: Scedil,\n\tscedil: scedil,\n\tScirc: Scirc,\n\tscirc: scirc,\n\tscnap: scnap,\n\tscnE: scnE,\n\tscnsim: scnsim,\n\tscpolint: scpolint,\n\tscsim: scsim,\n\tScy: Scy,\n\tscy: scy,\n\tsdotb: sdotb,\n\tsdot: sdot,\n\tsdote: sdote,\n\tsearhk: searhk,\n\tsearr: searr,\n\tseArr: seArr,\n\tsearrow: searrow,\n\tsect: sect$1,\n\tsemi: semi,\n\tseswar: seswar,\n\tsetminus: setminus,\n\tsetmn: setmn,\n\tsext: sext,\n\tSfr: Sfr,\n\tsfr: sfr,\n\tsfrown: sfrown,\n\tsharp: sharp,\n\tSHCHcy: SHCHcy,\n\tshchcy: shchcy,\n\tSHcy: SHcy,\n\tshcy: shcy,\n\tShortDownArrow: ShortDownArrow,\n\tShortLeftArrow: ShortLeftArrow,\n\tshortmid: shortmid,\n\tshortparallel: shortparallel,\n\tShortRightArrow: ShortRightArrow,\n\tShortUpArrow: ShortUpArrow,\n\tshy: shy$1,\n\tSigma: Sigma,\n\tsigma: sigma,\n\tsigmaf: sigmaf,\n\tsigmav: sigmav,\n\tsim: sim,\n\tsimdot: simdot,\n\tsime: sime,\n\tsimeq: simeq,\n\tsimg: simg,\n\tsimgE: simgE,\n\tsiml: siml,\n\tsimlE: simlE,\n\tsimne: simne,\n\tsimplus: simplus,\n\tsimrarr: simrarr,\n\tslarr: slarr,\n\tSmallCircle: SmallCircle,\n\tsmallsetminus: smallsetminus,\n\tsmashp: smashp,\n\tsmeparsl: smeparsl,\n\tsmid: smid,\n\tsmile: smile,\n\tsmt: smt,\n\tsmte: smte,\n\tsmtes: smtes,\n\tSOFTcy: SOFTcy,\n\tsoftcy: softcy,\n\tsolbar: solbar,\n\tsolb: solb,\n\tsol: sol,\n\tSopf: Sopf,\n\tsopf: sopf,\n\tspades: spades,\n\tspadesuit: spadesuit,\n\tspar: spar,\n\tsqcap: sqcap,\n\tsqcaps: sqcaps,\n\tsqcup: sqcup,\n\tsqcups: sqcups,\n\tSqrt: Sqrt,\n\tsqsub: sqsub,\n\tsqsube: sqsube,\n\tsqsubset: sqsubset,\n\tsqsubseteq: sqsubseteq,\n\tsqsup: sqsup,\n\tsqsupe: sqsupe,\n\tsqsupset: sqsupset,\n\tsqsupseteq: sqsupseteq,\n\tsquare: square,\n\tSquare: Square,\n\tSquareIntersection: SquareIntersection,\n\tSquareSubset: SquareSubset,\n\tSquareSubsetEqual: SquareSubsetEqual,\n\tSquareSuperset: SquareSuperset,\n\tSquareSupersetEqual: SquareSupersetEqual,\n\tSquareUnion: SquareUnion,\n\tsquarf: squarf,\n\tsqu: squ,\n\tsquf: squf,\n\tsrarr: srarr,\n\tSscr: Sscr,\n\tsscr: sscr,\n\tssetmn: ssetmn,\n\tssmile: ssmile,\n\tsstarf: sstarf,\n\tStar: Star,\n\tstar: star,\n\tstarf: starf,\n\tstraightepsilon: straightepsilon,\n\tstraightphi: straightphi,\n\tstrns: strns,\n\tsub: sub,\n\tSub: Sub,\n\tsubdot: subdot,\n\tsubE: subE,\n\tsube: sube,\n\tsubedot: subedot,\n\tsubmult: submult,\n\tsubnE: subnE,\n\tsubne: subne,\n\tsubplus: subplus,\n\tsubrarr: subrarr,\n\tsubset: subset,\n\tSubset: Subset,\n\tsubseteq: subseteq,\n\tsubseteqq: subseteqq,\n\tSubsetEqual: SubsetEqual,\n\tsubsetneq: subsetneq,\n\tsubsetneqq: subsetneqq,\n\tsubsim: subsim,\n\tsubsub: subsub,\n\tsubsup: subsup,\n\tsuccapprox: succapprox,\n\tsucc: succ,\n\tsucccurlyeq: succcurlyeq,\n\tSucceeds: Succeeds,\n\tSucceedsEqual: SucceedsEqual,\n\tSucceedsSlantEqual: SucceedsSlantEqual,\n\tSucceedsTilde: SucceedsTilde,\n\tsucceq: succeq,\n\tsuccnapprox: succnapprox,\n\tsuccneqq: succneqq,\n\tsuccnsim: succnsim,\n\tsuccsim: succsim,\n\tSuchThat: SuchThat,\n\tsum: sum,\n\tSum: Sum,\n\tsung: sung,\n\tsup1: sup1$1,\n\tsup2: sup2$1,\n\tsup3: sup3$1,\n\tsup: sup,\n\tSup: Sup,\n\tsupdot: supdot,\n\tsupdsub: supdsub,\n\tsupE: supE,\n\tsupe: supe,\n\tsupedot: supedot,\n\tSuperset: Superset,\n\tSupersetEqual: SupersetEqual,\n\tsuphsol: suphsol,\n\tsuphsub: suphsub,\n\tsuplarr: suplarr,\n\tsupmult: supmult,\n\tsupnE: supnE,\n\tsupne: supne,\n\tsupplus: supplus,\n\tsupset: supset,\n\tSupset: Supset,\n\tsupseteq: supseteq,\n\tsupseteqq: supseteqq,\n\tsupsetneq: supsetneq,\n\tsupsetneqq: supsetneqq,\n\tsupsim: supsim,\n\tsupsub: supsub,\n\tsupsup: supsup,\n\tswarhk: swarhk,\n\tswarr: swarr,\n\tswArr: swArr,\n\tswarrow: swarrow,\n\tswnwar: swnwar,\n\tszlig: szlig$1,\n\tTab: Tab,\n\ttarget: target,\n\tTau: Tau,\n\ttau: tau,\n\ttbrk: tbrk,\n\tTcaron: Tcaron,\n\ttcaron: tcaron,\n\tTcedil: Tcedil,\n\ttcedil: tcedil,\n\tTcy: Tcy,\n\ttcy: tcy,\n\ttdot: tdot,\n\ttelrec: telrec,\n\tTfr: Tfr,\n\ttfr: tfr,\n\tthere4: there4,\n\ttherefore: therefore,\n\tTherefore: Therefore,\n\tTheta: Theta,\n\ttheta: theta,\n\tthetasym: thetasym,\n\tthetav: thetav,\n\tthickapprox: thickapprox,\n\tthicksim: thicksim,\n\tThickSpace: ThickSpace,\n\tThinSpace: ThinSpace,\n\tthinsp: thinsp,\n\tthkap: thkap,\n\tthksim: thksim,\n\tTHORN: THORN$1,\n\tthorn: thorn$1,\n\ttilde: tilde,\n\tTilde: Tilde,\n\tTildeEqual: TildeEqual,\n\tTildeFullEqual: TildeFullEqual,\n\tTildeTilde: TildeTilde,\n\ttimesbar: timesbar,\n\ttimesb: timesb,\n\ttimes: times$1,\n\ttimesd: timesd,\n\ttint: tint,\n\ttoea: toea,\n\ttopbot: topbot,\n\ttopcir: topcir,\n\ttop: top,\n\tTopf: Topf,\n\ttopf: topf,\n\ttopfork: topfork,\n\ttosa: tosa,\n\ttprime: tprime,\n\ttrade: trade,\n\tTRADE: TRADE,\n\ttriangle: triangle,\n\ttriangledown: triangledown,\n\ttriangleleft: triangleleft,\n\ttrianglelefteq: trianglelefteq,\n\ttriangleq: triangleq,\n\ttriangleright: triangleright,\n\ttrianglerighteq: trianglerighteq,\n\ttridot: tridot,\n\ttrie: trie,\n\ttriminus: triminus,\n\tTripleDot: TripleDot,\n\ttriplus: triplus,\n\ttrisb: trisb,\n\ttritime: tritime,\n\ttrpezium: trpezium,\n\tTscr: Tscr,\n\ttscr: tscr,\n\tTScy: TScy,\n\ttscy: tscy,\n\tTSHcy: TSHcy,\n\ttshcy: tshcy,\n\tTstrok: Tstrok,\n\ttstrok: tstrok,\n\ttwixt: twixt,\n\ttwoheadleftarrow: twoheadleftarrow,\n\ttwoheadrightarrow: twoheadrightarrow,\n\tUacute: Uacute$1,\n\tuacute: uacute$1,\n\tuarr: uarr,\n\tUarr: Uarr,\n\tuArr: uArr,\n\tUarrocir: Uarrocir,\n\tUbrcy: Ubrcy,\n\tubrcy: ubrcy,\n\tUbreve: Ubreve,\n\tubreve: ubreve,\n\tUcirc: Ucirc$1,\n\tucirc: ucirc$1,\n\tUcy: Ucy,\n\tucy: ucy,\n\tudarr: udarr,\n\tUdblac: Udblac,\n\tudblac: udblac,\n\tudhar: udhar,\n\tufisht: ufisht,\n\tUfr: Ufr,\n\tufr: ufr,\n\tUgrave: Ugrave$1,\n\tugrave: ugrave$1,\n\tuHar: uHar,\n\tuharl: uharl,\n\tuharr: uharr,\n\tuhblk: uhblk,\n\tulcorn: ulcorn,\n\tulcorner: ulcorner,\n\tulcrop: ulcrop,\n\tultri: ultri,\n\tUmacr: Umacr,\n\tumacr: umacr,\n\tuml: uml$1,\n\tUnderBar: UnderBar,\n\tUnderBrace: UnderBrace,\n\tUnderBracket: UnderBracket,\n\tUnderParenthesis: UnderParenthesis,\n\tUnion: Union,\n\tUnionPlus: UnionPlus,\n\tUogon: Uogon,\n\tuogon: uogon,\n\tUopf: Uopf,\n\tuopf: uopf,\n\tUpArrowBar: UpArrowBar,\n\tuparrow: uparrow,\n\tUpArrow: UpArrow,\n\tUparrow: Uparrow,\n\tUpArrowDownArrow: UpArrowDownArrow,\n\tupdownarrow: updownarrow,\n\tUpDownArrow: UpDownArrow,\n\tUpdownarrow: Updownarrow,\n\tUpEquilibrium: UpEquilibrium,\n\tupharpoonleft: upharpoonleft,\n\tupharpoonright: upharpoonright,\n\tuplus: uplus,\n\tUpperLeftArrow: UpperLeftArrow,\n\tUpperRightArrow: UpperRightArrow,\n\tupsi: upsi,\n\tUpsi: Upsi,\n\tupsih: upsih,\n\tUpsilon: Upsilon,\n\tupsilon: upsilon,\n\tUpTeeArrow: UpTeeArrow,\n\tUpTee: UpTee,\n\tupuparrows: upuparrows,\n\turcorn: urcorn,\n\turcorner: urcorner,\n\turcrop: urcrop,\n\tUring: Uring,\n\turing: uring,\n\turtri: urtri,\n\tUscr: Uscr,\n\tuscr: uscr,\n\tutdot: utdot,\n\tUtilde: Utilde,\n\tutilde: utilde,\n\tutri: utri,\n\tutrif: utrif,\n\tuuarr: uuarr,\n\tUuml: Uuml$1,\n\tuuml: uuml$1,\n\tuwangle: uwangle,\n\tvangrt: vangrt,\n\tvarepsilon: varepsilon,\n\tvarkappa: varkappa,\n\tvarnothing: varnothing,\n\tvarphi: varphi,\n\tvarpi: varpi,\n\tvarpropto: varpropto,\n\tvarr: varr,\n\tvArr: vArr,\n\tvarrho: varrho,\n\tvarsigma: varsigma,\n\tvarsubsetneq: varsubsetneq,\n\tvarsubsetneqq: varsubsetneqq,\n\tvarsupsetneq: varsupsetneq,\n\tvarsupsetneqq: varsupsetneqq,\n\tvartheta: vartheta,\n\tvartriangleleft: vartriangleleft,\n\tvartriangleright: vartriangleright,\n\tvBar: vBar,\n\tVbar: Vbar,\n\tvBarv: vBarv,\n\tVcy: Vcy,\n\tvcy: vcy,\n\tvdash: vdash,\n\tvDash: vDash,\n\tVdash: Vdash,\n\tVDash: VDash,\n\tVdashl: Vdashl,\n\tveebar: veebar,\n\tvee: vee,\n\tVee: Vee,\n\tveeeq: veeeq,\n\tvellip: vellip,\n\tverbar: verbar,\n\tVerbar: Verbar,\n\tvert: vert,\n\tVert: Vert,\n\tVerticalBar: VerticalBar,\n\tVerticalLine: VerticalLine,\n\tVerticalSeparator: VerticalSeparator,\n\tVerticalTilde: VerticalTilde,\n\tVeryThinSpace: VeryThinSpace,\n\tVfr: Vfr,\n\tvfr: vfr,\n\tvltri: vltri,\n\tvnsub: vnsub,\n\tvnsup: vnsup,\n\tVopf: Vopf,\n\tvopf: vopf,\n\tvprop: vprop,\n\tvrtri: vrtri,\n\tVscr: Vscr,\n\tvscr: vscr,\n\tvsubnE: vsubnE,\n\tvsubne: vsubne,\n\tvsupnE: vsupnE,\n\tvsupne: vsupne,\n\tVvdash: Vvdash,\n\tvzigzag: vzigzag,\n\tWcirc: Wcirc,\n\twcirc: wcirc,\n\twedbar: wedbar,\n\twedge: wedge,\n\tWedge: Wedge,\n\twedgeq: wedgeq,\n\tweierp: weierp,\n\tWfr: Wfr,\n\twfr: wfr,\n\tWopf: Wopf,\n\twopf: wopf,\n\twp: wp,\n\twr: wr,\n\twreath: wreath,\n\tWscr: Wscr,\n\twscr: wscr,\n\txcap: xcap,\n\txcirc: xcirc,\n\txcup: xcup,\n\txdtri: xdtri,\n\tXfr: Xfr,\n\txfr: xfr,\n\txharr: xharr,\n\txhArr: xhArr,\n\tXi: Xi,\n\txi: xi,\n\txlarr: xlarr,\n\txlArr: xlArr,\n\txmap: xmap,\n\txnis: xnis,\n\txodot: xodot,\n\tXopf: Xopf,\n\txopf: xopf,\n\txoplus: xoplus,\n\txotime: xotime,\n\txrarr: xrarr,\n\txrArr: xrArr,\n\tXscr: Xscr,\n\txscr: xscr,\n\txsqcup: xsqcup,\n\txuplus: xuplus,\n\txutri: xutri,\n\txvee: xvee,\n\txwedge: xwedge,\n\tYacute: Yacute$1,\n\tyacute: yacute$1,\n\tYAcy: YAcy,\n\tyacy: yacy,\n\tYcirc: Ycirc,\n\tycirc: ycirc,\n\tYcy: Ycy,\n\tycy: ycy,\n\tyen: yen$1,\n\tYfr: Yfr,\n\tyfr: yfr,\n\tYIcy: YIcy,\n\tyicy: yicy,\n\tYopf: Yopf,\n\tyopf: yopf,\n\tYscr: Yscr,\n\tyscr: yscr,\n\tYUcy: YUcy,\n\tyucy: yucy,\n\tyuml: yuml$1,\n\tYuml: Yuml,\n\tZacute: Zacute,\n\tzacute: zacute,\n\tZcaron: Zcaron,\n\tzcaron: zcaron,\n\tZcy: Zcy,\n\tzcy: zcy,\n\tZdot: Zdot,\n\tzdot: zdot,\n\tzeetrf: zeetrf,\n\tZeroWidthSpace: ZeroWidthSpace,\n\tZeta: Zeta,\n\tzeta: zeta,\n\tzfr: zfr,\n\tZfr: Zfr,\n\tZHcy: ZHcy,\n\tzhcy: zhcy,\n\tzigrarr: zigrarr,\n\tzopf: zopf,\n\tZopf: Zopf,\n\tZscr: Zscr,\n\tzscr: zscr,\n\tzwj: zwj,\n\tzwnj: zwnj\n};\n\nvar Aacute = "Á";\nvar aacute = "á";\nvar Acirc = "Â";\nvar acirc = "â";\nvar acute = "´";\nvar AElig = "Æ";\nvar aelig = "æ";\nvar Agrave = "À";\nvar agrave = "à";\nvar amp$1 = "&";\nvar AMP = "&";\nvar Aring = "Å";\nvar aring = "å";\nvar Atilde = "Ã";\nvar atilde = "ã";\nvar Auml = "Ä";\nvar auml = "ä";\nvar brvbar = "¦";\nvar Ccedil = "Ç";\nvar ccedil = "ç";\nvar cedil = "¸";\nvar cent = "¢";\nvar copy = "©";\nvar COPY = "©";\nvar curren = "¤";\nvar deg = "°";\nvar divide = "÷";\nvar Eacute = "É";\nvar eacute = "é";\nvar Ecirc = "Ê";\nvar ecirc = "ê";\nvar Egrave = "È";\nvar egrave = "è";\nvar ETH = "Ð";\nvar eth = "ð";\nvar Euml = "Ë";\nvar euml = "ë";\nvar frac12 = "½";\nvar frac14 = "¼";\nvar frac34 = "¾";\nvar gt$1 = ">";\nvar GT = ">";\nvar Iacute = "Í";\nvar iacute = "í";\nvar Icirc = "Î";\nvar icirc = "î";\nvar iexcl = "¡";\nvar Igrave = "Ì";\nvar igrave = "ì";\nvar iquest = "¿";\nvar Iuml = "Ï";\nvar iuml = "ï";\nvar laquo = "«";\nvar lt$1 = "<";\nvar LT = "<";\nvar macr = "¯";\nvar micro = "µ";\nvar middot = "·";\nvar nbsp = " ";\nvar not = "¬";\nvar Ntilde = "Ñ";\nvar ntilde = "ñ";\nvar Oacute = "Ó";\nvar oacute = "ó";\nvar Ocirc = "Ô";\nvar ocirc = "ô";\nvar Ograve = "Ò";\nvar ograve = "ò";\nvar ordf = "ª";\nvar ordm = "º";\nvar Oslash = "Ø";\nvar oslash = "ø";\nvar Otilde = "Õ";\nvar otilde = "õ";\nvar Ouml = "Ö";\nvar ouml = "ö";\nvar para = "¶";\nvar plusmn = "±";\nvar pound = "£";\nvar quot$1 = "\\"";\nvar QUOT = "\\"";\nvar raquo = "»";\nvar reg = "®";\nvar REG = "®";\nvar sect = "§";\nvar shy = "­";\nvar sup1 = "¹";\nvar sup2 = "²";\nvar sup3 = "³";\nvar szlig = "ß";\nvar THORN = "Þ";\nvar thorn = "þ";\nvar times = "×";\nvar Uacute = "Ú";\nvar uacute = "ú";\nvar Ucirc = "Û";\nvar ucirc = "û";\nvar Ugrave = "Ù";\nvar ugrave = "ù";\nvar uml = "¨";\nvar Uuml = "Ü";\nvar uuml = "ü";\nvar Yacute = "Ý";\nvar yacute = "ý";\nvar yen = "¥";\nvar yuml = "ÿ";\nvar require$$1 = {\n\tAacute: Aacute,\n\taacute: aacute,\n\tAcirc: Acirc,\n\tacirc: acirc,\n\tacute: acute,\n\tAElig: AElig,\n\taelig: aelig,\n\tAgrave: Agrave,\n\tagrave: agrave,\n\tamp: amp$1,\n\tAMP: AMP,\n\tAring: Aring,\n\taring: aring,\n\tAtilde: Atilde,\n\tatilde: atilde,\n\tAuml: Auml,\n\tauml: auml,\n\tbrvbar: brvbar,\n\tCcedil: Ccedil,\n\tccedil: ccedil,\n\tcedil: cedil,\n\tcent: cent,\n\tcopy: copy,\n\tCOPY: COPY,\n\tcurren: curren,\n\tdeg: deg,\n\tdivide: divide,\n\tEacute: Eacute,\n\teacute: eacute,\n\tEcirc: Ecirc,\n\tecirc: ecirc,\n\tEgrave: Egrave,\n\tegrave: egrave,\n\tETH: ETH,\n\teth: eth,\n\tEuml: Euml,\n\teuml: euml,\n\tfrac12: frac12,\n\tfrac14: frac14,\n\tfrac34: frac34,\n\tgt: gt$1,\n\tGT: GT,\n\tIacute: Iacute,\n\tiacute: iacute,\n\tIcirc: Icirc,\n\ticirc: icirc,\n\tiexcl: iexcl,\n\tIgrave: Igrave,\n\tigrave: igrave,\n\tiquest: iquest,\n\tIuml: Iuml,\n\tiuml: iuml,\n\tlaquo: laquo,\n\tlt: lt$1,\n\tLT: LT,\n\tmacr: macr,\n\tmicro: micro,\n\tmiddot: middot,\n\tnbsp: nbsp,\n\tnot: not,\n\tNtilde: Ntilde,\n\tntilde: ntilde,\n\tOacute: Oacute,\n\toacute: oacute,\n\tOcirc: Ocirc,\n\tocirc: ocirc,\n\tOgrave: Ograve,\n\tograve: ograve,\n\tordf: ordf,\n\tordm: ordm,\n\tOslash: Oslash,\n\toslash: oslash,\n\tOtilde: Otilde,\n\totilde: otilde,\n\tOuml: Ouml,\n\touml: ouml,\n\tpara: para,\n\tplusmn: plusmn,\n\tpound: pound,\n\tquot: quot$1,\n\tQUOT: QUOT,\n\traquo: raquo,\n\treg: reg,\n\tREG: REG,\n\tsect: sect,\n\tshy: shy,\n\tsup1: sup1,\n\tsup2: sup2,\n\tsup3: sup3,\n\tszlig: szlig,\n\tTHORN: THORN,\n\tthorn: thorn,\n\ttimes: times,\n\tUacute: Uacute,\n\tuacute: uacute,\n\tUcirc: Ucirc,\n\tucirc: ucirc,\n\tUgrave: Ugrave,\n\tugrave: ugrave,\n\tuml: uml,\n\tUuml: Uuml,\n\tuuml: uuml,\n\tYacute: Yacute,\n\tyacute: yacute,\n\tyen: yen,\n\tyuml: yuml\n};\n\nvar amp = "&";\nvar apos = "\'";\nvar gt = ">";\nvar lt = "<";\nvar quot = "\\"";\nvar require$$0$1 = {\n\tamp: amp,\n\tapos: apos,\n\tgt: gt,\n\tlt: lt,\n\tquot: quot\n};\n\nvar decode_codepoint = {};\n\nvar require$$0 = {\n\t"0": 65533,\n\t"128": 8364,\n\t"130": 8218,\n\t"131": 402,\n\t"132": 8222,\n\t"133": 8230,\n\t"134": 8224,\n\t"135": 8225,\n\t"136": 710,\n\t"137": 8240,\n\t"138": 352,\n\t"139": 8249,\n\t"140": 338,\n\t"142": 381,\n\t"145": 8216,\n\t"146": 8217,\n\t"147": 8220,\n\t"148": 8221,\n\t"149": 8226,\n\t"150": 8211,\n\t"151": 8212,\n\t"152": 732,\n\t"153": 8482,\n\t"154": 353,\n\t"155": 8250,\n\t"156": 339,\n\t"158": 382,\n\t"159": 376\n};\n\nvar __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(decode_codepoint, "__esModule", { value: true });\nvar decode_json_1 = __importDefault$2(require$$0);\n// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nvar fromCodePoint$2 = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.fromCodePoint ||\n    function (codePoint) {\n        var output = "";\n        if (codePoint > 0xffff) {\n            codePoint -= 0x10000;\n            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n            codePoint = 0xdc00 | (codePoint & 0x3ff);\n        }\n        output += String.fromCharCode(codePoint);\n        return output;\n    };\nfunction decodeCodePoint(codePoint) {\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return "\\uFFFD";\n    }\n    if (codePoint in decode_json_1.default) {\n        codePoint = decode_json_1.default[codePoint];\n    }\n    return fromCodePoint$2(codePoint);\n}\ndecode_codepoint.default = decodeCodePoint;\n\nvar __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(decode, "__esModule", { value: true });\ndecode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;\nvar entities_json_1$1 = __importDefault$1(require$$1$1);\nvar legacy_json_1 = __importDefault$1(require$$1);\nvar xml_json_1$1 = __importDefault$1(require$$0$1);\nvar decode_codepoint_1 = __importDefault$1(decode_codepoint);\nvar strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\\da-fA-F]+|#\\d+);/g;\ndecode.decodeXML = getStrictDecoder(xml_json_1$1.default);\ndecode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);\nfunction getStrictDecoder(map) {\n    var replace = getReplacer(map);\n    return function (str) { return String(str).replace(strictEntityRe, replace); };\n}\nvar sorter = function (a, b) { return (a < b ? 1 : -1); };\ndecode.decodeHTML = (function () {\n    var legacy = Object.keys(legacy_json_1.default).sort(sorter);\n    var keys = Object.keys(entities_json_1$1.default).sort(sorter);\n    for (var i = 0, j = 0; i < keys.length; i++) {\n        if (legacy[j] === keys[i]) {\n            keys[i] += ";?";\n            j++;\n        }\n        else {\n            keys[i] += ";";\n        }\n    }\n    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)", "g");\n    var replace = getReplacer(entities_json_1$1.default);\n    function replacer(str) {\n        if (str.substr(-1) !== ";")\n            str += ";";\n        return replace(str);\n    }\n    // TODO consider creating a merged map\n    return function (str) { return String(str).replace(re, replacer); };\n})();\nfunction getReplacer(map) {\n    return function replace(str) {\n        if (str.charAt(1) === "#") {\n            var secondChar = str.charAt(2);\n            if (secondChar === "X" || secondChar === "x") {\n                return decode_codepoint_1.default(parseInt(str.substr(3), 16));\n            }\n            return decode_codepoint_1.default(parseInt(str.substr(2), 10));\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        return map[str.slice(1, -1)] || str;\n    };\n}\n\nvar encode = {};\n\nvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(encode, "__esModule", { value: true });\nencode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;\nvar xml_json_1 = __importDefault(require$$0$1);\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeXML = getASCIIEncoder(inverseXML);\nvar entities_json_1 = __importDefault(require$$1$1);\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\nfunction getInverseObj(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce(function (inverse, name) {\n        inverse[obj[name]] = "&" + name + ";";\n        return inverse;\n    }, {});\n}\nfunction getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n        var k = _a[_i];\n        if (k.length === 1) {\n            // Add value to single array\n            single.push("\\\\" + k);\n        }\n        else {\n            // Add value to multiple array\n            multiple.push(k);\n        }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n        // Find the end of a run of characters\n        var end = start;\n        while (end < single.length - 1 &&\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n            end += 1;\n        }\n        var count = 1 + end - start;\n        // We want to replace at least three characters\n        if (count < 3)\n            continue;\n        single.splice(start, count, single[start] + "-" + single[end]);\n    }\n    multiple.unshift("[" + single.join("") + "]");\n    return new RegExp(multiple.join("|"), "g");\n}\n// /[^\\0-\\x7F]/gu\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        function (str) { return str.codePointAt(0); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c) {\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\n                c.charCodeAt(1) -\n                0xdc00 +\n                0x10000;\n        };\nfunction singleCharReplacer(c) {\n    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\n        .toString(16)\n        .toUpperCase() + ";";\n}\nfunction getInverse(inverse, re) {\n    return function (data) {\n        return data\n            .replace(re, function (name) { return inverse[name]; })\n            .replace(reNonASCII, singleCharReplacer);\n    };\n}\nvar reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nfunction escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n}\nencode.escape = escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nfunction escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n}\nencode.escapeUTF8 = escapeUTF8;\nfunction getASCIIEncoder(obj) {\n    return function (data) {\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\n    };\n}\n\n(function (exports) {\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;\nvar decode_1 = decode;\nvar encode_1 = encode;\n/**\n * Decodes a string with entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeXML` or `decodeHTML` directly.\n */\nfunction decode$1(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);\n}\nexports.decode = decode$1;\n/**\n * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.\n */\nfunction decodeStrict(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);\n}\nexports.decodeStrict = decodeStrict;\n/**\n * Encodes a string with entities.\n *\n * @param data String to encode.\n * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.\n */\nfunction encode$1(data, level) {\n    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);\n}\nexports.encode = encode$1;\nvar encode_2 = encode;\nObject.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });\nObject.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nObject.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });\nObject.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });\nObject.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nObject.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nvar decode_2 = decode;\nObject.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });\nObject.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } });\n}(lib));\n\nvar ENTITY = \'&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});\';\nvar C_BACKSLASH$1 = 92;\nvar reBackslashOrAmp = /[\\\\&]/;\nvar ESCAPABLE = \'[!"#$%&\\\'()*+,./:;<=>?@[\\\\\\\\\\\\]^_`{|}~-]\';\nvar reEntityOrEscapedChar = new RegExp("\\\\\\\\" + ESCAPABLE + "|" + ENTITY, \'gi\');\nvar XMLSPECIAL = \'[&<>"]\';\nvar reXmlSpecial = new RegExp(XMLSPECIAL, \'g\');\nvar unescapeChar = function (s) {\n    if (s.charCodeAt(0) === C_BACKSLASH$1) {\n        return s.charAt(1);\n    }\n    return lib.decodeHTML(s);\n};\n// Replace entities and backslash escapes with literal characters.\nfunction unescapeString(s) {\n    if (reBackslashOrAmp.test(s)) {\n        return s.replace(reEntityOrEscapedChar, unescapeChar);\n    }\n    return s;\n}\nfunction normalizeURI(uri) {\n    try {\n        return encode_1(uri);\n    }\n    catch (err) {\n        return uri;\n    }\n}\nfunction replaceUnsafeChar(s) {\n    switch (s) {\n        case \'&\':\n            return \'&amp;\';\n        case \'<\':\n            return \'&lt;\';\n        case \'>\':\n            return \'&gt;\';\n        case \'"\':\n            return \'&quot;\';\n        default:\n            return s;\n    }\n}\nfunction escapeXml(s) {\n    if (reXmlSpecial.test(s)) {\n        return s.replace(reXmlSpecial, replaceUnsafeChar);\n    }\n    return s;\n}\nfunction repeat(str, count) {\n    var arr = [];\n    for (var i = 0; i < count; i++) {\n        arr.push(str);\n    }\n    return arr.join(\'\');\n}\nfunction isEmpty(str) {\n    if (!str) {\n        return true;\n    }\n    return !/[^ \\t]+/.test(str);\n}\n\nvar NodeWalker = /** @class */ (function () {\n    function NodeWalker(root) {\n        this.current = root;\n        this.root = root;\n        this.entering = true;\n    }\n    NodeWalker.prototype.next = function () {\n        var cur = this.current;\n        var entering = this.entering;\n        if (cur === null) {\n            return null;\n        }\n        var container = isContainer$1(cur);\n        if (entering && container) {\n            if (cur.firstChild) {\n                this.current = cur.firstChild;\n                this.entering = true;\n            }\n            else {\n                // stay on node but exit\n                this.entering = false;\n            }\n        }\n        else if (cur === this.root) {\n            this.current = null;\n        }\n        else if (cur.next === null) {\n            this.current = cur.parent;\n            this.entering = false;\n        }\n        else {\n            this.current = cur.next;\n            this.entering = true;\n        }\n        return { entering: entering, node: cur };\n    };\n    NodeWalker.prototype.resumeAt = function (node, entering) {\n        this.current = node;\n        this.entering = entering === true;\n    };\n    return NodeWalker;\n}());\n\nfunction isContainer$1(node) {\n    switch (node.type) {\n        case \'document\':\n        case \'blockQuote\':\n        case \'list\':\n        case \'item\':\n        case \'paragraph\':\n        case \'heading\':\n        case \'emph\':\n        case \'strong\':\n        case \'strike\':\n        case \'link\':\n        case \'image\':\n        case \'table\':\n        case \'tableHead\':\n        case \'tableBody\':\n        case \'tableRow\':\n        case \'tableCell\':\n        case \'tableDelimRow\':\n        case \'customInline\':\n            return true;\n        default:\n            return false;\n    }\n}\nvar lastNodeId = 1;\nvar nodeMap = {};\nfunction getNodeById(id) {\n    return nodeMap[id];\n}\nfunction removeNodeById(id) {\n    delete nodeMap[id];\n}\nfunction removeAllNode() {\n    nodeMap = {};\n}\nvar Node$1 = /** @class */ (function () {\n    function Node(nodeType, sourcepos) {\n        this.parent = null;\n        this.prev = null;\n        this.next = null;\n        // only for container node\n        this.firstChild = null;\n        this.lastChild = null;\n        // only for leaf node\n        this.literal = null;\n        if (nodeType === \'document\') {\n            this.id = -1;\n        }\n        else {\n            this.id = lastNodeId++;\n        }\n        this.type = nodeType;\n        this.sourcepos = sourcepos;\n        nodeMap[this.id] = this;\n    }\n    Node.prototype.isContainer = function () {\n        return isContainer$1(this);\n    };\n    Node.prototype.unlink = function () {\n        if (this.prev) {\n            this.prev.next = this.next;\n        }\n        else if (this.parent) {\n            this.parent.firstChild = this.next;\n        }\n        if (this.next) {\n            this.next.prev = this.prev;\n        }\n        else if (this.parent) {\n            this.parent.lastChild = this.prev;\n        }\n        this.parent = null;\n        this.next = null;\n        this.prev = null;\n    };\n    Node.prototype.replaceWith = function (node) {\n        this.insertBefore(node);\n        this.unlink();\n    };\n    Node.prototype.insertAfter = function (sibling) {\n        sibling.unlink();\n        sibling.next = this.next;\n        if (sibling.next) {\n            sibling.next.prev = sibling;\n        }\n        sibling.prev = this;\n        this.next = sibling;\n        if (this.parent) {\n            sibling.parent = this.parent;\n            if (!sibling.next) {\n                sibling.parent.lastChild = sibling;\n            }\n        }\n    };\n    Node.prototype.insertBefore = function (sibling) {\n        sibling.unlink();\n        sibling.prev = this.prev;\n        if (sibling.prev) {\n            sibling.prev.next = sibling;\n        }\n        sibling.next = this;\n        this.prev = sibling;\n        sibling.parent = this.parent;\n        if (!sibling.prev) {\n            sibling.parent.firstChild = sibling;\n        }\n    };\n    Node.prototype.appendChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.lastChild) {\n            this.lastChild.next = child;\n            child.prev = this.lastChild;\n            this.lastChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.prependChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.firstChild) {\n            this.firstChild.prev = child;\n            child.next = this.firstChild;\n            this.firstChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.walker = function () {\n        return new NodeWalker(this);\n    };\n    return Node;\n}());\nvar BlockNode = /** @class */ (function (_super) {\n    __extends(BlockNode, _super);\n    function BlockNode(nodeType, sourcepos) {\n        var _this = _super.call(this, nodeType, sourcepos) || this;\n        // temporal data (for parsing)\n        _this.open = true;\n        _this.lineOffsets = null;\n        _this.stringContent = null;\n        _this.lastLineBlank = false;\n        _this.lastLineChecked = false;\n        _this.type = nodeType;\n        return _this;\n    }\n    return BlockNode;\n}(Node$1));\nvar ListNode = /** @class */ (function (_super) {\n    __extends(ListNode, _super);\n    function ListNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.listData = null;\n        return _this;\n    }\n    return ListNode;\n}(BlockNode));\nvar HeadingNode = /** @class */ (function (_super) {\n    __extends(HeadingNode, _super);\n    function HeadingNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.level = 0;\n        _this.headingType = \'atx\';\n        return _this;\n    }\n    return HeadingNode;\n}(BlockNode));\nvar CodeBlockNode = /** @class */ (function (_super) {\n    __extends(CodeBlockNode, _super);\n    function CodeBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isFenced = false;\n        _this.fenceChar = null;\n        _this.fenceLength = 0;\n        _this.fenceOffset = -1;\n        _this.info = null;\n        _this.infoPadding = 0;\n        return _this;\n    }\n    return CodeBlockNode;\n}(BlockNode));\nvar TableNode = /** @class */ (function (_super) {\n    __extends(TableNode, _super);\n    function TableNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.columns = [];\n        return _this;\n    }\n    return TableNode;\n}(BlockNode));\nvar TableCellNode = /** @class */ (function (_super) {\n    __extends(TableCellNode, _super);\n    function TableCellNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.startIdx = 0;\n        _this.endIdx = 0;\n        _this.paddingLeft = 0;\n        _this.paddingRight = 0;\n        _this.ignored = false;\n        return _this;\n    }\n    return TableCellNode;\n}(BlockNode));\nvar RefDefNode = /** @class */ (function (_super) {\n    __extends(RefDefNode, _super);\n    function RefDefNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.title = \'\';\n        _this.dest = \'\';\n        _this.label = \'\';\n        return _this;\n    }\n    return RefDefNode;\n}(BlockNode));\nvar CustomBlockNode = /** @class */ (function (_super) {\n    __extends(CustomBlockNode, _super);\n    function CustomBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.syntaxLength = 0;\n        _this.offset = -1;\n        _this.info = \'\';\n        return _this;\n    }\n    return CustomBlockNode;\n}(BlockNode));\nvar HtmlBlockNode = /** @class */ (function (_super) {\n    __extends(HtmlBlockNode, _super);\n    function HtmlBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.htmlBlockType = -1;\n        return _this;\n    }\n    return HtmlBlockNode;\n}(BlockNode));\nvar LinkNode = /** @class */ (function (_super) {\n    __extends(LinkNode, _super);\n    function LinkNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.destination = null;\n        _this.title = null;\n        _this.extendedAutolink = false;\n        return _this;\n    }\n    return LinkNode;\n}(Node$1));\nvar CodeNode = /** @class */ (function (_super) {\n    __extends(CodeNode, _super);\n    function CodeNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.tickCount = 0;\n        return _this;\n    }\n    return CodeNode;\n}(Node$1));\nvar CustomInlineNode = /** @class */ (function (_super) {\n    __extends(CustomInlineNode, _super);\n    function CustomInlineNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.info = \'\';\n        return _this;\n    }\n    return CustomInlineNode;\n}(Node$1));\nfunction createNode$1(type, sourcepos) {\n    switch (type) {\n        case \'heading\':\n            return new HeadingNode(type, sourcepos);\n        case \'list\':\n        case \'item\':\n            return new ListNode(type, sourcepos);\n        case \'link\':\n        case \'image\':\n            return new LinkNode(type, sourcepos);\n        case \'codeBlock\':\n            return new CodeBlockNode(type, sourcepos);\n        case \'htmlBlock\':\n            return new HtmlBlockNode(type, sourcepos);\n        case \'table\':\n            return new TableNode(type, sourcepos);\n        case \'tableCell\':\n            return new TableCellNode(type, sourcepos);\n        case \'document\':\n        case \'paragraph\':\n        case \'blockQuote\':\n        case \'thematicBreak\':\n        case \'tableRow\':\n        case \'tableBody\':\n        case \'tableHead\':\n        case \'frontMatter\':\n            return new BlockNode(type, sourcepos);\n        case \'code\':\n            return new CodeNode(type, sourcepos);\n        case \'refDef\':\n            return new RefDefNode(type, sourcepos);\n        case \'customBlock\':\n            return new CustomBlockNode(type, sourcepos);\n        case \'customInline\':\n            return new CustomInlineNode(type, sourcepos);\n        default:\n            return new Node$1(type, sourcepos);\n    }\n}\nfunction isCodeBlock(node) {\n    return node.type === \'codeBlock\';\n}\nfunction isHtmlBlock(node) {\n    return node.type === \'htmlBlock\';\n}\nfunction isHeading(node) {\n    return node.type === \'heading\';\n}\nfunction isList(node) {\n    return node.type === \'list\';\n}\nfunction isTable(node) {\n    return node.type === \'table\';\n}\nfunction isRefDef(node) {\n    return node.type === \'refDef\';\n}\nfunction isCustomBlock(node) {\n    return node.type === \'customBlock\';\n}\nfunction isCustomInline(node) {\n    return node.type === \'customInline\';\n}\nfunction text$1(s, sourcepos) {\n    var node = createNode$1(\'text\', sourcepos);\n    node.literal = s;\n    return node;\n}\n\nvar TAGNAME = \'[A-Za-z][A-Za-z0-9-]*\';\nvar ATTRIBUTENAME = \'[a-zA-Z_:][a-zA-Z0-9:._-]*\';\nvar UNQUOTEDVALUE = \'[^"\\\'=<>`\\\\x00-\\\\x20]+\';\nvar SINGLEQUOTEDVALUE = "\'[^\']*\'";\nvar DOUBLEQUOTEDVALUE = \'"[^"]*"\';\nvar ATTRIBUTEVALUE = "(?:" + UNQUOTEDVALUE + "|" + SINGLEQUOTEDVALUE + "|" + DOUBLEQUOTEDVALUE + ")";\nvar ATTRIBUTEVALUESPEC = "" + \'(?:\\\\s*=\\\\s*\' + ATTRIBUTEVALUE + ")";\nvar ATTRIBUTE = "" + \'(?:\\\\s+\' + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)";\nvar OPENTAG = "<" + TAGNAME + ATTRIBUTE + "*\\\\s*/?>";\nvar CLOSETAG = "</" + TAGNAME + "\\\\s*[>]";\nvar HTMLCOMMENT = \'\x3c!----\x3e|\x3c!--(?:-?[^>-])(?:-?[^-])*--\x3e\';\nvar PROCESSINGINSTRUCTION = \'[<][?].*?[?][>]\';\nvar DECLARATION = \'<![A-Z]+\\\\s+[^>]*>\';\nvar CDATA = \'<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\';\nvar HTMLTAG = "(?:" + OPENTAG + "|" + CLOSETAG + "|" + HTMLCOMMENT + "|" + PROCESSINGINSTRUCTION + "|" + DECLARATION + "|" + CDATA + ")";\nvar reHtmlTag = new RegExp("^" + HTMLTAG, \'i\');\n\n// derived from https://github.com/mathiasbynens/String.fromCodePoint\n/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nvar fromCodePoint;\nif (String.fromCodePoint) {\n    fromCodePoint = function (_) {\n        try {\n            return String.fromCodePoint(_);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                return String.fromCharCode(0xfffd);\n            }\n            throw e;\n        }\n    };\n}\nelse {\n    var stringFromCharCode_1 = String.fromCharCode;\n    var floor_1 = Math.floor;\n    fromCodePoint = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = args.length;\n        if (!length) {\n            return \'\';\n        }\n        var result = \'\';\n        while (++index < length) {\n            var codePoint = Number(args[index]);\n            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                codePoint < 0 || // not a valid Unicode code point\n                codePoint > 0x10ffff || // not a valid Unicode code point\n                floor_1(codePoint) !== codePoint // not an integer\n            ) {\n                return String.fromCharCode(0xfffd);\n            }\n            if (codePoint <= 0xffff) {\n                // BMP code point\n                codeUnits.push(codePoint);\n            }\n            else {\n                // Astral code point; split in surrogate halves\n                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint -= 0x10000;\n                highSurrogate = (codePoint >> 10) + 0xd800;\n                lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                codeUnits.push(highSurrogate, lowSurrogate);\n            }\n            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                result += stringFromCharCode_1.apply(void 0, codeUnits);\n                codeUnits.length = 0;\n            }\n        }\n        return result;\n    };\n}\nvar fromCodePoint$1 = fromCodePoint;\n\nvar DOMAIN = \'(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+\';\nvar PATH = \'[^<\\\\s]*[^<?!.,:*_?~\\\\s]\';\nvar EMAIL = \'[\\\\w.+-]+@(?:[\\\\w-]+\\\\.)+[\\\\w-]+\';\nfunction trimUnmatchedTrailingParens(source) {\n    var trailingParen = /\\)+$/.exec(source);\n    if (trailingParen) {\n        var count = 0;\n        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {\n            var ch = source_1[_i];\n            if (ch === \'(\') {\n                if (count < 0) {\n                    count = 1;\n                }\n                else {\n                    count += 1;\n                }\n            }\n            else if (ch === \')\') {\n                count -= 1;\n            }\n        }\n        if (count < 0) {\n            var trimCount = Math.min(-count, trailingParen[0].length);\n            return source.substring(0, source.length - trimCount);\n        }\n    }\n    return source;\n}\nfunction trimTrailingEntity(source) {\n    return source.replace(/&[A-Za-z0-9]+;$/, \'\');\n}\nfunction parseEmailLink(source) {\n    var reEmailLink = new RegExp(EMAIL, \'g\');\n    var result = [];\n    var m;\n    while ((m = reEmailLink.exec(source))) {\n        var text_1 = m[0];\n        if (!/[_-]+$/.test(text_1)) {\n            result.push({\n                text: text_1,\n                range: [m.index, m.index + text_1.length - 1],\n                url: "mailto:" + text_1,\n            });\n        }\n    }\n    return result;\n}\nfunction parseUrlLink(source) {\n    var reWwwAutolink = new RegExp("(www|https?://)." + DOMAIN + PATH, \'g\');\n    var result = [];\n    var m;\n    while ((m = reWwwAutolink.exec(source))) {\n        var text_2 = trimTrailingEntity(trimUnmatchedTrailingParens(m[0]));\n        var scheme = m[1] === \'www\' ? \'http://\' : \'\';\n        result.push({\n            text: text_2,\n            range: [m.index, m.index + text_2.length - 1],\n            url: "" + scheme + text_2,\n        });\n    }\n    return result;\n}\nfunction baseAutolinkParser(source) {\n    return __spreadArray(__spreadArray([], parseUrlLink(source)), parseEmailLink(source)).sort(function (a, b) { return a.range[0] - b.range[0]; });\n}\nfunction convertExtAutoLinks(walker, autolinkParser) {\n    if (typeof autolinkParser === \'boolean\') {\n        autolinkParser = baseAutolinkParser;\n    }\n    var event;\n    var _loop_1 = function () {\n        var entering = event.entering, node = event.node;\n        if (entering && node.type === \'text\' && node.parent.type !== \'link\') {\n            var literal = node.literal;\n            var linkInfos = autolinkParser(literal);\n            if (!linkInfos || !linkInfos.length) {\n                return "continue";\n            }\n            var lastIdx = 0;\n            var _a = node.sourcepos[0], lineNum_1 = _a[0], chPos_1 = _a[1];\n            var sourcepos = function (startIdx, endIdx) { return [\n                [lineNum_1, chPos_1 + startIdx],\n                [lineNum_1, chPos_1 + endIdx],\n            ]; };\n            var newNodes = [];\n            for (var _i = 0, linkInfos_1 = linkInfos; _i < linkInfos_1.length; _i++) {\n                var _b = linkInfos_1[_i], range = _b.range, url = _b.url, linkText = _b.text;\n                if (range[0] > lastIdx) {\n                    newNodes.push(text$1(literal.substring(lastIdx, range[0]), sourcepos(lastIdx, range[0] - 1)));\n                }\n                var linkNode = createNode$1(\'link\', sourcepos.apply(void 0, range));\n                linkNode.appendChild(text$1(linkText, sourcepos.apply(void 0, range)));\n                linkNode.destination = url;\n                linkNode.extendedAutolink = true;\n                newNodes.push(linkNode);\n                lastIdx = range[1] + 1;\n            }\n            if (lastIdx < literal.length) {\n                newNodes.push(text$1(literal.substring(lastIdx), sourcepos(lastIdx, literal.length - 1)));\n            }\n            for (var _c = 0, newNodes_1 = newNodes; _c < newNodes_1.length; _c++) {\n                var newNode = newNodes_1[_c];\n                node.insertBefore(newNode);\n            }\n            node.unlink();\n        }\n    };\n    while ((event = walker.next())) {\n        _loop_1();\n    }\n}\n\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n// normalize a reference in reference link (remove []s, trim,\n// collapse internal space, unicode case fold.\n// See commonmark/commonmark.js#168.\nfunction normalizeReference(str) {\n    return str\n        .slice(1, str.length - 1)\n        .trim()\n        .replace(/[ \\t\\r\\n]+/, \' \')\n        .toLowerCase()\n        .toUpperCase();\n}\nfunction iterateObject(obj, iteratee) {\n    Object.keys(obj).forEach(function (key) {\n        iteratee(key, obj[key]);\n    });\n}\nfunction omit(obj) {\n    var propNames = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        propNames[_i - 1] = arguments[_i];\n    }\n    var resultMap = __assign({}, obj);\n    propNames.forEach(function (key) {\n        delete resultMap[key];\n    });\n    return resultMap;\n}\nfunction isEmptyObj(obj) {\n    return !Object.keys(obj).length;\n}\nfunction clearObj(obj) {\n    Object.keys(obj).forEach(function (key) {\n        delete obj[key];\n    });\n}\n\nvar C_NEWLINE = 10;\nvar C_ASTERISK = 42;\nvar C_UNDERSCORE = 95;\nvar C_BACKTICK = 96;\nvar C_OPEN_BRACKET$1 = 91;\nvar C_CLOSE_BRACKET = 93;\nvar C_TILDE = 126;\nvar C_LESSTHAN$1 = 60;\nvar C_BANG = 33;\nvar C_BACKSLASH = 92;\nvar C_AMPERSAND = 38;\nvar C_OPEN_PAREN = 40;\nvar C_CLOSE_PAREN = 41;\nvar C_COLON = 58;\nvar C_SINGLEQUOTE = 39;\nvar C_DOUBLEQUOTE = 34;\nvar C_DOLLAR = 36;\n// Some regexps used in inline parser:\nvar ESCAPED_CHAR = "\\\\\\\\" + ESCAPABLE;\nvar rePunctuation = new RegExp(/[!"#$%&\'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDF3C-\\uDF3E]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]/);\nvar reLinkTitle = new RegExp("^(?:\\"(" + ESCAPED_CHAR + "|[^\\"\\\\x00])*\\"" +\n    "|" +\n    ("\'(" + ESCAPED_CHAR + "|[^\'\\\\x00])*\'") +\n    "|" +\n    ("\\\\((" + ESCAPED_CHAR + "|[^()\\\\x00])*\\\\))"));\nvar reLinkDestinationBraces = /^(?:<(?:[^<>\\n\\\\\\x00]|\\\\.)*>)/;\nvar reEscapable = new RegExp("^" + ESCAPABLE);\nvar reEntityHere = new RegExp("^" + ENTITY, \'i\');\nvar reTicks = /`+/;\nvar reTicksHere = /^`+/;\nvar reEllipses = /\\.\\.\\./g;\nvar reDash = /--+/g;\nvar reEmailAutolink = /^<([a-zA-Z0-9.!#$%&\'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\\x00-\\x20]*>/i;\nvar reSpnl = /^ *(?:\\n *)?/;\nvar reWhitespaceChar = /^[ \\t\\n\\x0b\\x0c\\x0d]/;\nvar reUnicodeWhitespaceChar = /^\\s/;\nvar reFinalSpace = / *$/;\nvar reInitialSpace = /^ */;\nvar reSpaceAtEndOfLine = /^ *(?:\\n|$)/;\nvar reLinkLabel = /^\\[(?:[^\\\\\\[\\]]|\\\\.){0,1000}\\]/;\n// Matches a string of non-special characters.\nvar reMain = /^[^\\n`\\[\\]\\\\!<&*_\'"~$]+/m;\nvar InlineParser = /** @class */ (function () {\n    function InlineParser(options) {\n        // An InlineParser keeps track of a subject (a string to be parsed)\n        // and a position in that subject.\n        this.subject = \'\';\n        this.delimiters = null; // used by handleDelim method\n        this.brackets = null;\n        this.pos = 0;\n        this.lineStartNum = 0;\n        this.lineIdx = 0;\n        this.lineOffsets = [0];\n        this.linePosOffset = 0;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.options = options;\n    }\n    InlineParser.prototype.sourcepos = function (start, end) {\n        var linePosOffset = this.linePosOffset + this.lineOffsets[this.lineIdx];\n        var lineNum = this.lineStartNum + this.lineIdx;\n        var startpos = [lineNum, start + linePosOffset];\n        if (typeof end === \'number\') {\n            return [startpos, [lineNum, end + linePosOffset]];\n        }\n        return startpos;\n    };\n    InlineParser.prototype.nextLine = function () {\n        this.lineIdx += 1;\n        this.linePosOffset = -this.pos;\n    };\n    // If re matches at current position in the subject, advance\n    // position in subject and return the match; otherwise return null.\n    InlineParser.prototype.match = function (re) {\n        var m = re.exec(this.subject.slice(this.pos));\n        if (m === null) {\n            return null;\n        }\n        this.pos += m.index + m[0].length;\n        return m[0];\n    };\n    // Returns the code for the character at the current subject position, or -1\n    // there are no more characters.\n    InlineParser.prototype.peek = function () {\n        if (this.pos < this.subject.length) {\n            return this.subject.charCodeAt(this.pos);\n        }\n        return -1;\n    };\n    // Parse zero or more space characters, including at most one newline\n    InlineParser.prototype.spnl = function () {\n        this.match(reSpnl);\n        return true;\n    };\n    // All of the parsers below try to match something at the current position\n    // in the subject.  If they succeed in matching anything, they\n    // return the inline matched, advancing the subject.\n    // Attempt to parse backticks, adding either a backtick code span or a\n    // literal sequence of backticks.\n    InlineParser.prototype.parseBackticks = function (block) {\n        var startpos = this.pos + 1;\n        var ticks = this.match(reTicksHere);\n        if (ticks === null) {\n            return false;\n        }\n        var afterOpenTicks = this.pos;\n        var matched;\n        while ((matched = this.match(reTicks)) !== null) {\n            if (matched === ticks) {\n                var contents = this.subject.slice(afterOpenTicks, this.pos - ticks.length);\n                var sourcepos = this.sourcepos(startpos, this.pos);\n                var lines = contents.split(\'\\n\');\n                if (lines.length > 1) {\n                    var lastLine = last(lines);\n                    this.lineIdx += lines.length - 1;\n                    this.linePosOffset = -(this.pos - lastLine.length - ticks.length);\n                    sourcepos[1] = this.sourcepos(this.pos);\n                    contents = lines.join(\' \');\n                }\n                var node = createNode$1(\'code\', sourcepos);\n                if (contents.length > 0 &&\n                    contents.match(/[^ ]/) !== null &&\n                    contents[0] == \' \' &&\n                    contents[contents.length - 1] == \' \') {\n                    node.literal = contents.slice(1, contents.length - 1);\n                }\n                else {\n                    node.literal = contents;\n                }\n                node.tickCount = ticks.length;\n                block.appendChild(node);\n                return true;\n            }\n        }\n        // If we got here, we didn\'t match a closing backtick sequence.\n        this.pos = afterOpenTicks;\n        block.appendChild(text$1(ticks, this.sourcepos(startpos, this.pos - 1)));\n        return true;\n    };\n    // Parse a backslash-escaped special character, adding either the escaped\n    // character, a hard line break (if the backslash is followed by a newline),\n    // or a literal backslash to the block\'s children.  Assumes current character\n    // is a backslash.\n    InlineParser.prototype.parseBackslash = function (block) {\n        var subj = this.subject;\n        var node;\n        this.pos += 1;\n        var startpos = this.pos;\n        if (this.peek() === C_NEWLINE) {\n            this.pos += 1;\n            node = createNode$1(\'linebreak\', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            this.nextLine();\n        }\n        else if (reEscapable.test(subj.charAt(this.pos))) {\n            block.appendChild(text$1(subj.charAt(this.pos), this.sourcepos(startpos, this.pos)));\n            this.pos += 1;\n        }\n        else {\n            block.appendChild(text$1(\'\\\\\', this.sourcepos(startpos, startpos)));\n        }\n        return true;\n    };\n    // Attempt to parse an autolink (URL or email in pointy brackets).\n    InlineParser.prototype.parseAutolink = function (block) {\n        var m;\n        var dest;\n        var node;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEmailAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode$1(\'link\', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI("mailto:" + dest);\n            node.title = \'\';\n            node.appendChild(text$1(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        if ((m = this.match(reAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode$1(\'link\', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(dest);\n            node.title = \'\';\n            node.appendChild(text$1(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        return false;\n    };\n    // Attempt to parse a raw HTML tag.\n    InlineParser.prototype.parseHtmlTag = function (block) {\n        var startpos = this.pos + 1;\n        var m = this.match(reHtmlTag);\n        if (m === null) {\n            return false;\n        }\n        var node = createNode$1(\'htmlInline\', this.sourcepos(startpos, this.pos));\n        node.literal = m;\n        block.appendChild(node);\n        return true;\n    };\n    // Scan a sequence of characters with code cc, and return information about\n    // the number of delimiters and whether they are positioned such that\n    // they can open and/or close emphasis or strong emphasis.  A utility\n    // function for strong/emph parsing.\n    InlineParser.prototype.scanDelims = function (cc) {\n        var numdelims = 0;\n        var startpos = this.pos;\n        if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            numdelims++;\n            this.pos++;\n        }\n        else {\n            while (this.peek() === cc) {\n                numdelims++;\n                this.pos++;\n            }\n        }\n        if (numdelims === 0 || (numdelims < 2 && (cc === C_TILDE || cc === C_DOLLAR))) {\n            this.pos = startpos;\n            return null;\n        }\n        var charBefore = startpos === 0 ? \'\\n\' : this.subject.charAt(startpos - 1);\n        var ccAfter = this.peek();\n        var charAfter;\n        if (ccAfter === -1) {\n            charAfter = \'\\n\';\n        }\n        else {\n            charAfter = fromCodePoint$1(ccAfter);\n        }\n        var afterIsWhitespace = reUnicodeWhitespaceChar.test(charAfter);\n        var afterIsPunctuation = rePunctuation.test(charAfter);\n        var beforeIsWhitespace = reUnicodeWhitespaceChar.test(charBefore);\n        var beforeIsPunctuation = rePunctuation.test(charBefore);\n        var leftFlanking = !afterIsWhitespace && (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);\n        var rightFlanking = !beforeIsWhitespace && (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);\n        var canOpen;\n        var canClose;\n        if (cc === C_UNDERSCORE) {\n            canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);\n            canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);\n        }\n        else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            canOpen = leftFlanking && !rightFlanking;\n            canClose = rightFlanking;\n        }\n        else if (cc === C_DOLLAR) {\n            canOpen = !afterIsWhitespace;\n            canClose = !beforeIsWhitespace;\n        }\n        else {\n            canOpen = leftFlanking;\n            canClose = rightFlanking;\n        }\n        this.pos = startpos;\n        return { numdelims: numdelims, canOpen: canOpen, canClose: canClose };\n    };\n    // Handle a delimiter marker for emphasis or a quote.\n    InlineParser.prototype.handleDelim = function (cc, block) {\n        var res = this.scanDelims(cc);\n        if (!res) {\n            return false;\n        }\n        var numdelims = res.numdelims;\n        var startpos = this.pos + 1;\n        var contents;\n        this.pos += numdelims;\n        if (cc === C_SINGLEQUOTE) {\n            contents = \'\\u2019\';\n        }\n        else if (cc === C_DOUBLEQUOTE) {\n            contents = \'\\u201C\';\n        }\n        else {\n            contents = this.subject.slice(startpos - 1, this.pos);\n        }\n        var node = text$1(contents, this.sourcepos(startpos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        if ((res.canOpen || res.canClose) &&\n            (this.options.smart || (cc !== C_SINGLEQUOTE && cc !== C_DOUBLEQUOTE))) {\n            this.delimiters = {\n                cc: cc,\n                numdelims: numdelims,\n                origdelims: numdelims,\n                node: node,\n                previous: this.delimiters,\n                next: null,\n                canOpen: res.canOpen,\n                canClose: res.canClose,\n            };\n            if (this.delimiters.previous) {\n                this.delimiters.previous.next = this.delimiters;\n            }\n        }\n        return true;\n    };\n    InlineParser.prototype.removeDelimiter = function (delim) {\n        if (delim.previous !== null) {\n            delim.previous.next = delim.next;\n        }\n        if (delim.next === null) {\n            // top of stack\n            this.delimiters = delim.previous;\n        }\n        else {\n            delim.next.previous = delim.previous;\n        }\n    };\n    InlineParser.prototype.removeDelimitersBetween = function (bottom, top) {\n        if (bottom.next !== top) {\n            bottom.next = top;\n            top.previous = bottom;\n        }\n    };\n    /**\n     * Process all delimiters - emphasis, strong emphasis, strikethrough(gfm)\n     * If the smart punctuation options is true,\n     * convert single/double quotes to corresponding unicode characters.\n     **/\n    InlineParser.prototype.processEmphasis = function (stackBottom) {\n        var _a;\n        var opener;\n        var closer;\n        var oldCloser;\n        var openerInl, closerInl;\n        var openerFound;\n        var oddMatch = false;\n        var openersBottom = (_a = {},\n            _a[C_UNDERSCORE] = [stackBottom, stackBottom, stackBottom],\n            _a[C_ASTERISK] = [stackBottom, stackBottom, stackBottom],\n            _a[C_SINGLEQUOTE] = [stackBottom],\n            _a[C_DOUBLEQUOTE] = [stackBottom],\n            _a[C_TILDE] = [stackBottom],\n            _a[C_DOLLAR] = [stackBottom],\n            _a);\n        // find first closer above stackBottom:\n        closer = this.delimiters;\n        while (closer !== null && closer.previous !== stackBottom) {\n            closer = closer.previous;\n        }\n        // move forward, looking for closers, and handling each\n        while (closer !== null) {\n            var closercc = closer.cc;\n            var closerEmph = closercc === C_UNDERSCORE || closercc === C_ASTERISK;\n            if (!closer.canClose) {\n                closer = closer.next;\n            }\n            else {\n                // found emphasis closer. now look back for first matching opener:\n                opener = closer.previous;\n                openerFound = false;\n                while (opener !== null &&\n                    opener !== stackBottom &&\n                    opener !== openersBottom[closercc][closerEmph ? closer.origdelims % 3 : 0]) {\n                    oddMatch =\n                        closerEmph &&\n                            (closer.canOpen || opener.canClose) &&\n                            closer.origdelims % 3 !== 0 &&\n                            (opener.origdelims + closer.origdelims) % 3 === 0;\n                    if (opener.cc === closer.cc && opener.canOpen && !oddMatch) {\n                        openerFound = true;\n                        break;\n                    }\n                    opener = opener.previous;\n                }\n                oldCloser = closer;\n                if (closerEmph || closercc === C_TILDE || closercc === C_DOLLAR) {\n                    if (!openerFound) {\n                        closer = closer.next;\n                    }\n                    else if (opener) {\n                        // (null opener check for type narrowing)\n                        // calculate actual number of delimiters used from closer\n                        var useDelims = closer.numdelims >= 2 && opener.numdelims >= 2 ? 2 : 1;\n                        var emptyDelims = closerEmph ? 0 : 1;\n                        openerInl = opener.node;\n                        closerInl = closer.node;\n                        // build contents for new emph element\n                        var nodeType = closerEmph\n                            ? useDelims === 1\n                                ? \'emph\'\n                                : \'strong\'\n                            : \'strike\';\n                        if (closercc === C_DOLLAR) {\n                            nodeType = \'customInline\';\n                        }\n                        var newNode = createNode$1(nodeType);\n                        var openerEndPos = openerInl.sourcepos[1];\n                        var closerStartPos = closerInl.sourcepos[0];\n                        newNode.sourcepos = [\n                            [openerEndPos[0], openerEndPos[1] - useDelims + 1],\n                            [closerStartPos[0], closerStartPos[1] + useDelims - 1],\n                        ];\n                        openerInl.sourcepos[1][1] -= useDelims;\n                        closerInl.sourcepos[0][1] += useDelims;\n                        openerInl.literal = openerInl.literal.slice(useDelims);\n                        closerInl.literal = closerInl.literal.slice(useDelims);\n                        opener.numdelims -= useDelims;\n                        closer.numdelims -= useDelims;\n                        // remove used delimiters from stack elts and inlines\n                        var tmp = openerInl.next;\n                        var next = void 0;\n                        while (tmp && tmp !== closerInl) {\n                            next = tmp.next;\n                            tmp.unlink();\n                            newNode.appendChild(tmp);\n                            tmp = next;\n                        }\n                        // build custom inline node\n                        if (closercc === C_DOLLAR) {\n                            var textNode = newNode.firstChild;\n                            var literal = textNode.literal || \'\';\n                            var info = literal.split(/\\s/)[0];\n                            newNode.info = info;\n                            if (literal.length <= info.length) {\n                                textNode.unlink();\n                            }\n                            else {\n                                textNode.sourcepos[0][1] += info.length;\n                                textNode.literal = literal.replace(info + " ", \'\');\n                            }\n                        }\n                        openerInl.insertAfter(newNode);\n                        // remove elts between opener and closer in delimiters stack\n                        this.removeDelimitersBetween(opener, closer);\n                        // if opener has 0 delims, remove it and the inline\n                        // if opener has 1 delims and character is tilde, remove delimiter only\n                        if (opener.numdelims <= emptyDelims) {\n                            if (opener.numdelims === 0) {\n                                openerInl.unlink();\n                            }\n                            this.removeDelimiter(opener);\n                        }\n                        // if closer has 0 delims, remove it and the inline\n                        // if closer has 1 delims and character is tilde, remove delimiter only\n                        if (closer.numdelims <= emptyDelims) {\n                            if (closer.numdelims === 0) {\n                                closerInl.unlink();\n                            }\n                            var tempstack = closer.next;\n                            this.removeDelimiter(closer);\n                            closer = tempstack;\n                        }\n                    }\n                }\n                else if (closercc === C_SINGLEQUOTE) {\n                    closer.node.literal = \'\\u2019\';\n                    if (openerFound) {\n                        opener.node.literal = \'\\u2018\';\n                    }\n                    closer = closer.next;\n                }\n                else if (closercc === C_DOUBLEQUOTE) {\n                    closer.node.literal = \'\\u201D\';\n                    if (openerFound) {\n                        opener.node.literal = \'\\u201C\';\n                    }\n                    closer = closer.next;\n                }\n                if (!openerFound) {\n                    // Set lower bound for future searches for openers:\n                    openersBottom[closercc][closerEmph ? oldCloser.origdelims % 3 : 0] = oldCloser.previous;\n                    if (!oldCloser.canOpen) {\n                        // We can remove a closer that can\'t be an opener,\n                        // once we\'ve seen there\'s no matching opener:\n                        this.removeDelimiter(oldCloser);\n                    }\n                }\n            }\n        }\n        // remove all delimiters\n        while (this.delimiters !== null && this.delimiters !== stackBottom) {\n            this.removeDelimiter(this.delimiters);\n        }\n    };\n    // Attempt to parse link title (sans quotes), returning the string\n    // or null if no match.\n    InlineParser.prototype.parseLinkTitle = function () {\n        var title = this.match(reLinkTitle);\n        if (title === null) {\n            return null;\n        }\n        // chop off quotes from title and unescape:\n        return unescapeString(title.substr(1, title.length - 2));\n    };\n    // Attempt to parse link destination, returning the string or null if no match.\n    InlineParser.prototype.parseLinkDestination = function () {\n        var res = this.match(reLinkDestinationBraces);\n        if (res === null) {\n            if (this.peek() === C_LESSTHAN$1) {\n                return null;\n            }\n            // @TODO handrolled parser; res should be null or the string\n            var savepos = this.pos;\n            var openparens = 0;\n            var c = void 0;\n            while ((c = this.peek()) !== -1) {\n                if (c === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1))) {\n                    this.pos += 1;\n                    if (this.peek() !== -1) {\n                        this.pos += 1;\n                    }\n                }\n                else if (c === C_OPEN_PAREN) {\n                    this.pos += 1;\n                    openparens += 1;\n                }\n                else if (c === C_CLOSE_PAREN) {\n                    if (openparens < 1) {\n                        break;\n                    }\n                    else {\n                        this.pos += 1;\n                        openparens -= 1;\n                    }\n                }\n                else if (reWhitespaceChar.exec(fromCodePoint$1(c)) !== null) {\n                    break;\n                }\n                else {\n                    this.pos += 1;\n                }\n            }\n            if (this.pos === savepos && c !== C_CLOSE_PAREN) {\n                return null;\n            }\n            if (openparens !== 0) {\n                return null;\n            }\n            res = this.subject.substr(savepos, this.pos - savepos);\n            return normalizeURI(unescapeString(res));\n        } // chop off surrounding <..>:\n        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));\n    };\n    // Attempt to parse a link label, returning number of characters parsed.\n    InlineParser.prototype.parseLinkLabel = function () {\n        var m = this.match(reLinkLabel);\n        if (m === null || m.length > 1001) {\n            return 0;\n        }\n        return m.length;\n    };\n    // Add open bracket to delimiter stack and add a text node to block\'s children.\n    InlineParser.prototype.parseOpenBracket = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        var node = text$1(\'[\', this.sourcepos(this.pos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        this.addBracket(node, startpos, false);\n        return true;\n    };\n    // IF next character is [, and ! delimiter to delimiter stack and\n    // add a text node to block\'s children.  Otherwise just add a text node.\n    InlineParser.prototype.parseBang = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        if (this.peek() === C_OPEN_BRACKET$1) {\n            this.pos += 1;\n            var node = text$1(\'![\', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            // Add entry to stack for this opener\n            this.addBracket(node, startpos + 1, true);\n        }\n        else {\n            var node = text$1(\'!\', this.sourcepos(this.pos, this.pos));\n            block.appendChild(node);\n        }\n        return true;\n    };\n    // Try to match close bracket against an opening in the delimiter\n    // stack.  Add either a link or image, or a plain [ character,\n    // to block\'s children.  If there is a matching delimiter,\n    // remove it from the delimiter stack.\n    InlineParser.prototype.parseCloseBracket = function (block) {\n        var dest = null;\n        var title = null;\n        var matched = false;\n        this.pos += 1;\n        var startpos = this.pos;\n        // get last [ or ![\n        var opener = this.brackets;\n        if (opener === null) {\n            // no matched opener, just return a literal\n            block.appendChild(text$1(\']\', this.sourcepos(startpos, startpos)));\n            return true;\n        }\n        if (!opener.active) {\n            // no matched opener, just return a literal\n            block.appendChild(text$1(\']\', this.sourcepos(startpos, startpos)));\n            // take opener off brackets stack\n            this.removeBracket();\n            return true;\n        }\n        // If we got here, open is a potential opener\n        var isImage = opener.image;\n        // Check to see if we have a link/image\n        var savepos = this.pos;\n        // Inline link?\n        if (this.peek() === C_OPEN_PAREN) {\n            this.pos++;\n            if (this.spnl() &&\n                (dest = this.parseLinkDestination()) !== null &&\n                this.spnl() &&\n                // make sure there\'s a space before the title:\n                ((reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&\n                    (title = this.parseLinkTitle())) ||\n                    true) &&\n                this.spnl() &&\n                this.peek() === C_CLOSE_PAREN) {\n                this.pos += 1;\n                matched = true;\n            }\n            else {\n                this.pos = savepos;\n            }\n        }\n        var refLabel = \'\';\n        if (!matched) {\n            // Next, see if there\'s a link label\n            var beforelabel = this.pos;\n            var n = this.parseLinkLabel();\n            if (n > 2) {\n                refLabel = this.subject.slice(beforelabel, beforelabel + n);\n            }\n            else if (!opener.bracketAfter) {\n                // Empty or missing second label means to use the first label as the reference.\n                // The reference must not contain a bracket. If we know there\'s a bracket, we don\'t even bother checking it.\n                refLabel = this.subject.slice(opener.index, startpos);\n            }\n            if (n === 0) {\n                // If shortcut reference link, rewind before spaces we skipped.\n                this.pos = savepos;\n            }\n            if (refLabel) {\n                refLabel = normalizeReference(refLabel);\n                // lookup rawlabel in refMap\n                var link = this.refMap[refLabel];\n                if (link) {\n                    dest = link.destination;\n                    title = link.title;\n                    matched = true;\n                }\n            }\n        }\n        if (matched) {\n            var node = createNode$1(isImage ? \'image\' : \'link\');\n            node.destination = dest;\n            node.title = title || \'\';\n            node.sourcepos = [opener.startpos, this.sourcepos(this.pos)];\n            var tmp = opener.node.next;\n            var next = void 0;\n            while (tmp) {\n                next = tmp.next;\n                tmp.unlink();\n                node.appendChild(tmp);\n                tmp = next;\n            }\n            block.appendChild(node);\n            this.processEmphasis(opener.previousDelimiter);\n            this.removeBracket();\n            opener.node.unlink();\n            // We remove this bracket and processEmphasis will remove later delimiters.\n            // Now, for a link, we also deactivate earlier link openers.\n            // (no links in links)\n            if (!isImage) {\n                opener = this.brackets;\n                while (opener !== null) {\n                    if (!opener.image) {\n                        opener.active = false; // deactivate this opener\n                    }\n                    opener = opener.previous;\n                }\n            }\n            if (this.options.referenceDefinition) {\n                this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n            }\n            return true;\n        } // no match\n        this.removeBracket(); // remove this opener from stack\n        this.pos = startpos;\n        block.appendChild(text$1(\']\', this.sourcepos(startpos, startpos)));\n        if (this.options.referenceDefinition) {\n            this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n        }\n        return true;\n    };\n    InlineParser.prototype.addBracket = function (node, index, image) {\n        if (this.brackets !== null) {\n            this.brackets.bracketAfter = true;\n        }\n        this.brackets = {\n            node: node,\n            startpos: this.sourcepos(index + (image ? 0 : 1)),\n            previous: this.brackets,\n            previousDelimiter: this.delimiters,\n            index: index,\n            image: image,\n            active: true,\n        };\n    };\n    InlineParser.prototype.removeBracket = function () {\n        if (this.brackets) {\n            this.brackets = this.brackets.previous;\n        }\n    };\n    // Attempt to parse an entity.\n    InlineParser.prototype.parseEntity = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEntityHere))) {\n            block.appendChild(text$1(lib.decodeHTML(m), this.sourcepos(startpos, this.pos)));\n            return true;\n        }\n        return false;\n    };\n    // Parse a run of ordinary characters, or a single character with\n    // a special meaning in markdown, as a plain string.\n    InlineParser.prototype.parseString = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reMain))) {\n            if (this.options.smart) {\n                var lit = m.replace(reEllipses, \'\\u2026\').replace(reDash, function (chars) {\n                    var enCount = 0;\n                    var emCount = 0;\n                    if (chars.length % 3 === 0) {\n                        // If divisible by 3, use all em dashes\n                        emCount = chars.length / 3;\n                    }\n                    else if (chars.length % 2 === 0) {\n                        // If divisible by 2, use all en dashes\n                        enCount = chars.length / 2;\n                    }\n                    else if (chars.length % 3 === 2) {\n                        // If 2 extra dashes, use en dash for last 2; em dashes for rest\n                        enCount = 1;\n                        emCount = (chars.length - 2) / 3;\n                    }\n                    else {\n                        // Use en dashes for last 4 hyphens; em dashes for rest\n                        enCount = 2;\n                        emCount = (chars.length - 4) / 3;\n                    }\n                    return repeat(\'\\u2014\', emCount) + repeat(\'\\u2013\', enCount);\n                });\n                block.appendChild(text$1(lit, this.sourcepos(startpos, this.pos)));\n            }\n            else {\n                var node = text$1(m, this.sourcepos(startpos, this.pos));\n                block.appendChild(node);\n            }\n            return true;\n        }\n        return false;\n    };\n    // Parse a newline.  If it was preceded by two spaces, return a hard\n    // line break; otherwise a soft line break.\n    InlineParser.prototype.parseNewline = function (block) {\n        this.pos += 1; // assume we\'re at a \\n\n        // check previous node for trailing spaces\n        var lastc = block.lastChild;\n        if (lastc && lastc.type === \'text\' && lastc.literal[lastc.literal.length - 1] === \' \') {\n            var hardbreak = lastc.literal[lastc.literal.length - 2] === \' \';\n            var litLen = lastc.literal.length;\n            lastc.literal = lastc.literal.replace(reFinalSpace, \'\');\n            var finalSpaceLen = litLen - lastc.literal.length;\n            lastc.sourcepos[1][1] -= finalSpaceLen;\n            block.appendChild(createNode$1(hardbreak ? \'linebreak\' : \'softbreak\', this.sourcepos(this.pos - finalSpaceLen, this.pos)));\n        }\n        else {\n            block.appendChild(createNode$1(\'softbreak\', this.sourcepos(this.pos, this.pos)));\n        }\n        this.nextLine();\n        this.match(reInitialSpace); // gobble leading spaces in next line\n        return true;\n    };\n    // Attempt to parse a link reference, modifying refmap.\n    InlineParser.prototype.parseReference = function (block, refMap) {\n        if (!this.options.referenceDefinition) {\n            return 0;\n        }\n        this.subject = block.stringContent;\n        this.pos = 0;\n        var title = null;\n        var startpos = this.pos;\n        // label:\n        var matchChars = this.parseLinkLabel();\n        if (matchChars === 0) {\n            return 0;\n        }\n        var rawlabel = this.subject.substr(0, matchChars);\n        // colon:\n        if (this.peek() === C_COLON) {\n            this.pos++;\n        }\n        else {\n            this.pos = startpos;\n            return 0;\n        }\n        //  link url\n        this.spnl();\n        var dest = this.parseLinkDestination();\n        if (dest === null) {\n            this.pos = startpos;\n            return 0;\n        }\n        var beforetitle = this.pos;\n        this.spnl();\n        if (this.pos !== beforetitle) {\n            title = this.parseLinkTitle();\n        }\n        if (title === null) {\n            title = \'\';\n            // rewind before spaces\n            this.pos = beforetitle;\n        }\n        // make sure we\'re at line end:\n        var atLineEnd = true;\n        if (this.match(reSpaceAtEndOfLine) === null) {\n            if (title === \'\') {\n                atLineEnd = false;\n            }\n            else {\n                // the potential title we found is not at the line end,\n                // but it could still be a legal link reference if we\n                // discard the title\n                title = \'\';\n                // rewind before spaces\n                this.pos = beforetitle;\n                // and instead check if the link URL is at the line end\n                atLineEnd = this.match(reSpaceAtEndOfLine) !== null;\n            }\n        }\n        if (!atLineEnd) {\n            this.pos = startpos;\n            return 0;\n        }\n        var normalLabel = normalizeReference(rawlabel);\n        if (normalLabel === \'\') {\n            // label must contain non-whitespace characters\n            this.pos = startpos;\n            return 0;\n        }\n        var sourcepos = this.getReferenceDefSourcepos(block);\n        block.sourcepos[0][0] = sourcepos[1][0] + 1;\n        var node = createNode$1(\'refDef\', sourcepos);\n        node.title = title;\n        node.dest = dest;\n        node.label = normalLabel;\n        block.insertBefore(node);\n        if (!refMap[normalLabel]) {\n            refMap[normalLabel] = createRefDefState(node);\n        }\n        else {\n            this.refDefCandidateMap[node.id] = node;\n        }\n        return this.pos - startpos;\n    };\n    InlineParser.prototype.mergeTextNodes = function (walker) {\n        var event;\n        var textNodes = [];\n        while ((event = walker.next())) {\n            var entering = event.entering, node = event.node;\n            if (entering && node.type === \'text\') {\n                textNodes.push(node);\n            }\n            else if (textNodes.length === 1) {\n                textNodes = [];\n            }\n            else if (textNodes.length > 1) {\n                var firstNode = textNodes[0];\n                var lastNode = textNodes[textNodes.length - 1];\n                if (firstNode.sourcepos && lastNode.sourcepos) {\n                    firstNode.sourcepos[1] = lastNode.sourcepos[1];\n                }\n                firstNode.next = lastNode.next;\n                if (firstNode.next) {\n                    firstNode.next.prev = firstNode;\n                }\n                for (var i = 1; i < textNodes.length; i += 1) {\n                    firstNode.literal += textNodes[i].literal;\n                    textNodes[i].unlink();\n                }\n                textNodes = [];\n            }\n        }\n    };\n    InlineParser.prototype.getReferenceDefSourcepos = function (block) {\n        var lines = block.stringContent.split(/\\n|\\r\\n/);\n        var passedUrlLine = false;\n        var quotationCount = 0;\n        var lastLineOffset = { line: 0, ch: 0 };\n        for (var i = 0; i < lines.length; i += 1) {\n            var line = lines[i];\n            if (reWhitespaceChar.test(line)) {\n                break;\n            }\n            if (/\\:/.test(line) && quotationCount === 0) {\n                if (passedUrlLine) {\n                    break;\n                }\n                var lineOffset = line.indexOf(\':\') === line.length - 1 ? i + 1 : i;\n                lastLineOffset = { line: lineOffset, ch: lines[lineOffset].length };\n                passedUrlLine = true;\n            }\n            // should consider extendable title\n            var matched = line.match(/\'|"/g);\n            if (matched) {\n                quotationCount += matched.length;\n            }\n            if (quotationCount === 2) {\n                lastLineOffset = { line: i, ch: line.length };\n                break;\n            }\n        }\n        return [\n            [block.sourcepos[0][0], block.sourcepos[0][1]],\n            [block.sourcepos[0][0] + lastLineOffset.line, lastLineOffset.ch],\n        ];\n    };\n    // Parse the next inline element in subject, advancing subject position.\n    // On success, add the result to block\'s children and return true.\n    // On failure, return false.\n    InlineParser.prototype.parseInline = function (block) {\n        var _a;\n        var res = false;\n        var c = this.peek();\n        if (c === -1) {\n            return false;\n        }\n        switch (c) {\n            case C_NEWLINE:\n                res = this.parseNewline(block);\n                break;\n            case C_BACKSLASH:\n                res = this.parseBackslash(block);\n                break;\n            case C_BACKTICK:\n                res = this.parseBackticks(block);\n                break;\n            case C_ASTERISK:\n            case C_UNDERSCORE:\n            case C_TILDE:\n            case C_DOLLAR:\n                res = this.handleDelim(c, block);\n                break;\n            case C_SINGLEQUOTE:\n            case C_DOUBLEQUOTE:\n                res = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.smart) && this.handleDelim(c, block);\n                break;\n            case C_OPEN_BRACKET$1:\n                res = this.parseOpenBracket(block);\n                break;\n            case C_BANG:\n                res = this.parseBang(block);\n                break;\n            case C_CLOSE_BRACKET:\n                res = this.parseCloseBracket(block);\n                break;\n            case C_LESSTHAN$1:\n                res = this.parseAutolink(block) || this.parseHtmlTag(block);\n                break;\n            case C_AMPERSAND:\n                if (!block.disabledEntityParse) {\n                    res = this.parseEntity(block);\n                }\n                break;\n            default:\n                res = this.parseString(block);\n                break;\n        }\n        if (!res) {\n            this.pos += 1;\n            block.appendChild(text$1(fromCodePoint$1(c), this.sourcepos(this.pos, this.pos + 1)));\n        }\n        return true;\n    };\n    // Parse string content in block into inline children,\n    // using refmap to resolve references.\n    InlineParser.prototype.parse = function (block) {\n        this.subject = block.stringContent.trim();\n        this.pos = 0;\n        this.delimiters = null;\n        this.brackets = null;\n        this.lineOffsets = block.lineOffsets || [0];\n        this.lineIdx = 0;\n        this.linePosOffset = 0;\n        this.lineStartNum = block.sourcepos[0][0];\n        if (isHeading(block)) {\n            this.lineOffsets[0] += block.level + 1;\n        }\n        while (this.parseInline(block)) { }\n        block.stringContent = null; // allow raw string to be garbage collected\n        this.processEmphasis(null);\n        this.mergeTextNodes(block.walker());\n        var _a = this.options, extendedAutolinks = _a.extendedAutolinks, customParser = _a.customParser;\n        if (extendedAutolinks) {\n            convertExtAutoLinks(block.walker(), extendedAutolinks);\n        }\n        if (customParser && block.firstChild) {\n            var event_1;\n            var walker = block.firstChild.walker();\n            while ((event_1 = walker.next())) {\n                var node = event_1.node, entering = event_1.entering;\n                if (customParser[node.type]) {\n                    customParser[node.type](node, { entering: entering, options: this.options });\n                }\n            }\n        }\n    };\n    return InlineParser;\n}());\n\nvar reTaskListItemMarker = /^\\[([ \\txX])\\][ \\t]+/;\n// finalize for block handler\nfunction taskListItemFinalize(_, block) {\n    if (block.firstChild && block.firstChild.type === \'paragraph\') {\n        var p = block.firstChild;\n        var m = p.stringContent.match(reTaskListItemMarker);\n        if (m) {\n            var mLen = m[0].length;\n            p.stringContent = p.stringContent.substring(mLen - 1);\n            p.sourcepos[0][1] += mLen;\n            p.lineOffsets[0] += mLen;\n            block.listData.task = true;\n            block.listData.checked = /[xX]/.test(m[1]);\n        }\n    }\n}\n\nvar table = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === \'tableHead\' || t === \'tableBody\';\n    },\n    acceptsLines: false,\n};\nvar tableBody$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === \'tableRow\';\n    },\n    acceptsLines: false,\n};\nvar tableHead$1 = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === \'tableRow\' || t === \'tableDelimRow\';\n    },\n    acceptsLines: false,\n};\nvar tableDelimRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === \'tableDelimCell\';\n    },\n    acceptsLines: false,\n};\nvar tableDelimCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar tableRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === \'tableCell\';\n    },\n    acceptsLines: false,\n};\nvar tableCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\n\nvar CODE_INDENT = 4;\nvar C_TAB = 9;\nvar C_GREATERTHAN = 62;\nvar C_LESSTHAN = 60;\nvar C_SPACE = 32;\nvar C_OPEN_BRACKET = 91;\nvar reNonSpace = /[^ \\t\\f\\v\\r\\n]/;\nvar reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;\n// Returns true if block ends with a blank line, descending if needed\n// into lists and sublists.\nfunction endsWithBlankLine(block) {\n    var curBlock = block;\n    while (curBlock) {\n        if (curBlock.lastLineBlank) {\n            return true;\n        }\n        var t = curBlock.type;\n        if (!curBlock.lastLineChecked && (t === \'list\' || t === \'item\')) {\n            curBlock.lastLineChecked = true;\n            curBlock = curBlock.lastChild;\n        }\n        else {\n            curBlock.lastLineChecked = true;\n            break;\n        }\n    }\n    return false;\n}\nfunction peek(ln, pos) {\n    if (pos < ln.length) {\n        return ln.charCodeAt(pos);\n    }\n    return -1;\n}\n// Returns true if string contains only space characters.\nfunction isBlank(s) {\n    return !reNonSpace.test(s);\n}\nfunction isSpaceOrTab(c) {\n    return c === C_SPACE || c === C_TAB;\n}\n\nvar reClosingCustomBlock = /^\\$\\$$/;\nvar customBlock$1 = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reClosingCustomBlock);\n        if (match) {\n            // closing custom block\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        // skip optional spaces of custom block offset\n        var i = container.offset;\n        while (i > 0 && isSpaceOrTab(peek(line, parser.offset))) {\n            parser.advanceOffset(1, true);\n            i--;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        // first line becomes info string\n        var content = block.stringContent;\n        var newlinePos = content.indexOf(\'\\n\');\n        var firstLine = content.slice(0, newlinePos);\n        var rest = content.slice(newlinePos + 1);\n        var infoString = firstLine.match(/^(\\s*)(.*)/);\n        block.info = unescapeString(infoString[2].trim());\n        block.literal = rest;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\n\nvar noop = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar document$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== \'item\';\n    },\n    acceptsLines: false,\n};\nvar list = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var item = block.firstChild;\n        while (item) {\n            // check for non-final list item ending with blank line:\n            if (endsWithBlankLine(item) && item.next) {\n                block.listData.tight = false;\n                break;\n            }\n            // recurse into children of list item, to see if there are\n            // spaces between any of them:\n            var subitem = item.firstChild;\n            while (subitem) {\n                if (endsWithBlankLine(subitem) && (item.next || subitem.next)) {\n                    block.listData.tight = false;\n                    break;\n                }\n                subitem = subitem.next;\n            }\n            item = item.next;\n        }\n    },\n    canContain: function (t) {\n        return t === \'item\';\n    },\n    acceptsLines: false,\n};\nvar blockQuote$1 = {\n    continue: function (parser) {\n        var ln = parser.currentLine;\n        if (!parser.indented && peek(ln, parser.nextNonspace) === C_GREATERTHAN) {\n            parser.advanceNextNonspace();\n            parser.advanceOffset(1, false);\n            if (isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n            }\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== \'item\';\n    },\n    acceptsLines: false,\n};\nvar item = {\n    continue: function (parser, container) {\n        if (parser.blank) {\n            if (container.firstChild === null) {\n                // Blank line after empty list item\n                return 1 /* Stop */;\n            }\n            parser.advanceNextNonspace();\n        }\n        else if (parser.indent >= container.listData.markerOffset + container.listData.padding) {\n            parser.advanceOffset(container.listData.markerOffset + container.listData.padding, true);\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: taskListItemFinalize,\n    canContain: function (t) {\n        return t !== \'item\';\n    },\n    acceptsLines: false,\n};\nvar heading = {\n    continue: function () {\n        // a heading can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar thematicBreak$1 = {\n    continue: function () {\n        // a thematic break can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar codeBlock = {\n    continue: function (parser, container) {\n        var ln = parser.currentLine;\n        var indent = parser.indent;\n        if (container.isFenced) {\n            // fenced\n            var match = indent <= 3 &&\n                ln.charAt(parser.nextNonspace) === container.fenceChar &&\n                ln.slice(parser.nextNonspace).match(reClosingCodeFence);\n            if (match && match[0].length >= container.fenceLength) {\n                // closing fence - we\'re at end of line, so we can return\n                parser.lastLineLength = parser.offset + indent + match[0].length;\n                parser.finalize(container, parser.lineNumber);\n                return 2 /* Finished */;\n            }\n            // skip optional spaces of fence offset\n            var i = container.fenceOffset;\n            while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n                i--;\n            }\n        }\n        else {\n            // indented\n            if (indent >= CODE_INDENT) {\n                parser.advanceOffset(CODE_INDENT, true);\n            }\n            else if (parser.blank) {\n                parser.advanceNextNonspace();\n            }\n            else {\n                return 1 /* Stop */;\n            }\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        if (block.stringContent === null) {\n            return;\n        }\n        if (block.isFenced) {\n            // fenced\n            // first line becomes info string\n            var content = block.stringContent;\n            var newlinePos = content.indexOf(\'\\n\');\n            var firstLine = content.slice(0, newlinePos);\n            var rest = content.slice(newlinePos + 1);\n            var infoString = firstLine.match(/^(\\s*)(.*)/);\n            block.infoPadding = infoString[1].length;\n            block.info = unescapeString(infoString[2].trim());\n            block.literal = rest;\n        }\n        else {\n            // indented\n            block.literal = (_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, \'\\n\');\n        }\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar htmlBlock$1 = {\n    continue: function (parser, container) {\n        return parser.blank && (container.htmlBlockType === 6 || container.htmlBlockType === 7)\n            ? 1 /* Stop */\n            : 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        block.literal = ((_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, \'\')) || null;\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar paragraph = {\n    continue: function (parser) {\n        return parser.blank ? 1 /* Stop */ : 0 /* Go */;\n    },\n    finalize: function (parser, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        var pos;\n        var hasReferenceDefs = false;\n        // try parsing the beginning as link reference definitions:\n        while (peek(block.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(block, parser.refMap))) {\n            block.stringContent = block.stringContent.slice(pos);\n            hasReferenceDefs = true;\n        }\n        if (hasReferenceDefs && isBlank(block.stringContent)) {\n            block.unlink();\n        }\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar refDef = noop;\nvar frontMatter$2 = noop;\nvar blockHandlers = {\n    document: document$1,\n    list: list,\n    blockQuote: blockQuote$1,\n    item: item,\n    heading: heading,\n    thematicBreak: thematicBreak$1,\n    codeBlock: codeBlock,\n    htmlBlock: htmlBlock$1,\n    paragraph: paragraph,\n    table: table,\n    tableBody: tableBody$1,\n    tableHead: tableHead$1,\n    tableRow: tableRow,\n    tableCell: tableCell,\n    tableDelimRow: tableDelimRow,\n    tableDelimCell: tableDelimCell,\n    refDef: refDef,\n    customBlock: customBlock$1,\n    frontMatter: frontMatter$2,\n};\n\nfunction parseRowContent(content) {\n    var startIdx = 0;\n    var offset = 0;\n    var cells = [];\n    for (var i = 0; i < content.length; i += 1) {\n        if (content[i] === \'|\' && content[i - 1] !== \'\\\\\') {\n            var cell = content.substring(startIdx, i);\n            if (startIdx === 0 && isEmpty(cell)) {\n                offset = i + 1;\n            }\n            else {\n                cells.push(cell);\n            }\n            startIdx = i + 1;\n        }\n    }\n    if (startIdx < content.length) {\n        var cell = content.substring(startIdx, content.length);\n        if (!isEmpty(cell)) {\n            cells.push(cell);\n        }\n    }\n    return [offset, cells];\n}\nfunction generateTableCells(cellType, contents, lineNum, chPos) {\n    var cells = [];\n    for (var _i = 0, contents_1 = contents; _i < contents_1.length; _i++) {\n        var content = contents_1[_i];\n        var preSpaces = content.match(/^[ \\t]+/);\n        var paddingLeft = preSpaces ? preSpaces[0].length : 0;\n        var paddingRight = void 0, trimmed = void 0;\n        if (paddingLeft === content.length) {\n            paddingLeft = 0;\n            paddingRight = 0;\n            trimmed = \'\';\n        }\n        else {\n            var postSpaces = content.match(/[ \\t]+$/);\n            paddingRight = postSpaces ? postSpaces[0].length : 0;\n            trimmed = content.slice(paddingLeft, content.length - paddingRight);\n        }\n        var chPosStart = chPos + paddingLeft;\n        var tableCell = createNode$1(cellType, [\n            [lineNum, chPos],\n            [lineNum, chPos + content.length - 1],\n        ]);\n        tableCell.stringContent = trimmed.replace(/\\\\\\|/g, \'|\'); // replace esacped pipe(\\|)\n        tableCell.startIdx = cells.length;\n        tableCell.endIdx = cells.length;\n        tableCell.lineOffsets = [chPosStart - 1];\n        tableCell.paddingLeft = paddingLeft;\n        tableCell.paddingRight = paddingRight;\n        cells.push(tableCell);\n        chPos += content.length + 1;\n    }\n    return cells;\n}\nfunction getColumnFromDelimCell(cellNode) {\n    var align = null;\n    var content = cellNode.stringContent;\n    var firstCh = content[0];\n    var lastCh = content[content.length - 1];\n    if (lastCh === \':\') {\n        align = firstCh === \':\' ? \'center\' : \'right\';\n    }\n    else if (firstCh === \':\') {\n        align = \'left\';\n    }\n    return { align: align };\n}\nvar tableHead = function (parser, container) {\n    var stringContent = container.stringContent;\n    if (container.type === \'paragraph\' && !parser.indented && !parser.blank) {\n        var lastNewLineIdx = stringContent.length - 1;\n        var lastLineStartIdx = stringContent.lastIndexOf(\'\\n\', lastNewLineIdx - 1) + 1;\n        var headerContent = stringContent.slice(lastLineStartIdx, lastNewLineIdx);\n        var delimContent = parser.currentLine.slice(parser.nextNonspace);\n        var _a = parseRowContent(headerContent), headerOffset = _a[0], headerCells = _a[1];\n        var _b = parseRowContent(delimContent), delimOffset = _b[0], delimCells = _b[1];\n        var reValidDelimCell_1 = /^[ \\t]*:?-+:?[ \\t]*$/;\n        if (\n        // not checking if the number of header cells and delimiter cells are the same\n        // to consider the case of merged-column (via plugin)\n        !headerCells.length ||\n            !delimCells.length ||\n            delimCells.some(function (cell) { return !reValidDelimCell_1.test(cell); }) ||\n            // to prevent to regard setTextHeading as tabel delim cell with \'disallowDeepHeading\' option\n            (delimCells.length === 1 && delimContent.indexOf(\'|\') !== 0)) {\n            return 0 /* None */;\n        }\n        var lineOffsets = container.lineOffsets;\n        var firstLineNum = parser.lineNumber - 1;\n        var firstLineStart = last(lineOffsets) + 1;\n        var table = createNode$1(\'table\', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        // eslint-disable-next-line arrow-body-style\n        table.columns = delimCells.map(function () { return ({ align: null }); });\n        container.insertAfter(table);\n        if (lineOffsets.length === 1) {\n            container.unlink();\n        }\n        else {\n            container.stringContent = stringContent.slice(0, lastLineStartIdx);\n            var paraLastLineStartIdx = stringContent.lastIndexOf(\'\\n\', lastLineStartIdx - 2) + 1;\n            var paraLastLineLen = lastLineStartIdx - paraLastLineStartIdx - 1;\n            parser.lastLineLength = lineOffsets[lineOffsets.length - 2] + paraLastLineLen;\n            parser.finalize(container, firstLineNum - 1);\n        }\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        var tableHead_1 = createNode$1(\'tableHead\', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        table.appendChild(tableHead_1);\n        var tableHeadRow_1 = createNode$1(\'tableRow\', [\n            [firstLineNum, firstLineStart],\n            [firstLineNum, firstLineStart + headerContent.length - 1],\n        ]);\n        var tableDelimRow_1 = createNode$1(\'tableDelimRow\', [\n            [parser.lineNumber, parser.nextNonspace + 1],\n            [parser.lineNumber, parser.offset],\n        ]);\n        tableHead_1.appendChild(tableHeadRow_1);\n        tableHead_1.appendChild(tableDelimRow_1);\n        generateTableCells(\'tableCell\', headerCells, firstLineNum, firstLineStart + headerOffset).forEach(function (cellNode) {\n            tableHeadRow_1.appendChild(cellNode);\n        });\n        var delimCellNodes = generateTableCells(\'tableDelimCell\', delimCells, parser.lineNumber, parser.nextNonspace + 1 + delimOffset);\n        delimCellNodes.forEach(function (cellNode) {\n            tableDelimRow_1.appendChild(cellNode);\n        });\n        table.columns = delimCellNodes.map(getColumnFromDelimCell);\n        parser.tip = table;\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar tableBody = function (parser, container) {\n    if ((container.type !== \'table\' && container.type !== \'tableBody\') ||\n        (!parser.blank && parser.currentLine.indexOf(\'|\') === -1)) {\n        return 0 /* None */;\n    }\n    parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n    if (parser.blank) {\n        var table_1 = container;\n        if (container.type === \'tableBody\') {\n            table_1 = container.parent;\n            parser.finalize(container, parser.lineNumber - 1);\n        }\n        parser.finalize(table_1, parser.lineNumber - 1);\n        return 0 /* None */;\n    }\n    var tableBody = container;\n    if (container.type === \'table\') {\n        tableBody = parser.addChild(\'tableBody\', parser.nextNonspace);\n        tableBody.stringContent = null;\n    }\n    var tableRow = createNode$1(\'tableRow\', [\n        [parser.lineNumber, parser.nextNonspace + 1],\n        [parser.lineNumber, parser.currentLine.length],\n    ]);\n    tableBody.appendChild(tableRow);\n    var table = tableBody.parent;\n    var content = parser.currentLine.slice(parser.nextNonspace);\n    var _a = parseRowContent(content), offset = _a[0], cellContents = _a[1];\n    generateTableCells(\'tableCell\', cellContents, parser.lineNumber, parser.nextNonspace + 1 + offset).forEach(function (cellNode, idx) {\n        if (idx >= table.columns.length) {\n            cellNode.ignored = true;\n        }\n        tableRow.appendChild(cellNode);\n    });\n    return 2 /* Leaf */;\n};\n\nvar reCustomBlock = /^(\\$\\$)(\\s*[a-zA-Z])+/;\nvar reCanBeCustomInline = /^(\\$\\$)(\\s*[a-zA-Z])+.*(\\$\\$)/;\nvar customBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        !reCanBeCustomInline.test(parser.currentLine) &&\n        (match = parser.currentLine.match(reCustomBlock))) {\n        var syntaxLength = match[1].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild(\'customBlock\', parser.nextNonspace);\n        container.syntaxLength = syntaxLength;\n        container.offset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(syntaxLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\n\nvar reCodeFence = /^`{3,}(?!.*`)|^~{3,}/;\nvar reHtmlBlockOpen = [\n    /./,\n    /^<(?:script|pre|style)(?:\\s|>|$)/i,\n    /^\x3c!--/,\n    /^<[?]/,\n    /^<![A-Z]/,\n    /^<!\\[CDATA\\[/,\n    /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|[/]?[>]|$)/i,\n    new RegExp("^(?:" + OPENTAG + "|" + CLOSETAG + ")\\\\s*$", \'i\'),\n];\nvar reSetextHeadingLine = /^(?:=+|-+)[ \\t]*$/;\nvar reATXHeadingMarker = /^#{1,6}(?:[ \\t]+|$)/;\nvar reThematicBreak = /^(?:(?:\\*[ \\t]*){3,}|(?:_[ \\t]*){3,}|(?:-[ \\t]*){3,})[ \\t]*$/;\nvar reBulletListMarker = /^[*+-]/;\nvar reOrderedListMarker = /^(\\d{1,9})([.)])/;\n// Parse a list marker and return data on the marker (type,\n// start, delimiter, bullet character, padding) or null.\nfunction parseListMarker(parser, container) {\n    var rest = parser.currentLine.slice(parser.nextNonspace);\n    var match;\n    var nextc;\n    var data = {\n        type: \'bullet\',\n        tight: true,\n        bulletChar: \'\',\n        start: 0,\n        delimiter: \'\',\n        padding: 0,\n        markerOffset: parser.indent,\n        // GFM: Task List Item\n        task: false,\n        checked: false,\n    };\n    if (parser.indent >= 4) {\n        return null;\n    }\n    if ((match = rest.match(reBulletListMarker))) {\n        data.type = \'bullet\';\n        data.bulletChar = match[0][0];\n    }\n    else if ((match = rest.match(reOrderedListMarker)) &&\n        (container.type !== \'paragraph\' || match[1] === \'1\')) {\n        data.type = \'ordered\';\n        data.start = parseInt(match[1], 10);\n        data.delimiter = match[2];\n    }\n    else {\n        return null;\n    }\n    // make sure we have spaces after\n    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);\n    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {\n        return null;\n    }\n    // if it interrupts paragraph, make sure first line isn\'t blank\n    if (container.type === \'paragraph\' &&\n        !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {\n        return null;\n    }\n    // we\'ve got a match! advance offset and calculate padding\n    parser.advanceNextNonspace(); // to start of marker\n    parser.advanceOffset(match[0].length, true); // to end of marker\n    var spacesStartCol = parser.column;\n    var spacesStartOffset = parser.offset;\n    do {\n        parser.advanceOffset(1, true);\n        nextc = peek(parser.currentLine, parser.offset);\n    } while (parser.column - spacesStartCol < 5 && isSpaceOrTab(nextc));\n    var blankItem = peek(parser.currentLine, parser.offset) === -1;\n    var spacesAfterMarker = parser.column - spacesStartCol;\n    if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || blankItem) {\n        data.padding = match[0].length + 1;\n        parser.column = spacesStartCol;\n        parser.offset = spacesStartOffset;\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n    }\n    else {\n        data.padding = match[0].length + spacesAfterMarker;\n    }\n    return data;\n}\n// Returns true if the two list items are of the same type,\n// with the same delimiter and bullet character.  This is used\n// in agglomerating list items into lists.\nfunction listsMatch(listData, itemData) {\n    return (listData.type === itemData.type &&\n        listData.delimiter === itemData.delimiter &&\n        listData.bulletChar === itemData.bulletChar);\n}\nfunction isDisallowedDeepHeading(parser, node) {\n    return parser.options.disallowDeepHeading && (node.type === \'blockQuote\' || node.type === \'item\');\n}\nvar blockQuote = function (parser) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(1, false);\n        // optional following space\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n        parser.closeUnmatchedBlocks();\n        parser.addChild(\'blockQuote\', parser.nextNonspace);\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\nvar atxHeading = function (parser, container) {\n    var match;\n    if (!parser.indented &&\n        // The nested Heading is disallowed in list and blockquote with \'disallowDeepHeading\' option\n        !isDisallowedDeepHeading(parser, container) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(match[0].length, false);\n        parser.closeUnmatchedBlocks();\n        var heading = parser.addChild(\'heading\', parser.nextNonspace);\n        heading.level = match[0].trim().length; // number of #s\n        heading.headingType = \'atx\';\n        // remove trailing ###s:\n        heading.stringContent = parser.currentLine\n            .slice(parser.offset)\n            .replace(/^[ \\t]*#+[ \\t]*$/, \'\')\n            .replace(/[ \\t]+#+[ \\t]*$/, \'\');\n        parser.advanceOffset(parser.currentLine.length - parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar fencedCodeBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {\n        var fenceLength = match[0].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild(\'codeBlock\', parser.nextNonspace);\n        container.isFenced = true;\n        container.fenceLength = fenceLength;\n        container.fenceChar = match[0][0];\n        container.fenceOffset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(fenceLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar htmlBlock = function (parser, container) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {\n        var s = parser.currentLine.slice(parser.nextNonspace);\n        var disallowedTags = parser.options.disallowedHtmlBlockTags;\n        var blockType = void 0;\n        for (blockType = 1; blockType <= 7; blockType++) {\n            var matched = s.match(reHtmlBlockOpen[blockType]);\n            if (matched) {\n                if (blockType === 7) {\n                    if (container.type === \'paragraph\') {\n                        return 0 /* None */;\n                    }\n                    if (disallowedTags.length > 0) {\n                        var reDisallowedTags = new RegExp("</?(?:" + disallowedTags.join(\'|\') + ")", \'i\');\n                        if (reDisallowedTags.test(matched[0])) {\n                            return 0 /* None */;\n                        }\n                    }\n                }\n                parser.closeUnmatchedBlocks();\n                // We don\'t adjust parser.offset;\n                // spaces are part of the HTML block:\n                var b = parser.addChild(\'htmlBlock\', parser.offset);\n                b.htmlBlockType = blockType;\n                return 2 /* Leaf */;\n            }\n        }\n    }\n    return 0 /* None */;\n};\nvar seTextHeading = function (parser, container) {\n    var match;\n    if (container.stringContent !== null &&\n        !parser.indented &&\n        container.type === \'paragraph\' &&\n        // The nested Heading is disallowed in list and blockquote with \'disallowDeepHeading\' option\n        !isDisallowedDeepHeading(parser, container.parent) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine))) {\n        parser.closeUnmatchedBlocks();\n        // resolve reference link definitions\n        var pos = void 0;\n        while (peek(container.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(container, parser.refMap))) {\n            container.stringContent = container.stringContent.slice(pos);\n        }\n        if (container.stringContent.length > 0) {\n            var heading = createNode$1(\'heading\', container.sourcepos);\n            heading.level = match[0][0] === \'=\' ? 1 : 2;\n            heading.headingType = \'setext\';\n            heading.stringContent = container.stringContent;\n            container.insertAfter(heading);\n            container.unlink();\n            parser.tip = heading;\n            parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n            return 2 /* Leaf */;\n        }\n        return 0 /* None */;\n    }\n    return 0 /* None */;\n};\nvar thematicBreak = function (parser) {\n    if (!parser.indented && reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {\n        parser.closeUnmatchedBlocks();\n        parser.addChild(\'thematicBreak\', parser.nextNonspace);\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar listItem = function (parser, container) {\n    var data;\n    var currNode = container;\n    if ((!parser.indented || container.type === \'list\') &&\n        (data = parseListMarker(parser, currNode))) {\n        parser.closeUnmatchedBlocks();\n        // add the list if needed\n        if (parser.tip.type !== \'list\' || !listsMatch(currNode.listData, data)) {\n            currNode = parser.addChild(\'list\', parser.nextNonspace);\n            currNode.listData = data;\n        }\n        // add the list item\n        currNode = parser.addChild(\'item\', parser.nextNonspace);\n        currNode.listData = data;\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\n// indented code block\nvar indentedCodeBlock = function (parser) {\n    if (parser.indented && parser.tip.type !== \'paragraph\' && !parser.blank) {\n        // indented code\n        parser.advanceOffset(CODE_INDENT, true);\n        parser.closeUnmatchedBlocks();\n        parser.addChild(\'codeBlock\', parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar blockStarts = [\n    blockQuote,\n    atxHeading,\n    fencedCodeBlock,\n    htmlBlock,\n    seTextHeading,\n    thematicBreak,\n    listItem,\n    indentedCodeBlock,\n    tableHead,\n    tableBody,\n    customBlock,\n];\n\n// `---` for YAML, `+++` for TOML, `;;;` for JSON\nvar reFrontMatter = /^(-{3}|\\+{3}|;{3})$/;\nvar frontMatter$1 = function (parser, container) {\n    var currentLine = parser.currentLine, lineNumber = parser.lineNumber, indented = parser.indented;\n    if (lineNumber === 1 &&\n        !indented &&\n        container.type === \'document\' &&\n        reFrontMatter.test(currentLine)) {\n        parser.closeUnmatchedBlocks();\n        var frontMatter_1 = parser.addChild(\'frontMatter\', parser.nextNonspace);\n        frontMatter_1.stringContent = currentLine;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(currentLine.length, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\n\nvar frontMatter = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reFrontMatter);\n        if (container.type === \'frontMatter\' && match) {\n            container.stringContent += line;\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        block.literal = block.stringContent;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\n\nvar reHtmlBlockClose = [\n    /./,\n    /<\\/(?:script|pre|style)>/i,\n    /--\x3e/,\n    /\\?>/,\n    />/,\n    /\\]\\]>/,\n];\nvar reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/;\nvar reLineEnding$1 = /\\r\\n|\\n|\\r/;\nfunction document$2() {\n    return createNode$1(\'document\', [\n        [1, 1],\n        [0, 0],\n    ]);\n}\nvar defaultOptions$1 = {\n    smart: false,\n    tagFilter: false,\n    extendedAutolinks: false,\n    disallowedHtmlBlockTags: [],\n    referenceDefinition: false,\n    disallowDeepHeading: false,\n    customParser: null,\n    frontMatter: false,\n};\nvar Parser = /** @class */ (function () {\n    function Parser(options) {\n        this.options = __assign(__assign({}, defaultOptions$1), options);\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.oldtip = this.doc;\n        this.lineNumber = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.nextNonspace = 0;\n        this.nextNonspaceColumn = 0;\n        this.indent = 0;\n        this.currentLine = \'\';\n        this.indented = false;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.allClosed = true;\n        this.lastMatchedContainer = this.doc;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.lastLineLength = 0;\n        this.lines = [];\n        if (this.options.frontMatter) {\n            blockHandlers.frontMatter = frontMatter;\n            blockStarts.unshift(frontMatter$1);\n        }\n        this.inlineParser = new InlineParser(this.options);\n    }\n    Parser.prototype.advanceOffset = function (count, columns) {\n        if (columns === void 0) { columns = false; }\n        var currentLine = this.currentLine;\n        var charsToTab, charsToAdvance;\n        var c;\n        while (count > 0 && (c = currentLine[this.offset])) {\n            if (c === \'\\t\') {\n                charsToTab = 4 - (this.column % 4);\n                if (columns) {\n                    this.partiallyConsumedTab = charsToTab > count;\n                    charsToAdvance = charsToTab > count ? count : charsToTab;\n                    this.column += charsToAdvance;\n                    this.offset += this.partiallyConsumedTab ? 0 : 1;\n                    count -= charsToAdvance;\n                }\n                else {\n                    this.partiallyConsumedTab = false;\n                    this.column += charsToTab;\n                    this.offset += 1;\n                    count -= 1;\n                }\n            }\n            else {\n                this.partiallyConsumedTab = false;\n                this.offset += 1;\n                this.column += 1; // assume ascii; block starts are ascii\n                count -= 1;\n            }\n        }\n    };\n    Parser.prototype.advanceNextNonspace = function () {\n        this.offset = this.nextNonspace;\n        this.column = this.nextNonspaceColumn;\n        this.partiallyConsumedTab = false;\n    };\n    Parser.prototype.findNextNonspace = function () {\n        var currentLine = this.currentLine;\n        var i = this.offset;\n        var cols = this.column;\n        var c;\n        while ((c = currentLine.charAt(i)) !== \'\') {\n            if (c === \' \') {\n                i++;\n                cols++;\n            }\n            else if (c === \'\\t\') {\n                i++;\n                cols += 4 - (cols % 4);\n            }\n            else {\n                break;\n            }\n        }\n        this.blank = c === \'\\n\' || c === \'\\r\' || c === \'\';\n        this.nextNonspace = i;\n        this.nextNonspaceColumn = cols;\n        this.indent = this.nextNonspaceColumn - this.column;\n        this.indented = this.indent >= CODE_INDENT;\n    };\n    // Add a line to the block at the tip.  We assume the tip\n    // can accept lines -- that check should be done before calling this.\n    Parser.prototype.addLine = function () {\n        if (this.partiallyConsumedTab) {\n            this.offset += 1; // skip over tab\n            // add space characters:\n            var charsToTab = 4 - (this.column % 4);\n            this.tip.stringContent += repeat(\' \', charsToTab);\n        }\n        if (this.tip.lineOffsets) {\n            this.tip.lineOffsets.push(this.offset);\n        }\n        else {\n            this.tip.lineOffsets = [this.offset];\n        }\n        this.tip.stringContent += this.currentLine.slice(this.offset) + "\\n";\n    };\n    // Add block of type tag as a child of the tip.  If the tip can\'t\n    // accept children, close and finalize it and try its parent,\n    // and so on til we find a block that can accept children.\n    Parser.prototype.addChild = function (tag, offset) {\n        while (!blockHandlers[this.tip.type].canContain(tag)) {\n            this.finalize(this.tip, this.lineNumber - 1);\n        }\n        var columnNumber = offset + 1; // offset 0 = column 1\n        var newBlock = createNode$1(tag, [\n            [this.lineNumber, columnNumber],\n            [0, 0],\n        ]);\n        newBlock.stringContent = \'\';\n        this.tip.appendChild(newBlock);\n        this.tip = newBlock;\n        return newBlock;\n    };\n    // Finalize and close any unmatched blocks.\n    Parser.prototype.closeUnmatchedBlocks = function () {\n        if (!this.allClosed) {\n            // finalize any blocks not matched\n            while (this.oldtip !== this.lastMatchedContainer) {\n                var parent_1 = this.oldtip.parent;\n                this.finalize(this.oldtip, this.lineNumber - 1);\n                this.oldtip = parent_1;\n            }\n            this.allClosed = true;\n        }\n    };\n    // Finalize a block.  Close it and do any necessary postprocessing,\n    // e.g. creating stringContent from strings, setting the \'tight\'\n    // or \'loose\' status of a list, and parsing the beginnings\n    // of paragraphs for reference definitions.  Reset the tip to the\n    // parent of the closed block.\n    Parser.prototype.finalize = function (block, lineNumber) {\n        var above = block.parent;\n        block.open = false;\n        block.sourcepos[1] = [lineNumber, this.lastLineLength];\n        blockHandlers[block.type].finalize(this, block);\n        this.tip = above;\n    };\n    // Walk through a block & children recursively, parsing string content\n    // into inline content where appropriate.\n    Parser.prototype.processInlines = function (block) {\n        var event;\n        var customParser = this.options.customParser;\n        var walker = block.walker();\n        this.inlineParser.refMap = this.refMap;\n        this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap;\n        this.inlineParser.refDefCandidateMap = this.refDefCandidateMap;\n        this.inlineParser.options = this.options;\n        while ((event = walker.next())) {\n            var node = event.node, entering = event.entering;\n            var t = node.type;\n            if (customParser && customParser[t]) {\n                customParser[t](node, { entering: entering, options: this.options });\n            }\n            if (!entering &&\n                (t === \'paragraph\' ||\n                    t === \'heading\' ||\n                    (t === \'tableCell\' && !node.ignored))) {\n                this.inlineParser.parse(node);\n            }\n        }\n    };\n    // Analyze a line of text and update the document appropriately.\n    // We parse markdown text by calling this on each line of input,\n    // then finalizing the document.\n    Parser.prototype.incorporateLine = function (ln) {\n        var container = this.doc;\n        this.oldtip = this.tip;\n        this.offset = 0;\n        this.column = 0;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.lineNumber += 1;\n        // replace NUL characters for security\n        if (ln.indexOf(\'\\u0000\') !== -1) {\n            ln = ln.replace(/\\0/g, \'\\uFFFD\');\n        }\n        this.currentLine = ln;\n        // For each containing block, try to parse the associated line start.\n        // Bail out on failure: container will point to the last matching block.\n        // Set allMatched to false if not all containers match.\n        var allMatched = true;\n        var lastChild;\n        while ((lastChild = container.lastChild) && lastChild.open) {\n            container = lastChild;\n            this.findNextNonspace();\n            switch (blockHandlers[container.type][\'continue\'](this, container)) {\n                case 0 /* Go */: // we\'ve matched, keep going\n                    break;\n                case 1 /* Stop */: // we\'ve failed to match a block\n                    allMatched = false;\n                    break;\n                case 2 /* Finished */: // we\'ve hit end of line for fenced code close and can return\n                    this.lastLineLength = ln.length;\n                    return;\n                default:\n                    throw new Error(\'continue returned illegal value, must be 0, 1, or 2\');\n            }\n            if (!allMatched) {\n                container = container.parent; // back up to last matching block\n                break;\n            }\n        }\n        this.allClosed = container === this.oldtip;\n        this.lastMatchedContainer = container;\n        var matchedLeaf = container.type !== \'paragraph\' && blockHandlers[container.type].acceptsLines;\n        var blockStartsLen = blockStarts.length;\n        // Unless last matched container is a code block, try new container starts,\n        // adding children to the last matched container:\n        while (!matchedLeaf) {\n            this.findNextNonspace();\n            // this is a little performance optimization:\n            if (container.type !== \'table\' &&\n                container.type !== \'tableBody\' &&\n                container.type !== \'paragraph\' &&\n                !this.indented &&\n                !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {\n                this.advanceNextNonspace();\n                break;\n            }\n            var i = 0;\n            while (i < blockStartsLen) {\n                var res = blockStarts[i](this, container);\n                if (res === 1 /* Container */) {\n                    container = this.tip;\n                    break;\n                }\n                else if (res === 2 /* Leaf */) {\n                    container = this.tip;\n                    matchedLeaf = true;\n                    break;\n                }\n                else {\n                    i++;\n                }\n            }\n            if (i === blockStartsLen) {\n                // nothing matched\n                this.advanceNextNonspace();\n                break;\n            }\n        }\n        // What remains at the offset is a text line.  Add the text to the\n        // appropriate container.\n        // First check for a lazy paragraph continuation:\n        if (!this.allClosed && !this.blank && this.tip.type === \'paragraph\') {\n            // lazy paragraph continuation\n            this.addLine();\n        }\n        else {\n            // not a lazy continuation\n            // finalize any blocks not matched\n            this.closeUnmatchedBlocks();\n            if (this.blank && container.lastChild) {\n                container.lastChild.lastLineBlank = true;\n            }\n            var t = container.type;\n            // Block quote lines are never blank as they start with >\n            // and we don\'t count blanks in fenced code for purposes of tight/loose\n            // lists or breaking out of lists. We also don\'t set _lastLineBlank\n            // on an empty list item, or if we just closed a fenced block.\n            var lastLineBlank = this.blank &&\n                !(t === \'blockQuote\' ||\n                    (isCodeBlock(container) && container.isFenced) ||\n                    (t === \'item\' && !container.firstChild && container.sourcepos[0][0] === this.lineNumber));\n            // propagate lastLineBlank up through parents:\n            var cont = container;\n            while (cont) {\n                cont.lastLineBlank = lastLineBlank;\n                cont = cont.parent;\n            }\n            if (blockHandlers[t].acceptsLines) {\n                this.addLine();\n                // if HtmlBlock, check for end condition\n                if (isHtmlBlock(container) &&\n                    container.htmlBlockType >= 1 &&\n                    container.htmlBlockType <= 5 &&\n                    reHtmlBlockClose[container.htmlBlockType].test(this.currentLine.slice(this.offset))) {\n                    this.lastLineLength = ln.length;\n                    this.finalize(container, this.lineNumber);\n                }\n            }\n            else if (this.offset < ln.length && !this.blank) {\n                // create paragraph container for line\n                container = this.addChild(\'paragraph\', this.offset);\n                this.advanceNextNonspace();\n                this.addLine();\n            }\n        }\n        this.lastLineLength = ln.length;\n    };\n    // The main parsing function.  Returns a parsed document AST.\n    Parser.prototype.parse = function (input, lineTexts) {\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.lineNumber = 0;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = \'\';\n        var lines = input.split(reLineEnding$1);\n        var len = lines.length;\n        this.lines = lineTexts ? lineTexts : lines;\n        if (this.options.referenceDefinition) {\n            this.clearRefMaps();\n        }\n        if (input.charCodeAt(input.length - 1) === C_NEWLINE) {\n            // ignore last blank line created by final newline\n            len -= 1;\n        }\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        while (this.tip) {\n            this.finalize(this.tip, len);\n        }\n        this.processInlines(this.doc);\n        return this.doc;\n    };\n    Parser.prototype.partialParseStart = function (lineNumber, lines) {\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.lineNumber = lineNumber - 1;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = \'\';\n        var len = lines.length;\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        return this.doc;\n    };\n    Parser.prototype.partialParseExtends = function (lines) {\n        for (var i = 0; i < lines.length; i++) {\n            this.incorporateLine(lines[i]);\n        }\n    };\n    Parser.prototype.partialParseFinish = function () {\n        while (this.tip) {\n            this.finalize(this.tip, this.lineNumber);\n        }\n        this.processInlines(this.doc);\n    };\n    Parser.prototype.setRefMaps = function (refMap, refLinkCandidateMap, refDefCandidateMap) {\n        this.refMap = refMap;\n        this.refLinkCandidateMap = refLinkCandidateMap;\n        this.refDefCandidateMap = refDefCandidateMap;\n    };\n    Parser.prototype.clearRefMaps = function () {\n        [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (map) {\n            clearObj(map);\n        });\n    };\n    return Parser;\n}());\n\nfunction comparePos(p1, p2) {\n    if (p1[0] < p2[0]) {\n        return 1 /* LT */;\n    }\n    if (p1[0] > p2[0]) {\n        return -1 /* GT */;\n    }\n    if (p1[1] < p2[1]) {\n        return 1 /* LT */;\n    }\n    if (p1[1] > p2[1]) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction compareRangeAndPos(_a, pos) {\n    var startPos = _a[0], endPos = _a[1];\n    if (comparePos(endPos, pos) === 1 /* LT */) {\n        return 1 /* LT */;\n    }\n    if (comparePos(startPos, pos) === -1 /* GT */) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction removeNextUntil(node, last) {\n    if (node.parent !== last.parent || node === last) {\n        return;\n    }\n    var next = node.next;\n    while (next && next !== last) {\n        var temp = next.next;\n        for (var _i = 0, _a = [\'parent\', \'prev\', \'next\']; _i < _a.length; _i++) {\n            var type = _a[_i];\n            if (next[type]) {\n                removeNodeById(next[type].id);\n                next[type] = null;\n            }\n        }\n        next = temp;\n    }\n    node.next = last.next;\n    if (last.next) {\n        last.next.prev = node;\n    }\n    else {\n        node.parent.lastChild = node;\n    }\n}\nfunction getChildNodes(parent) {\n    var nodes = [];\n    var curr = parent.firstChild;\n    while (curr) {\n        nodes.push(curr);\n        curr = curr.next;\n    }\n    return nodes;\n}\nfunction insertNodesBefore(target, nodes) {\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var node = nodes_1[_i];\n        target.insertBefore(node);\n    }\n}\nfunction prependChildNodes(parent, nodes) {\n    for (var i = nodes.length - 1; i >= 0; i -= 1) {\n        parent.prependChild(nodes[i]);\n    }\n}\nfunction updateNextLineNumbers(base, diff) {\n    if (!base || !base.parent || diff === 0) {\n        return;\n    }\n    var walker = base.parent.walker();\n    walker.resumeAt(base, true);\n    var event;\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            node.sourcepos[0][0] += diff;\n            node.sourcepos[1][0] += diff;\n        }\n    }\n}\nfunction compareRangeAndLine(_a, line) {\n    var startPos = _a[0], endPos = _a[1];\n    if (endPos[0] < line) {\n        return 1 /* LT */;\n    }\n    if (startPos[0] > line) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction findChildNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            return node;\n        }\n        if (comp === -1 /* GT */) {\n            // To consider that top line is blank line\n            return node.prev || node;\n        }\n        node = node.next;\n    }\n    return parent.lastChild;\n}\nfunction lastLeafNode(node) {\n    while (node.lastChild) {\n        node = node.lastChild;\n    }\n    return node;\n}\nfunction sameLineTopAncestor(node) {\n    while (node.parent &&\n        node.parent.type !== \'document\' &&\n        node.parent.sourcepos[0][0] === node.sourcepos[0][0]) {\n        node = node.parent;\n    }\n    return node;\n}\nfunction findFirstNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            if (node.sourcepos[0][0] === line || !node.firstChild) {\n                return node;\n            }\n            prev = node;\n            node = node.firstChild;\n        }\n        else if (comp === -1 /* GT */) {\n            break;\n        }\n        else {\n            prev = node;\n            node = node.next;\n        }\n    }\n    if (prev) {\n        return sameLineTopAncestor(lastLeafNode(prev));\n    }\n    return null;\n}\nfunction findNodeAtPosition(parent, pos) {\n    var node = parent;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndPos(node.sourcepos, pos);\n        if (comp === 0 /* EQ */) {\n            if (node.firstChild) {\n                prev = node;\n                node = node.firstChild;\n            }\n            else {\n                return node;\n            }\n        }\n        else if (comp === -1 /* GT */) {\n            return prev;\n        }\n        else if (node.next) {\n            node = node.next;\n        }\n        else {\n            return prev;\n        }\n    }\n    return node;\n}\nfunction findNodeById(id) {\n    return getNodeById(id) || null;\n}\nfunction invokeNextUntil(callback, start, end) {\n    if (end === void 0) { end = null; }\n    if (start) {\n        var walker = start.walker();\n        while (start && start !== end) {\n            callback(start);\n            var next = walker.next();\n            if (next) {\n                start = next.node;\n            }\n            else {\n                break;\n            }\n        }\n    }\n}\nfunction isUnlinked(id) {\n    var node = findNodeById(id);\n    if (!node) {\n        return true;\n    }\n    while (node && node.type !== \'document\') {\n        // eslint-disable-next-line no-loop-func\n        if (!node.parent && !node.prev && !node.next) {\n            return true;\n        }\n        node = node.parent;\n    }\n    return false;\n}\n\nvar reLineEnding = /\\r\\n|\\n|\\r/;\nfunction canBeContinuedListItem(lineText) {\n    var spaceMatch = lineText.match(/^[ \\t]+/);\n    if (spaceMatch && (spaceMatch[0].length >= 2 || /\\t/.test(spaceMatch[0]))) {\n        return true;\n    }\n    var leftTrimmed = spaceMatch ? lineText.slice(spaceMatch.length) : lineText;\n    return reBulletListMarker.test(leftTrimmed) || reOrderedListMarker.test(leftTrimmed);\n}\nfunction canBeContinuedTableBody(lineText) {\n    return !isBlank(lineText) && lineText.indexOf(\'|\') !== -1;\n}\nfunction createRefDefState(node) {\n    var id = node.id, title = node.title, sourcepos = node.sourcepos, dest = node.dest;\n    return {\n        id: id,\n        title: title,\n        sourcepos: sourcepos,\n        unlinked: false,\n        destination: dest,\n    };\n}\nvar ToastMark = /** @class */ (function () {\n    function ToastMark(contents, options) {\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.referenceDefinition = !!(options === null || options === void 0 ? void 0 : options.referenceDefinition);\n        this.parser = new Parser(options);\n        this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap);\n        this.eventHandlerMap = { change: [] };\n        contents = contents || \'\';\n        this.lineTexts = contents.split(reLineEnding);\n        this.root = this.parser.parse(contents, this.lineTexts);\n    }\n    ToastMark.prototype.updateLineTexts = function (startPos, endPos, newText) {\n        var _a;\n        var startLine = startPos[0], startCol = startPos[1];\n        var endLine = endPos[0], endCol = endPos[1];\n        var newLines = newText.split(reLineEnding);\n        var newLineLen = newLines.length;\n        var startLineText = this.lineTexts[startLine - 1];\n        var endLineText = this.lineTexts[endLine - 1];\n        newLines[0] = startLineText.slice(0, startCol - 1) + newLines[0];\n        newLines[newLineLen - 1] = newLines[newLineLen - 1] + endLineText.slice(endCol - 1);\n        var removedLineLen = endLine - startLine + 1;\n        (_a = this.lineTexts).splice.apply(_a, __spreadArray([startLine - 1, removedLineLen], newLines));\n        return newLineLen - removedLineLen;\n    };\n    ToastMark.prototype.updateRootNodeState = function () {\n        if (this.lineTexts.length === 1 && this.lineTexts[0] === \'\') {\n            this.root.lastLineBlank = true;\n            this.root.sourcepos = [\n                [1, 1],\n                [1, 0],\n            ];\n            return;\n        }\n        if (this.root.lastChild) {\n            this.root.lastLineBlank = this.root.lastChild.lastLineBlank;\n        }\n        var lineTexts = this.lineTexts;\n        var idx = lineTexts.length - 1;\n        while (lineTexts[idx] === \'\') {\n            idx -= 1;\n        }\n        if (lineTexts.length - 2 > idx) {\n            idx += 1;\n        }\n        this.root.sourcepos[1] = [idx + 1, lineTexts[idx].length];\n    };\n    ToastMark.prototype.replaceRangeNodes = function (startNode, endNode, newNodes) {\n        if (!startNode) {\n            if (endNode) {\n                insertNodesBefore(endNode, newNodes);\n                removeNodeById(endNode.id);\n                endNode.unlink();\n            }\n            else {\n                prependChildNodes(this.root, newNodes);\n            }\n        }\n        else {\n            insertNodesBefore(startNode, newNodes);\n            removeNextUntil(startNode, endNode);\n            [startNode.id, endNode.id].forEach(function (id) { return removeNodeById(id); });\n            startNode.unlink();\n        }\n    };\n    ToastMark.prototype.getNodeRange = function (startPos, endPos) {\n        var startNode = findChildNodeAtLine(this.root, startPos[0]);\n        var endNode = findChildNodeAtLine(this.root, endPos[0]);\n        // extend node range to include a following block which doesn\'t have preceding blank line\n        if (endNode && endNode.next && endPos[0] + 1 === endNode.next.sourcepos[0][0]) {\n            endNode = endNode.next;\n        }\n        return [startNode, endNode];\n    };\n    ToastMark.prototype.trigger = function (eventName, param) {\n        this.eventHandlerMap[eventName].forEach(function (handler) {\n            handler(param);\n        });\n    };\n    ToastMark.prototype.extendEndLine = function (line) {\n        while (this.lineTexts[line] === \'\') {\n            line += 1;\n        }\n        return line;\n    };\n    ToastMark.prototype.parseRange = function (startNode, endNode, startLine, endLine) {\n        // extends starting range if the first node can be a continued list item\n        if (startNode &&\n            startNode.prev &&\n            ((isList(startNode.prev) && canBeContinuedListItem(this.lineTexts[startLine - 1])) ||\n                (isTable(startNode.prev) && canBeContinuedTableBody(this.lineTexts[startLine - 1])))) {\n            startNode = startNode.prev;\n            startLine = startNode.sourcepos[0][0];\n        }\n        var editedLines = this.lineTexts.slice(startLine - 1, endLine);\n        var root = this.parser.partialParseStart(startLine, editedLines);\n        // extends ending range if the following node can be a fenced code block or a continued list item\n        var nextNode = endNode ? endNode.next : this.root.firstChild;\n        var lastChild = root.lastChild;\n        var isOpenedLastChildCodeBlock = lastChild && isCodeBlock(lastChild) && lastChild.open;\n        var isOpenedLastChildCustomBlock = lastChild && isCustomBlock(lastChild) && lastChild.open;\n        var isLastChildList = lastChild && isList(lastChild);\n        while (((isOpenedLastChildCodeBlock || isOpenedLastChildCustomBlock) && nextNode) ||\n            (isLastChildList && nextNode && (nextNode.type === \'list\' || nextNode.sourcepos[0][1] >= 2))) {\n            var newEndLine = this.extendEndLine(nextNode.sourcepos[1][0]);\n            this.parser.partialParseExtends(this.lineTexts.slice(endLine, newEndLine));\n            if (!startNode) {\n                startNode = endNode;\n            }\n            endNode = nextNode;\n            endLine = newEndLine;\n            nextNode = nextNode.next;\n        }\n        this.parser.partialParseFinish();\n        var newNodes = getChildNodes(root);\n        return { newNodes: newNodes, extStartNode: startNode, extEndNode: endNode };\n    };\n    ToastMark.prototype.getRemovedNodeRange = function (extStartNode, extEndNode) {\n        if (!extStartNode ||\n            (extStartNode && isRefDef(extStartNode)) ||\n            (extEndNode && isRefDef(extEndNode))) {\n            return null;\n        }\n        return {\n            id: [extStartNode.id, extEndNode.id],\n            line: [extStartNode.sourcepos[0][0] - 1, extEndNode.sourcepos[1][0] - 1],\n        };\n    };\n    ToastMark.prototype.markDeletedRefMap = function (extStartNode, extEndNode) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var markDeleted = function (node) {\n                if (isRefDef(node)) {\n                    var refDefState = _this.refMap[node.label];\n                    if (refDefState && node.id === refDefState.id) {\n                        refDefState.unlinked = true;\n                    }\n                }\n            };\n            if (extStartNode) {\n                invokeNextUntil(markDeleted, extStartNode.parent, extEndNode);\n            }\n            if (extEndNode) {\n                invokeNextUntil(markDeleted, extEndNode);\n            }\n        }\n    };\n    ToastMark.prototype.replaceWithNewRefDefState = function (nodes) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var replaceWith_1 = function (node) {\n                if (isRefDef(node)) {\n                    var label = node.label;\n                    var refDefState = _this.refMap[label];\n                    if (!refDefState || refDefState.unlinked) {\n                        _this.refMap[label] = createRefDefState(node);\n                    }\n                }\n            };\n            nodes.forEach(function (node) {\n                invokeNextUntil(replaceWith_1, node);\n            });\n        }\n    };\n    ToastMark.prototype.replaceWithRefDefCandidate = function () {\n        var _this = this;\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            iterateObject(this.refDefCandidateMap, function (_, candidate) {\n                var label = candidate.label, sourcepos = candidate.sourcepos;\n                var refDefState = _this.refMap[label];\n                if (!refDefState ||\n                    refDefState.unlinked ||\n                    refDefState.sourcepos[0][0] > sourcepos[0][0]) {\n                    _this.refMap[label] = createRefDefState(candidate);\n                }\n            });\n        }\n    };\n    ToastMark.prototype.getRangeWithRefDef = function (startLine, endLine, startNode, endNode, lineDiff) {\n        if (this.referenceDefinition && !isEmptyObj(this.refMap)) {\n            var prevNode = findChildNodeAtLine(this.root, startLine - 1);\n            var nextNode = findChildNodeAtLine(this.root, endLine + 1);\n            if (prevNode && isRefDef(prevNode) && prevNode !== startNode && prevNode !== endNode) {\n                startNode = prevNode;\n                startLine = startNode.sourcepos[0][0];\n            }\n            if (nextNode && isRefDef(nextNode) && nextNode !== startNode && nextNode !== endNode) {\n                endNode = nextNode;\n                endLine = this.extendEndLine(endNode.sourcepos[1][0] + lineDiff);\n            }\n        }\n        return [startNode, endNode, startLine, endLine];\n    };\n    ToastMark.prototype.parse = function (startPos, endPos, lineDiff) {\n        if (lineDiff === void 0) { lineDiff = 0; }\n        var range = this.getNodeRange(startPos, endPos);\n        var startNode = range[0], endNode = range[1];\n        var startLine = startNode ? Math.min(startNode.sourcepos[0][0], startPos[0]) : startPos[0];\n        var endLine = this.extendEndLine((endNode ? Math.max(endNode.sourcepos[1][0], endPos[0]) : endPos[0]) + lineDiff);\n        var parseResult = this.parseRange.apply(this, this.getRangeWithRefDef(startLine, endLine, startNode, endNode, lineDiff));\n        var newNodes = parseResult.newNodes, extStartNode = parseResult.extStartNode, extEndNode = parseResult.extEndNode;\n        var removedNodeRange = this.getRemovedNodeRange(extStartNode, extEndNode);\n        var nextNode = extEndNode ? extEndNode.next : this.root.firstChild;\n        if (this.referenceDefinition) {\n            this.markDeletedRefMap(extStartNode, extEndNode);\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n            this.replaceWithNewRefDefState(newNodes);\n        }\n        else {\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n        }\n        return { nodes: newNodes, removedNodeRange: removedNodeRange, nextNode: nextNode };\n    };\n    ToastMark.prototype.parseRefLink = function () {\n        var _this = this;\n        var result = [];\n        if (!isEmptyObj(this.refMap)) {\n            iterateObject(this.refMap, function (label, value) {\n                if (value.unlinked) {\n                    delete _this.refMap[label];\n                }\n                iterateObject(_this.refLinkCandidateMap, function (_, candidate) {\n                    var node = candidate.node, refLabel = candidate.refLabel;\n                    if (refLabel === label) {\n                        result.push(_this.parse(node.sourcepos[0], node.sourcepos[1]));\n                    }\n                });\n            });\n        }\n        return result;\n    };\n    ToastMark.prototype.removeUnlinkedCandidate = function () {\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (candidateMap) {\n                iterateObject(candidateMap, function (id) {\n                    if (isUnlinked(id)) {\n                        delete candidateMap[id];\n                    }\n                });\n            });\n        }\n    };\n    ToastMark.prototype.editMarkdown = function (startPos, endPos, newText) {\n        var lineDiff = this.updateLineTexts(startPos, endPos, newText);\n        var parseResult = this.parse(startPos, endPos, lineDiff);\n        var editResult = omit(parseResult, \'nextNode\');\n        updateNextLineNumbers(parseResult.nextNode, lineDiff);\n        this.updateRootNodeState();\n        var result = [editResult];\n        if (this.referenceDefinition) {\n            this.removeUnlinkedCandidate();\n            this.replaceWithRefDefCandidate();\n            result = result.concat(this.parseRefLink());\n        }\n        this.trigger(\'change\', result);\n        return result;\n    };\n    ToastMark.prototype.getLineTexts = function () {\n        return this.lineTexts;\n    };\n    ToastMark.prototype.getRootNode = function () {\n        return this.root;\n    };\n    ToastMark.prototype.findNodeAtPosition = function (pos) {\n        var node = findNodeAtPosition(this.root, pos);\n        if (!node || node === this.root) {\n            return null;\n        }\n        return node;\n    };\n    ToastMark.prototype.findFirstNodeAtLine = function (line) {\n        return findFirstNodeAtLine(this.root, line);\n    };\n    ToastMark.prototype.on = function (eventName, callback) {\n        this.eventHandlerMap[eventName].push(callback);\n    };\n    ToastMark.prototype.off = function (eventName, callback) {\n        var handlers = this.eventHandlerMap[eventName];\n        var idx = handlers.indexOf(callback);\n        handlers.splice(idx, 1);\n    };\n    ToastMark.prototype.findNodeById = function (id) {\n        return findNodeById(id);\n    };\n    ToastMark.prototype.removeAllNode = function () {\n        removeAllNode();\n    };\n    return ToastMark;\n}());\n\nvar disallowedTags = [\n    \'title\',\n    \'textarea\',\n    \'style\',\n    \'xmp\',\n    \'iframe\',\n    \'noembed\',\n    \'noframes\',\n    \'script\',\n    \'plaintext\',\n];\nvar reDisallowedTag = new RegExp("<(/?(?:" + disallowedTags.join(\'|\') + ")[^>]*>)", \'ig\');\nfunction filterDisallowedTags(str) {\n    if (reDisallowedTag.test(str)) {\n        return str.replace(reDisallowedTag, function (_, group) { return "&lt;" + group; });\n    }\n    return str;\n}\n\nvar baseConvertors$1 = {\n    heading: function (node, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? \'openTag\' : \'closeTag\',\n            tagName: "h" + node.level,\n            outerNewLine: true,\n        };\n    },\n    text: function (node) {\n        return {\n            type: \'text\',\n            content: node.literal,\n        };\n    },\n    softbreak: function (_, _a) {\n        var options = _a.options;\n        return {\n            type: \'html\',\n            content: options.softbreak,\n        };\n    },\n    linebreak: function () {\n        return {\n            type: \'html\',\n            content: \'<br />\\n\',\n        };\n    },\n    emph: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? \'openTag\' : \'closeTag\',\n            tagName: \'em\',\n        };\n    },\n    strong: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? \'openTag\' : \'closeTag\',\n            tagName: \'strong\',\n        };\n    },\n    paragraph: function (node, _a) {\n        var _b;\n        var entering = _a.entering;\n        var grandparent = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent;\n        if (grandparent && grandparent.type === \'list\') {\n            if (grandparent.listData.tight) {\n                return null;\n            }\n        }\n        return {\n            type: entering ? \'openTag\' : \'closeTag\',\n            tagName: \'p\',\n            outerNewLine: true,\n        };\n    },\n    thematicBreak: function () {\n        return {\n            type: \'openTag\',\n            tagName: \'hr\',\n            outerNewLine: true,\n            selfClose: true,\n        };\n    },\n    blockQuote: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? \'openTag\' : \'closeTag\',\n            tagName: \'blockquote\',\n            outerNewLine: true,\n            innerNewLine: true,\n        };\n    },\n    list: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, type = _b.type, start = _b.start;\n        var tagName = type === \'bullet\' ? \'ul\' : \'ol\';\n        var attributes = {};\n        if (tagName === \'ol\' && start !== null && start !== 1) {\n            attributes.start = start.toString();\n        }\n        return {\n            type: entering ? \'openTag\' : \'closeTag\',\n            tagName: tagName,\n            attributes: attributes,\n            outerNewLine: true,\n        };\n    },\n    item: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? \'openTag\' : \'closeTag\',\n            tagName: \'li\',\n            outerNewLine: true,\n        };\n    },\n    htmlInline: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        return { type: \'html\', content: content };\n    },\n    htmlBlock: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        if (options.nodeId) {\n            return [\n                { type: \'openTag\', tagName: \'div\', outerNewLine: true },\n                { type: \'html\', content: content },\n                { type: \'closeTag\', tagName: \'div\', outerNewLine: true },\n            ];\n        }\n        return { type: \'html\', content: content, outerNewLine: true };\n    },\n    code: function (node) {\n        return [\n            { type: \'openTag\', tagName: \'code\' },\n            { type: \'text\', content: node.literal },\n            { type: \'closeTag\', tagName: \'code\' },\n        ];\n    },\n    codeBlock: function (node) {\n        var infoStr = node.info;\n        var infoWords = infoStr ? infoStr.split(/\\s+/) : [];\n        var codeClassNames = [];\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            codeClassNames.push("language-" + escapeXml(infoWords[0]));\n        }\n        return [\n            { type: \'openTag\', tagName: \'pre\', outerNewLine: true },\n            { type: \'openTag\', tagName: \'code\', classNames: codeClassNames },\n            { type: \'text\', content: node.literal },\n            { type: \'closeTag\', tagName: \'code\' },\n            { type: \'closeTag\', tagName: \'pre\', outerNewLine: true },\n        ];\n    },\n    link: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = node, title = _b.title, destination = _b.destination;\n            return {\n                type: \'openTag\',\n                tagName: \'a\',\n                attributes: __assign({ href: escapeXml(destination) }, (title && { title: escapeXml(title) })),\n            };\n        }\n        return { type: \'closeTag\', tagName: \'a\' };\n    },\n    image: function (node, _a) {\n        var getChildrenText = _a.getChildrenText, skipChildren = _a.skipChildren;\n        var _b = node, title = _b.title, destination = _b.destination;\n        skipChildren();\n        return {\n            type: \'openTag\',\n            tagName: \'img\',\n            selfClose: true,\n            attributes: __assign({ src: escapeXml(destination), alt: getChildrenText(node) }, (title && { title: escapeXml(title) })),\n        };\n    },\n    customBlock: function (node, context, convertors) {\n        var info = node.info.trim().toLowerCase();\n        var customConvertor = convertors[info];\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn("[@toast-ui/editor] - The error occurred when " + info + " block node was parsed in markdown renderer: " + e);\n            }\n        }\n        return [\n            { type: \'openTag\', tagName: \'div\', outerNewLine: true },\n            { type: \'text\', content: node.literal },\n            { type: \'closeTag\', tagName: \'div\', outerNewLine: true },\n        ];\n    },\n    frontMatter: function (node) {\n        return [\n            {\n                type: \'openTag\',\n                tagName: \'div\',\n                outerNewLine: true,\n                // Because front matter is metadata, it should not be render.\n                attributes: { style: \'white-space: pre; display: none;\' },\n            },\n            { type: \'text\', content: node.literal },\n            { type: \'closeTag\', tagName: \'div\', outerNewLine: true },\n        ];\n    },\n    customInline: function (node, context, convertors) {\n        var _a = node, info = _a.info, firstChild = _a.firstChild;\n        var nomalizedInfo = info.trim().toLowerCase();\n        var customConvertor = convertors[nomalizedInfo];\n        var entering = context.entering;\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn("[@toast-ui/editor] - The error occurred when " + nomalizedInfo + " inline node was parsed in markdown renderer: " + e);\n            }\n        }\n        return entering\n            ? [\n                { type: \'openTag\', tagName: \'span\' },\n                { type: \'text\', content: "$$" + info + (firstChild ? \' \' : \'\') },\n            ]\n            : [\n                { type: \'text\', content: \'$$\' },\n                { type: \'closeTag\', tagName: \'span\' },\n            ];\n    },\n};\n\nvar gfmConvertors = {\n    strike: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? \'openTag\' : \'closeTag\',\n            tagName: \'del\',\n        };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, checked = _b.checked, task = _b.task;\n        if (entering) {\n            var itemTag = {\n                type: \'openTag\',\n                tagName: \'li\',\n                outerNewLine: true,\n            };\n            if (task) {\n                return [\n                    itemTag,\n                    {\n                        type: \'openTag\',\n                        tagName: \'input\',\n                        selfClose: true,\n                        attributes: __assign(__assign({}, (checked && { checked: \'\' })), { disabled: \'\', type: \'checkbox\' }),\n                    },\n                    {\n                        type: \'text\',\n                        content: \' \',\n                    },\n                ];\n            }\n            return itemTag;\n        }\n        return {\n            type: \'closeTag\',\n            tagName: \'li\',\n            outerNewLine: true,\n        };\n    },\n    table: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? \'openTag\' : \'closeTag\',\n            tagName: \'table\',\n            outerNewLine: true,\n        };\n    },\n    tableHead: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? \'openTag\' : \'closeTag\',\n            tagName: \'thead\',\n            outerNewLine: true,\n        };\n    },\n    tableBody: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? \'openTag\' : \'closeTag\',\n            tagName: \'tbody\',\n            outerNewLine: true,\n        };\n    },\n    tableRow: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            return {\n                type: \'openTag\',\n                tagName: \'tr\',\n                outerNewLine: true,\n            };\n        }\n        var result = [];\n        if (node.lastChild) {\n            var columnLen = node.parent.parent.columns.length;\n            var lastColIdx = node.lastChild.endIdx;\n            for (var i = lastColIdx + 1; i < columnLen; i += 1) {\n                result.push({\n                    type: \'openTag\',\n                    tagName: \'td\',\n                    outerNewLine: true,\n                }, {\n                    type: \'closeTag\',\n                    tagName: \'td\',\n                    outerNewLine: true,\n                });\n            }\n        }\n        result.push({\n            type: \'closeTag\',\n            tagName: \'tr\',\n            outerNewLine: true,\n        });\n        return result;\n    },\n    tableCell: function (node, _a) {\n        var entering = _a.entering;\n        if (node.ignored) {\n            return {\n                type: \'text\',\n                content: \'\',\n            };\n        }\n        var tablePart = node.parent.parent;\n        var tagName = tablePart.type === \'tableHead\' ? \'th\' : \'td\';\n        var table = tablePart.parent;\n        var columnInfo = table.columns[node.startIdx];\n        var attributes = (columnInfo === null || columnInfo === void 0 ? void 0 : columnInfo.align) ? { align: columnInfo.align } : null;\n        if (entering) {\n            return __assign({ type: \'openTag\', tagName: tagName, outerNewLine: true }, (attributes && { attributes: attributes }));\n        }\n        return {\n            type: \'closeTag\',\n            tagName: tagName,\n            outerNewLine: true,\n        };\n    },\n};\n\nvar defaultOptions = {\n    softbreak: \'\\n\',\n    gfm: false,\n    tagFilter: false,\n    nodeId: false,\n};\nfunction getChildrenText(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var node_1 = event.node;\n        if (node_1.type === \'text\') {\n            buffer.push(node_1.literal);\n        }\n    }\n    return buffer.join(\'\');\n}\nvar Renderer = /** @class */ (function () {\n    function Renderer(customOptions) {\n        this.buffer = [];\n        this.options = __assign(__assign({}, defaultOptions), customOptions);\n        this.convertors = this.createConvertors();\n        delete this.options.convertors;\n    }\n    Renderer.prototype.createConvertors = function () {\n        var convertors = __assign({}, baseConvertors$1);\n        if (this.options.gfm) {\n            convertors = __assign(__assign({}, convertors), gfmConvertors);\n        }\n        if (this.options.convertors) {\n            var customConvertors_1 = this.options.convertors;\n            var nodeTypes = Object.keys(customConvertors_1);\n            var defaultConvertors_1 = __assign(__assign({}, baseConvertors$1), gfmConvertors);\n            nodeTypes.forEach(function (nodeType) {\n                var orgConvertor = convertors[nodeType];\n                var convertor = customConvertors_1[nodeType];\n                var convertorType = Object.keys(defaultConvertors_1).indexOf(nodeType) === -1\n                    ? nodeType.toLowerCase()\n                    : nodeType;\n                if (orgConvertor) {\n                    convertors[convertorType] = function (node, context, convertors) {\n                        context.origin = function () { return orgConvertor(node, context, convertors); };\n                        return convertor(node, context);\n                    };\n                }\n                else {\n                    convertors[convertorType] = convertor;\n                }\n            });\n        }\n        return convertors;\n    };\n    Renderer.prototype.getConvertors = function () {\n        return this.convertors;\n    };\n    Renderer.prototype.getOptions = function () {\n        return this.options;\n    };\n    Renderer.prototype.render = function (rootNode) {\n        var _this = this;\n        this.buffer = [];\n        var walker = rootNode.walker();\n        var event = null;\n        var _loop_1 = function () {\n            var node = event.node, entering = event.entering;\n            var convertor = this_1.convertors[node.type];\n            if (!convertor) {\n                return "continue";\n            }\n            var skipped = false;\n            var context = {\n                entering: entering,\n                leaf: !isContainer$1(node),\n                options: this_1.options,\n                getChildrenText: getChildrenText,\n                skipChildren: function () {\n                    skipped = true;\n                },\n            };\n            var converted = isCustomBlock(node) || isCustomInline(node)\n                ? convertor(node, context, this_1.convertors)\n                : convertor(node, context);\n            if (converted) {\n                var htmlNodes = Array.isArray(converted) ? converted : [converted];\n                htmlNodes.forEach(function (htmlNode, index) {\n                    if (htmlNode.type === \'openTag\' && _this.options.nodeId && index === 0) {\n                        if (!htmlNode.attributes) {\n                            htmlNode.attributes = {};\n                        }\n                        htmlNode.attributes[\'data-nodeid\'] = String(node.id);\n                    }\n                    _this.renderHTMLNode(htmlNode);\n                });\n                if (skipped) {\n                    walker.resumeAt(node, false);\n                    walker.next();\n                }\n            }\n        };\n        var this_1 = this;\n        while ((event = walker.next())) {\n            _loop_1();\n        }\n        this.addNewLine();\n        return this.buffer.join(\'\');\n    };\n    Renderer.prototype.renderHTMLNode = function (node) {\n        switch (node.type) {\n            case \'openTag\':\n            case \'closeTag\':\n                this.renderElementNode(node);\n                break;\n            case \'text\':\n                this.renderTextNode(node);\n                break;\n            case \'html\':\n                this.renderRawHtmlNode(node);\n                break;\n            // no-default-case\n        }\n    };\n    Renderer.prototype.generateOpenTagString = function (node) {\n        var _this = this;\n        var tagName = node.tagName, classNames = node.classNames, attributes = node.attributes;\n        this.buffer.push("<" + tagName);\n        if (classNames && classNames.length > 0) {\n            this.buffer.push(" class=\\"" + classNames.join(\' \') + "\\"");\n        }\n        if (attributes) {\n            Object.keys(attributes).forEach(function (attrName) {\n                var attrValue = attributes[attrName];\n                _this.buffer.push(" " + attrName + "=\\"" + attrValue + "\\"");\n            });\n        }\n        if (node.selfClose) {\n            this.buffer.push(\' /\');\n        }\n        this.buffer.push(\'>\');\n    };\n    Renderer.prototype.generateCloseTagString = function (_a) {\n        var tagName = _a.tagName;\n        this.buffer.push("</" + tagName + ">");\n    };\n    Renderer.prototype.addNewLine = function () {\n        if (this.buffer.length && last(last(this.buffer)) !== \'\\n\') {\n            this.buffer.push(\'\\n\');\n        }\n    };\n    Renderer.prototype.addOuterNewLine = function (node) {\n        if (node.outerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.addInnerNewLine = function (node) {\n        if (node.innerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.renderTextNode = function (node) {\n        this.buffer.push(escapeXml(node.content));\n    };\n    Renderer.prototype.renderRawHtmlNode = function (node) {\n        this.addOuterNewLine(node);\n        this.buffer.push(node.content);\n        this.addOuterNewLine(node);\n    };\n    Renderer.prototype.renderElementNode = function (node) {\n        if (node.type === \'openTag\') {\n            this.addOuterNewLine(node);\n            this.generateOpenTagString(node);\n            if (node.selfClose) {\n                this.addOuterNewLine(node);\n            }\n            else {\n                this.addInnerNewLine(node);\n            }\n        }\n        else {\n            this.addInnerNewLine(node);\n            this.generateCloseTagString(node);\n            this.addOuterNewLine(node);\n        }\n    };\n    return Renderer;\n}());\n\n/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar hasOwnProperty = Object.hasOwnProperty,\n    setPrototypeOf = Object.setPrototypeOf,\n    isFrozen = Object.isFrozen,\n    getPrototypeOf = Object.getPrototypeOf,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar freeze = Object.freeze,\n    seal = Object.seal,\n    create = Object.create; // eslint-disable-line import/no-mutable-exports\n\nvar _ref = typeof Reflect !== \'undefined\' && Reflect,\n    apply = _ref.apply,\n    construct = _ref.construct;\n\nif (!apply) {\n  apply = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\nif (!freeze) {\n  freeze = function freeze(x) {\n    return x;\n  };\n}\n\nif (!seal) {\n  seal = function seal(x) {\n    return x;\n  };\n}\n\nif (!construct) {\n  construct = function construct(Func, args) {\n    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n  };\n}\n\nvar arrayForEach = unapply(Array.prototype.forEach);\nvar arrayPop = unapply(Array.prototype.pop);\nvar arrayPush = unapply(Array.prototype.push);\n\nvar stringToLowerCase = unapply(String.prototype.toLowerCase);\nvar stringMatch = unapply(String.prototype.match);\nvar stringReplace = unapply(String.prototype.replace);\nvar stringIndexOf = unapply(String.prototype.indexOf);\nvar stringTrim = unapply(String.prototype.trim);\n\nvar regExpTest = unapply(RegExp.prototype.test);\n\nvar typeErrorCreate = unconstruct(TypeError);\n\nfunction unapply(func) {\n  return function (thisArg) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return apply(func, thisArg, args);\n  };\n}\n\nfunction unconstruct(func) {\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return construct(func, args);\n  };\n}\n\n/* Add properties to a lookup table */\nfunction addToSet(set, array) {\n  if (setPrototypeOf) {\n    // Make \'in\' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  var l = array.length;\n  while (l--) {\n    var element = array[l];\n    if (typeof element === \'string\') {\n      var lcElement = stringToLowerCase(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          array[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/* Shallow clone an object */\nfunction clone(object) {\n  var newObject = create(null);\n\n  var property = void 0;\n  for (property in object) {\n    if (apply(hasOwnProperty, object, [property])) {\n      newObject[property] = object[property];\n    }\n  }\n\n  return newObject;\n}\n\n/* IE10 doesn\'t support __lookupGetter__ so lets\'\n * simulate it. It also automatically checks\n * if the prop is function or getter and behaves\n * accordingly. */\nfunction lookupGetter(object, prop) {\n  while (object !== null) {\n    var desc = getOwnPropertyDescriptor(object, prop);\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n\n      if (typeof desc.value === \'function\') {\n        return unapply(desc.value);\n      }\n    }\n\n    object = getPrototypeOf(object);\n  }\n\n  function fallbackValue(element) {\n    console.warn(\'fallback value for\', element);\n    return null;\n  }\n\n  return fallbackValue;\n}\n\nvar html$2 = freeze([\'a\', \'abbr\', \'acronym\', \'address\', \'area\', \'article\', \'aside\', \'audio\', \'b\', \'bdi\', \'bdo\', \'big\', \'blink\', \'blockquote\', \'body\', \'br\', \'button\', \'canvas\', \'caption\', \'center\', \'cite\', \'code\', \'col\', \'colgroup\', \'content\', \'data\', \'datalist\', \'dd\', \'decorator\', \'del\', \'details\', \'dfn\', \'dialog\', \'dir\', \'div\', \'dl\', \'dt\', \'element\', \'em\', \'fieldset\', \'figcaption\', \'figure\', \'font\', \'footer\', \'form\', \'h1\', \'h2\', \'h3\', \'h4\', \'h5\', \'h6\', \'head\', \'header\', \'hgroup\', \'hr\', \'html\', \'i\', \'img\', \'input\', \'ins\', \'kbd\', \'label\', \'legend\', \'li\', \'main\', \'map\', \'mark\', \'marquee\', \'menu\', \'menuitem\', \'meter\', \'nav\', \'nobr\', \'ol\', \'optgroup\', \'option\', \'output\', \'p\', \'picture\', \'pre\', \'progress\', \'q\', \'rp\', \'rt\', \'ruby\', \'s\', \'samp\', \'section\', \'select\', \'shadow\', \'small\', \'source\', \'spacer\', \'span\', \'strike\', \'strong\', \'style\', \'sub\', \'summary\', \'sup\', \'table\', \'tbody\', \'td\', \'template\', \'textarea\', \'tfoot\', \'th\', \'thead\', \'time\', \'tr\', \'track\', \'tt\', \'u\', \'ul\', \'var\', \'video\', \'wbr\']);\n\n// SVG\nvar svg = freeze([\'svg\', \'a\', \'altglyph\', \'altglyphdef\', \'altglyphitem\', \'animatecolor\', \'animatemotion\', \'animatetransform\', \'circle\', \'clippath\', \'defs\', \'desc\', \'ellipse\', \'filter\', \'font\', \'g\', \'glyph\', \'glyphref\', \'hkern\', \'image\', \'line\', \'lineargradient\', \'marker\', \'mask\', \'metadata\', \'mpath\', \'path\', \'pattern\', \'polygon\', \'polyline\', \'radialgradient\', \'rect\', \'stop\', \'style\', \'switch\', \'symbol\', \'text\', \'textpath\', \'title\', \'tref\', \'tspan\', \'view\', \'vkern\']);\n\nvar svgFilters = freeze([\'feBlend\', \'feColorMatrix\', \'feComponentTransfer\', \'feComposite\', \'feConvolveMatrix\', \'feDiffuseLighting\', \'feDisplacementMap\', \'feDistantLight\', \'feFlood\', \'feFuncA\', \'feFuncB\', \'feFuncG\', \'feFuncR\', \'feGaussianBlur\', \'feMerge\', \'feMergeNode\', \'feMorphology\', \'feOffset\', \'fePointLight\', \'feSpecularLighting\', \'feSpotLight\', \'feTile\', \'feTurbulence\']);\n\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nvar svgDisallowed = freeze([\'animate\', \'color-profile\', \'cursor\', \'discard\', \'fedropshadow\', \'feimage\', \'font-face\', \'font-face-format\', \'font-face-name\', \'font-face-src\', \'font-face-uri\', \'foreignobject\', \'hatch\', \'hatchpath\', \'mesh\', \'meshgradient\', \'meshpatch\', \'meshrow\', \'missing-glyph\', \'script\', \'set\', \'solidcolor\', \'unknown\', \'use\']);\n\nvar mathMl = freeze([\'math\', \'menclose\', \'merror\', \'mfenced\', \'mfrac\', \'mglyph\', \'mi\', \'mlabeledtr\', \'mmultiscripts\', \'mn\', \'mo\', \'mover\', \'mpadded\', \'mphantom\', \'mroot\', \'mrow\', \'ms\', \'mspace\', \'msqrt\', \'mstyle\', \'msub\', \'msup\', \'msubsup\', \'mtable\', \'mtd\', \'mtext\', \'mtr\', \'munder\', \'munderover\']);\n\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nvar mathMlDisallowed = freeze([\'maction\', \'maligngroup\', \'malignmark\', \'mlongdiv\', \'mscarries\', \'mscarry\', \'msgroup\', \'mstack\', \'msline\', \'msrow\', \'semantics\', \'annotation\', \'annotation-xml\', \'mprescripts\', \'none\']);\n\nvar text = freeze([\'#text\']);\n\nvar html$1$1 = freeze([\'accept\', \'action\', \'align\', \'alt\', \'autocapitalize\', \'autocomplete\', \'autopictureinpicture\', \'autoplay\', \'background\', \'bgcolor\', \'border\', \'capture\', \'cellpadding\', \'cellspacing\', \'checked\', \'cite\', \'class\', \'clear\', \'color\', \'cols\', \'colspan\', \'controls\', \'controlslist\', \'coords\', \'crossorigin\', \'datetime\', \'decoding\', \'default\', \'dir\', \'disabled\', \'disablepictureinpicture\', \'disableremoteplayback\', \'download\', \'draggable\', \'enctype\', \'enterkeyhint\', \'face\', \'for\', \'headers\', \'height\', \'hidden\', \'high\', \'href\', \'hreflang\', \'id\', \'inputmode\', \'integrity\', \'ismap\', \'kind\', \'label\', \'lang\', \'list\', \'loading\', \'loop\', \'low\', \'max\', \'maxlength\', \'media\', \'method\', \'min\', \'minlength\', \'multiple\', \'muted\', \'name\', \'noshade\', \'novalidate\', \'nowrap\', \'open\', \'optimum\', \'pattern\', \'placeholder\', \'playsinline\', \'poster\', \'preload\', \'pubdate\', \'radiogroup\', \'readonly\', \'rel\', \'required\', \'rev\', \'reversed\', \'role\', \'rows\', \'rowspan\', \'spellcheck\', \'scope\', \'selected\', \'shape\', \'size\', \'sizes\', \'span\', \'srclang\', \'start\', \'src\', \'srcset\', \'step\', \'style\', \'summary\', \'tabindex\', \'title\', \'translate\', \'type\', \'usemap\', \'valign\', \'value\', \'width\', \'xmlns\', \'slot\']);\n\nvar svg$1 = freeze([\'accent-height\', \'accumulate\', \'additive\', \'alignment-baseline\', \'ascent\', \'attributename\', \'attributetype\', \'azimuth\', \'basefrequency\', \'baseline-shift\', \'begin\', \'bias\', \'by\', \'class\', \'clip\', \'clippathunits\', \'clip-path\', \'clip-rule\', \'color\', \'color-interpolation\', \'color-interpolation-filters\', \'color-profile\', \'color-rendering\', \'cx\', \'cy\', \'d\', \'dx\', \'dy\', \'diffuseconstant\', \'direction\', \'display\', \'divisor\', \'dur\', \'edgemode\', \'elevation\', \'end\', \'fill\', \'fill-opacity\', \'fill-rule\', \'filter\', \'filterunits\', \'flood-color\', \'flood-opacity\', \'font-family\', \'font-size\', \'font-size-adjust\', \'font-stretch\', \'font-style\', \'font-variant\', \'font-weight\', \'fx\', \'fy\', \'g1\', \'g2\', \'glyph-name\', \'glyphref\', \'gradientunits\', \'gradienttransform\', \'height\', \'href\', \'id\', \'image-rendering\', \'in\', \'in2\', \'k\', \'k1\', \'k2\', \'k3\', \'k4\', \'kerning\', \'keypoints\', \'keysplines\', \'keytimes\', \'lang\', \'lengthadjust\', \'letter-spacing\', \'kernelmatrix\', \'kernelunitlength\', \'lighting-color\', \'local\', \'marker-end\', \'marker-mid\', \'marker-start\', \'markerheight\', \'markerunits\', \'markerwidth\', \'maskcontentunits\', \'maskunits\', \'max\', \'mask\', \'media\', \'method\', \'mode\', \'min\', \'name\', \'numoctaves\', \'offset\', \'operator\', \'opacity\', \'order\', \'orient\', \'orientation\', \'origin\', \'overflow\', \'paint-order\', \'path\', \'pathlength\', \'patterncontentunits\', \'patterntransform\', \'patternunits\', \'points\', \'preservealpha\', \'preserveaspectratio\', \'primitiveunits\', \'r\', \'rx\', \'ry\', \'radius\', \'refx\', \'refy\', \'repeatcount\', \'repeatdur\', \'restart\', \'result\', \'rotate\', \'scale\', \'seed\', \'shape-rendering\', \'specularconstant\', \'specularexponent\', \'spreadmethod\', \'startoffset\', \'stddeviation\', \'stitchtiles\', \'stop-color\', \'stop-opacity\', \'stroke-dasharray\', \'stroke-dashoffset\', \'stroke-linecap\', \'stroke-linejoin\', \'stroke-miterlimit\', \'stroke-opacity\', \'stroke\', \'stroke-width\', \'style\', \'surfacescale\', \'systemlanguage\', \'tabindex\', \'targetx\', \'targety\', \'transform\', \'text-anchor\', \'text-decoration\', \'text-rendering\', \'textlength\', \'type\', \'u1\', \'u2\', \'unicode\', \'values\', \'viewbox\', \'visibility\', \'version\', \'vert-adv-y\', \'vert-origin-x\', \'vert-origin-y\', \'width\', \'word-spacing\', \'wrap\', \'writing-mode\', \'xchannelselector\', \'ychannelselector\', \'x\', \'x1\', \'x2\', \'xmlns\', \'y\', \'y1\', \'y2\', \'z\', \'zoomandpan\']);\n\nvar mathMl$1 = freeze([\'accent\', \'accentunder\', \'align\', \'bevelled\', \'close\', \'columnsalign\', \'columnlines\', \'columnspan\', \'denomalign\', \'depth\', \'dir\', \'display\', \'displaystyle\', \'encoding\', \'fence\', \'frame\', \'height\', \'href\', \'id\', \'largeop\', \'length\', \'linethickness\', \'lspace\', \'lquote\', \'mathbackground\', \'mathcolor\', \'mathsize\', \'mathvariant\', \'maxsize\', \'minsize\', \'movablelimits\', \'notation\', \'numalign\', \'open\', \'rowalign\', \'rowlines\', \'rowspacing\', \'rowspan\', \'rspace\', \'rquote\', \'scriptlevel\', \'scriptminsize\', \'scriptsizemultiplier\', \'selection\', \'separator\', \'separators\', \'stretchy\', \'subscriptshift\', \'supscriptshift\', \'symmetric\', \'voffset\', \'width\', \'xmlns\']);\n\nvar xml = freeze([\'xlink:href\', \'xml:id\', \'xlink:title\', \'xml:space\', \'xmlns:xlink\']);\n\n// eslint-disable-next-line unicorn/better-regex\nvar MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nvar ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\nvar DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nvar ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nvar IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nvar IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nvar ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nfunction _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar getGlobal = function getGlobal() {\n  return typeof window === \'undefined\' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don\'t export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {Document} document The document object (to determine policy name suffix)\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported).\n */\nvar _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n  if ((typeof trustedTypes === \'undefined\' ? \'undefined\' : _typeof(trustedTypes)) !== \'object\' || typeof trustedTypes.createPolicy !== \'function\') {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  var suffix = null;\n  var ATTR_NAME = \'data-tt-policy-suffix\';\n  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n    suffix = document.currentScript.getAttribute(ATTR_NAME);\n  }\n\n  var policyName = \'dompurify\' + (suffix ? \'#\' + suffix : \'\');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML: function createHTML(html$$1) {\n        return html$$1;\n      }\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn(\'TrustedTypes policy \' + policyName + \' could not be created.\');\n    return null;\n  }\n};\n\nfunction createDOMPurify() {\n  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n  var DOMPurify = function DOMPurify(root) {\n    return createDOMPurify(root);\n  };\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  DOMPurify.version = \'2.3.3\';\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  DOMPurify.removed = [];\n\n  if (!window || !window.document || window.document.nodeType !== 9) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  var originalDocument = window.document;\n\n  var document = window.document;\n  var DocumentFragment = window.DocumentFragment,\n      HTMLTemplateElement = window.HTMLTemplateElement,\n      Node = window.Node,\n      Element = window.Element,\n      NodeFilter = window.NodeFilter,\n      _window$NamedNodeMap = window.NamedNodeMap,\n      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n      Text = window.Text,\n      Comment = window.Comment,\n      DOMParser = window.DOMParser,\n      trustedTypes = window.trustedTypes;\n\n\n  var ElementPrototype = Element.prototype;\n\n  var cloneNode = lookupGetter(ElementPrototype, \'cloneNode\');\n  var getNextSibling = lookupGetter(ElementPrototype, \'nextSibling\');\n  var getChildNodes = lookupGetter(ElementPrototype, \'childNodes\');\n  var getParentNode = lookupGetter(ElementPrototype, \'parentNode\');\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === \'function\') {\n    var template = document.createElement(\'template\');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(\'\') : \'\';\n\n  var _document = document,\n      implementation = _document.implementation,\n      createNodeIterator = _document.createNodeIterator,\n      createDocumentFragment = _document.createDocumentFragment,\n      getElementsByTagName = _document.getElementsByTagName;\n  var importNode = originalDocument.importNode;\n\n\n  var documentMode = {};\n  try {\n    documentMode = clone(document).documentMode ? document.documentMode : {};\n  } catch (_) {}\n\n  var hooks = {};\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported = typeof getParentNode === \'function\' && implementation && typeof implementation.createHTMLDocument !== \'undefined\' && documentMode !== 9;\n\n  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n      ERB_EXPR$$1 = ERB_EXPR,\n      DATA_ATTR$$1 = DATA_ATTR,\n      ARIA_ATTR$$1 = ARIA_ATTR,\n      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don\'t add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n\n  var ALLOWED_TAGS = null;\n  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html$2), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n  /* Allowed attribute names */\n  var ALLOWED_ATTR = null;\n  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  var FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  var FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  var ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  var ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  var SAFE_FOR_TEMPLATES = false;\n\n  /* Decide if document with <html>... should be returned */\n  var WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  var SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  var FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  var RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  var RETURN_DOM_FRAGMENT = false;\n\n  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n   * `Node` is imported into the current `Document`. If this flag is not enabled the\n   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n   * DOMPurify.\n   *\n   * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n   * might cause XSS from attacks hidden in closed shadowroots in case the browser\n   * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n   */\n  var RETURN_DOM_IMPORT = true;\n\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  var RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks? */\n  var SANITIZE_DOM = true;\n\n  /* Keep element content when removing element? */\n  var KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  var IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  var USE_PROFILES = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  var FORBID_CONTENTS = null;\n  var DEFAULT_FORBID_CONTENTS = addToSet({}, [\'annotation-xml\', \'audio\', \'colgroup\', \'desc\', \'foreignobject\', \'head\', \'iframe\', \'math\', \'mi\', \'mn\', \'mo\', \'ms\', \'mtext\', \'noembed\', \'noframes\', \'noscript\', \'plaintext\', \'script\', \'style\', \'svg\', \'template\', \'thead\', \'title\', \'video\', \'xmp\']);\n\n  /* Tags that are safe for data: URIs */\n  var DATA_URI_TAGS = null;\n  var DEFAULT_DATA_URI_TAGS = addToSet({}, [\'audio\', \'video\', \'img\', \'source\', \'image\', \'track\']);\n\n  /* Attributes safe for values like "javascript:" */\n  var URI_SAFE_ATTRIBUTES = null;\n  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\'alt\', \'class\', \'for\', \'id\', \'label\', \'name\', \'pattern\', \'placeholder\', \'role\', \'summary\', \'title\', \'value\', \'style\', \'xmlns\']);\n\n  var MATHML_NAMESPACE = \'http://www.w3.org/1998/Math/MathML\';\n  var SVG_NAMESPACE = \'http://www.w3.org/2000/svg\';\n  var HTML_NAMESPACE = \'http://www.w3.org/1999/xhtml\';\n  /* Document namespace */\n  var NAMESPACE = HTML_NAMESPACE;\n  var IS_EMPTY_INPUT = false;\n\n  /* Parsing of strict XHTML documents */\n  var PARSER_MEDIA_TYPE = void 0;\n  var SUPPORTED_PARSER_MEDIA_TYPES = [\'application/xhtml+xml\', \'text/html\'];\n  var DEFAULT_PARSER_MEDIA_TYPE = \'text/html\';\n  var transformCaseFunc = void 0;\n\n  /* Keep a reference to config to pass to hooks */\n  var CONFIG = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  var formElement = document.createElement(\'form\');\n\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  var _parseConfig = function _parseConfig(cfg) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || (typeof cfg === \'undefined\' ? \'undefined\' : _typeof(cfg)) !== \'object\') {\n      cfg = {};\n    }\n\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = \'ALLOWED_TAGS\' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = \'ALLOWED_ATTR\' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n    URI_SAFE_ATTRIBUTES = \'ADD_URI_SAFE_ATTR\' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = \'ADD_DATA_URI_TAGS\' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS = \'FORBID_CONTENTS\' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS = \'FORBID_TAGS\' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n    FORBID_ATTR = \'FORBID_ATTR\' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n    USE_PROFILES = \'USE_PROFILES\' in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n\n    PARSER_MEDIA_TYPE =\n    // eslint-disable-next-line unicorn/prefer-includes\n    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n\n    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n    transformCaseFunc = PARSER_MEDIA_TYPE === \'application/xhtml+xml\' ? function (x) {\n      return x;\n    } : stringToLowerCase;\n\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html$2);\n        addToSet(ALLOWED_ATTR, html$1$1);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl);\n        addToSet(ALLOWED_ATTR, mathMl$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n    }\n\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS[\'#text\'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, [\'html\', \'head\', \'body\']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, [\'tbody\']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\'mi\', \'mo\', \'mn\', \'ms\', \'mtext\']);\n\n  var HTML_INTEGRATION_POINTS = addToSet({}, [\'foreignobject\', \'desc\', \'title\', \'annotation-xml\']);\n\n  /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */\n  var ALL_SVG_TAGS = addToSet({}, svg);\n  addToSet(ALL_SVG_TAGS, svgFilters);\n  addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n  var ALL_MATHML_TAGS = addToSet({}, mathMl);\n  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n  /**\n   *\n   *\n   * @param  {Element} element a DOM element whose namespace is being checked\n   * @returns {boolean} Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */\n  var _checkValidNamespace = function _checkValidNamespace(element) {\n    var parent = getParentNode(element);\n\n    // In JSDOM, if we\'re inside shadow DOM, then parentNode\n    // can be null. We just simulate parent in this case.\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: HTML_NAMESPACE,\n        tagName: \'template\'\n      };\n    }\n\n    var tagName = stringToLowerCase(element.tagName);\n    var parentTagName = stringToLowerCase(parent.tagName);\n\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      // The only way to switch from HTML namespace to SVG\n      // is via <svg>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === \'svg\';\n      }\n\n      // The only way to switch from MathML to SVG is via\n      // svg if parent is either <annotation-xml> or MathML\n      // text integration points.\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return tagName === \'svg\' && (parentTagName === \'annotation-xml\' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n      }\n\n      // We only allow elements that are defined in SVG\n      // spec. All others are disallowed in SVG namespace.\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      // The only way to switch from HTML namespace to MathML\n      // is via <math>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === \'math\';\n      }\n\n      // The only way to switch from SVG to MathML is via\n      // <math> and HTML integration points\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === \'math\' && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n\n      // We only allow elements that are defined in MathML\n      // spec. All others are disallowed in MathML namespace.\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      // The only way to switch from SVG to HTML is via\n      // HTML integration points, and from MathML to HTML\n      // is via MathML text integration points\n      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n\n      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n\n      // Certain elements are allowed in both SVG and HTML\n      // namespace. We need to specify them explicitly\n      // so that they don\'t get erronously deleted from\n      // HTML namespace.\n      var commonSvgAndHTMLElements = addToSet({}, [\'title\', \'style\', \'font\', \'a\', \'script\']);\n\n      // We disallow tags that are specific for MathML\n      // or SVG and should never appear in HTML namespace\n      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n    }\n\n    // The code should never reach this place (this means\n    // that the element somehow got namespace that is not\n    // HTML, SVG or MathML). Return false just in case.\n    return false;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n  var _forceRemove = function _forceRemove(node) {\n    arrayPush(DOMPurify.removed, { element: node });\n    try {\n      // eslint-disable-next-line unicorn/prefer-dom-node-remove\n      node.parentNode.removeChild(node);\n    } catch (_) {\n      try {\n        node.outerHTML = emptyHTML;\n      } catch (_) {\n        node.remove();\n      }\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n  var _removeAttribute = function _removeAttribute(name, node) {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: node.getAttributeNode(name),\n        from: node\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: node\n      });\n    }\n\n    node.removeAttribute(name);\n\n    // We void attribute values for unremovable "is"" attributes\n    if (name === \'is\' && !ALLOWED_ATTR[name]) {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(node);\n        } catch (_) {}\n      } else {\n        try {\n          node.setAttribute(name, \'\');\n        } catch (_) {}\n      }\n    }\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n  var _initDocument = function _initDocument(dirty) {\n    /* Create a HTML document */\n    var doc = void 0;\n    var leadingWhitespace = void 0;\n\n    if (FORCE_BODY) {\n      dirty = \'<remove></remove>\' + dirty;\n    } else {\n      /* If FORCE_BODY isn\'t used, leading whitespace needs to be preserved manually */\n      var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n\n    if (PARSER_MEDIA_TYPE === \'application/xhtml+xml\') {\n      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n      dirty = \'<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>\' + dirty + \'</body></html>\';\n    }\n\n    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n      } catch (_) {}\n    }\n\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, \'template\', null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? \'\' : dirtyPayload;\n      } catch (_) {\n        // Syntax error if dirtyPayload is invalid xml\n      }\n    }\n\n    var body = doc.body || doc.documentElement;\n\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n    }\n\n    /* Work on whole document or just its body */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? \'html\' : \'body\')[0];\n    }\n\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n\n  /**\n   * _createIterator\n   *\n   * @param  {Document} root document/fragment to create iterator for\n   * @return {Iterator} iterator instance\n   */\n  var _createIterator = function _createIterator(root) {\n    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n  var _isClobbered = function _isClobbered(elm) {\n    if (elm instanceof Text || elm instanceof Comment) {\n      return false;\n    }\n\n    if (typeof elm.nodeName !== \'string\' || typeof elm.textContent !== \'string\' || typeof elm.removeChild !== \'function\' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== \'function\' || typeof elm.setAttribute !== \'function\' || typeof elm.namespaceURI !== \'string\' || typeof elm.insertBefore !== \'function\') {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * _isNode\n   *\n   * @param  {Node} obj object to check whether it\'s a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n  var _isNode = function _isNode(object) {\n    return (typeof Node === \'undefined\' ? \'undefined\' : _typeof(Node)) === \'object\' ? object instanceof Node : object && (typeof object === \'undefined\' ? \'undefined\' : _typeof(object)) === \'object\' && typeof object.nodeType === \'number\' && typeof object.nodeName === \'string\';\n  };\n\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook\'s entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n  var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n\n    arrayForEach(hooks[entryPoint], function (hook) {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  var _sanitizeElements = function _sanitizeElements(currentNode) {\n    var content = void 0;\n\n    /* Execute a hook if present */\n    _executeHook(\'beforeSanitizeElements\', currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check if tagname contains Unicode */\n    if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let\'s check the element\'s type and name */\n    var tagName = transformCaseFunc(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHook(\'uponSanitizeElement\', currentNode, {\n      tagName: tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Mitigate a problem with templates inside select */\n    if (tagName === \'select\' && regExpTest(/<template/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n        if (childNodes && parentNode) {\n          var childCount = childNodes.length;\n\n          for (var i = childCount - 1; i >= 0; --i) {\n            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n          }\n        }\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check whether element has a valid namespace */\n    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    if ((tagName === \'noscript\' || tagName === \'noembed\') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      /* Get the element\'s text content */\n      content = currentNode.textContent;\n      content = stringReplace(content, MUSTACHE_EXPR$$1, \' \');\n      content = stringReplace(content, ERB_EXPR$$1, \' \');\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHook(\'afterSanitizeElements\', currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (SANITIZE_DOM && (lcName === \'id\' || lcName === \'name\') && (value in document || value in formElement)) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after "-"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don\'t need to check the value; it\'s always URI safe. */\n    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      return false;\n\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, \'\'))) ; else if ((lcName === \'src\' || lcName === \'xlink:href\' || lcName === \'href\') && lcTag !== \'script\' && stringIndexOf(value, \'data:\') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, \'\'))) ; else if (!value) ; else {\n      return false;\n    }\n\n    return true;\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n    var attr = void 0;\n    var value = void 0;\n    var lcName = void 0;\n    var l = void 0;\n    /* Execute a hook if present */\n    _executeHook(\'beforeSanitizeAttributes\', currentNode, null);\n\n    var attributes = currentNode.attributes;\n\n    /* Check if we have attributes; if not we might have a text node */\n\n    if (!attributes) {\n      return;\n    }\n\n    var hookEvent = {\n      attrName: \'\',\n      attrValue: \'\',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR\n    };\n    l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      attr = attributes[l];\n      var _attr = attr,\n          name = _attr.name,\n          namespaceURI = _attr.namespaceURI;\n\n      value = stringTrim(attr.value);\n      lcName = transformCaseFunc(name);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHook(\'uponSanitizeAttribute\', currentNode, hookEvent);\n      value = hookEvent.attrValue;\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Remove attribute */\n      _removeAttribute(name, currentNode);\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        value = stringReplace(value, MUSTACHE_EXPR$$1, \' \');\n        value = stringReplace(value, ERB_EXPR$$1, \' \');\n      }\n\n      /* Is `value` valid for this attribute? */\n      var lcTag = transformCaseFunc(currentNode.nodeName);\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */\n          currentNode.setAttribute(name, value);\n        }\n\n        arrayPop(DOMPurify.removed);\n      } catch (_) {}\n    }\n\n    /* Execute a hook if present */\n    _executeHook(\'afterSanitizeAttributes\', currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n    var shadowNode = void 0;\n    var shadowIterator = _createIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHook(\'beforeSanitizeShadowDOM\', fragment, null);\n\n    while (shadowNode = shadowIterator.nextNode()) {\n      /* Execute a hook if present */\n      _executeHook(\'uponSanitizeShadowNode\', shadowNode, null);\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(shadowNode);\n    }\n\n    /* Execute a hook if present */\n    _executeHook(\'afterSanitizeShadowDOM\', fragment, null);\n  };\n\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} configuration object\n   */\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg) {\n    var body = void 0;\n    var importedNode = void 0;\n    var currentNode = void 0;\n    var oldNode = void 0;\n    var returnNode = void 0;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = \'\x3c!--\x3e\';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== \'string\' && !_isNode(dirty)) {\n      // eslint-disable-next-line no-negated-condition\n      if (typeof dirty.toString !== \'function\') {\n        throw typeErrorCreate(\'toString is not a function\');\n      } else {\n        dirty = dirty.toString();\n        if (typeof dirty !== \'string\') {\n          throw typeErrorCreate(\'dirty is not a string, aborting\');\n        }\n      }\n    }\n\n    /* Check we can run. Otherwise fall back or ignore */\n    if (!DOMPurify.isSupported) {\n      if (_typeof(window.toStaticHTML) === \'object\' || typeof window.toStaticHTML === \'function\') {\n        if (typeof dirty === \'string\') {\n          return window.toStaticHTML(dirty);\n        }\n\n        if (_isNode(dirty)) {\n          return window.toStaticHTML(dirty.outerHTML);\n        }\n      }\n\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === \'string\') {\n      IN_PLACE = false;\n    }\n\n    if (IN_PLACE) ; else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument(\'\x3c!----\x3e\');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === 1 && importedNode.nodeName === \'BODY\') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === \'HTML\') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n      // eslint-disable-next-line unicorn/prefer-includes\n      dirty.indexOf(\'<\') === -1) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : emptyHTML;\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while (currentNode = nodeIterator.nextNode()) {\n      /* Fix IE\'s strange behavior with manipulated textNodes #89 */\n      if (currentNode.nodeType === 3 && currentNode === oldNode) {\n        continue;\n      }\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(currentNode);\n\n      oldNode = currentNode;\n    }\n\n    oldNode = null;\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (RETURN_DOM_IMPORT) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, \' \');\n      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, \' \');\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n  DOMPurify.setConfig = function (cfg) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {string} tag Tag name of containing element.\n   * @param  {string} attr Attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    var lcTag = transformCaseFunc(tag);\n    var lcName = transformCaseFunc(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== \'function\') {\n      return;\n    }\n\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   */\n  DOMPurify.removeHook = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      arrayPop(hooks[entryPoint]);\n    }\n  };\n\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n  DOMPurify.removeHooks = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   *\n   */\n  DOMPurify.removeAllHooks = function () {\n    hooks = {};\n  };\n\n  return DOMPurify;\n}\n\nvar purify = createDOMPurify();\n\nvar CAN_BE_WHITE_TAG_LIST = [\'iframe\', \'embed\'];\nvar whiteTagList = [];\nfunction registerTagWhitelistIfPossible(tagName) {\n    if (includes(CAN_BE_WHITE_TAG_LIST, tagName)) {\n        whiteTagList.push(tagName.toLowerCase());\n    }\n}\nfunction sanitizeHTML(html, options) {\n    return purify.sanitize(html, __assign$1({ ADD_TAGS: whiteTagList, ADD_ATTR: [\'rel\', \'target\', \'hreflang\', \'type\'], FORBID_TAGS: [\n            \'input\',\n            \'script\',\n            \'textarea\',\n            \'form\',\n            \'button\',\n            \'select\',\n            \'meta\',\n            \'style\',\n            \'link\',\n            \'title\',\n            \'object\',\n            \'base\',\n        ] }, options));\n}\n\nfunction getChildrenHTML(node, typeName) {\n    return node\n        .literal.replace(new RegExp("(<\\\\s*" + typeName + "[^>]*>)|(</" + typeName + "\\\\s*[>])", \'ig\'), \'\')\n        .trim();\n}\nfunction getHTMLAttrsByHTMLString(html) {\n    html = html.match(reHTMLTag)[0];\n    var attrs = html.match(new RegExp(ATTRIBUTE$1, \'g\'));\n    return attrs\n        ? attrs.reduce(function (acc, attr) {\n            var _a = attr.trim().split(\'=\'), name = _a[0], values = _a.slice(1);\n            if (values.length) {\n                acc[name] = values.join(\'=\').replace(/\'|"/g, \'\').trim();\n            }\n            return acc;\n        }, {})\n        : {};\n}\nfunction getHTMLAttrs(dom) {\n    return toArray_1(dom.attributes).reduce(function (acc, attr) {\n        acc[attr.nodeName] = attr.nodeValue;\n        return acc;\n    }, {});\n}\nfunction sanitizeDOM(node, typeName, sanitizer, wwToDOMAdaptor) {\n    var dom = wwToDOMAdaptor.getToDOMNode(typeName)(node);\n    var html = sanitizer(dom.outerHTML);\n    var container = document.createElement(\'div\');\n    container.innerHTML = html;\n    dom = container.firstChild;\n    var htmlAttrs = getHTMLAttrs(dom);\n    return { dom: dom, htmlAttrs: htmlAttrs };\n}\nvar schemaFactory = {\n    htmlBlock: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            atom: true,\n            content: \'block+\',\n            group: \'block\',\n            attrs: {\n                htmlAttrs: { default: {} },\n                childrenHTML: { default: \'\' },\n                htmlBlock: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                            childrenHTML: dom.innerHTML,\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var _a = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor), dom = _a.dom, htmlAttrs = _a.htmlAttrs;\n                htmlAttrs.class = htmlAttrs.class ? htmlAttrs.class + " html-block" : \'html-block\';\n                return __spreadArray$1([typeName, htmlAttrs], toArray_1(dom.childNodes));\n            },\n        };\n    },\n    htmlInline: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            attrs: {\n                htmlAttrs: { default: {} },\n                htmlInline: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var htmlAttrs = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor).htmlAttrs;\n                return [typeName, htmlAttrs, 0];\n            },\n        };\n    },\n};\nfunction createHTMLSchemaMap(convertorMap, sanitizeHTML, wwToDOMAdaptor) {\n    var htmlSchemaMap = { nodes: {}, marks: {} };\n    [\'htmlBlock\', \'htmlInline\'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            Object.keys(convertorMap[htmlType]).forEach(function (type) {\n                var targetType = htmlType === \'htmlBlock\' ? \'nodes\' : \'marks\';\n                // register tag white list for preventing to remove the html in sanitizer\n                registerTagWhitelistIfPossible(type);\n                htmlSchemaMap[targetType][type] = schemaFactory[htmlType](type, sanitizeHTML, wwToDOMAdaptor);\n            });\n        }\n    });\n    return htmlSchemaMap;\n}\n\nvar reCloseTag = /^\\s*<\\s*\\//;\nvar baseConvertors = {\n    paragraph: function (_, _a) {\n        var entering = _a.entering, origin = _a.origin, options = _a.options;\n        if (options.nodeId) {\n            return {\n                type: entering ? \'openTag\' : \'closeTag\',\n                outerNewLine: true,\n                tagName: \'p\',\n            };\n        }\n        return origin();\n    },\n    softbreak: function (node) {\n        var isPrevNodeHTML = node.prev && node.prev.type === \'htmlInline\';\n        var isPrevBR = isPrevNodeHTML && /<br ?\\/?>/.test(node.prev.literal);\n        var content = isPrevBR ? \'\\n\' : \'<br>\\n\';\n        return { type: \'html\', content: content };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var attributes = {};\n            var classNames = [];\n            if (node.listData.task) {\n                attributes[\'data-task\'] = \'\';\n                classNames.push(\'task-list-item\');\n                if (node.listData.checked) {\n                    classNames.push(\'checked\');\n                    attributes[\'data-task-checked\'] = \'\';\n                }\n            }\n            return {\n                type: \'openTag\',\n                tagName: \'li\',\n                classNames: classNames,\n                attributes: attributes,\n                outerNewLine: true,\n            };\n        }\n        return {\n            type: \'closeTag\',\n            tagName: \'li\',\n            outerNewLine: true,\n        };\n    },\n    code: function (node) {\n        var attributes = { \'data-backticks\': String(node.tickCount) };\n        return [\n            { type: \'openTag\', tagName: \'code\', attributes: attributes },\n            { type: \'text\', content: node.literal },\n            { type: \'closeTag\', tagName: \'code\' },\n        ];\n    },\n    codeBlock: function (node) {\n        var _a = node, fenceLength = _a.fenceLength, info = _a.info;\n        var infoWords = info ? info.split(/\\s+/) : [];\n        var preClasses = [];\n        var codeAttrs = {};\n        if (fenceLength > 3) {\n            codeAttrs[\'data-backticks\'] = fenceLength;\n        }\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            var lang = infoWords[0];\n            preClasses.push("lang-" + lang);\n            codeAttrs[\'data-language\'] = lang;\n        }\n        return [\n            { type: \'openTag\', tagName: \'pre\', classNames: preClasses },\n            { type: \'openTag\', tagName: \'code\', attributes: codeAttrs },\n            { type: \'text\', content: node.literal },\n            { type: \'closeTag\', tagName: \'code\' },\n            { type: \'closeTag\', tagName: \'pre\' },\n        ];\n    },\n    customInline: function (node, _a) {\n        var origin = _a.origin, entering = _a.entering, skipChildren = _a.skipChildren;\n        var info = node.info;\n        if (info.indexOf(\'widget\') !== -1 && entering) {\n            skipChildren();\n            var content = getWidgetContent(node);\n            var htmlInline = widgetToDOM(info, content).outerHTML;\n            return [\n                { type: \'openTag\', tagName: \'span\', classNames: [\'tui-widget\'] },\n                { type: \'html\', content: htmlInline },\n                { type: \'closeTag\', tagName: \'span\' },\n            ];\n        }\n        return origin();\n    },\n};\nfunction getHTMLRenderConvertors(linkAttributes, customConvertors) {\n    var convertors = __assign$1({}, baseConvertors);\n    if (linkAttributes) {\n        convertors.link = function (_, _a) {\n            var entering = _a.entering, origin = _a.origin;\n            var result = origin();\n            if (entering) {\n                result.attributes = __assign$1(__assign$1({}, result.attributes), linkAttributes);\n            }\n            return result;\n        };\n    }\n    if (customConvertors) {\n        Object.keys(customConvertors).forEach(function (nodeType) {\n            var orgConvertor = convertors[nodeType];\n            var customConvertor = customConvertors[nodeType];\n            if (orgConvertor && isFunction_1(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var newContext = __assign$1({}, context);\n                    newContext.origin = function () { return orgConvertor(node, context); };\n                    return customConvertor(node, newContext);\n                };\n            }\n            else if (includes([\'htmlBlock\', \'htmlInline\'], nodeType) && !isFunction_1(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var matched = node.literal.match(reHTMLTag);\n                    if (matched) {\n                        var rootHTML = matched[0], openTagName = matched[1], closeTagName = matched[3];\n                        var typeName = (openTagName || closeTagName).toLowerCase();\n                        var htmlConvertor = customConvertor[typeName];\n                        var childrenHTML = getChildrenHTML(node, typeName);\n                        if (htmlConvertor) {\n                            // copy for preventing to overwrite the originial property\n                            var newNode = __assign$1({}, node);\n                            newNode.attrs = getHTMLAttrsByHTMLString(rootHTML);\n                            newNode.childrenHTML = childrenHTML;\n                            newNode.type = typeName;\n                            context.entering = !reCloseTag.test(node.literal);\n                            return htmlConvertor(newNode, context);\n                        }\n                    }\n                    return context.origin();\n                };\n            }\n            else {\n                convertors[nodeType] = customConvertor;\n            }\n        });\n    }\n    return convertors;\n}\n\nvar nestableTypes = [\'list\', \'item\', \'blockQuote\'];\nvar nestableTagNames = [\'UL\', \'OL\', \'BLOCKQUOTE\'];\nfunction isBlankLine(doc, index) {\n    var _a;\n    var pmNode = doc.child(index);\n    return !pmNode.childCount || (pmNode.childCount === 1 && !((_a = pmNode.firstChild.text) === null || _a === void 0 ? void 0 : _a.trim()));\n}\nfunction getEditorRangeHeightInfo(doc, mdNode, children) {\n    var start = getMdStartLine(mdNode) - 1;\n    var end = getMdEndLine(mdNode) - 1;\n    var rect = children[start].getBoundingClientRect();\n    var height = children[end].offsetTop -\n        children[start].offsetTop +\n        children[end].clientHeight;\n    return {\n        height: height <= 0\n            ? children[start].clientHeight\n            : height + getBlankLinesHeight(doc, children, Math.min(end + 1, doc.childCount - 1)),\n        rect: rect,\n    };\n}\nfunction getBlankLinesHeight(doc, children, start) {\n    var end = doc.childCount - 1;\n    var height = 0;\n    while (start <= end && isBlankLine(doc, start)) {\n        height += children[start].clientHeight;\n        start += 1;\n    }\n    return height;\n}\nfunction findAncestorHavingId(el, root) {\n    while (!el.getAttribute(\'data-nodeid\') && el.parentElement !== root) {\n        el = el.parentElement;\n    }\n    return el;\n}\nfunction getTotalOffsetTop(el, root) {\n    var offsetTop = 0;\n    while (el && el !== root) {\n        if (!includes(nestableTagNames, el.tagName)) {\n            offsetTop += el.offsetTop;\n        }\n        if (el.offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.parentElement;\n    }\n    return offsetTop;\n}\nfunction findAdjacentElementToScrollTop(scrollTop, root) {\n    var el = root;\n    var prev = null;\n    while (el) {\n        var firstElementChild = el.firstElementChild;\n        if (!firstElementChild) {\n            break;\n        }\n        var lastSibling = findLastSiblingElementToScrollTop(firstElementChild, scrollTop, getTotalOffsetTop(el, root));\n        prev = el;\n        el = lastSibling;\n    }\n    var adjacentEl = el || prev;\n    return adjacentEl === root ? null : adjacentEl;\n}\nfunction findLastSiblingElementToScrollTop(el, scrollTop, offsetTop) {\n    if (el && scrollTop > offsetTop + el.offsetTop) {\n        return (findLastSiblingElementToScrollTop(el.nextElementSibling, scrollTop, offsetTop) || el);\n    }\n    return null;\n}\nfunction getAdditionalPos(scrollTop, offsetTop, height, targetNodeHeight) {\n    var ratio = Math.min((scrollTop - offsetTop) / height, 1);\n    return ratio * targetNodeHeight;\n}\nfunction getParentNodeObj(previewContent, mdNode) {\n    var el = previewContent.querySelector("[data-nodeid=\\"" + mdNode.id + "\\"]");\n    while (!el || isStyledInlineNode(mdNode)) {\n        mdNode = mdNode.parent;\n        el = previewContent.querySelector("[data-nodeid=\\"" + mdNode.id + "\\"]");\n    }\n    return getNonNestableNodeObj({ mdNode: mdNode, el: el });\n}\nfunction getNonNestableNodeObj(_a) {\n    var mdNode = _a.mdNode, el = _a.el;\n    while ((includes(nestableTypes, mdNode.type) || mdNode.type === \'table\') && mdNode.firstChild) {\n        mdNode = mdNode.firstChild;\n        el = el.firstElementChild;\n    }\n    return { mdNode: mdNode, el: el };\n}\n\nvar offsetInfoMap = {};\nfunction setHeight(id, height) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].height = height;\n}\nfunction setOffsetTop(id, offsetTop) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].offsetTop = offsetTop;\n}\nfunction getHeight(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].height;\n}\nfunction getOffsetTop(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].offsetTop;\n}\nfunction removeOffsetInfoByNode(node) {\n    if (node) {\n        delete offsetInfoMap[Number(node.getAttribute(\'data-nodeid\'))];\n        toArray_1(node.children).forEach(function (child) {\n            removeOffsetInfoByNode(child);\n        });\n    }\n}\nfunction getAndSaveOffsetInfo(node, root, mdNodeId) {\n    var cachedHeight = getHeight(mdNodeId);\n    var cachedTop = getOffsetTop(mdNodeId);\n    var nodeHeight = cachedHeight || node.clientHeight;\n    var offsetTop = cachedTop || getTotalOffsetTop(node, root) || node.offsetTop;\n    if (!cachedHeight) {\n        setHeight(mdNodeId, nodeHeight);\n    }\n    if (!cachedTop) {\n        setOffsetTop(mdNodeId, offsetTop);\n    }\n    return { nodeHeight: nodeHeight, offsetTop: offsetTop };\n}\n\nvar CLASS_HIGHLIGHT = cls(\'md-preview-highlight\');\nfunction findTableCell(tableRow, chOffset) {\n    var cell = tableRow.firstChild;\n    while (cell && cell.next) {\n        if (getMdStartCh(cell.next) > chOffset + 1) {\n            break;\n        }\n        cell = cell.next;\n    }\n    return cell;\n}\n/**\n * Class Markdown Preview\n * @param {HTMLElement} el - base element\n * @param {eventEmitter} eventEmitter - event manager\n * @param {object} options\n * @param {boolean} options.isViewer - true for view-only mode\n * @param {boolean} options.highlight - true for using live-highlight feature\n * @param {object} opitons.linkAttributes - attributes for link element\n * @param {object} opitons.customHTMLRenderer - map of custom HTML render functions\n *\n * @ignore\n */\nvar MarkdownPreview = /** @class */ (function () {\n    function MarkdownPreview(eventEmitter, options) {\n        var el = document.createElement(\'div\');\n        this.el = el;\n        this.eventEmitter = eventEmitter;\n        this.isViewer = !!options.isViewer;\n        this.el.className = cls(\'md-preview\');\n        var linkAttributes = options.linkAttributes, customHTMLRenderer = options.customHTMLRenderer, sanitizer = options.sanitizer, _a = options.highlight, highlight = _a === void 0 ? false : _a;\n        this.renderer = new Renderer({\n            gfm: true,\n            nodeId: true,\n            convertors: getHTMLRenderConvertors(linkAttributes, customHTMLRenderer),\n        });\n        this.cursorNodeId = null;\n        this.sanitizer = sanitizer;\n        this.initEvent(highlight);\n        this.initContentSection();\n        // To prevent overflowing contents in the viewer\n        if (this.isViewer) {\n            this.previewContent.style.overflowWrap = \'break-word\';\n        }\n    }\n    MarkdownPreview.prototype.initContentSection = function () {\n        this.previewContent = createElementWith("<div class=\\"" + cls(\'contents\') + "\\"></div>");\n        if (!this.isViewer) {\n            this.el.appendChild(this.previewContent);\n        }\n    };\n    MarkdownPreview.prototype.toggleActive = function (active) {\n        toggleClass(this.el, \'active\', active);\n    };\n    MarkdownPreview.prototype.initEvent = function (highlight) {\n        var _this = this;\n        this.eventEmitter.listen(\'updatePreview\', this.update.bind(this));\n        if (this.isViewer) {\n            return;\n        }\n        if (highlight) {\n            this.eventEmitter.listen(\'changeToolbarState\', function (_a) {\n                var mdNode = _a.mdNode, cursorPos = _a.cursorPos;\n                _this.updateCursorNode(mdNode, cursorPos);\n            });\n            this.eventEmitter.listen(\'blur\', function () {\n                _this.removeHighlight();\n            });\n        }\n        on_1(this.el, \'scroll\', function (event) {\n            _this.eventEmitter.emit(\'scroll\', \'preview\', findAdjacentElementToScrollTop(event.target.scrollTop, _this.previewContent));\n        });\n        this.eventEmitter.listen(\'changePreviewTabPreview\', function () { return _this.toggleActive(true); });\n        this.eventEmitter.listen(\'changePreviewTabWrite\', function () { return _this.toggleActive(false); });\n    };\n    MarkdownPreview.prototype.removeHighlight = function () {\n        if (this.cursorNodeId) {\n            var currentEl = this.getElementByNodeId(this.cursorNodeId);\n            if (currentEl) {\n                removeClass_1(currentEl, CLASS_HIGHLIGHT);\n            }\n        }\n    };\n    MarkdownPreview.prototype.updateCursorNode = function (cursorNode, cursorPos) {\n        if (cursorNode) {\n            cursorNode = findClosestNode(cursorNode, function (mdNode) { return !isInlineNode$1(mdNode); });\n            if (cursorNode.type === \'tableRow\') {\n                cursorNode = findTableCell(cursorNode, cursorPos[1]);\n            }\n            else if (cursorNode.type === \'tableBody\') {\n                // empty line next to table\n                cursorNode = null;\n            }\n        }\n        var cursorNodeId = cursorNode ? cursorNode.id : null;\n        if (this.cursorNodeId === cursorNodeId) {\n            return;\n        }\n        var oldEL = this.getElementByNodeId(this.cursorNodeId);\n        var newEL = this.getElementByNodeId(cursorNodeId);\n        if (oldEL) {\n            removeClass_1(oldEL, CLASS_HIGHLIGHT);\n        }\n        if (newEL) {\n            addClass_1(newEL, CLASS_HIGHLIGHT);\n        }\n        this.cursorNodeId = cursorNodeId;\n    };\n    MarkdownPreview.prototype.getElementByNodeId = function (nodeId) {\n        return nodeId\n            ? this.previewContent.querySelector("[data-nodeid=\\"" + nodeId + "\\"]")\n            : null;\n    };\n    MarkdownPreview.prototype.update = function (changed) {\n        var _this = this;\n        changed.forEach(function (editResult) { return _this.replaceRangeNodes(editResult); });\n        this.eventEmitter.emit(\'afterPreviewRender\', this);\n    };\n    MarkdownPreview.prototype.replaceRangeNodes = function (editResult) {\n        var _this = this;\n        var nodes = editResult.nodes, removedNodeRange = editResult.removedNodeRange;\n        var contentEl = this.previewContent;\n        var newHtml = this.eventEmitter.emitReduce(\'beforePreviewRender\', this.sanitizer(nodes.map(function (node) { return _this.renderer.render(node); }).join(\'\')));\n        if (!removedNodeRange) {\n            contentEl.insertAdjacentHTML(\'afterbegin\', newHtml);\n        }\n        else {\n            var _a = removedNodeRange.id, startNodeId = _a[0], endNodeId = _a[1];\n            var startEl = this.getElementByNodeId(startNodeId);\n            var endEl = this.getElementByNodeId(endNodeId);\n            if (startEl) {\n                startEl.insertAdjacentHTML(\'beforebegin\', newHtml);\n                var el = startEl;\n                while (el && el !== endEl) {\n                    var nextEl = el.nextElementSibling;\n                    removeNode$1(el);\n                    removeOffsetInfoByNode(el);\n                    el = nextEl;\n                }\n                if (el === null || el === void 0 ? void 0 : el.parentNode) {\n                    removeNode$1(el);\n                    removeOffsetInfoByNode(el);\n                }\n            }\n        }\n    };\n    MarkdownPreview.prototype.getRenderer = function () {\n        return this.renderer;\n    };\n    MarkdownPreview.prototype.destroy = function () {\n        off_1(this.el, \'scroll\');\n        this.el = null;\n    };\n    MarkdownPreview.prototype.getElement = function () {\n        return this.el;\n    };\n    MarkdownPreview.prototype.getHTML = function () {\n        return removeProseMirrorHackNodes(this.previewContent.innerHTML);\n    };\n    MarkdownPreview.prototype.setHTML = function (html) {\n        this.previewContent.innerHTML = html;\n    };\n    MarkdownPreview.prototype.setHeight = function (height) {\n        css_1(this.el, { height: height + "px" });\n    };\n    MarkdownPreview.prototype.setMinHeight = function (minHeight) {\n        css_1(this.el, { minHeight: minHeight + "px" });\n    };\n    return MarkdownPreview;\n}());\n\nfunction findNodeBy(pos, condition) {\n    var depth = pos.depth;\n    while (depth) {\n        var node = pos.node(depth);\n        if (condition(node, depth)) {\n            return {\n                node: node,\n                depth: depth,\n                offset: depth > 0 ? pos.before(depth) : 0,\n            };\n        }\n        depth -= 1;\n    }\n    return null;\n}\nfunction isInListNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === \'listItem\' || type.name === \'bulletList\' || type.name === \'orderedList\';\n    });\n}\nfunction isInTableNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === \'tableHeadCell\' || type.name === \'tableBodyCell\';\n    });\n}\nfunction findListItem(pos) {\n    return findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === \'listItem\';\n    });\n}\nfunction createDOMInfoParsedRawHTML(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            var rawHTML = dom.getAttribute(\'data-raw-html\');\n            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n        },\n    };\n}\nfunction createCellAttrs(attrs) {\n    return Object.keys(attrs).reduce(function (acc, attrName) {\n        if (attrName !== \'rawHTML\' && attrs[attrName]) {\n            attrName = attrName === \'className\' ? \'class\' : attrName;\n            acc[attrName] = attrs[attrName];\n        }\n        return acc;\n    }, {});\n}\nfunction createParsedCellDOM(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            return [\'rawHTML\', \'colspan\', \'rowspan\', \'extended\'].reduce(function (acc, attrName) {\n                var attrNameInDOM = attrName === \'rawHTML\' ? \'data-raw-html\' : attrName;\n                var attrValue = dom.getAttribute(attrNameInDOM);\n                if (attrValue) {\n                    acc[attrName] = includes([\'rawHTML\', \'extended\'], attrName)\n                        ? attrValue\n                        : Number(attrValue);\n                }\n                return acc;\n            }, {});\n        },\n    };\n}\nfunction getDefaultCustomAttrs() {\n    return {\n        htmlAttrs: { default: null },\n        classNames: { default: null },\n    };\n}\nfunction getCustomAttrs(attrs) {\n    var htmlAttrs = attrs.htmlAttrs, classNames = attrs.classNames;\n    return __assign$1(__assign$1({}, htmlAttrs), { class: classNames ? classNames.join(\' \') : null });\n}\n\nfunction findWrappingOutside(range, type) {\n    var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;\n    var around = parent.contentMatchAt(startIndex).findWrapping(type);\n    if (around) {\n        var outer = around.length ? around[0] : type;\n        return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n    }\n    return null;\n}\nfunction findWrappingInside(range, type) {\n    var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;\n    var inner = parent.child(startIndex);\n    var inside = type.contentMatch.findWrapping(inner.type);\n    if (inside) {\n        var lastType = inside.length ? inside[inside.length - 1] : type;\n        var innerMatch = lastType.contentMatch;\n        for (var i = startIndex; innerMatch && i < endIndex; i += 1) {\n            innerMatch = innerMatch.matchType(parent.child(i).type);\n        }\n        if (innerMatch && innerMatch.validEnd) {\n            return inside;\n        }\n    }\n    return null;\n}\nfunction findWrappers(range, innerRange, nodeType, attrs) {\n    var around = findWrappingOutside(range, nodeType);\n    var inner = findWrappingInside(innerRange, nodeType);\n    if (around && inner) {\n        var aroundNodes = around.map(function (type) {\n            return { type: type };\n        });\n        var innerNodes = inner.map(function (type) {\n            return { type: type, attrs: attrs };\n        });\n        return aroundNodes.concat({ type: nodeType }).concat(innerNodes);\n    }\n    return null;\n}\nfunction wrapInList(tr, _a, wrappers, joinBefore, list) {\n    var start = _a.start, end = _a.end, startIndex = _a.startIndex, endIndex = _a.endIndex, parent = _a.parent;\n    var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    for (var i = wrappers.length - 1; i >= 0; i -= 1) {\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(start - (joinBefore ? 2 : 0), end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, 0, 0), wrappers.length, true));\n    var foundListIndex = 0;\n    for (var i = 0; i < wrappers.length; i += 1) {\n        if (wrappers[i].type === list) {\n            foundListIndex = i + 1;\n            break;\n        }\n    }\n    var splitDepth = wrappers.length - foundListIndex;\n    var splitPos = start + wrappers.length - (joinBefore ? 2 : 0);\n    for (var i = startIndex, len = endIndex; i < len; i += 1) {\n        var first = i === startIndex;\n        if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.canSplit)(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += splitDepth * 2;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\nfunction changeToList(tr, range, list, attrs) {\n    var $from = range.$from, $to = range.$to, depth = range.depth;\n    var outerRange = range;\n    var joinBefore = false;\n    if (depth >= 2 &&\n        $from.node(depth - 1).type.compatibleContent(list) &&\n        range.startIndex === 0 &&\n        $from.index(depth - 1)) {\n        var start = tr.doc.resolve(range.start - 2);\n        outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange(start, start, depth);\n        if (range.endIndex < range.parent.childCount) {\n            range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange($from, tr.doc.resolve($to.end(depth)), depth);\n        }\n        joinBefore = true;\n    }\n    var wrappers = findWrappers(outerRange, range, list, attrs);\n    if (wrappers) {\n        return wrapInList(tr, range, wrappers, joinBefore, list);\n    }\n    return tr;\n}\nfunction getBeforeLineListItem(doc, offset) {\n    var endListItemPos = doc.resolve(offset);\n    while (endListItemPos.node().type.name !== \'paragraph\') {\n        offset -= 2; // The position value of </li></ul>\n        endListItemPos = doc.resolve(offset);\n    }\n    return findListItem(endListItemPos);\n}\nfunction toggleTaskListItems(tr, _a) {\n    var $from = _a.$from, $to = _a.$to;\n    var startListItem = findListItem($from);\n    var endListItem = findListItem($to);\n    if (startListItem && endListItem) {\n        while (endListItem) {\n            var offset = endListItem.offset, node = endListItem.node;\n            var attrs = { task: !node.attrs.task, checked: false };\n            tr.setNodeMarkup(offset, null, attrs);\n            if (offset === startListItem.offset) {\n                break;\n            }\n            endListItem = getBeforeLineListItem(tr.doc, offset);\n        }\n    }\n    return tr;\n}\nfunction changeListType(tr, _a, list) {\n    var $from = _a.$from, $to = _a.$to;\n    var startListItem = findListItem($from);\n    var endListItem = findListItem($to);\n    if (startListItem && endListItem) {\n        while (endListItem) {\n            var offset = endListItem.offset, node = endListItem.node, depth = endListItem.depth;\n            if (node.attrs.task) {\n                tr.setNodeMarkup(offset, null, { task: false, checked: false });\n            }\n            var resolvedPos = tr.doc.resolve(offset);\n            if (resolvedPos.parent.type !== list) {\n                var parentOffset = resolvedPos.before(depth - 1);\n                tr.setNodeMarkup(parentOffset, list);\n            }\n            if (offset === startListItem.offset) {\n                break;\n            }\n            endListItem = getBeforeLineListItem(tr.doc, offset);\n        }\n    }\n    return tr;\n}\nfunction changeList(list) {\n    return function (_a, dispatch) {\n        var selection = _a.selection, tr = _a.tr;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range) {\n            var newTr = isInListNode($from)\n                ? changeListType(tr, range, list)\n                : changeToList(tr, range, list);\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction toggleTask() {\n    return function (_a, dispatch) {\n        var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range) {\n            var newTr = isInListNode($from)\n                ? toggleTaskListItems(tr, range)\n                : changeToList(tr, range, schema.nodes.bulletList, { task: true });\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction sinkListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to, function (_a) {\n            var childCount = _a.childCount, firstChild = _a.firstChild;\n            return !!childCount && firstChild.type === listItem;\n        });\n        if (range && range.startIndex > 0) {\n            var parent_1 = range.parent;\n            var nodeBefore = parent_1.child(range.startIndex - 1);\n            if (nodeBefore.type !== listItem) {\n                return false;\n            }\n            var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type === parent_1.type;\n            var inner = nestedBefore ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create()) : null;\n            var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(parent_1.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            var before = range.start;\n            var after = range.end;\n            tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true));\n            dispatch(tr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction liftToOuterList(tr, range, listItem) {\n    var $from = range.$from, $to = range.$to, end = range.end, depth = range.depth, parent = range.parent;\n    var endOfList = $to.end(depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create(null, parent.copy())), 1, 0), 1, true));\n        range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), depth);\n    }\n    tr.lift(range, (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.liftTarget)(range));\n    return tr;\n}\nfunction liftOutOfList(tr, range) {\n    var list = range.parent;\n    var pos = range.end;\n    // Merge the list items into a single big item\n    for (var i = range.endIndex - 1, len = range.startIndex; i > len; i -= 1) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    var startPos = tr.doc.resolve(range.start);\n    var listItem = startPos.nodeAfter;\n    var atStart = range.startIndex === 0;\n    var atEnd = range.endIndex === list.childCount;\n    var parent = startPos.node(-1);\n    var indexBefore = startPos.index(-1);\n    var canReplaceParent = parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, listItem === null || listItem === void 0 ? void 0 : listItem.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list)));\n    if (listItem && canReplaceParent) {\n        var start = startPos.pos;\n        var end = start + listItem.nodeSize;\n        // Strip off the surrounding list. At the sides where we\'re not at\n        // the end of the list, the existing list is closed. At sides where\n        // this is the end, it is overwritten to its end.\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty))).append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    }\n    return tr;\n}\nfunction liftListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to, function (_a) {\n            var childCount = _a.childCount, firstChild = _a.firstChild;\n            return !!childCount && firstChild.type === listItem;\n        });\n        if (range) {\n            var topListItem = $from.node(range.depth - 1).type === listItem;\n            var newTr = topListItem ? liftToOuterList(tr, range, listItem) : liftOutOfList(tr, range);\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction splitListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        if ($from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        var grandParent = $from.node(-1);\n        if (grandParent.type !== listItem) {\n            return false;\n        }\n        if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth === 2 ||\n                $from.node(-3).type !== listItem ||\n                $from.index(-2) !== $from.node(-2).childCount - 1) {\n                return false;\n            }\n            var keepItem = $from.index(-1) > 0;\n            var wrapper = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n            // Build a fragment containing empty versions of the structure\n            // from the outer list item to the parent node of the cursor\n            for (var depth = $from.depth - (keepItem ? 1 : 2); depth >= $from.depth - 3; depth -= 1) {\n                wrapper = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from($from.node(depth).copy(wrapper));\n            }\n            // Add a second list item with an empty default start node\n            wrapper = wrapper.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.createAndFill()));\n            tr.replace(keepItem ? $from.before() : $from.before(-1), $from.after(-3), new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(wrapper, keepItem ? 3 : 2, 2));\n            tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))));\n            dispatch(tr);\n            return true;\n        }\n        var nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        var types = nextType && [null, { type: nextType }];\n        tr.delete($from.pos, $to.pos);\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.canSplit)(tr.doc, $from.pos, 2, types)) {\n            tr.split($from.pos, 2, types);\n            dispatch(tr);\n            return true;\n        }\n        return false;\n    };\n}\n\nfunction indent() {\n    return function () { return function (state, dispatch) {\n        var selection = state.selection, schema = state.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range && isInListNode($from)) {\n            return sinkListItem(schema.nodes.listItem)(state, dispatch);\n        }\n        return false;\n    }; };\n}\nfunction outdent() {\n    return function () { return function (state, dispatch) {\n        var selection = state.selection, schema = state.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range && isInListNode($from)) {\n            return liftListItem(schema.nodes.listItem)(state, dispatch);\n        }\n        return false;\n    }; };\n}\nfunction getWwCommands() {\n    return {\n        indent: indent(),\n        outdent: outdent(),\n    };\n}\n\nvar cache = new Map();\n/* eslint-disable @typescript-eslint/no-unused-vars */\nvar TableOffsetMap = /** @class */ (function () {\n    function TableOffsetMap(table, tableRows, tableStartPos, rowInfo) {\n        this.table = table;\n        this.tableRows = tableRows;\n        this.tableStartPos = tableStartPos;\n        this.rowInfo = rowInfo;\n    }\n    TableOffsetMap.create = function (cellPos) {\n        var table = findNodeBy(cellPos, function (_a) {\n            var type = _a.type;\n            return type.name === \'table\';\n        });\n        if (table) {\n            var node = table.node, depth = table.depth, offset = table.offset;\n            var cached = cache.get(node);\n            if ((cached === null || cached === void 0 ? void 0 : cached.tableStartPos) === offset + 1) {\n                return cached;\n            }\n            var rows_1 = [];\n            var tablePos = cellPos.start(depth);\n            var thead = node.child(0);\n            var tbody = node.child(1);\n            var theadCellInfo = createOffsetMap(thead, tablePos);\n            var tbodyCellInfo = createOffsetMap(tbody, tablePos + thead.nodeSize);\n            thead.forEach(function (row) { return rows_1.push(row); });\n            tbody.forEach(function (row) { return rows_1.push(row); });\n            var map = new TableOffsetMap(node, rows_1, tablePos, theadCellInfo.concat(tbodyCellInfo));\n            cache.set(node, map);\n            return map;\n        }\n        return null;\n    };\n    Object.defineProperty(TableOffsetMap.prototype, "totalRowCount", {\n        get: function () {\n            return this.rowInfo.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, "totalColumnCount", {\n        get: function () {\n            return this.rowInfo[0].length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, "tableStartOffset", {\n        get: function () {\n            return this.tableStartPos;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, "tableEndOffset", {\n        get: function () {\n            return this.tableStartPos + this.table.nodeSize - 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    TableOffsetMap.prototype.getCellInfo = function (rowIdx, colIdx) {\n        return this.rowInfo[rowIdx][colIdx];\n    };\n    TableOffsetMap.prototype.posAt = function (rowIdx, colIdx) {\n        for (var i = 0, rowStart = this.tableStartPos;; i += 1) {\n            var rowEnd = rowStart + this.tableRows[i].nodeSize;\n            if (i === rowIdx) {\n                var index = colIdx;\n                // Skip the cells from previous row(via rowspan)\n                while (index < this.totalColumnCount && this.rowInfo[i][index].offset < rowStart) {\n                    index += 1;\n                }\n                return index === this.totalColumnCount ? rowEnd : this.rowInfo[i][index].offset;\n            }\n            rowStart = rowEnd;\n        }\n    };\n    TableOffsetMap.prototype.getNodeAndPos = function (rowIdx, colIdx) {\n        var cellInfo = this.rowInfo[rowIdx][colIdx];\n        return {\n            node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),\n            pos: cellInfo.offset,\n        };\n    };\n    TableOffsetMap.prototype.extendedRowspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.extendedColspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.getRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getRowspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getCellStartOffset = function (rowIdx, colIdx) {\n        var offset = this.rowInfo[rowIdx][colIdx].offset;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset;\n    };\n    TableOffsetMap.prototype.getCellEndOffset = function (rowIdx, colIdx) {\n        var _a = this.rowInfo[rowIdx][colIdx], offset = _a.offset, nodeSize = _a.nodeSize;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset + nodeSize;\n    };\n    TableOffsetMap.prototype.getCellIndex = function (cellPos) {\n        for (var rowIdx = 0; rowIdx < this.totalRowCount; rowIdx += 1) {\n            var rowInfo = this.rowInfo[rowIdx];\n            for (var colIdx = 0; colIdx < this.totalColumnCount; colIdx += 1) {\n                if (rowInfo[colIdx].offset + 1 > cellPos.pos) {\n                    return [rowIdx, colIdx];\n                }\n            }\n        }\n        return [0, 0];\n    };\n    TableOffsetMap.prototype.getRectOffsets = function (startCellPos, endCellPos) {\n        var _a, _b, _c;\n        if (endCellPos === void 0) { endCellPos = startCellPos; }\n        if (startCellPos.pos > endCellPos.pos) {\n            _a = [endCellPos, startCellPos], startCellPos = _a[0], endCellPos = _a[1];\n        }\n        var _d = this.getCellIndex(startCellPos), startRowIdx = _d[0], startColIdx = _d[1];\n        var _e = this.getCellIndex(endCellPos), endRowIdx = _e[0], endColIdx = _e[1];\n        _b = getSortedNumPair(startRowIdx, endRowIdx), startRowIdx = _b[0], endRowIdx = _b[1];\n        _c = getSortedNumPair(startColIdx, endColIdx), startColIdx = _c[0], endColIdx = _c[1];\n        return this.getSpannedOffsets({ startRowIdx: startRowIdx, startColIdx: startColIdx, endRowIdx: endRowIdx, endColIdx: endColIdx });\n    };\n    TableOffsetMap.prototype.getSpannedOffsets = function (selectionInfo) {\n        return selectionInfo;\n    };\n    return TableOffsetMap;\n}());\n/* eslint-enable @typescript-eslint/no-unused-vars */\nvar createOffsetMap = function (headOrBody, startOffset) {\n    var cellInfoMatrix = [];\n    headOrBody.forEach(function (row, rowOffset) {\n        // get row index based on table(not table head or table body)\n        var rowInfo = { rowspanMap: {}, colspanMap: {}, length: 0 };\n        row.forEach(function (_a, cellOffset) {\n            var nodeSize = _a.nodeSize;\n            var colIdx = 0;\n            while (rowInfo[colIdx]) {\n                colIdx += 1;\n            }\n            rowInfo[colIdx] = {\n                // 2 is the sum of the front and back positions of the tag\n                offset: startOffset + rowOffset + cellOffset + 2,\n                nodeSize: nodeSize,\n            };\n            rowInfo.length += 1;\n        });\n        cellInfoMatrix.push(rowInfo);\n    });\n    return cellInfoMatrix;\n};\nfunction mixinTableOffsetMapPrototype(offsetMapMixin, createOffsetMapMixin) {\n    assign(TableOffsetMap.prototype, offsetMapMixin);\n    createOffsetMap = createOffsetMapMixin;\n    return TableOffsetMap;\n}\n\nfunction getSelectionRanges(doc, map, _a) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;\n    var ranges = [];\n    for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n        for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n            var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n            ranges.push(new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange(doc.resolve(offset + 1), doc.resolve(offset + nodeSize - 1)));\n        }\n    }\n    return ranges;\n}\nfunction createTableFragment(tableHead, tableBody) {\n    var fragment = [];\n    if (tableHead.childCount) {\n        fragment.push(tableHead);\n    }\n    if (tableBody.childCount) {\n        fragment.push(tableBody);\n    }\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(fragment);\n}\nvar CellSelection = /** @class */ (function (_super) {\n    __extends$1(CellSelection, _super);\n    function CellSelection(startCellPos, endCellPos) {\n        if (endCellPos === void 0) { endCellPos = startCellPos; }\n        var _this = this;\n        var doc = startCellPos.node(0);\n        var map = TableOffsetMap.create(startCellPos);\n        var selectionInfo = map.getRectOffsets(startCellPos, endCellPos);\n        var ranges = getSelectionRanges(doc, map, selectionInfo);\n        _this = _super.call(this, ranges[0].$from, ranges[0].$to, ranges) || this;\n        _this.startCell = startCellPos;\n        _this.endCell = endCellPos;\n        _this.offsetMap = map;\n        _this.isCellSelection = true;\n        // This property is the api of the \'Selection\' in prosemirror,\n        // and is used to disable the text selection.\n        _this.visible = false;\n        return _this;\n    }\n    CellSelection.prototype.map = function (doc, mapping) {\n        var startPos = this.startCell.pos;\n        var endPos = this.endCell.pos;\n        var startCell = doc.resolve(mapping.map(startPos));\n        var endCell = doc.resolve(mapping.map(endPos));\n        var map = TableOffsetMap.create(startCell);\n        // text selection when rows or columns are deleted\n        if (this.offsetMap.totalColumnCount > map.totalColumnCount ||\n            this.offsetMap.totalRowCount > map.totalRowCount) {\n            var depthMap = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 };\n            var depthFromTable = depthMap[endCell.parent.type.name];\n            var tableEndPos = endCell.end(endCell.depth - depthFromTable);\n            // subtract 4(</td></tr></tbody></table> tag length)\n            var from = Math.min(tableEndPos - 4, endCell.pos);\n            return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, from);\n        }\n        return new CellSelection(startCell, endCell);\n    };\n    CellSelection.prototype.eq = function (cell) {\n        return (cell instanceof CellSelection &&\n            cell.startCell.pos === this.startCell.pos &&\n            cell.endCell.pos === this.endCell.pos);\n    };\n    CellSelection.prototype.content = function () {\n        var table = this.startCell.node(-2);\n        var tableOffset = this.startCell.start(-2);\n        var row = table.child(1).firstChild;\n        var tableHead = table.child(0).type.create();\n        var tableBody = table.child(1).type.create();\n        var map = TableOffsetMap.create(this.startCell);\n        var selectionInfo = map.getRectOffsets(this.startCell, this.endCell);\n        var startRowIdx = selectionInfo.startRowIdx, startColIdx = selectionInfo.startColIdx, endRowIdx = selectionInfo.endRowIdx, endColIdx = selectionInfo.endColIdx;\n        var isTableHeadCell = false;\n        for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n            var cells = [];\n            for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                var offset = map.getCellInfo(rowIdx, colIdx).offset;\n                var cell = table.nodeAt(offset - tableOffset);\n                if (cell) {\n                    isTableHeadCell = cell.type.name === \'tableHeadCell\';\n                    // mark the extended cell for pasting\n                    if (map.extendedRowspan(rowIdx, colIdx) || map.extendedColspan(rowIdx, colIdx)) {\n                        cells.push(cell.type.create({ extended: true }));\n                    }\n                    else {\n                        cells.push(cell.copy(cell.content));\n                    }\n                }\n            }\n            var copiedRow = row.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n            var targetNode = isTableHeadCell ? tableHead : tableBody;\n            // @ts-ignore\n            targetNode.content = targetNode.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(copiedRow));\n        }\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(createTableFragment(tableHead, tableBody), 1, 1);\n    };\n    CellSelection.prototype.toJSON = function () {\n        return JSON.stringify(this);\n    };\n    return CellSelection;\n}(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection));\n\nfunction createTableHeadRow(columnCount, schema, data) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableHeadCell = _a.tableHeadCell, paragraph = _a.paragraph;\n    var cells = [];\n    for (var index = 0; index < columnCount; index += 1) {\n        var text = data && data[index];\n        var para = paragraph.create(null, text ? schema.text(text) : []);\n        cells.push(tableHeadCell.create(null, para));\n    }\n    return [tableRow.create(null, cells)];\n}\nfunction createTableBodyRows(rowCount, columnCount, schema, data) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell, paragraph = _a.paragraph;\n    var tableRows = [];\n    for (var rowIdx = 0; rowIdx < rowCount; rowIdx += 1) {\n        var cells = [];\n        for (var colIdx = 0; colIdx < columnCount; colIdx += 1) {\n            var text = data && data[rowIdx * columnCount + colIdx];\n            var para = paragraph.create(null, text ? schema.text(text) : []);\n            cells.push(tableBodyCell.create(null, para));\n        }\n        tableRows.push(tableRow.create(null, cells));\n    }\n    return tableRows;\n}\nfunction createDummyCells(columnCount, rowIdx, schema, attrs) {\n    if (attrs === void 0) { attrs = null; }\n    var _a = schema.nodes, tableHeadCell = _a.tableHeadCell, tableBodyCell = _a.tableBodyCell, paragraph = _a.paragraph;\n    var cell = rowIdx === 0 ? tableHeadCell : tableBodyCell;\n    var cells = [];\n    for (var index = 0; index < columnCount; index += 1) {\n        cells.push(cell.create(attrs, paragraph.create()));\n    }\n    return cells;\n}\nfunction findCellElement(node, root) {\n    while (node && node !== root) {\n        if (node.nodeName === \'TD\' || node.nodeName === \'TH\') {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nfunction findCell(pos) {\n    return findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === \'tableHeadCell\' || type.name === \'tableBodyCell\';\n    });\n}\nfunction getResolvedSelection(selection) {\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n        var $anchor = selection.$anchor;\n        var foundCell = findCell($anchor);\n        if (foundCell) {\n            var anchor = $anchor.node(0).resolve($anchor.before(foundCell.depth));\n            return { anchor: anchor, head: anchor };\n        }\n    }\n    var _a = selection, startCell = _a.startCell, endCell = _a.endCell;\n    return { anchor: startCell, head: endCell };\n}\nfunction getTableContentFromSlice(slice) {\n    var _a;\n    if (slice.size) {\n        var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;\n        if (content.childCount !== 1) {\n            return null;\n        }\n        while (content.childCount === 1 &&\n            ((openStart > 0 && openEnd > 0) || ((_a = content.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) === \'table\')) {\n            openStart -= 1;\n            openEnd -= 1;\n            content = content.firstChild.content;\n        }\n        if (content.firstChild.type.name === \'tableHead\' ||\n            content.firstChild.type.name === \'tableBody\') {\n            return content;\n        }\n    }\n    return null;\n}\nfunction getRowAndColumnCount(_a) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;\n    var rowCount = endRowIdx - startRowIdx + 1;\n    var columnCount = endColIdx - startColIdx + 1;\n    return { rowCount: rowCount, columnCount: columnCount };\n}\nfunction setAttrs(cell, attrs) {\n    return __assign$1(__assign$1({}, cell.attrs), attrs);\n}\n\nvar pluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\'cellSelection\');\nvar MOUSE_RIGHT_BUTTON = 2;\nvar TableSelection = /** @class */ (function () {\n    function TableSelection(view) {\n        this.view = view;\n        this.handlers = {\n            mousedown: this.handleMousedown.bind(this),\n            mousemove: this.handleMousemove.bind(this),\n            mouseup: this.handleMouseup.bind(this),\n        };\n        this.startCellPos = null;\n        this.init();\n    }\n    TableSelection.prototype.init = function () {\n        this.view.dom.addEventListener(\'mousedown\', this.handlers.mousedown);\n    };\n    TableSelection.prototype.handleMousedown = function (ev) {\n        var foundCell = findCellElement(ev.target, this.view.dom);\n        if (ev.button === MOUSE_RIGHT_BUTTON) {\n            ev.preventDefault();\n            return;\n        }\n        if (foundCell) {\n            var startCellPos = this.getCellPos(ev);\n            if (startCellPos) {\n                this.startCellPos = startCellPos;\n            }\n            this.bindEvent();\n        }\n    };\n    TableSelection.prototype.handleMousemove = function (ev) {\n        var prevEndCellOffset = pluginKey.getState(this.view.state);\n        var endCellPos = this.getCellPos(ev);\n        var startCellPos = this.startCellPos;\n        var prevEndCellPos;\n        if (prevEndCellOffset) {\n            prevEndCellPos = this.view.state.doc.resolve(prevEndCellOffset);\n        }\n        else if (startCellPos !== endCellPos) {\n            prevEndCellPos = startCellPos;\n        }\n        if (prevEndCellPos && startCellPos && endCellPos) {\n            this.setCellSelection(startCellPos, endCellPos);\n        }\n    };\n    TableSelection.prototype.handleMouseup = function () {\n        this.startCellPos = null;\n        this.unbindEvent();\n        if (pluginKey.getState(this.view.state) !== null) {\n            this.view.dispatch(this.view.state.tr.setMeta(pluginKey, -1));\n        }\n    };\n    TableSelection.prototype.bindEvent = function () {\n        var dom = this.view.dom;\n        dom.addEventListener(\'mousemove\', this.handlers.mousemove);\n        dom.addEventListener(\'mouseup\', this.handlers.mouseup);\n    };\n    TableSelection.prototype.unbindEvent = function () {\n        var dom = this.view.dom;\n        dom.removeEventListener(\'mousemove\', this.handlers.mousemove);\n        dom.removeEventListener(\'mouseup\', this.handlers.mouseup);\n    };\n    TableSelection.prototype.getCellPos = function (_a) {\n        var clientX = _a.clientX, clientY = _a.clientY;\n        var mousePos = this.view.posAtCoords({ left: clientX, top: clientY });\n        if (mousePos) {\n            var doc = this.view.state.doc;\n            var currentPos = doc.resolve(mousePos.pos);\n            var foundCell = findCell(currentPos);\n            if (foundCell) {\n                var cellOffset = currentPos.before(foundCell.depth);\n                return doc.resolve(cellOffset);\n            }\n        }\n        return null;\n    };\n    TableSelection.prototype.setCellSelection = function (startCellPos, endCellPos) {\n        var _a = this.view.state, selection = _a.selection, tr = _a.tr;\n        var starting = pluginKey.getState(this.view.state) === null;\n        var cellSelection = new CellSelection(startCellPos, endCellPos);\n        if (starting || !selection.eq(cellSelection)) {\n            var newTr = tr.setSelection(cellSelection);\n            if (starting) {\n                newTr.setMeta(pluginKey, endCellPos.pos);\n            }\n            this.view.dispatch(newTr);\n        }\n    };\n    TableSelection.prototype.destroy = function () {\n        this.view.dom.removeEventListener(\'mousedown\', this.handlers.mousedown);\n    };\n    return TableSelection;\n}());\n\nvar SELECTED_CELL_CLASS_NAME = cls(\'cell-selected\');\nfunction drawCellSelection(_a) {\n    var selection = _a.selection, doc = _a.doc;\n    if (selection instanceof CellSelection) {\n        var cells_1 = [];\n        var ranges = selection.ranges;\n        ranges.forEach(function (_a) {\n            var $from = _a.$from, $to = _a.$to;\n            cells_1.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.node($from.pos - 1, $to.pos + 1, { class: SELECTED_CELL_CLASS_NAME }));\n        });\n        return prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet.create(doc, cells_1);\n    }\n    return null;\n}\nfunction tableSelection() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: pluginKey,\n        state: {\n            init: function () {\n                return null;\n            },\n            apply: function (tr, value) {\n                var cellOffset = tr.getMeta(pluginKey);\n                if (cellOffset) {\n                    return cellOffset === -1 ? null : cellOffset;\n                }\n                if (isNull_1(value) || !tr.docChanged) {\n                    return value;\n                }\n                var _a = tr.mapping.mapResult(value), deleted = _a.deleted, pos = _a.pos;\n                return deleted ? null : pos;\n            },\n        },\n        props: {\n            decorations: drawCellSelection,\n            createSelectionBetween: function (_a) {\n                var state = _a.state;\n                if (!isNull_1(pluginKey.getState(state))) {\n                    return state.selection;\n                }\n                return null;\n            },\n        },\n        view: function (editorView) {\n            return new TableSelection(editorView);\n        },\n    });\n}\n\n/**\n * @class\n * @ignore\n * @classdesc ES6 Map\n */\nvar Map$1 = /** @class */ (function () {\n    function Map() {\n        this.keys = [];\n        this.values = [];\n    }\n    Map.prototype.getKeyIndex = function (key) {\n        return inArray_1(key, this.keys);\n    };\n    Map.prototype.get = function (key) {\n        return this.values[this.getKeyIndex(key)];\n    };\n    Map.prototype.set = function (key, value) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.values[keyIndex] = value;\n        }\n        else {\n            this.keys.push(key);\n            this.values.push(value);\n        }\n        return this;\n    };\n    Map.prototype.has = function (key) {\n        return this.getKeyIndex(key) > -1;\n    };\n    Map.prototype.delete = function (key) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.keys.splice(keyIndex, 1);\n            this.values.splice(keyIndex, 1);\n            return true;\n        }\n        return false;\n    };\n    Map.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        if (thisArg === void 0) { thisArg = this; }\n        this.values.forEach(function (value, index) {\n            if (value && _this.keys[index]) {\n                callback.call(thisArg, value, _this.keys[index], _this);\n            }\n        });\n    };\n    Map.prototype.clear = function () {\n        this.keys = [];\n        this.values = [];\n    };\n    return Map;\n}());\n\n/**\n * @fileoverview Implements i18n\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n */\nvar DEFAULT_CODE = \'en-US\';\n/**\n * Class I18n\n * @ignore\n */\nvar I18n = /** @class */ (function () {\n    function I18n() {\n        this.code = DEFAULT_CODE;\n        this.langs = new Map$1();\n    }\n    I18n.prototype.setCode = function (code) {\n        this.code = code || DEFAULT_CODE;\n    };\n    /**\n     * Set language set\n     * @param {string|string[]} codes locale code\n     * @param {object} data language set\n     */\n    I18n.prototype.setLanguage = function (codes, data) {\n        var _this = this;\n        codes = [].concat(codes);\n        codes.forEach(function (code) {\n            if (!_this.langs.has(code)) {\n                _this.langs.set(code, data);\n            }\n            else {\n                var langData = _this.langs.get(code);\n                _this.langs.set(code, extend_1(langData, data));\n            }\n        });\n    };\n    I18n.prototype.get = function (key, code) {\n        if (!code) {\n            code = this.code;\n        }\n        var langSet = this.langs.get(code);\n        if (!langSet) {\n            langSet = this.langs.get(DEFAULT_CODE);\n        }\n        var text = langSet[key];\n        if (!text) {\n            throw new Error("There is no text key \\"" + key + "\\" in " + code);\n        }\n        return text;\n    };\n    return I18n;\n}());\nvar i18n = new I18n();\n\nvar contextMenuGroups = [\n    [\n        {\n            action: \'Add row to up\',\n            command: \'addRowToUp\',\n            disableInThead: true,\n            className: \'add-row-up\',\n        },\n        {\n            action: \'Add row to down\',\n            command: \'addRowToDown\',\n            disableInThead: true,\n            className: \'add-row-down\',\n        },\n        { action: \'Remove row\', command: \'removeRow\', disableInThead: true, className: \'remove-row\' },\n    ],\n    [\n        { action: \'Add column to left\', command: \'addColumnToLeft\', className: \'add-column-left\' },\n        { action: \'Add column to right\', command: \'addColumnToRight\', className: \'add-column-right\' },\n        { action: \'Remove column\', command: \'removeColumn\', className: \'remove-column\' },\n    ],\n    [\n        {\n            action: \'Align column to left\',\n            command: \'alignColumn\',\n            payload: { align: \'left\' },\n            className: \'align-column-left\',\n        },\n        {\n            action: \'Align column to center\',\n            command: \'alignColumn\',\n            payload: { align: \'center\' },\n            className: \'align-column-center\',\n        },\n        {\n            action: \'Align column to right\',\n            command: \'alignColumn\',\n            payload: { align: \'right\' },\n            className: \'align-column-right\',\n        },\n    ],\n    [{ action: \'Remove table\', command: \'removeTable\', className: \'remove-table\' }],\n];\nfunction getContextMenuGroups(eventEmitter, inTableHead) {\n    return contextMenuGroups\n        .map(function (contextMenuGroup) {\n        return contextMenuGroup.map(function (_a) {\n            var action = _a.action, command = _a.command, payload = _a.payload, disableInThead = _a.disableInThead, className = _a.className;\n            return {\n                label: i18n.get(action),\n                onClick: function () {\n                    eventEmitter.emit(\'command\', command, payload);\n                },\n                disabled: inTableHead && !!disableInThead,\n                className: className,\n            };\n        });\n    })\n        .concat();\n}\nfunction tableContextMenu(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                contextmenu: function (view, ev) {\n                    var tableCell = findCellElement(ev.target, view.dom);\n                    if (tableCell) {\n                        ev.preventDefault();\n                        var _a = ev, clientX = _a.clientX, clientY = _a.clientY;\n                        var _b = view.dom.parentNode.getBoundingClientRect(), left = _b.left, top_1 = _b.top;\n                        var inTableHead = tableCell.nodeName === \'TH\';\n                        eventEmitter.emit(\'contextmenu\', {\n                            pos: { left: clientX - left + 10 + "px", top: clientY - top_1 + 30 + "px" },\n                            menuGroups: getContextMenuGroups(eventEmitter, inTableHead),\n                            tableCell: tableCell,\n                        });\n                        return true;\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nfunction task() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                mousedown: function (view, ev) {\n                    var _a = ev, clientX = _a.clientX, clientY = _a.clientY;\n                    var mousePos = view.posAtCoords({ left: clientX, top: clientY });\n                    if (mousePos) {\n                        var _b = view.state, doc = _b.doc, tr = _b.tr;\n                        var currentPos = doc.resolve(mousePos.pos);\n                        var listItem = findListItem(currentPos);\n                        var target = ev.target;\n                        var style = getComputedStyle(target, \':before\');\n                        var _c = ev, offsetX = _c.offsetX, offsetY = _c.offsetY;\n                        if (!listItem || !isPositionInBox(style, offsetX, offsetY)) {\n                            return false;\n                        }\n                        ev.preventDefault();\n                        var offset = currentPos.before(listItem.depth);\n                        var attrs = listItem.node.attrs;\n                        tr.setNodeMarkup(offset, null, __assign$1(__assign$1({}, attrs), { checked: !attrs.checked }));\n                        view.dispatch(tr);\n                        return true;\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nvar EXCEPT_TYPES = [\'image\', \'link\', \'customBlock\', \'frontMatter\'];\nvar MARK_TYPES = [\'strong\', \'strike\', \'emph\', \'code\'];\nvar LIST_TYPES = [\'bulletList\', \'orderedList\', \'taskList\'];\nfunction getToolbarStateType(node, parentNode) {\n    var type = node.type.name;\n    if (type === \'listItem\') {\n        return node.attrs.task ? \'taskList\' : parentNode.type.name;\n    }\n    if (type.indexOf(\'table\') !== -1) {\n        return \'table\';\n    }\n    return type;\n}\nfunction setListNodeToolbarState(type, nodeTypeState) {\n    nodeTypeState[type] = { active: true };\n    LIST_TYPES.filter(function (listName) { return listName !== type; }).forEach(function (listType) {\n        if (nodeTypeState[listType]) {\n            delete nodeTypeState[listType];\n        }\n    });\n}\nfunction setMarkTypeStates(from, to, schema, toolbarState) {\n    MARK_TYPES.forEach(function (type) {\n        var mark = schema.marks[type];\n        var marksAtPos = from.marksAcross(to) || [];\n        var foundMark = !!mark.isInSet(marksAtPos);\n        if (foundMark) {\n            toolbarState[type] = { active: true };\n        }\n    });\n}\nfunction getToolbarState(selection, doc, schema) {\n    var $from = selection.$from, $to = selection.$to, from = selection.from, to = selection.to;\n    var toolbarState = {\n        indent: { active: false, disabled: true },\n        outdent: { active: false, disabled: true },\n    };\n    doc.nodesBetween(from, to, function (node, _, parentNode) {\n        var type = getToolbarStateType(node, parentNode);\n        if (includes(EXCEPT_TYPES, type)) {\n            return;\n        }\n        if (includes(LIST_TYPES, type)) {\n            setListNodeToolbarState(type, toolbarState);\n            toolbarState.indent.disabled = false;\n            toolbarState.outdent.disabled = false;\n        }\n        else if (type === \'paragraph\' || type === \'text\') {\n            setMarkTypeStates($from, $to, schema, toolbarState);\n        }\n        else {\n            toolbarState[type] = { active: true };\n        }\n    });\n    return toolbarState;\n}\nfunction toolbarStateHighlight(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        view: function () {\n            return {\n                update: function (view) {\n                    var _a = view.state, selection = _a.selection, doc = _a.doc, schema = _a.schema;\n                    eventEmitter.emit(\'changeToolbarState\', {\n                        toolbarState: getToolbarState(selection, doc, schema),\n                    });\n                },\n            };\n        },\n    });\n}\n\nvar CustomBlockView = /** @class */ (function () {\n    function CustomBlockView(node, view, getPos, toDOMAdaptor) {\n        var _this = this;\n        this.openEditor = function () {\n            if (_this.innerEditorView) {\n                throw new Error(\'The editor is already opened.\');\n            }\n            _this.dom.draggable = false;\n            _this.wrapper.style.display = \'none\';\n            _this.innerViewContainer.style.display = \'block\';\n            _this.innerEditorView = new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(_this.innerViewContainer, {\n                state: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n                    doc: _this.node,\n                    plugins: [\n                        (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)({\n                            \'Mod-z\': function () { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(_this.innerEditorView.state, _this.innerEditorView.dispatch); },\n                            \'Shift-Mod-z\': function () { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.redo)(_this.innerEditorView.state, _this.innerEditorView.dispatch); },\n                            Tab: function (state, dispatch) {\n                                dispatch(state.tr.insertText(\'\\t\'));\n                                return true;\n                            },\n                            Enter: prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.newlineInCode,\n                            Escape: function () {\n                                _this.cancelEditing();\n                                return true;\n                            },\n                            \'Ctrl-Enter\': function () {\n                                _this.saveAndFinishEditing();\n                                return true;\n                            },\n                        }),\n                        (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.history)(),\n                    ],\n                }),\n                dispatchTransaction: function (tr) { return _this.dispatchInner(tr); },\n                handleDOMEvents: {\n                    mousedown: function () {\n                        if (_this.editorView.hasFocus()) {\n                            _this.innerEditorView.focus();\n                        }\n                        return true;\n                    },\n                    blur: function () {\n                        _this.saveAndFinishEditing();\n                        return true;\n                    },\n                },\n            });\n            _this.innerEditorView.focus();\n        };\n        this.node = node;\n        this.editorView = view;\n        this.getPos = getPos;\n        this.toDOMAdaptor = toDOMAdaptor;\n        this.innerEditorView = null;\n        this.canceled = false;\n        this.dom = document.createElement(\'div\');\n        this.dom.className = cls(\'custom-block\');\n        this.wrapper = document.createElement(\'div\');\n        this.wrapper.className = cls(\'custom-block-view\');\n        this.createInnerViewContainer();\n        this.renderCustomBlock();\n        this.dom.appendChild(this.innerViewContainer);\n        this.dom.appendChild(this.wrapper);\n    }\n    CustomBlockView.prototype.renderToolArea = function () {\n        var _this = this;\n        var tool = document.createElement(\'div\');\n        var span = document.createElement(\'span\');\n        var button = document.createElement(\'button\');\n        tool.className = \'tool\';\n        span.textContent = this.node.attrs.info;\n        span.className = \'info\';\n        button.type = \'button\';\n        button.addEventListener(\'click\', function () { return _this.openEditor(); });\n        tool.appendChild(span);\n        tool.appendChild(button);\n        this.wrapper.appendChild(tool);\n    };\n    CustomBlockView.prototype.renderCustomBlock = function () {\n        var toDOMNode = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info);\n        if (toDOMNode) {\n            var node = toDOMNode(this.node);\n            while (this.wrapper.hasChildNodes()) {\n                this.wrapper.removeChild(this.wrapper.lastChild);\n            }\n            if (node) {\n                this.wrapper.appendChild(node);\n            }\n            this.renderToolArea();\n        }\n    };\n    CustomBlockView.prototype.createInnerViewContainer = function () {\n        this.innerViewContainer = document.createElement(\'div\');\n        this.innerViewContainer.className = cls(\'custom-block-editor\');\n        this.innerViewContainer.style.display = \'none\';\n    };\n    CustomBlockView.prototype.closeEditor = function () {\n        if (this.innerEditorView) {\n            this.innerEditorView.destroy();\n            this.innerEditorView = null;\n            this.innerViewContainer.style.display = \'none\';\n        }\n        this.wrapper.style.display = \'block\';\n    };\n    CustomBlockView.prototype.saveAndFinishEditing = function () {\n        var to = this.editorView.state.selection.to;\n        var outerState = this.editorView.state;\n        this.editorView.dispatch(outerState.tr.setSelection(createTextSelection(outerState.tr, to)));\n        this.editorView.focus();\n        this.renderCustomBlock();\n        this.closeEditor();\n    };\n    CustomBlockView.prototype.cancelEditing = function () {\n        var undoableCount = (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undoDepth)(this.innerEditorView.state);\n        this.canceled = true;\n        // should undo editing result\n        // eslint-disable-next-line no-plusplus\n        while (undoableCount--) {\n            (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(this.innerEditorView.state, this.innerEditorView.dispatch);\n            (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(this.editorView.state, this.editorView.dispatch);\n        }\n        this.canceled = false;\n        var to = this.editorView.state.selection.to;\n        var outerState = this.editorView.state;\n        this.editorView.dispatch(outerState.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(outerState.doc, to)));\n        this.editorView.focus();\n        this.closeEditor();\n    };\n    CustomBlockView.prototype.dispatchInner = function (tr) {\n        var _a = this.innerEditorView.state.applyTransaction(tr), state = _a.state, transactions = _a.transactions;\n        this.innerEditorView.updateState(state);\n        if (!this.canceled && isFunction_1(this.getPos)) {\n            var outerTr = this.editorView.state.tr;\n            var offsetMap = prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.StepMap.offset(this.getPos() + 1);\n            for (var i = 0; i < transactions.length; i += 1) {\n                var steps = transactions[i].steps;\n                for (var j = 0; j < steps.length; j += 1) {\n                    outerTr.step(steps[j].map(offsetMap));\n                }\n            }\n            if (outerTr.docChanged) {\n                this.editorView.dispatch(outerTr);\n            }\n        }\n    };\n    CustomBlockView.prototype.update = function (node) {\n        if (!node.sameMarkup(this.node)) {\n            return false;\n        }\n        this.node = node;\n        if (!this.innerEditorView) {\n            this.renderCustomBlock();\n        }\n        return true;\n    };\n    CustomBlockView.prototype.stopEvent = function (event) {\n        return (!!this.innerEditorView &&\n            !!event.target &&\n            this.innerEditorView.dom.contains(event.target));\n    };\n    CustomBlockView.prototype.ignoreMutation = function () {\n        return true;\n    };\n    CustomBlockView.prototype.destroy = function () {\n        this.dom.removeEventListener(\'dblclick\', this.openEditor);\n        this.closeEditor();\n    };\n    return CustomBlockView;\n}());\n\nvar IMAGE_LINK_CLASS_NAME = \'image-link\';\nvar ImageView = /** @class */ (function () {\n    function ImageView(node, view, getPos, eventEmitter) {\n        var _this = this;\n        var _a;\n        this.handleMousedown = function (ev) {\n            ev.preventDefault();\n            var target = ev.target, offsetX = ev.offsetX, offsetY = ev.offsetY;\n            if (_this.imageLink &&\n                isFunction_1(_this.getPos) &&\n                hasClass_1(target, IMAGE_LINK_CLASS_NAME)) {\n                var style = getComputedStyle(target, \':before\');\n                ev.stopPropagation();\n                if (isPositionInBox(style, offsetX, offsetY)) {\n                    var tr = _this.view.state.tr;\n                    var pos = _this.getPos();\n                    tr.setSelection(createTextSelection(tr, pos, pos + 1));\n                    _this.view.dispatch(tr);\n                    _this.eventEmitter.emit(\'openPopup\', \'link\', _this.imageLink.attrs);\n                }\n            }\n        };\n        this.node = node;\n        this.view = view;\n        this.getPos = getPos;\n        this.eventEmitter = eventEmitter;\n        this.imageLink = (_a = node.marks.filter(function (_a) {\n            var type = _a.type;\n            return type.name === \'link\';\n        })[0]) !== null && _a !== void 0 ? _a : null;\n        this.dom = this.createElement();\n        this.bindEvent();\n    }\n    ImageView.prototype.createElement = function () {\n        var image = this.createImageElement(this.node);\n        if (this.imageLink) {\n            var wrapper = document.createElement(\'span\');\n            wrapper.className = IMAGE_LINK_CLASS_NAME;\n            wrapper.appendChild(image);\n            return wrapper;\n        }\n        return image;\n    };\n    ImageView.prototype.createImageElement = function (node) {\n        var image = document.createElement(\'img\');\n        var _a = node.attrs, imageUrl = _a.imageUrl, altText = _a.altText;\n        var attrs = getCustomAttrs(node.attrs);\n        image.src = imageUrl;\n        if (altText) {\n            image.alt = altText;\n        }\n        setAttributes(attrs, image);\n        return image;\n    };\n    ImageView.prototype.bindEvent = function () {\n        if (this.imageLink) {\n            this.dom.addEventListener(\'mousedown\', this.handleMousedown);\n        }\n    };\n    ImageView.prototype.stopEvent = function () {\n        return true;\n    };\n    ImageView.prototype.destroy = function () {\n        if (this.imageLink) {\n            this.dom.removeEventListener(\'mousedown\', this.handleMousedown);\n        }\n    };\n    return ImageView;\n}());\n\nvar WRAPPER_CLASS_NAME = \'toastui-editor-ww-code-block\';\nvar CODE_BLOCK_LANG_CLASS_NAME = \'toastui-editor-ww-code-block-language\';\nvar CodeBlockView = /** @class */ (function () {\n    function CodeBlockView(node, view, getPos, eventEmitter) {\n        var _this = this;\n        this.contentDOM = null;\n        this.input = null;\n        this.timer = null;\n        this.handleMousedown = function (ev) {\n            var target = ev.target;\n            var style = getComputedStyle(target, \':after\');\n            // judge to click pseudo element with background image for IE11\n            if (style.backgroundImage !== \'none\' && isFunction_1(_this.getPos)) {\n                var _a = _this.view.coordsAtPos(_this.getPos()), top_1 = _a.top, right = _a.right;\n                _this.createLanguageEditor({ top: top_1, right: right });\n            }\n        };\n        this.handleKeydown = function (ev) {\n            if (ev.key === \'Enter\' && _this.input) {\n                ev.preventDefault();\n                _this.changeLanguage();\n            }\n        };\n        this.node = node;\n        this.view = view;\n        this.getPos = getPos;\n        this.eventEmitter = eventEmitter;\n        this.createElement();\n        this.bindDOMEvent();\n        this.bindEvent();\n    }\n    CodeBlockView.prototype.createElement = function () {\n        var language = this.node.attrs.language;\n        var wrapper = document.createElement(\'div\');\n        wrapper.setAttribute(\'data-language\', language || \'text\');\n        wrapper.className = WRAPPER_CLASS_NAME;\n        var pre = this.createCodeBlockElement();\n        var code = pre.firstChild;\n        wrapper.appendChild(pre);\n        this.dom = wrapper;\n        this.contentDOM = code;\n    };\n    CodeBlockView.prototype.createCodeBlockElement = function () {\n        var pre = document.createElement(\'pre\');\n        var code = document.createElement(\'code\');\n        var language = this.node.attrs.language;\n        var attrs = getCustomAttrs(this.node.attrs);\n        if (language) {\n            code.setAttribute(\'data-language\', language);\n        }\n        setAttributes(attrs, pre);\n        pre.appendChild(code);\n        return pre;\n    };\n    CodeBlockView.prototype.createLanguageEditor = function (_a) {\n        var _this = this;\n        var top = _a.top, right = _a.right;\n        var wrapper = document.createElement(\'span\');\n        wrapper.className = CODE_BLOCK_LANG_CLASS_NAME;\n        var input = document.createElement(\'input\');\n        input.type = \'text\';\n        input.value = this.node.attrs.language;\n        wrapper.appendChild(input);\n        this.view.dom.parentElement.appendChild(wrapper);\n        var wrpperWidth = wrapper.clientWidth;\n        css_1(wrapper, {\n            top: top + 10 + "px",\n            left: right - wrpperWidth - 10 + "px",\n            width: wrpperWidth + "px",\n        });\n        this.input = input;\n        this.input.addEventListener(\'blur\', function () { return _this.changeLanguage(); });\n        this.input.addEventListener(\'keydown\', this.handleKeydown);\n        this.clearTimer();\n        this.timer = setTimeout(function () {\n            _this.input.focus();\n        });\n    };\n    CodeBlockView.prototype.bindDOMEvent = function () {\n        if (this.dom) {\n            this.dom.addEventListener(\'click\', this.handleMousedown);\n        }\n    };\n    CodeBlockView.prototype.bindEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen(\'scroll\', function () {\n            if (_this.input) {\n                _this.reset();\n            }\n        });\n    };\n    CodeBlockView.prototype.changeLanguage = function () {\n        if (this.input && isFunction_1(this.getPos)) {\n            var value = this.input.value;\n            this.reset();\n            var pos = this.getPos();\n            var tr = this.view.state.tr;\n            tr.setNodeMarkup(pos, null, { language: value });\n            this.view.dispatch(tr);\n        }\n    };\n    CodeBlockView.prototype.reset = function () {\n        var _a;\n        if ((_a = this.input) === null || _a === void 0 ? void 0 : _a.parentElement) {\n            var parent_1 = this.input.parentElement;\n            this.input = null;\n            removeNode$1(parent_1);\n        }\n    };\n    CodeBlockView.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    CodeBlockView.prototype.stopEvent = function () {\n        return true;\n    };\n    CodeBlockView.prototype.update = function (node) {\n        if (!node.sameMarkup(this.node)) {\n            return false;\n        }\n        this.node = node;\n        return true;\n    };\n    CodeBlockView.prototype.destroy = function () {\n        this.reset();\n        this.clearTimer();\n        if (this.dom) {\n            this.dom.removeEventListener(\'click\', this.handleMousedown);\n        }\n    };\n    return CodeBlockView;\n}());\n\nvar reMSOListClassName = /MsoListParagraph/;\nvar reMSOStylePrefix = /style=(.|\\n)*mso-/;\nvar reMSOListStyle = /mso-list:(.*)/;\nvar reMSOTagName = /O:P/;\nvar reMSOListBullet = /^(n|u|l)/;\nvar MSO_CLASS_NAME_LIST_PARA = \'p.MsoListParagraph\';\nfunction isFromMso(html) {\n    return reMSOStylePrefix.test(html);\n}\nfunction getListItemContents(para) {\n    var removedNodes = [];\n    var walker = document.createTreeWalker(para, 1, null, false);\n    while (walker.nextNode()) {\n        var node = walker.currentNode;\n        if (isElemNode(node)) {\n            var _a = node, outerHTML = _a.outerHTML, textContent = _a.textContent;\n            var msoSpan = reMSOStylePrefix.test(outerHTML);\n            var bulletSpan = reMSOListStyle.test(outerHTML);\n            if (msoSpan && !bulletSpan && textContent) {\n                removedNodes.push([node, true]);\n            }\n            else if (reMSOTagName.test(node.nodeName) || (msoSpan && !textContent) || bulletSpan) {\n                removedNodes.push([node, false]);\n            }\n        }\n    }\n    removedNodes.forEach(function (_a) {\n        var node = _a[0], isUnwrap = _a[1];\n        if (isUnwrap) {\n            unwrapNode(node);\n        }\n        else {\n            removeNode$1(node);\n        }\n    });\n    return para.innerHTML.trim();\n}\nfunction createListItemDataFromParagraph(para, index) {\n    var styleAttr = para.getAttribute(\'style\');\n    if (styleAttr) {\n        var _a = styleAttr.match(reMSOListStyle), listItemInfo = _a[1];\n        var _b = listItemInfo.trim().split(\' \'), levelStr = _b[1];\n        var level = parseInt(levelStr.replace(\'level\', \'\'), 10);\n        var unordered = reMSOListBullet.test(para.textContent || \'\');\n        return {\n            id: index,\n            level: level,\n            prev: null,\n            parent: null,\n            children: [],\n            unordered: unordered,\n            contents: getListItemContents(para),\n        };\n    }\n    return null;\n}\nfunction addListItemDetailData(data, prevData) {\n    if (prevData.level < data.level) {\n        prevData.children.push(data);\n        data.parent = prevData;\n    }\n    else {\n        while (prevData) {\n            if (prevData.level === data.level) {\n                break;\n            }\n            prevData = prevData.parent;\n        }\n        if (prevData) {\n            data.prev = prevData;\n            data.parent = prevData.parent;\n            if (data.parent) {\n                data.parent.children.push(data);\n            }\n        }\n    }\n}\nfunction createListData(paras) {\n    var listData = [];\n    paras.forEach(function (para, index) {\n        var prevListItemData = listData[index - 1];\n        var listItemData = createListItemDataFromParagraph(para, index);\n        if (listItemData) {\n            if (prevListItemData) {\n                addListItemDetailData(listItemData, prevListItemData);\n            }\n            listData.push(listItemData);\n        }\n    });\n    return listData;\n}\nfunction makeList(listData) {\n    var listTagName = listData[0].unordered ? \'ul\' : \'ol\';\n    var list = document.createElement(listTagName);\n    listData.forEach(function (data) {\n        var children = data.children, contents = data.contents;\n        var listItem = document.createElement(\'li\');\n        listItem.innerHTML = contents;\n        list.appendChild(listItem);\n        if (children.length) {\n            list.appendChild(makeList(children));\n        }\n    });\n    return list;\n}\nfunction makeListFromParagraphs(paras) {\n    var listData = createListData(paras);\n    var rootChildren = listData.filter(function (_a) {\n        var parent = _a.parent;\n        return !parent;\n    });\n    return makeList(rootChildren);\n}\nfunction isMsoListParagraphEnd(node) {\n    while (node) {\n        if (isElemNode(node)) {\n            break;\n        }\n        node = node.nextSibling;\n    }\n    return node ? !reMSOListClassName.test(node.className) : true;\n}\nfunction convertMsoParagraphsToList(html) {\n    var container = document.createElement(\'div\');\n    container.innerHTML = html;\n    var paras = [];\n    var foundParas = findNodes(container, MSO_CLASS_NAME_LIST_PARA);\n    foundParas.forEach(function (para) {\n        var msoListParaEnd = isMsoListParagraphEnd(para.nextSibling);\n        paras.push(para);\n        if (msoListParaEnd) {\n            var list = makeListFromParagraphs(paras);\n            var nextSibling = para.nextSibling;\n            if (nextSibling) {\n                insertBeforeNode(list, nextSibling);\n            }\n            else {\n                appendNodes(container, list);\n            }\n            paras = [];\n        }\n        removeNode$1(para);\n    });\n    // without `<p></p>`, the list string was parsed as a paragraph node and added\n    var extraHTML = foundParas.length ? \'<p></p>\' : \'\';\n    return "" + extraHTML + container.innerHTML;\n}\n\nvar START_FRAGMENT_COMMENT = \'\x3c!--StartFragment--\x3e\';\nvar END_FRAGMENT_COMMENT = \'\x3c!--EndFragment--\x3e\';\nfunction getContentBetweenFragmentComments(html) {\n    var startFragmentIndex = html.indexOf(START_FRAGMENT_COMMENT);\n    var endFragmentIndex = html.lastIndexOf(END_FRAGMENT_COMMENT);\n    if (startFragmentIndex > -1 && endFragmentIndex > -1) {\n        html = html.slice(startFragmentIndex + START_FRAGMENT_COMMENT.length, endFragmentIndex);\n    }\n    return html.replace(/<br[^>]*>/g, ALTERNATIVE_TAG_FOR_BR);\n}\nfunction convertMsoTableToCompletedTable(html) {\n    // wrap with <tr> if html contains dangling <td> tags\n    // dangling <td> tag is that tag does not have <tr> as parent node\n    if (/<\\/td>((?!<\\/tr>)[\\s\\S])*$/i.test(html)) {\n        html = "<tr>" + html + "</tr>";\n    }\n    // wrap with <table> if html contains dangling <tr> tags\n    // dangling <tr> tag is that tag does not have <table> as parent node\n    if (/<\\/tr>((?!<\\/table>)[\\s\\S])*$/i.test(html)) {\n        html = "<table>" + html + "</table>";\n    }\n    return html;\n}\nfunction changePastedHTML(html) {\n    html = getContentBetweenFragmentComments(html);\n    html = convertMsoTableToCompletedTable(html);\n    if (isFromMso(html)) {\n        html = convertMsoParagraphsToList(html);\n    }\n    return html;\n}\nfunction getMaxColumnCount(rows) {\n    var row = rows.reduce(function (prevRow, currentRow) {\n        return prevRow.childCount > currentRow.childCount ? prevRow : currentRow;\n    });\n    return row.childCount;\n}\nfunction createCells(orgRow, maxColumnCount, cell) {\n    var cells = [];\n    var cellCount = orgRow.childCount;\n    for (var colIdx = 0; colIdx < cellCount; colIdx += 1) {\n        if (!orgRow.child(colIdx).attrs.extended) {\n            var copiedCell = colIdx < cellCount\n                ? cell.create(orgRow.child(colIdx).attrs, orgRow.child(colIdx).content)\n                : cell.createAndFill();\n            cells.push(copiedCell);\n        }\n    }\n    return cells;\n}\nfunction copyTableHeadRow(orgRow, maxColumnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableHeadCell = _a.tableHeadCell;\n    var cells = createCells(orgRow, maxColumnCount, tableHeadCell);\n    return tableRow.create(null, cells);\n}\nfunction copyTableBodyRow(orgRow, maxColumnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell;\n    var cells = createCells(orgRow, maxColumnCount, tableBodyCell);\n    return tableRow.create(null, cells);\n}\nfunction creatTableBodyDummyRow(columnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell;\n    var cells = [];\n    for (var columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {\n        var dummyCell = tableBodyCell.createAndFill();\n        cells.push(dummyCell);\n    }\n    return tableRow.create({ dummyRowForPasting: true }, cells);\n}\nfunction createRowsFromPastingTable(tableContent) {\n    var tableHeadRows = [];\n    var tableBodyRows = [];\n    if (tableContent.firstChild.type.name === \'tableHead\') {\n        var tableHead = tableContent.firstChild;\n        tableHead.forEach(function (row) { return tableHeadRows.push(row); });\n    }\n    if (tableContent.lastChild.type.name === \'tableBody\') {\n        var tableBody = tableContent.lastChild;\n        tableBody.forEach(function (row) { return tableBodyRows.push(row); });\n    }\n    return __spreadArray$1(__spreadArray$1([], tableHeadRows), tableBodyRows);\n}\nfunction createTableHead(tableHeadRow, maxColumnCount, schema) {\n    var copiedRow = copyTableHeadRow(tableHeadRow, maxColumnCount, schema);\n    return schema.nodes.tableHead.create(null, copiedRow);\n}\nfunction createTableBody(tableBodyRows, maxColumnCount, schema) {\n    var copiedRows = tableBodyRows.map(function (tableBodyRow) {\n        return copyTableBodyRow(tableBodyRow, maxColumnCount, schema);\n    });\n    if (!tableBodyRows.length) {\n        var dummyTableRow = creatTableBodyDummyRow(maxColumnCount, schema);\n        copiedRows.push(dummyTableRow);\n    }\n    return schema.nodes.tableBody.create(null, copiedRows);\n}\nfunction createTableFromPastingTable(rows, schema, startFromBody, isInTable) {\n    var columnCount = getMaxColumnCount(rows);\n    if (startFromBody && isInTable) {\n        return schema.nodes.table.create(null, [createTableBody(rows, columnCount, schema)]);\n    }\n    var tableHeadRow = rows[0];\n    var tableBodyRows = rows.slice(1);\n    var nodes = [createTableHead(tableHeadRow, columnCount, schema)];\n    if (tableBodyRows.length) {\n        nodes.push(createTableBody(tableBodyRows, columnCount, schema));\n    }\n    return schema.nodes.table.create(null, nodes);\n}\nfunction changePastedSlice(slice, schema, isInTable) {\n    var nodes = [];\n    var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;\n    content.forEach(function (node) {\n        if (node.type.name === \'table\') {\n            var tableContent = getTableContentFromSlice(new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node), 0, 0));\n            if (tableContent) {\n                var rows = createRowsFromPastingTable(tableContent);\n                var startFromBody = tableContent.firstChild.type.name === \'tableBody\';\n                var table = createTableFromPastingTable(rows, schema, startFromBody, isInTable);\n                nodes.push(table);\n            }\n        }\n        else {\n            nodes.push(node);\n        }\n    });\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(nodes), openStart, openEnd);\n}\n\nvar DUMMY_CELL_SIZE = 4;\nvar TR_NODES_SIZE = 2;\nfunction getDummyCellSize(dummyCellCount) {\n    return dummyCellCount * DUMMY_CELL_SIZE;\n}\nfunction createPastingCells(tableContent, curSelectionInfo, schema) {\n    var pastingRows = [];\n    var pastingTableRows = createRowsFromPastingTable(tableContent);\n    var columnCount = pastingTableRows[0].childCount;\n    var rowCount = pastingTableRows.length;\n    var startToTableHead = curSelectionInfo.startRowIdx === 0;\n    var slicedRows = pastingTableRows.slice(0, rowCount);\n    if (startToTableHead) {\n        var tableHeadRow = slicedRows.shift();\n        if (tableHeadRow) {\n            var content = copyTableHeadRow(tableHeadRow, columnCount, schema).content;\n            pastingRows.push(content);\n        }\n    }\n    slicedRows.forEach(function (tableBodyRow) {\n        if (!tableBodyRow.attrs.dummyRowForPasting) {\n            var content = copyTableBodyRow(tableBodyRow, columnCount, schema).content;\n            pastingRows.push(content);\n        }\n    });\n    return pastingRows;\n}\nfunction getPastingRangeInfo(map, _a, pastingCells) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx;\n    var pastingRowCount = pastingCells.length;\n    var pastingColumnCount = 0;\n    var _loop_1 = function (i) {\n        var columnCount = pastingCells[i].childCount;\n        pastingCells[i].forEach(function (_a) {\n            var attrs = _a.attrs;\n            var colspan = attrs.colspan;\n            if (colspan > 1) {\n                columnCount += colspan - 1;\n            }\n        });\n        pastingColumnCount = Math.max(pastingColumnCount, columnCount);\n    };\n    for (var i = 0; i < pastingRowCount; i += 1) {\n        _loop_1(i);\n    }\n    var endRowIdx = startRowIdx + pastingRowCount - 1;\n    var endColIdx = startColIdx + pastingColumnCount - 1;\n    var addedRowCount = Math.max(endRowIdx + 1 - map.totalRowCount, 0);\n    var addedColumnCount = Math.max(endColIdx + 1 - map.totalColumnCount, 0);\n    return {\n        startRowIdx: startRowIdx,\n        startColIdx: startColIdx,\n        endRowIdx: endRowIdx,\n        endColIdx: endColIdx,\n        addedRowCount: addedRowCount,\n        addedColumnCount: addedColumnCount,\n    };\n}\nfunction addReplacedOffsets(_a, cellsOffsets) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;\n    for (var rowIdx = startRowIdx; rowIdx <= endRowIdx - addedRowCount; rowIdx += 1) {\n        cellsOffsets.push({\n            rowIdx: rowIdx,\n            startColIdx: startColIdx,\n            endColIdx: endColIdx - addedColumnCount,\n        });\n    }\n}\nfunction expandColumns(tr, schema, map, _a, cellsOffsets) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;\n    var totalRowCount = map.totalRowCount;\n    var index = 0;\n    for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n        var _b = map.getCellInfo(rowIdx, endColIdx - addedColumnCount), offset = _b.offset, nodeSize = _b.nodeSize;\n        var insertOffset = tr.mapping.map(offset + nodeSize);\n        var cells = createDummyCells(addedColumnCount, rowIdx, schema);\n        tr.insert(insertOffset, cells);\n        if (rowIdx >= startRowIdx && rowIdx <= endRowIdx - addedRowCount) {\n            var cellInfo = map.getCellInfo(rowIdx, endColIdx - addedColumnCount);\n            var startCellOffset = tr.mapping.map(cellInfo.offset);\n            var endCellOffset = insertOffset + getDummyCellSize(addedColumnCount);\n            cellsOffsets[index] = {\n                rowIdx: rowIdx,\n                startColIdx: startColIdx,\n                endColIdx: endColIdx,\n                dummyOffsets: [startCellOffset, endCellOffset],\n            };\n            index += 1;\n        }\n    }\n}\nfunction expandRows(tr, schema, map, _a, cellsOffsets) {\n    var addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount, startColIdx = _a.startColIdx, endColIdx = _a.endColIdx;\n    var mapStart = tr.mapping.maps.length;\n    var tableEndPos = map.tableEndOffset - 2;\n    var rows = createTableBodyRows(addedRowCount, map.totalColumnCount + addedColumnCount, schema);\n    var startOffset = tableEndPos;\n    tr.insert(tr.mapping.slice(mapStart).map(startOffset), rows);\n    for (var rowIndex = 0; rowIndex < addedRowCount; rowIndex += 1) {\n        var startCellOffset = startOffset + getDummyCellSize(startColIdx) + 1;\n        var endCellOffset = startOffset + getDummyCellSize(endColIdx + 1) + 1;\n        var nextCellOffset = startOffset + getDummyCellSize(map.totalColumnCount + addedColumnCount) + TR_NODES_SIZE;\n        cellsOffsets.push({\n            rowIdx: rowIndex + map.totalRowCount,\n            startColIdx: startColIdx,\n            endColIdx: endColIdx,\n            dummyOffsets: [startCellOffset, endCellOffset],\n        });\n        startOffset = nextCellOffset;\n    }\n}\nfunction replaceCells(tr, pastingRows, cellsOffsets, map) {\n    var mapStart = tr.mapping.maps.length;\n    cellsOffsets.forEach(function (offsets, index) {\n        var rowIdx = offsets.rowIdx, startColIdx = offsets.startColIdx, endColIdx = offsets.endColIdx, dummyOffsets = offsets.dummyOffsets;\n        var mapping = tr.mapping.slice(mapStart);\n        var cells = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(pastingRows[index], 0, 0);\n        var from = dummyOffsets ? dummyOffsets[0] : map.getCellStartOffset(rowIdx, startColIdx);\n        var to = dummyOffsets ? dummyOffsets[1] : map.getCellEndOffset(rowIdx, endColIdx);\n        tr.replace(mapping.map(from), mapping.map(to), cells);\n    });\n}\nfunction pasteToTable(view, slice) {\n    var _a = view.state, selection = _a.selection, schema = _a.schema, tr = _a.tr;\n    var _b = getResolvedSelection(selection), anchor = _b.anchor, head = _b.head;\n    if (anchor && head) {\n        var tableContent = getTableContentFromSlice(slice);\n        if (!tableContent) {\n            return false;\n        }\n        var map = TableOffsetMap.create(anchor);\n        var curSelectionInfo = map.getRectOffsets(anchor, head);\n        var pastingCells = createPastingCells(tableContent, curSelectionInfo, schema);\n        var pastingInfo = getPastingRangeInfo(map, curSelectionInfo, pastingCells);\n        var cellsOffsets = [];\n        // @TODO: unmerge the span and paste the cell\n        if (canMerge(map, pastingInfo)) {\n            addReplacedOffsets(pastingInfo, cellsOffsets);\n            if (pastingInfo.addedColumnCount) {\n                expandColumns(tr, schema, map, pastingInfo, cellsOffsets);\n            }\n            if (pastingInfo.addedRowCount) {\n                expandRows(tr, schema, map, pastingInfo, cellsOffsets);\n            }\n            replaceCells(tr, pastingCells, cellsOffsets, map);\n            view.dispatch(tr);\n            setSelection(view, cellsOffsets, map.getCellInfo(0, 0).offset);\n        }\n        return true;\n    }\n    return false;\n}\nfunction setSelection(view, cellsOffsets, pos) {\n    var _a = view.state, tr = _a.tr, doc = _a.doc;\n    // get changed cell offsets\n    var map = TableOffsetMap.create(doc.resolve(pos));\n    // eslint-disable-next-line prefer-destructuring\n    var _b = cellsOffsets[0], startRowIdx = _b.rowIdx, startColIdx = _b.startColIdx;\n    var _c = last$1(cellsOffsets), endRowIdx = _c.rowIdx, endColIdx = _c.endColIdx;\n    var startOffset = map.getCellInfo(startRowIdx, startColIdx).offset;\n    var endOffset = map.getCellInfo(endRowIdx, endColIdx).offset;\n    view.dispatch(tr.setSelection(new CellSelection(doc.resolve(startOffset), doc.resolve(endOffset))));\n}\nfunction canMerge(map, pastingInfo) {\n    var ranges = map.getSpannedOffsets(pastingInfo);\n    var _a = getRowAndColumnCount(ranges), rowCount = _a.rowCount, columnCount = _a.columnCount;\n    var _b = getRowAndColumnCount(pastingInfo), pastingRowCount = _b.rowCount, pastingColumnCount = _b.columnCount;\n    return rowCount === pastingRowCount && columnCount === pastingColumnCount;\n}\n\nvar Doc = /** @class */ (function (_super) {\n    __extends$1(Doc, _super);\n    function Doc() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Doc.prototype, "name", {\n        get: function () {\n            return \'doc\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Doc.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'block+\',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Doc;\n}(Node$2));\n\nvar Paragraph = /** @class */ (function (_super) {\n    __extends$1(Paragraph, _super);\n    function Paragraph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Paragraph.prototype, "name", {\n        get: function () {\n            return \'paragraph\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Paragraph.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'inline*\',\n                group: \'block\',\n                attrs: __assign$1({}, getDefaultCustomAttrs()),\n                parseDOM: [{ tag: \'p\' }],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\'p\', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Paragraph;\n}(Node$2));\n\nvar reSoftTabLen = /\\s{1,4}$/;\nvar Text = /** @class */ (function (_super) {\n    __extends$1(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Text.prototype, "name", {\n        get: function () {\n            return \'text\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, "schema", {\n        get: function () {\n            return {\n                group: \'inline\',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Text.prototype.addSpaces = function () {\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var $from = selection.$from, $to = selection.$to;\n            var range = $from.blockRange($to);\n            if (range && !isInListNode($from) && !isInTableNode($from)) {\n                dispatch(tr.insertText(\'    \', $from.pos, $to.pos));\n                return true;\n            }\n            return false;\n        };\n    };\n    Text.prototype.removeSpaces = function () {\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var $from = selection.$from, $to = selection.$to, from = selection.from;\n            var range = $from.blockRange($to);\n            if (range && !isInListNode($from) && !isInTableNode($from)) {\n                var nodeBefore = $from.nodeBefore;\n                if (nodeBefore && nodeBefore.isText) {\n                    var text = nodeBefore.text;\n                    var removedSpaceText = text.replace(reSoftTabLen, \'\');\n                    var spaces = text.length - removedSpaceText.length;\n                    dispatch(tr.delete(from - spaces, from));\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Text.prototype.keymaps = function () {\n        return {\n            Tab: this.addSpaces(),\n            \'Shift-Tab\': this.removeSpaces(),\n        };\n    };\n    return Text;\n}(Node$2));\n\nvar Heading = /** @class */ (function (_super) {\n    __extends$1(Heading, _super);\n    function Heading() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Heading.prototype, "name", {\n        get: function () {\n            return \'heading\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, "levels", {\n        get: function () {\n            return [1, 2, 3, 4, 5, 6];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, "schema", {\n        get: function () {\n            var parseDOM = this.levels.map(function (level) {\n                return {\n                    tag: "h" + level,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute(\'data-raw-html\');\n                        return __assign$1({ level: level }, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ level: { default: 1 }, headingType: { default: \'atx\' }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                content: \'inline*\',\n                group: \'block\',\n                defining: true,\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ["h" + attrs.level, getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Heading.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            var nodeType = state.schema.nodes[payload.level ? \'heading\' : \'paragraph\'];\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(nodeType, payload)(state, dispatch);\n        }; };\n    };\n    return Heading;\n}(Node$2));\n\nvar CodeBlock = /** @class */ (function (_super) {\n    __extends$1(CodeBlock, _super);\n    function CodeBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CodeBlock.prototype, "name", {\n        get: function () {\n            return \'codeBlock\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CodeBlock.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'text*\',\n                group: \'block\',\n                attrs: __assign$1({ language: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                code: true,\n                defining: true,\n                marks: \'\',\n                parseDOM: [\n                    {\n                        tag: \'pre\',\n                        preserveWhitespace: \'full\',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute(\'data-raw-html\');\n                            var child = dom.firstElementChild;\n                            return __assign$1({ language: (child === null || child === void 0 ? void 0 : child.getAttribute(\'data-language\')) || null }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || \'pre\',\n                        [\'code\', __assign$1({ \'data-language\': attrs.language }, getCustomAttrs(attrs)), 0],\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CodeBlock.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(state.schema.nodes.codeBlock)(state, dispatch); }; };\n    };\n    CodeBlock.prototype.moveCursor = function (direction) {\n        var _this = this;\n        return function (state, dispatch) {\n            var tr = state.tr, doc = state.doc, schema = state.schema;\n            var $from = state.selection.$from;\n            var view = _this.context.view;\n            if (view.endOfTextblock(direction) && $from.node().type.name === \'codeBlock\') {\n                var lines = $from.parent.textContent.split(\'\\n\');\n                var offset = direction === \'up\' ? $from.start() : $from.end();\n                var range = direction === \'up\'\n                    ? [offset, lines[0].length + offset]\n                    : [offset - last$1(lines).length, offset];\n                var pos = doc.resolve(direction === \'up\' ? $from.before() : $from.after());\n                var node = direction === \'up\' ? pos.nodeBefore : pos.nodeAfter;\n                if (between$1($from.pos, range[0], range[1]) && !node) {\n                    var newTr = addParagraph(tr, pos, schema);\n                    if (newTr) {\n                        dispatch(newTr);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n    };\n    CodeBlock.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return {\n            \'Shift-Mod-p\': codeCommand,\n            \'Shift-Mod-P\': codeCommand,\n            ArrowUp: this.moveCursor(\'up\'),\n            ArrowDown: this.moveCursor(\'down\'),\n        };\n    };\n    return CodeBlock;\n}(Node$2));\n\nvar BulletList = /** @class */ (function (_super) {\n    __extends$1(BulletList, _super);\n    function BulletList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BulletList.prototype, "name", {\n        get: function () {\n            return \'bulletList\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BulletList.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'listItem+\',\n                group: \'block\',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML(\'ul\')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\'ul\', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BulletList.prototype.changeList = function () {\n        return function (state, dispatch) { return changeList(state.schema.nodes.bulletList)(state, dispatch); };\n    };\n    BulletList.prototype.commands = function () {\n        return {\n            bulletList: this.changeList,\n            taskList: toggleTask,\n        };\n    };\n    BulletList.prototype.keymaps = function () {\n        var bulletListCommand = this.changeList();\n        var _a = getWwCommands(), indent = _a.indent, outdent = _a.outdent;\n        return {\n            \'Mod-u\': bulletListCommand,\n            \'Mod-U\': bulletListCommand,\n            Tab: indent(),\n            \'Shift-Tab\': outdent(),\n        };\n    };\n    return BulletList;\n}(Node$2));\n\nvar OrderedList = /** @class */ (function (_super) {\n    __extends$1(OrderedList, _super);\n    function OrderedList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(OrderedList.prototype, "name", {\n        get: function () {\n            return \'orderedList\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OrderedList.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'listItem+\',\n                group: \'block\',\n                attrs: __assign$1({ order: { default: 1 }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: \'ol\',\n                        getAttrs: function (dom) {\n                            var start = dom.getAttribute(\'start\');\n                            var rawHTML = dom.getAttribute(\'data-raw-html\');\n                            return __assign$1({ order: dom.hasAttribute(\'start\') ? Number(start) : 1 }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || \'ol\',\n                        __assign$1({ start: attrs.order === 1 ? null : attrs.order }, getCustomAttrs(attrs)),\n                        0,\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    OrderedList.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return changeList(state.schema.nodes.orderedList)(state, dispatch); }; };\n    };\n    OrderedList.prototype.keymaps = function () {\n        var orderedListCommand = this.commands()();\n        var _a = getWwCommands(), indent = _a.indent, outdent = _a.outdent;\n        return {\n            \'Mod-o\': orderedListCommand,\n            \'Mod-O\': orderedListCommand,\n            Tab: indent(),\n            \'Shift-Tab\': outdent(),\n        };\n    };\n    return OrderedList;\n}(Node$2));\n\nvar ListItem = /** @class */ (function (_super) {\n    __extends$1(ListItem, _super);\n    function ListItem() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ListItem.prototype, "name", {\n        get: function () {\n            return \'listItem\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ListItem.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'paragraph block*\',\n                selectable: false,\n                attrs: {\n                    task: { default: false },\n                    checked: { default: false },\n                    rawHTML: { default: null },\n                },\n                defining: true,\n                parseDOM: [\n                    {\n                        tag: \'li\',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute(\'data-raw-html\');\n                            return __assign$1({ task: dom.hasAttribute(\'data-task\'), checked: dom.hasAttribute(\'data-task-checked\') }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var task = attrs.task, checked = attrs.checked;\n                    if (!task) {\n                        return [attrs.rawHTML || \'li\', 0];\n                    }\n                    var classNames = [\'task-list-item\'];\n                    if (checked) {\n                        classNames.push(\'checked\');\n                    }\n                    return [\n                        attrs.rawHTML || \'li\',\n                        __assign$1({ class: classNames.join(\' \'), \'data-task\': task }, (checked && { \'data-task-checked\': checked })),\n                        0,\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ListItem.prototype.liftToPrevListItem = function () {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var $from = selection.$from, empty = selection.empty;\n            var listItem = schema.nodes.listItem;\n            var parent = $from.parent;\n            var listItemParent = $from.node(-1);\n            if (empty && !parent.childCount && listItemParent.type === listItem) {\n                // move to previous sibling list item when the current list item is not top list item\n                if ($from.index(-2) >= 1) {\n                    // should subtract \'1\' for considering tag length(<li>)\n                    tr.delete($from.start(-1) - 1, $from.end(-1));\n                    dispatch(tr);\n                    return true;\n                }\n                var grandParentListItem = $from.node(-3);\n                // move to parent list item when the current list item is top list item\n                if (grandParentListItem.type === listItem) {\n                    // should subtract \'1\' for considering tag length(<ul>)\n                    tr.delete($from.start(-2) - 1, $from.end(-1));\n                    dispatch(tr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    ListItem.prototype.keymaps = function () {\n        var split = function (state, dispatch) {\n            return splitListItem(state.schema.nodes.listItem)(state, dispatch);\n        };\n        return {\n            Backspace: this.liftToPrevListItem(),\n            Enter: split,\n        };\n    };\n    return ListItem;\n}(Node$2));\n\nvar BlockQuote = /** @class */ (function (_super) {\n    __extends$1(BlockQuote, _super);\n    function BlockQuote() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BlockQuote.prototype, "name", {\n        get: function () {\n            return \'blockQuote\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BlockQuote.prototype, "schema", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                content: \'block+\',\n                group: \'block\',\n                parseDOM: [createDOMInfoParsedRawHTML(\'blockquote\')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\'blockquote\', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BlockQuote.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.wrapIn)(state.schema.nodes.blockQuote)(state, dispatch); }; };\n    };\n    BlockQuote.prototype.keymaps = function () {\n        var blockQutoeCommand = this.commands()();\n        return {\n            \'Alt-q\': blockQutoeCommand,\n            \'Alt-Q\': blockQutoeCommand,\n        };\n    };\n    return BlockQuote;\n}(Node$2));\n\nvar cellOffsetFnMap = {\n    left: getLeftCellOffset,\n    right: getRightCellOffset,\n    up: getUpCellOffset,\n    down: getDownCellOffset,\n};\nfunction isInFirstListItem(pos, doc, _a) {\n    var paraDepth = _a[0], listDepth = _a[1];\n    var listItemNode = doc.resolve(pos.before(paraDepth - 1));\n    return listDepth === paraDepth && !listItemNode.nodeBefore;\n}\nfunction isInLastListItem(pos) {\n    var _a;\n    var depth = pos.depth;\n    var parentNode;\n    while (depth) {\n        parentNode = pos.node(depth);\n        if (parentNode.type.name === \'tableBodyCell\') {\n            break;\n        }\n        if (parentNode.type.name === \'listItem\') {\n            var grandParent = pos.node(depth - 1);\n            var lastListItem = grandParent.lastChild === parentNode;\n            var hasChildren = ((_a = parentNode.lastChild) === null || _a === void 0 ? void 0 : _a.type.name) !== \'paragraph\';\n            if (!lastListItem) {\n                return false;\n            }\n            return !hasChildren;\n        }\n        depth -= 1;\n    }\n    return false;\n}\nfunction canMoveToBeforeCell(direction, _a, from, doc, inList) {\n    var paraDepth = _a[0], listDepth = _a[1], curDepth = _a[2];\n    if (direction === "left" /* LEFT */ || direction === "up" /* UP */) {\n        if (inList && !isInFirstListItem(from, doc, [paraDepth, listDepth])) {\n            return false;\n        }\n        var endOffset = from.before(curDepth);\n        var nodeBefore = doc.resolve(endOffset).nodeBefore;\n        if (nodeBefore) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canMoveToAfterCell(direction, curDepth, from, doc, inList) {\n    if (direction === "right" /* RIGHT */ || direction === "down" /* DOWN */) {\n        if (inList && !isInLastListItem(from)) {\n            return false;\n        }\n        var endOffset = from.after(curDepth);\n        var nodeAfter = doc.resolve(endOffset).nodeAfter;\n        if (nodeAfter) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canMoveBetweenCells(direction, _a, from, doc) {\n    var cellDepth = _a[0], paraDepth = _a[1];\n    var listDepth = cellDepth + 3; // 3 is position of <ul><li><p>\n    var inList = paraDepth >= listDepth;\n    var curDepth = inList ? cellDepth + 1 : paraDepth;\n    var moveBeforeCell = canMoveToBeforeCell(direction, [paraDepth, listDepth, curDepth], from, doc, inList);\n    var moveAfterCell = canMoveToAfterCell(direction, curDepth, from, doc, inList);\n    return moveBeforeCell && moveAfterCell;\n}\nfunction canBeOutOfTable(direction, map, _a) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var rowspanInfo = map.getRowspanStartInfo(rowIdx, colIdx);\n    var inFirstRow = direction === "up" /* UP */ && rowIdx === 0;\n    var inLastRow = direction === "down" /* DOWN */ &&\n        ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1 ? rowIdx + rowspanInfo.count - 1 : rowIdx) === map.totalRowCount - 1;\n    return inFirstRow || inLastRow;\n}\nfunction addParagraphBeforeTable(tr, map, schema) {\n    var tableStartPos = tr.doc.resolve(map.tableStartOffset - 1);\n    if (!tableStartPos.nodeBefore) {\n        return addParagraph(tr, tableStartPos, schema);\n    }\n    return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tableStartPos, -1));\n}\nfunction addParagraphAfterTable(tr, map, schema, forcedAddtion) {\n    if (forcedAddtion === void 0) { forcedAddtion = false; }\n    var tableEndPos = tr.doc.resolve(map.tableEndOffset);\n    if (forcedAddtion || !tableEndPos.nodeAfter) {\n        return addParagraph(tr, tableEndPos, schema);\n    }\n    return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tableEndPos, 1));\n}\nfunction getRightCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;\n    var lastCellInRow = colIdx === totalColumnCount - 1;\n    var lastCellInTable = rowIdx === totalRowCount - 1 && lastCellInRow;\n    if (!lastCellInTable) {\n        var nextColIdx = colIdx + 1;\n        var colspanInfo = map.getColspanStartInfo(rowIdx, colIdx);\n        if ((colspanInfo === null || colspanInfo === void 0 ? void 0 : colspanInfo.count) > 1) {\n            nextColIdx += colspanInfo.count - 1;\n        }\n        if (lastCellInRow || nextColIdx === totalColumnCount) {\n            rowIdx += 1;\n            nextColIdx = 0;\n        }\n        var offset = map.getCellInfo(rowIdx, nextColIdx).offset;\n        return offset + 2;\n    }\n    return null;\n}\nfunction getLeftCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalColumnCount = map.totalColumnCount;\n    var firstCellInRow = colIdx === 0;\n    var firstCellInTable = rowIdx === 0 && firstCellInRow;\n    if (!firstCellInTable) {\n        colIdx -= 1;\n        if (firstCellInRow) {\n            rowIdx -= 1;\n            colIdx = totalColumnCount - 1;\n        }\n        var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n        return offset + nodeSize - 2;\n    }\n    return null;\n}\nfunction getUpCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    if (rowIdx > 0) {\n        var _b = map.getCellInfo(rowIdx - 1, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n        return offset + nodeSize - 2;\n    }\n    return null;\n}\nfunction getDownCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalRowCount = map.totalRowCount;\n    if (rowIdx < totalRowCount - 1) {\n        var nextRowIdx = rowIdx + 1;\n        var rowspanInfo = map.getRowspanStartInfo(rowIdx, colIdx);\n        if ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1) {\n            nextRowIdx += rowspanInfo.count - 1;\n        }\n        var offset = map.getCellInfo(nextRowIdx, colIdx).offset;\n        return offset + 2;\n    }\n    return null;\n}\nfunction moveToCell(direction, tr, cellIndex, map) {\n    var cellOffsetFn = cellOffsetFnMap[direction];\n    var offset = cellOffsetFn(cellIndex, map);\n    if (offset) {\n        var dir = direction === "right" /* RIGHT */ || direction === "down" /* DOWN */ ? 1 : -1;\n        return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(offset), dir));\n    }\n    return null;\n}\nfunction canSelectTableNode(direction, map, _a) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    if (direction === "up" /* UP */ || direction === "down" /* DOWN */) {\n        return false;\n    }\n    var tableStartOffset = map.tableStartOffset, tableEndOffset = map.tableEndOffset;\n    var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n    var pos = direction === "left" /* LEFT */ ? tableStartOffset : tableEndOffset;\n    var curPos = direction === "left" /* LEFT */ ? offset - 2 : offset + nodeSize + 3;\n    return pos === curPos;\n}\nfunction selectNode(tr, pos, depth) {\n    var tablePos = tr.doc.resolve(pos.before(depth - 3));\n    return tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection(tablePos));\n}\n\nfunction getTargetRowInfo(direction, map, selectionInfo) {\n    var targetRowIdx;\n    var insertColIdx;\n    var nodeSize;\n    if (direction === "up" /* UP */) {\n        targetRowIdx = selectionInfo.startRowIdx;\n        insertColIdx = 0;\n        nodeSize = -1;\n    }\n    else {\n        targetRowIdx = selectionInfo.endRowIdx;\n        insertColIdx = map.totalColumnCount - 1;\n        nodeSize = map.getCellInfo(targetRowIdx, insertColIdx).nodeSize + 1;\n    }\n    return { targetRowIdx: targetRowIdx, insertColIdx: insertColIdx, nodeSize: nodeSize };\n}\nfunction getRowRanges(map, rowIdx, totalColumnCount) {\n    var startOffset = map.getCellInfo(rowIdx, 0).offset;\n    var _a = map.getCellInfo(rowIdx, totalColumnCount - 1), offset = _a.offset, nodeSize = _a.nodeSize;\n    return { from: startOffset, to: offset + nodeSize };\n}\nvar Table = /** @class */ (function (_super) {\n    __extends$1(Table, _super);\n    function Table() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Table.prototype, "name", {\n        get: function () {\n            return \'table\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Table.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'tableHead{1} tableBody{1}\',\n                group: \'block\',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML(\'table\')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\'table\', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Table.prototype.addTable = function () {\n        return function (payload) {\n            if (payload === void 0) { payload = { rowCount: 2, columnCount: 1, data: [] }; }\n            return function (state, dispatch) {\n                var rowCount = payload.rowCount, columnCount = payload.columnCount, data = payload.data;\n                var schema = state.schema, selection = state.selection, tr = state.tr;\n                var from = selection.from, to = selection.to, $from = selection.$from;\n                var collapsed = from === to;\n                if (collapsed && !isInTableNode($from)) {\n                    var _a = schema.nodes, tableHead = _a.tableHead, tableBody = _a.tableBody;\n                    var theadData = data === null || data === void 0 ? void 0 : data.slice(0, columnCount);\n                    var tbodyData = data === null || data === void 0 ? void 0 : data.slice(columnCount, data.length);\n                    var tableHeadRow = createTableHeadRow(columnCount, schema, theadData);\n                    var tableBodyRows = createTableBodyRows(rowCount - 1, columnCount, schema, tbodyData);\n                    var table = schema.nodes.table.create(null, [\n                        tableHead.create(null, tableHeadRow),\n                        tableBody.create(null, tableBodyRows),\n                    ]);\n                    dispatch(tr.replaceSelectionWith(table));\n                    return true;\n                }\n                return false;\n            };\n        };\n    };\n    Table.prototype.removeTable = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var map = TableOffsetMap.create(selection.$anchor);\n            if (map) {\n                var tableStartOffset = map.tableStartOffset, tableEndOffset = map.tableEndOffset;\n                var startOffset = tableStartOffset - 1;\n                var cursorPos = createTextSelection(tr.delete(startOffset, tableEndOffset), startOffset);\n                dispatch(tr.setSelection(cursorPos));\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.addColumn = function (direction) {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var targetColIdx = direction === "left" /* LEFT */ ? selectionInfo.startColIdx : selectionInfo.endColIdx + 1;\n                var columnCount = getRowAndColumnCount(selectionInfo).columnCount;\n                var totalRowCount = map.totalRowCount;\n                for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                    var cells = createDummyCells(columnCount, rowIdx, schema);\n                    tr.insert(tr.mapping.map(map.posAt(rowIdx, targetColIdx)), cells);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.removeColumn = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var totalColumnCount = map.totalColumnCount, totalRowCount = map.totalRowCount;\n                var columnCount = getRowAndColumnCount(selectionInfo).columnCount;\n                var selectedAllColumn = columnCount === totalColumnCount;\n                if (selectedAllColumn) {\n                    return false;\n                }\n                var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;\n                var mapStart = tr.mapping.maps.length;\n                for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                    for (var colIdx = endColIdx; colIdx >= startColIdx; colIdx -= 1) {\n                        var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n                        var from = tr.mapping.slice(mapStart).map(offset);\n                        var to = from + nodeSize;\n                        tr.delete(from, to);\n                    }\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.addRow = function (direction) {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var totalColumnCount = map.totalColumnCount;\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var rowCount = getRowAndColumnCount(selectionInfo).rowCount;\n                var _b = getTargetRowInfo(direction, map, selectionInfo), targetRowIdx = _b.targetRowIdx, insertColIdx = _b.insertColIdx, nodeSize = _b.nodeSize;\n                var selectedThead = targetRowIdx === 0;\n                if (!selectedThead) {\n                    var rows = [];\n                    var from = tr.mapping.map(map.posAt(targetRowIdx, insertColIdx)) + nodeSize;\n                    var cells = [];\n                    for (var colIdx = 0; colIdx < totalColumnCount; colIdx += 1) {\n                        cells = cells.concat(createDummyCells(1, targetRowIdx, schema));\n                    }\n                    for (var i = 0; i < rowCount; i += 1) {\n                        rows.push(schema.nodes.tableRow.create(null, cells));\n                    }\n                    dispatch(tr.insert(from, rows));\n                    return true;\n                }\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.removeRow = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var rowCount = getRowAndColumnCount(selectionInfo).rowCount;\n                var startRowIdx = selectionInfo.startRowIdx, endRowIdx = selectionInfo.endRowIdx;\n                var selectedThead = startRowIdx === 0;\n                var selectedAllTbodyRow = rowCount === totalRowCount - 1;\n                if (selectedAllTbodyRow || selectedThead) {\n                    return false;\n                }\n                for (var rowIdx = endRowIdx; rowIdx >= startRowIdx; rowIdx -= 1) {\n                    var _b = getRowRanges(map, rowIdx, totalColumnCount), from = _b.from, to = _b.to;\n                    // delete table row\n                    tr.delete(from - 1, to + 1);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.alignColumn = function () {\n        return function (payload) {\n            if (payload === void 0) { payload = { align: \'center\' }; }\n            return function (state, dispatch) {\n                var align = payload.align;\n                var selection = state.selection, tr = state.tr;\n                var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n                if (anchor && head) {\n                    var map = TableOffsetMap.create(anchor);\n                    var totalRowCount = map.totalRowCount;\n                    var selectionInfo = map.getRectOffsets(anchor, head);\n                    var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;\n                    for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                        for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                            if (!map.extendedRowspan(rowIdx, colIdx) && !map.extendedColspan(rowIdx, colIdx)) {\n                                var _b = map.getNodeAndPos(rowIdx, colIdx), node = _b.node, pos = _b.pos;\n                                var attrs = setAttrs(node, { align: align });\n                                tr.setNodeMarkup(pos, null, attrs);\n                            }\n                        }\n                    }\n                    dispatch(tr);\n                    return true;\n                }\n                return false;\n            };\n        };\n    };\n    Table.prototype.moveToCell = function (direction) {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var cellIndex = map.getCellIndex(anchor);\n                var newTr = void 0;\n                if (canBeOutOfTable(direction, map, cellIndex)) {\n                    // When there is no content before or after the table,\n                    // an empty line(\'paragraph\') is created by pressing the arrow keys.\n                    newTr = addParagraphAfterTable(tr, map, schema);\n                }\n                else {\n                    newTr = moveToCell(direction, tr, cellIndex, map);\n                }\n                if (newTr) {\n                    dispatch(newTr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.moveInCell = function (direction) {\n        var _this = this;\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, doc = state.doc, schema = state.schema;\n            var $from = selection.$from;\n            var view = _this.context.view;\n            if (!view.endOfTextblock(direction)) {\n                return false;\n            }\n            var cell = findNodeBy($from, function (_a) {\n                var type = _a.type;\n                return type.name === \'tableHeadCell\' || type.name === \'tableBodyCell\';\n            });\n            if (cell) {\n                var para = findNodeBy($from, function (_a) {\n                    var type = _a.type;\n                    return type.name === \'paragraph\';\n                });\n                var cellDepth = cell.depth;\n                if (para && canMoveBetweenCells(direction, [cellDepth, para.depth], $from, doc)) {\n                    var anchor = getResolvedSelection(selection).anchor;\n                    var map = TableOffsetMap.create(anchor);\n                    var cellIndex = map.getCellIndex(anchor);\n                    var newTr = void 0;\n                    if (canSelectTableNode(direction, map, cellIndex)) {\n                        // When the cursor position is at the end of the cell,\n                        // the table is selected when the left / right arrow keys are pressed.\n                        newTr = selectNode(tr, $from, cellDepth);\n                    }\n                    else if (canBeOutOfTable(direction, map, cellIndex)) {\n                        // When there is no content before or after the table,\n                        // an empty line(\'paragraph\') is created by pressing the arrow keys.\n                        if (direction === "up" /* UP */) {\n                            newTr = addParagraphBeforeTable(tr, map, schema);\n                        }\n                        else if (direction === "down" /* DOWN */) {\n                            newTr = addParagraphAfterTable(tr, map, schema);\n                        }\n                    }\n                    else {\n                        newTr = moveToCell(direction, tr, cellIndex, map);\n                    }\n                    if (newTr) {\n                        dispatch(newTr);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.deleteCells = function () {\n        return function (state, dispatch) {\n            var schema = state.schema, selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            var textSelection = selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;\n            if (anchor && head && !textSelection) {\n                var map = TableOffsetMap.create(anchor);\n                var _b = map.getRectOffsets(anchor, head), startRowIdx = _b.startRowIdx, startColIdx = _b.startColIdx, endRowIdx = _b.endRowIdx, endColIdx = _b.endColIdx;\n                for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n                    for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                        if (!map.extendedRowspan(rowIdx, colIdx) && !map.extendedColspan(rowIdx, colIdx)) {\n                            var _c = map.getNodeAndPos(rowIdx, colIdx), node = _c.node, pos = _c.pos;\n                            var cells = createDummyCells(1, rowIdx, schema, node.attrs);\n                            tr.replaceWith(tr.mapping.map(pos), tr.mapping.map(pos + node.nodeSize), cells);\n                        }\n                    }\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.exitTable = function () {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var $from = selection.$from;\n            var cell = findNodeBy($from, function (_a) {\n                var type = _a.type;\n                return type.name === \'tableHeadCell\' || type.name === \'tableBodyCell\';\n            });\n            if (cell) {\n                var para = findNodeBy($from, function (_a) {\n                    var type = _a.type;\n                    return type.name === \'paragraph\';\n                });\n                if (para) {\n                    var anchor = getResolvedSelection(selection).anchor;\n                    var map = TableOffsetMap.create(anchor);\n                    dispatch(addParagraphAfterTable(tr, map, schema, true));\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.commands = function () {\n        return {\n            addTable: this.addTable(),\n            removeTable: this.removeTable(),\n            addColumnToLeft: this.addColumn("left" /* LEFT */),\n            addColumnToRight: this.addColumn("right" /* RIGHT */),\n            removeColumn: this.removeColumn(),\n            addRowToUp: this.addRow("up" /* UP */),\n            addRowToDown: this.addRow("down" /* DOWN */),\n            removeRow: this.removeRow(),\n            alignColumn: this.alignColumn(),\n        };\n    };\n    Table.prototype.keymaps = function () {\n        var deleteCellContent = this.deleteCells();\n        return {\n            Tab: this.moveToCell("right" /* RIGHT */),\n            \'Shift-Tab\': this.moveToCell("left" /* LEFT */),\n            ArrowUp: this.moveInCell("up" /* UP */),\n            ArrowDown: this.moveInCell("down" /* DOWN */),\n            ArrowLeft: this.moveInCell("left" /* LEFT */),\n            ArrowRight: this.moveInCell("right" /* RIGHT */),\n            Backspace: deleteCellContent,\n            \'Mod-Backspace\': deleteCellContent,\n            Delete: deleteCellContent,\n            \'Mod-Delete\': deleteCellContent,\n            \'Mod-Enter\': this.exitTable(),\n        };\n    };\n    return Table;\n}(Node$2));\n\nvar TableHead = /** @class */ (function (_super) {\n    __extends$1(TableHead, _super);\n    function TableHead() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableHead.prototype, "name", {\n        get: function () {\n            return \'tableHead\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableHead.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'tableRow{1}\',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML(\'thead\')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\'thead\', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableHead;\n}(Node$2));\n\nvar TableBody = /** @class */ (function (_super) {\n    __extends$1(TableBody, _super);\n    function TableBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableBody.prototype, "name", {\n        get: function () {\n            return \'tableBody\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableBody.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'tableRow+\',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: \'tbody\',\n                        getAttrs: function (dom) {\n                            var rows = dom.querySelectorAll(\'tr\');\n                            var columns = rows[0].children.length;\n                            var rawHTML = dom.getAttribute(\'data-raw-html\');\n                            if (!columns) {\n                                return false;\n                            }\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\'tbody\', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableBody;\n}(Node$2));\n\nvar TableRow = /** @class */ (function (_super) {\n    __extends$1(TableRow, _super);\n    function TableRow() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableRow.prototype, "name", {\n        get: function () {\n            return \'tableRow\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableRow.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'(tableHeadCell | tableBodyCell)*\',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: \'tr\',\n                        getAttrs: function (dom) {\n                            var columns = dom.children.length;\n                            var rawHTML = dom.getAttribute(\'data-raw-html\');\n                            if (!columns) {\n                                return false;\n                            }\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\'tr\', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableRow;\n}(Node$2));\n\nvar TableHeadCell = /** @class */ (function (_super) {\n    __extends$1(TableHeadCell, _super);\n    function TableHeadCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableHeadCell.prototype, "name", {\n        get: function () {\n            return \'tableHeadCell\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableHeadCell.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'paragraph+\',\n                attrs: __assign$1({ align: { default: null }, className: { default: null }, rawHTML: { default: null }, colspan: { default: null }, extended: { default: null } }, getDefaultCustomAttrs()),\n                isolating: true,\n                parseDOM: [createParsedCellDOM(\'th\')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var cellAttrs = createCellAttrs(attrs);\n                    return [\'th\', __assign$1(__assign$1({}, cellAttrs), getCustomAttrs(attrs)), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableHeadCell;\n}(Node$2));\n\nvar TableBodyCell = /** @class */ (function (_super) {\n    __extends$1(TableBodyCell, _super);\n    function TableBodyCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableBodyCell.prototype, "name", {\n        get: function () {\n            return \'tableBodyCell\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableBodyCell.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'(paragraph | bulletList | orderedList)+\',\n                attrs: {\n                    align: { default: null },\n                    className: { default: null },\n                    rawHTML: { default: null },\n                    colspan: { default: null },\n                    rowspan: { default: null },\n                    extended: { default: null },\n                },\n                isolating: true,\n                parseDOM: [createParsedCellDOM(\'td\')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var cellAttrs = createCellAttrs(attrs);\n                    return [\'td\', cellAttrs, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableBodyCell;\n}(Node$2));\n\nvar Image = /** @class */ (function (_super) {\n    __extends$1(Image, _super);\n    function Image() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Image.prototype, "name", {\n        get: function () {\n            return \'image\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Image.prototype, "schema", {\n        get: function () {\n            return {\n                inline: true,\n                attrs: __assign$1({ imageUrl: { default: \'\' }, altText: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                group: \'inline\',\n                selectable: false,\n                parseDOM: [\n                    {\n                        tag: \'img[src]\',\n                        getAttrs: function (dom) {\n                            var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true })\n                                .firstChild;\n                            var imageUrl = sanitizedDOM.getAttribute(\'src\') || \'\';\n                            var rawHTML = sanitizedDOM.getAttribute(\'data-raw-html\');\n                            var altText = sanitizedDOM.getAttribute(\'alt\');\n                            return __assign$1({ imageUrl: imageUrl,\n                                altText: altText }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || \'img\',\n                        __assign$1(__assign$1({ src: escapeXml$1(attrs.imageUrl) }, (attrs.altText && { alt: attrs.altText })), getCustomAttrs(attrs)),\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Image.prototype.addImage = function () {\n        return function (payload) { return function (_a, dispatch) {\n            var schema = _a.schema, tr = _a.tr;\n            var _b = payload, imageUrl = _b.imageUrl, altText = _b.altText;\n            if (!imageUrl) {\n                return false;\n            }\n            var node = schema.nodes.image.createAndFill(__assign$1({ imageUrl: imageUrl }, (altText && { altText: altText })));\n            dispatch(tr.replaceSelectionWith(node).scrollIntoView());\n            return true;\n        }; };\n    };\n    Image.prototype.commands = function () {\n        return {\n            addImage: this.addImage(),\n        };\n    };\n    return Image;\n}(Node$2));\n\nvar ROOT_BLOCK_DEPTH = 1;\nvar ThematicBreak = /** @class */ (function (_super) {\n    __extends$1(ThematicBreak, _super);\n    function ThematicBreak() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ThematicBreak.prototype, "name", {\n        get: function () {\n            return \'thematicBreak\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThematicBreak.prototype, "schema", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                group: \'block\',\n                parseDOM: [{ tag: \'hr\' }],\n                selectable: false,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\'div\', getCustomAttrs(attrs), [attrs.rawHTML || \'hr\']];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ThematicBreak.prototype.hr = function () {\n        var _this = this;\n        return function () { return function (state, dispatch) {\n            var _a;\n            var _b = state.selection, $from = _b.$from, $to = _b.$to;\n            if ($from === $to) {\n                var doc = state.doc;\n                var _c = state.schema.nodes, thematicBreak = _c.thematicBreak, paragraph = _c.paragraph;\n                var nodes = [thematicBreak.create()];\n                var rootBlock = $from.node(ROOT_BLOCK_DEPTH);\n                var lastBlock = doc.child(doc.childCount - 1) === rootBlock;\n                var blockEnd = doc.resolve($from.after(ROOT_BLOCK_DEPTH));\n                var nextHr = ((_a = $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.type.name) === _this.name;\n                if (lastBlock || nextHr) {\n                    nodes.push(paragraph.create());\n                }\n                dispatch(state.tr.insert(blockEnd.pos, nodes).scrollIntoView());\n                return true;\n            }\n            return false;\n        }; };\n    };\n    ThematicBreak.prototype.commands = function () {\n        return { hr: this.hr() };\n    };\n    ThematicBreak.prototype.keymaps = function () {\n        var hrCommand = this.hr()();\n        return {\n            \'Mod-l\': hrCommand,\n            \'Mod-L\': hrCommand,\n        };\n    };\n    return ThematicBreak;\n}(Node$2));\n\nvar Strong = /** @class */ (function (_super) {\n    __extends$1(Strong, _super);\n    function Strong() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strong.prototype, "name", {\n        get: function () {\n            return \'strong\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strong.prototype, "schema", {\n        get: function () {\n            var parseDOM = [\'b\', \'strong\'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute(\'data-raw-html\');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || \'strong\', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strong.prototype.bold = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.strong)(state, dispatch); }; };\n    };\n    Strong.prototype.commands = function () {\n        return { bold: this.bold() };\n    };\n    Strong.prototype.keymaps = function () {\n        var boldCommand = this.bold()();\n        return {\n            \'Mod-b\': boldCommand,\n            \'Mod-B\': boldCommand,\n        };\n    };\n    return Strong;\n}(Mark));\n\nvar Emph = /** @class */ (function (_super) {\n    __extends$1(Emph, _super);\n    function Emph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Emph.prototype, "name", {\n        get: function () {\n            return \'emph\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Emph.prototype, "schema", {\n        get: function () {\n            var parseDOM = [\'i\', \'em\'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute(\'data-raw-html\');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || \'em\', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Emph.prototype.italic = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.emph)(state, dispatch); }; };\n    };\n    Emph.prototype.commands = function () {\n        return { italic: this.italic() };\n    };\n    Emph.prototype.keymaps = function () {\n        var italicCommand = this.italic()();\n        return {\n            \'Mod-i\': italicCommand,\n            \'Mod-I\': italicCommand,\n        };\n    };\n    return Emph;\n}(Mark));\n\nvar Strike = /** @class */ (function (_super) {\n    __extends$1(Strike, _super);\n    function Strike() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strike.prototype, "name", {\n        get: function () {\n            return \'strike\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strike.prototype, "schema", {\n        get: function () {\n            var parseDOM = [\'s\', \'del\'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute(\'data-raw-html\');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || \'del\', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strike.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.strike)(state, dispatch); }; };\n    };\n    Strike.prototype.keymaps = function () {\n        var strikeCommand = this.commands()();\n        return {\n            \'Mod-s\': strikeCommand,\n            \'Mod-S\': strikeCommand,\n        };\n    };\n    return Strike;\n}(Mark));\n\nvar Link = /** @class */ (function (_super) {\n    __extends$1(Link, _super);\n    function Link(linkAttributes) {\n        var _this = _super.call(this) || this;\n        _this.linkAttributes = linkAttributes;\n        return _this;\n    }\n    Object.defineProperty(Link.prototype, "name", {\n        get: function () {\n            return \'link\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Link.prototype, "schema", {\n        get: function () {\n            var _this = this;\n            return {\n                attrs: __assign$1({ linkUrl: { default: \'\' }, title: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                inclusive: false,\n                parseDOM: [\n                    {\n                        tag: \'a[href]\',\n                        getAttrs: function (dom) {\n                            var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true })\n                                .firstChild;\n                            var href = sanitizedDOM.getAttribute(\'href\') || \'\';\n                            var title = sanitizedDOM.getAttribute(\'title\') || \'\';\n                            var rawHTML = sanitizedDOM.getAttribute(\'data-raw-html\');\n                            return __assign$1({ linkUrl: href, title: title }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || \'a\',\n                        __assign$1(__assign$1({ href: escapeXml$1(attrs.linkUrl) }, _this.linkAttributes), getCustomAttrs(attrs)),\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Link.prototype.addLink = function () {\n        return function (payload) { return function (state, dispatch) {\n            var _a = payload, linkUrl = _a.linkUrl, _b = _a.linkText, linkText = _b === void 0 ? \'\' : _b;\n            var schema = state.schema, tr = state.tr, selection = state.selection;\n            var empty = selection.empty, from = selection.from, to = selection.to;\n            if (from && to && linkUrl) {\n                var attrs = { linkUrl: linkUrl };\n                var mark = schema.mark(\'link\', attrs);\n                if (empty && linkText) {\n                    var node = createTextNode$1(schema, linkText, mark);\n                    tr.replaceRangeWith(from, to, node);\n                }\n                else {\n                    tr.addMark(from, to, mark);\n                }\n                dispatch(tr.scrollIntoView());\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Link.prototype.toggleLink = function () {\n        return function (payload) { return function (state, dispatch) {\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.link, payload)(state, dispatch);\n        }; };\n    };\n    Link.prototype.commands = function () {\n        return {\n            addLink: this.addLink(),\n            toggleLink: this.toggleLink(),\n        };\n    };\n    return Link;\n}(Mark));\n\nvar Code = /** @class */ (function (_super) {\n    __extends$1(Code, _super);\n    function Code() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Code.prototype, "name", {\n        get: function () {\n            return \'code\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Code.prototype, "schema", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: \'code\',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute(\'data-raw-html\');\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || \'code\', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Code.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.code)(state, dispatch); }; };\n    };\n    Code.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return {\n            \'Shift-Mod-c\': codeCommand,\n            \'Shift-Mod-C\': codeCommand,\n        };\n    };\n    return Code;\n}(Mark));\n\nvar CustomBlock = /** @class */ (function (_super) {\n    __extends$1(CustomBlock, _super);\n    function CustomBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CustomBlock.prototype, "name", {\n        get: function () {\n            return \'customBlock\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CustomBlock.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'text*\',\n                group: \'block\',\n                attrs: {\n                    info: { default: null },\n                },\n                atom: true,\n                code: true,\n                defining: true,\n                parseDOM: [\n                    {\n                        tag: \'div[data-custom-info]\',\n                        getAttrs: function (dom) {\n                            var info = dom.getAttribute(\'data-custom-info\');\n                            return { info: info };\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\'div\', { \'data-custom-info\': attrs.info || null }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CustomBlock.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            return (payload === null || payload === void 0 ? void 0 : payload.info)\n                ? (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(state.schema.nodes.customBlock, payload)(state, dispatch)\n                : false;\n        }; };\n    };\n    return CustomBlock;\n}(Node$2));\n\nvar FrontMatter = /** @class */ (function (_super) {\n    __extends$1(FrontMatter, _super);\n    function FrontMatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(FrontMatter.prototype, "name", {\n        get: function () {\n            return \'frontMatter\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FrontMatter.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'text*\',\n                group: \'block\',\n                code: true,\n                defining: true,\n                parseDOM: [\n                    {\n                        preserveWhitespace: \'full\',\n                        tag: \'div[data-front-matter]\',\n                    },\n                ],\n                toDOM: function () {\n                    return [\'div\', { \'data-front-matter\': \'true\' }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FrontMatter.prototype.commands = function () {\n        return function () { return function (state, dispatch, view) {\n            var $from = state.selection.$from;\n            if (view.endOfTextblock(\'down\') && $from.node().type.name === \'frontMatter\') {\n                return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.exitCode)(state, dispatch);\n            }\n            return false;\n        }; };\n    };\n    FrontMatter.prototype.keymaps = function () {\n        return {\n            Enter: this.commands()(),\n        };\n    };\n    return FrontMatter;\n}(Node$2));\n\nvar HTMLComment = /** @class */ (function (_super) {\n    __extends$1(HTMLComment, _super);\n    function HTMLComment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(HTMLComment.prototype, "name", {\n        get: function () {\n            return \'htmlComment\';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(HTMLComment.prototype, "schema", {\n        get: function () {\n            return {\n                content: \'text*\',\n                group: \'block\',\n                code: true,\n                defining: true,\n                parseDOM: [{ preserveWhitespace: \'full\', tag: \'div[data-html-comment]\' }],\n                toDOM: function () {\n                    return [\'div\', { \'data-html-comment\': \'true\' }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    HTMLComment.prototype.commands = function () {\n        return function () { return function (state, dispatch, view) {\n            var $from = state.selection.$from;\n            if (view.endOfTextblock(\'down\') && $from.node().type.name === \'htmlComment\') {\n                return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.exitCode)(state, dispatch);\n            }\n            return false;\n        }; };\n    };\n    HTMLComment.prototype.keymaps = function () {\n        return {\n            Enter: this.commands()(),\n        };\n    };\n    return HTMLComment;\n}(Node$2));\n\nfunction createSpecs(linkAttributes) {\n    return new SpecManager([\n        new Doc(),\n        new Paragraph(),\n        new Text(),\n        new Heading(),\n        new CodeBlock(),\n        new BulletList(),\n        new OrderedList(),\n        new ListItem(),\n        new BlockQuote(),\n        new Table(),\n        new TableHead(),\n        new TableBody(),\n        new TableRow(),\n        new TableHeadCell(),\n        new TableBodyCell(),\n        new Image(),\n        new ThematicBreak(),\n        new Strong(),\n        new Emph(),\n        new Strike(),\n        new Link(linkAttributes),\n        new Code(),\n        new CustomBlock(),\n        new FrontMatter(),\n        new Widget(),\n        new HTMLComment(),\n    ]);\n}\n\nvar CONTENTS_CLASS_NAME = cls(\'contents\');\nvar WysiwygEditor = /** @class */ (function (_super) {\n    __extends$1(WysiwygEditor, _super);\n    function WysiwygEditor(eventEmitter, options) {\n        var _this = _super.call(this, eventEmitter) || this;\n        var toDOMAdaptor = options.toDOMAdaptor, _a = options.htmlSchemaMap, htmlSchemaMap = _a === void 0 ? {} : _a, _b = options.linkAttributes, linkAttributes = _b === void 0 ? {} : _b, _c = options.useCommandShortcut, useCommandShortcut = _c === void 0 ? true : _c, _d = options.wwPlugins, wwPlugins = _d === void 0 ? [] : _d, _e = options.wwNodeViews, wwNodeViews = _e === void 0 ? {} : _e;\n        _this.editorType = \'wysiwyg\';\n        _this.el.classList.add(\'ww-mode\');\n        _this.toDOMAdaptor = toDOMAdaptor;\n        _this.linkAttributes = linkAttributes;\n        _this.extraPlugins = wwPlugins;\n        _this.pluginNodeViews = wwNodeViews;\n        _this.specs = _this.createSpecs();\n        _this.schema = _this.createSchema(htmlSchemaMap);\n        _this.context = _this.createContext();\n        _this.keymaps = _this.createKeymaps(useCommandShortcut);\n        _this.view = _this.createView();\n        _this.commands = _this.createCommands();\n        _this.specs.setContext(__assign$1(__assign$1({}, _this.context), { view: _this.view }));\n        _this.initEvent();\n        return _this;\n    }\n    WysiwygEditor.prototype.createSpecs = function () {\n        return createSpecs(this.linkAttributes);\n    };\n    WysiwygEditor.prototype.createContext = function () {\n        return {\n            schema: this.schema,\n            eventEmitter: this.eventEmitter,\n        };\n    };\n    WysiwygEditor.prototype.createSchema = function (htmlSchemaMap) {\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Schema({\n            nodes: __assign$1(__assign$1({}, this.specs.nodes), htmlSchemaMap.nodes),\n            marks: __assign$1(__assign$1({}, this.specs.marks), htmlSchemaMap.marks),\n        });\n    };\n    WysiwygEditor.prototype.createPlugins = function () {\n        return __spreadArray$1([\n            tableSelection(),\n            tableContextMenu(this.eventEmitter),\n            task(),\n            toolbarStateHighlight(this.eventEmitter)\n        ], this.createPluginProps()).concat(this.defaultPlugins);\n    };\n    WysiwygEditor.prototype.createPluginNodeViews = function () {\n        var _a = this, eventEmitter = _a.eventEmitter, pluginNodeViews = _a.pluginNodeViews;\n        var pluginNodeViewMap = {};\n        if (pluginNodeViews) {\n            Object.keys(pluginNodeViews).forEach(function (key) {\n                pluginNodeViewMap[key] = function (node, view, getPos) {\n                    return pluginNodeViews[key](node, view, getPos, eventEmitter);\n                };\n            });\n        }\n        return pluginNodeViewMap;\n    };\n    WysiwygEditor.prototype.createView = function () {\n        var _this = this;\n        var _a = this, toDOMAdaptor = _a.toDOMAdaptor, eventEmitter = _a.eventEmitter;\n        return new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(this.el, {\n            state: this.createState(),\n            attributes: {\n                class: CONTENTS_CLASS_NAME,\n            },\n            nodeViews: __assign$1({ customBlock: function (node, view, getPos) {\n                    return new CustomBlockView(node, view, getPos, toDOMAdaptor);\n                },\n                image: function (node, view, getPos) {\n                    return new ImageView(node, view, getPos, eventEmitter);\n                },\n                codeBlock: function (node, view, getPos) {\n                    return new CodeBlockView(node, view, getPos, eventEmitter);\n                }, widget: widgetNodeView }, this.createPluginNodeViews()),\n            dispatchTransaction: function (tr) {\n                var state = _this.view.state.applyTransaction(tr).state;\n                _this.view.updateState(state);\n                _this.emitChangeEvent(tr.scrollIntoView());\n                _this.eventEmitter.emit(\'setFocusedNode\', state.selection.$from.node(1));\n            },\n            transformPastedHTML: changePastedHTML,\n            transformPasted: function (slice) {\n                return changePastedSlice(slice, _this.schema, isInTableNode(_this.view.state.selection.$from));\n            },\n            handlePaste: function (view, _, slice) { return pasteToTable(view, slice); },\n            handleKeyDown: function (_, ev) {\n                _this.eventEmitter.emit(\'keydown\', _this.editorType, ev);\n                return false;\n            },\n            handleDOMEvents: {\n                paste: function (_, ev) {\n                    var clipboardData = ev.clipboardData || window.clipboardData;\n                    var items = clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.items;\n                    if (items) {\n                        var containRtfItem = toArray_1(items).some(function (item) { return item.kind === \'string\' && item.type === \'text/rtf\'; });\n                        // if it contains rtf, it\'s most likely copy paste from office -> no image\n                        if (!containRtfItem) {\n                            var imageBlob = pasteImageOnly(items);\n                            if (imageBlob) {\n                                ev.preventDefault();\n                                emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);\n                            }\n                        }\n                    }\n                    return false;\n                },\n                keyup: function (_, ev) {\n                    _this.eventEmitter.emit(\'keyup\', _this.editorType, ev);\n                    return false;\n                },\n                scroll: function () {\n                    _this.eventEmitter.emit(\'scroll\', \'editor\');\n                    return true;\n                },\n            },\n        });\n    };\n    WysiwygEditor.prototype.createCommands = function () {\n        return this.specs.commands(this.view, getWwCommands());\n    };\n    WysiwygEditor.prototype.getHTML = function () {\n        return removeProseMirrorHackNodes(this.view.dom.innerHTML);\n    };\n    WysiwygEditor.prototype.getModel = function () {\n        return this.view.state.doc;\n    };\n    WysiwygEditor.prototype.getSelection = function () {\n        var _a = this.view.state.selection, from = _a.from, to = _a.to;\n        return [from, to];\n    };\n    WysiwygEditor.prototype.getSchema = function () {\n        return this.view.state.schema;\n    };\n    WysiwygEditor.prototype.replaceSelection = function (text, start, end) {\n        var _a = this.view.state, schema = _a.schema, tr = _a.tr;\n        var lineTexts = text.split(\'\\n\');\n        var paras = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(paras), 1, 1);\n        var newTr = isNumber_1(start) && isNumber_1(end)\n            ? tr.replaceRange(start, end, slice)\n            : tr.replaceSelection(slice);\n        this.view.dispatch(newTr);\n        this.focus();\n    };\n    WysiwygEditor.prototype.deleteSelection = function (start, end) {\n        var tr = this.view.state.tr;\n        var newTr = isNumber_1(start) && isNumber_1(end) ? tr.deleteRange(start, end) : tr.deleteSelection();\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    WysiwygEditor.prototype.getSelectedText = function (start, end) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var from = selection.from, to = selection.to;\n        if (isNumber_1(start) && isNumber_1(end)) {\n            from = start;\n            to = end;\n        }\n        return doc.textBetween(from, to, \'\\n\');\n    };\n    WysiwygEditor.prototype.setModel = function (newDoc, cursorToEnd) {\n        if (cursorToEnd === void 0) { cursorToEnd = false; }\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc;\n        this.view.dispatch(tr.replaceWith(0, doc.content.size, newDoc));\n        if (cursorToEnd) {\n            this.moveCursorToEnd(true);\n        }\n    };\n    WysiwygEditor.prototype.setSelection = function (start, end) {\n        if (end === void 0) { end = start; }\n        var tr = this.view.state.tr;\n        var selection = createTextSelection(tr, start, end);\n        this.view.dispatch(tr.setSelection(selection).scrollIntoView());\n    };\n    WysiwygEditor.prototype.addWidget = function (node, style, pos) {\n        var _a = this.view, dispatch = _a.dispatch, state = _a.state;\n        dispatch(state.tr.setMeta(\'widget\', { pos: pos !== null && pos !== void 0 ? pos : state.selection.to, node: node, style: style }));\n    };\n    WysiwygEditor.prototype.replaceWithWidget = function (start, end, text) {\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema;\n        var nodes = createNodesWithWidget(text, schema);\n        this.view.dispatch(tr.replaceWith(start, end, nodes));\n    };\n    WysiwygEditor.prototype.getRangeInfoOfNode = function (pos) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var $pos = pos ? doc.resolve(pos) : selection.$from;\n        var marks = $pos.marks();\n        var node = $pos.node();\n        var start = $pos.start();\n        var end = $pos.end();\n        var type = node.type.name;\n        if (marks.length || type === \'paragraph\') {\n            var mark_1 = marks[marks.length - 1];\n            var maybeHasMark_1 = function (nodeMarks) {\n                return nodeMarks.length ? includes(nodeMarks, mark_1) : true;\n            };\n            type = mark_1 ? mark_1.type.name : \'text\';\n            node.forEach(function (child, offset) {\n                var isText = child.isText, nodeSize = child.nodeSize, nodeMarks = child.marks;\n                var startOffset = $pos.pos - start;\n                if (isText &&\n                    offset <= startOffset &&\n                    offset + nodeSize >= startOffset &&\n                    maybeHasMark_1(nodeMarks)) {\n                    start = start + offset;\n                    end = start + nodeSize;\n                }\n            });\n        }\n        return { range: [start, end], type: type };\n    };\n    return WysiwygEditor;\n}(EditorBase));\n\n/**\n * @fileoverview Check whether the given variable is existing or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined = isUndefined_1;\nvar isNull = isNull_1;\n\n/**\n * Check whether the given variable is existing or not.\n * If the given variable is not null and not undefined, returns true.\n * @param {*} param - Target for checking\n * @returns {boolean} Is existy?\n * @memberof module:type\n * @example\n * // ES6\n * import isExisty from \'tui-code-snippet/type/isExisty\');\n * \n * // CommonJS\n * const isExisty = require(\'tui-code-snippet/type/isExisty\');\n *\n * isExisty(\'\'); //true\n * isExisty(0); //true\n * isExisty([]); //true\n * isExisty({}); //true\n * isExisty(null); //false\n * isExisty(undefined); //false\n*/\nfunction isExisty$1(param) {\n  return !isUndefined(param) && !isNull(param);\n}\n\nvar isExisty_1 = isExisty$1;\n\n/**\n * @fileoverview Check whether the given variable is truthy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isExisty = isExisty_1;\n\n/**\n * Check whether the given variable is truthy or not.\n * If the given variable is not null or not undefined or not false, returns true.\n * (It regards 0 as true)\n * @param {*} obj - Target for checking\n * @returns {boolean} Is truthy?\n * @memberof module:type\n */\nfunction isTruthy$1(obj) {\n  return isExisty(obj) && obj !== false;\n}\n\nvar isTruthy_1 = isTruthy$1;\n\n/**\n * @fileoverview Check whether the given variable is falsy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isTruthy = isTruthy_1;\n\n/**\n * Check whether the given variable is falsy or not.\n * If the given variable is null or undefined or false, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is falsy?\n * @memberof module:type\n */\nfunction isFalsy(obj) {\n  return !isTruthy(obj);\n}\n\nvar isFalsy_1 = isFalsy;\n\nvar eventTypeList = [\n    \'afterPreviewRender\',\n    \'updatePreview\',\n    \'changeMode\',\n    \'needChangeMode\',\n    \'command\',\n    \'changePreviewStyle\',\n    \'changePreviewTabPreview\',\n    \'changePreviewTabWrite\',\n    \'scroll\',\n    \'contextmenu\',\n    \'show\',\n    \'hide\',\n    \'changeLanguage\',\n    \'changeToolbarState\',\n    \'toggleScrollSync\',\n    \'mixinTableOffsetMapPrototype\',\n    \'setFocusedNode\',\n    \'removePopupWidget\',\n    \'query\',\n    // provide event for user\n    \'openPopup\',\n    \'closePopup\',\n    \'addImageBlobHook\',\n    \'beforePreviewRender\',\n    \'beforeConvertWysiwygToMarkdown\',\n    \'load\',\n    \'loadUI\',\n    \'change\',\n    \'caretChange\',\n    \'destroy\',\n    \'focus\',\n    \'blur\',\n    \'keydown\',\n    \'keyup\',\n];\n/**\n * Class EventEmitter\n * @ignore\n */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        var _this = this;\n        this.events = new Map$1();\n        this.eventTypes = eventTypeList.reduce(function (types, type) {\n            return __assign$1(__assign$1({}, types), { type: type });\n        }, {});\n        this.hold = false;\n        eventTypeList.forEach(function (eventType) {\n            _this.addEventType(eventType);\n        });\n    }\n    /**\n     * Listen event and bind event handler\n     * @param {string} type Event type string\n     * @param {function} handler Event handler\n     */\n    EventEmitter.prototype.listen = function (type, handler) {\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type) || [];\n        if (!this.hasEventType(typeInfo.type)) {\n            throw new Error("There is no event type " + typeInfo.type);\n        }\n        if (typeInfo.namespace) {\n            handler.namespace = typeInfo.namespace;\n        }\n        eventHandlers.push(handler);\n        this.events.set(typeInfo.type, eventHandlers);\n    };\n    /**\n     * Emit event\n     * @param {string} eventName Event name to emit\n     * @returns {Array}\n     */\n    EventEmitter.prototype.emit = function (type) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type);\n        var results = [];\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, args);\n                if (!isUndefined_1(result)) {\n                    results.push(result);\n                }\n            });\n        }\n        return results;\n    };\n    /**\n     * Emit given event and return result\n     * @param {string} eventName Event name to emit\n     * @param {any} source Source to change\n     * @returns {string}\n     */\n    EventEmitter.prototype.emitReduce = function (type, source) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var eventHandlers = this.events.get(type);\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, __spreadArray$1([source], args));\n                if (!isFalsy_1(result)) {\n                    source = result;\n                }\n            });\n        }\n        return source;\n    };\n    /**\n     * Get event type and namespace\n     * @param {string} type Event type name\n     * @returns {{type: string, namespace: string}}\n     * @private\n     */\n    EventEmitter.prototype.getTypeInfo = function (type) {\n        var splited = type.split(\'.\');\n        return {\n            type: splited[0],\n            namespace: splited[1],\n        };\n    };\n    /**\n     * Check whether event type exists or not\n     * @param {string} type Event type name\n     * @returns {boolean}\n     * @private\n     */\n    EventEmitter.prototype.hasEventType = function (type) {\n        return !isUndefined_1(this.eventTypes[this.getTypeInfo(type).type]);\n    };\n    /**\n     * Add event type when given event not exists\n     * @param {string} type Event type name\n     */\n    EventEmitter.prototype.addEventType = function (type) {\n        if (this.hasEventType(type)) {\n            throw new Error("There is already have event type " + type);\n        }\n        this.eventTypes[type] = type;\n    };\n    /**\n     * Remove event handler from given event type\n     * @param {string} eventType Event type name\n     * @param {function} [handler] - registered event handler\n     */\n    EventEmitter.prototype.removeEventHandler = function (eventType, handler) {\n        var _this = this;\n        var _a = this.getTypeInfo(eventType), type = _a.type, namespace = _a.namespace;\n        if (type && handler) {\n            this.removeEventHandlerWithHandler(type, handler);\n        }\n        else if (type && !namespace) {\n            this.events.delete(type);\n        }\n        else if (!type && namespace) {\n            this.events.forEach(function (_, evtType) {\n                _this.removeEventHandlerWithTypeInfo(evtType, namespace);\n            });\n        }\n        else if (type && namespace) {\n            this.removeEventHandlerWithTypeInfo(type, namespace);\n        }\n    };\n    /**\n     * Remove event handler with event handler\n     * @param {string} type - event type name\n     * @param {function} handler - event handler\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithHandler = function (type, handler) {\n        var eventHandlers = this.events.get(type);\n        if (eventHandlers) {\n            var handlerIndex = eventHandlers.indexOf(handler);\n            if (eventHandlers.indexOf(handler) >= 0) {\n                eventHandlers.splice(handlerIndex, 1);\n            }\n        }\n    };\n    /**\n     * Remove event handler with event type information\n     * @param {string} type Event type name\n     * @param {string} namespace Event namespace\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithTypeInfo = function (type, namespace) {\n        var handlersToSurvive = [];\n        var eventHandlers = this.events.get(type);\n        if (!eventHandlers) {\n            return;\n        }\n        eventHandlers.map(function (handler) {\n            if (handler.namespace !== namespace) {\n                handlersToSurvive.push(handler);\n            }\n            return null;\n        });\n        this.events.set(type, handlersToSurvive);\n    };\n    EventEmitter.prototype.getEvents = function () {\n        return this.events;\n    };\n    EventEmitter.prototype.holdEventInvoke = function (fn) {\n        this.hold = true;\n        fn();\n        this.hold = false;\n    };\n    return EventEmitter;\n}());\n\nvar CommandManager = /** @class */ (function () {\n    function CommandManager(eventEmitter, mdCommands, wwCommands, getEditorType) {\n        this.eventEmitter = eventEmitter;\n        this.mdCommands = mdCommands;\n        this.wwCommands = wwCommands;\n        this.getEditorType = getEditorType;\n        this.initEvent();\n    }\n    CommandManager.prototype.initEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen(\'command\', function (command, payload) {\n            _this.exec(command, payload);\n        });\n    };\n    CommandManager.prototype.addCommand = function (type, name, command) {\n        if (type === \'markdown\') {\n            this.mdCommands[name] = command;\n        }\n        else {\n            this.wwCommands[name] = command;\n        }\n    };\n    CommandManager.prototype.deleteCommand = function (type, name) {\n        if (type === \'markdown\') {\n            delete this.mdCommands[name];\n        }\n        else {\n            delete this.wwCommands[name];\n        }\n    };\n    CommandManager.prototype.exec = function (name, payload) {\n        var type = this.getEditorType();\n        if (type === \'markdown\') {\n            this.mdCommands[name](payload);\n        }\n        else {\n            this.wwCommands[name](payload);\n        }\n    };\n    return CommandManager;\n}());\n\nfunction getTextWithoutTrailingNewline(text) {\n    return text[text.length - 1] === \'\\n\' ? text.slice(0, text.length - 1) : text;\n}\nfunction isCustomHTMLInlineNode(_a, node) {\n    var schema = _a.schema;\n    var html = node.literal;\n    var matched = html.match(reHTMLTag);\n    if (matched) {\n        var openTagName = matched[1], closeTagName = matched[3];\n        var typeName = (openTagName || closeTagName).toLowerCase();\n        return node.type === \'htmlInline\' && !!(schema.marks[typeName] || schema.nodes[typeName]);\n    }\n    return false;\n}\nfunction isInlineNode(_a) {\n    var type = _a.type;\n    return includes([\'text\', \'strong\', \'emph\', \'strike\', \'image\', \'link\', \'code\'], type);\n}\nfunction isSoftbreak(mdNode) {\n    return (mdNode === null || mdNode === void 0 ? void 0 : mdNode.type) === \'softbreak\';\n}\nfunction isListNode(_a) {\n    var type = _a.type, literal = _a.literal;\n    var matched = type === \'htmlInline\' && literal.match(reHTMLTag);\n    if (matched) {\n        var openTagName = matched[1], closeTagName = matched[3];\n        var tagName = openTagName || closeTagName;\n        if (tagName) {\n            return includes([\'ul\', \'ol\', \'li\'], tagName.toLowerCase());\n        }\n    }\n    return false;\n}\nfunction getListItemAttrs(_a) {\n    var literal = _a.literal;\n    var task = /data-task/.test(literal);\n    var checked = /data-task-checked/.test(literal);\n    return { task: task, checked: checked };\n}\nfunction getMatchedAttributeValue(rawHTML) {\n    var attrNames = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        attrNames[_i - 1] = arguments[_i];\n    }\n    var wrapper = document.createElement(\'div\');\n    wrapper.innerHTML = sanitizeHTML(rawHTML);\n    var el = wrapper.firstChild;\n    return attrNames.map(function (attrName) { return el.getAttribute(attrName) || \'\'; });\n}\nfunction createConvertors(convertors) {\n    var convertorMap = {};\n    Object.keys(convertors).forEach(function (key) {\n        var tagNames = key.split(\', \');\n        tagNames.forEach(function (tagName) {\n            var name = tagName.toLowerCase();\n            convertorMap[name] = convertors[key];\n        });\n    });\n    return convertorMap;\n}\nvar convertors = {\n    \'b, strong\': function (state, _, openTagName) {\n        var strong = state.schema.marks.strong;\n        if (openTagName) {\n            state.openMark(strong.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(strong);\n        }\n    },\n    \'i, em\': function (state, _, openTagName) {\n        var emph = state.schema.marks.emph;\n        if (openTagName) {\n            state.openMark(emph.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(emph);\n        }\n    },\n    \'s, del\': function (state, _, openTagName) {\n        var strike = state.schema.marks.strike;\n        if (openTagName) {\n            state.openMark(strike.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(strike);\n        }\n    },\n    code: function (state, _, openTagName) {\n        var code = state.schema.marks.code;\n        if (openTagName) {\n            state.openMark(code.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(code);\n        }\n    },\n    a: function (state, node, openTagName) {\n        var tag = node.literal;\n        var link = state.schema.marks.link;\n        if (openTagName) {\n            var linkUrl = getMatchedAttributeValue(tag, \'href\')[0];\n            state.openMark(link.create({\n                linkUrl: linkUrl,\n                rawHTML: openTagName,\n            }));\n        }\n        else {\n            state.closeMark(link);\n        }\n    },\n    img: function (state, node, openTagName) {\n        var tag = node.literal;\n        if (openTagName) {\n            var _a = getMatchedAttributeValue(tag, \'src\', \'alt\'), imageUrl = _a[0], altText = _a[1];\n            var image = state.schema.nodes.image;\n            state.addNode(image, __assign$1({ rawHTML: openTagName, imageUrl: imageUrl }, (altText && { altText: altText })));\n        }\n    },\n    hr: function (state, _, openTagName) {\n        state.addNode(state.schema.nodes.thematicBreak, { rawHTML: openTagName });\n    },\n    br: function (state, node) {\n        var paragraph = state.schema.nodes.paragraph;\n        var parent = node.parent, prev = node.prev, next = node.next;\n        if ((parent === null || parent === void 0 ? void 0 : parent.type) === \'paragraph\') {\n            // should open a paragraph node when line text has only <br> tag\n            // ex) first line\\n\\n<br>\\nfourth line\n            if (isSoftbreak(prev)) {\n                state.openNode(paragraph);\n            }\n            // should close a paragraph node when line text has only <br> tag\n            // ex) first line\\n\\n<br>\\nfourth line\n            if (isSoftbreak(next)) {\n                state.closeNode();\n                // should close a paragraph node and open a paragraph node to separate between blocks\n                // when <br> tag is in the middle of the paragraph\n                // ex) first <br>line\\nthird line\n            }\n            else if (next) {\n                state.closeNode();\n                state.openNode(paragraph);\n            }\n        }\n        else if ((parent === null || parent === void 0 ? void 0 : parent.type) === \'tableCell\') {\n            if (prev && (isInlineNode(prev) || isCustomHTMLInlineNode(state, prev))) {\n                state.closeNode();\n            }\n            if (next && (isInlineNode(next) || isCustomHTMLInlineNode(state, next))) {\n                state.openNode(paragraph);\n            }\n        }\n    },\n    pre: function (state, node, openTagName) {\n        var _a, _b;\n        var container = document.createElement(\'div\');\n        container.innerHTML = node.literal;\n        var literal = (_b = (_a = container.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.textContent;\n        state.openNode(state.schema.nodes.codeBlock, { rawHTML: openTagName });\n        state.addText(getTextWithoutTrailingNewline(literal));\n        state.closeNode();\n    },\n    \'ul, ol\': function (state, node, openTagName) {\n        // in the table cell, \'<ul>\', \'<ol>\' is parsed as \'htmlInline\' node\n        if (node.parent.type === \'tableCell\') {\n            var _a = state.schema.nodes, bulletList = _a.bulletList, orderedList = _a.orderedList, paragraph = _a.paragraph;\n            var list = openTagName === \'ul\' ? bulletList : orderedList;\n            if (openTagName) {\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.openNode(list, { rawHTML: openTagName });\n            }\n            else {\n                state.closeNode();\n                if (node.next && !isListNode(node.next)) {\n                    state.openNode(paragraph);\n                }\n            }\n        }\n    },\n    li: function (state, node, openTagName) {\n        var _a;\n        // in the table cell, \'<li>\' is parsed as \'htmlInline\' node\n        if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === \'tableCell\') {\n            var _b = state.schema.nodes, listItem = _b.listItem, paragraph = _b.paragraph;\n            if (openTagName) {\n                var attrs = getListItemAttrs(node);\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.openNode(listItem, __assign$1({ rawHTML: openTagName }, attrs));\n                if (node.next && !isListNode(node.next)) {\n                    state.openNode(paragraph);\n                }\n            }\n            else {\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.closeNode();\n            }\n        }\n    },\n};\nvar htmlToWwConvertors = createConvertors(convertors);\n\nfunction isBRTag(node) {\n    return node.type === \'htmlInline\' && reBR.test(node.literal);\n}\nfunction addRawHTMLAttributeToDOM(parent) {\n    toArray_1(parent.childNodes).forEach(function (child) {\n        if (isElemNode(child)) {\n            var openTagName = child.nodeName.toLowerCase();\n            child.setAttribute(\'data-raw-html\', openTagName);\n            if (child.childNodes) {\n                addRawHTMLAttributeToDOM(child);\n            }\n        }\n    });\n}\nvar toWwConvertors = {\n    text: function (state, node) {\n        state.addText(node.literal || \'\');\n    },\n    paragraph: function (state, node, _a, customAttrs) {\n        var _b;\n        var entering = _a.entering;\n        if (entering) {\n            var paragraph = state.schema.nodes.paragraph;\n            // The `\\n\\n` entered in markdown separates the paragraph.\n            // When changing to wysiwyg, a newline is added between the two paragraphs.\n            if (((_b = node.prev) === null || _b === void 0 ? void 0 : _b.type) === \'paragraph\') {\n                state.openNode(paragraph, customAttrs);\n                state.closeNode();\n            }\n            state.openNode(paragraph, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    heading: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = node, level = _b.level, headingType = _b.headingType;\n            state.openNode(state.schema.nodes.heading, __assign$1({ level: level, headingType: headingType }, customAttrs));\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    codeBlock: function (state, node, customAttrs) {\n        var codeBlock = state.schema.nodes.codeBlock;\n        var _a = node, info = _a.info, literal = _a.literal;\n        state.openNode(codeBlock, __assign$1({ language: info }, customAttrs));\n        state.addText(getTextWithoutTrailingNewline(literal || \'\'));\n        state.closeNode();\n    },\n    list: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = state.schema.nodes, bulletList = _b.bulletList, orderedList = _b.orderedList;\n            var _c = node.listData, type = _c.type, start = _c.start;\n            if (type === \'bullet\') {\n                state.openNode(bulletList, customAttrs);\n            }\n            else {\n                state.openNode(orderedList, __assign$1({ order: start }, customAttrs));\n            }\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    item: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        var listItem = state.schema.nodes.listItem;\n        var _b = node.listData, task = _b.task, checked = _b.checked;\n        if (entering) {\n            var attrs = __assign$1(__assign$1(__assign$1({}, (task && { task: task })), (checked && { checked: checked })), customAttrs);\n            state.openNode(listItem, attrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    blockQuote: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.blockQuote, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    image: function (state, node, _a, customAttrs) {\n        var entering = _a.entering, skipChildren = _a.skipChildren;\n        var image = state.schema.nodes.image;\n        var _b = node, destination = _b.destination, firstChild = _b.firstChild;\n        if (entering && skipChildren) {\n            skipChildren();\n        }\n        state.addNode(image, __assign$1(__assign$1({ imageUrl: destination }, (firstChild && { altText: firstChild.literal })), customAttrs));\n    },\n    thematicBreak: function (state, node, _, customAttrs) {\n        state.addNode(state.schema.nodes.thematicBreak, customAttrs);\n    },\n    strong: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var strong = state.schema.marks.strong;\n        if (entering) {\n            state.openMark(strong.create(customAttrs));\n        }\n        else {\n            state.closeMark(strong);\n        }\n    },\n    emph: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var emph = state.schema.marks.emph;\n        if (entering) {\n            state.openMark(emph.create(customAttrs));\n        }\n        else {\n            state.closeMark(emph);\n        }\n    },\n    link: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        var link = state.schema.marks.link;\n        var _b = node, destination = _b.destination, title = _b.title;\n        if (entering) {\n            var attrs = __assign$1({ linkUrl: destination, title: title }, customAttrs);\n            state.openMark(link.create(attrs));\n        }\n        else {\n            state.closeMark(link);\n        }\n    },\n    softbreak: function (state, node) {\n        if (node.parent.type === \'paragraph\') {\n            var prev = node.prev, next = node.next;\n            if (prev && !isBRTag(prev)) {\n                state.closeNode();\n            }\n            if (next && !isBRTag(next)) {\n                state.openNode(state.schema.nodes.paragraph);\n            }\n        }\n    },\n    // GFM specifications node\n    table: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.table, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableHead: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableHead, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableBody: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableBody, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableRow: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableRow, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableCell: function (state, node, _a) {\n        var entering = _a.entering;\n        if (!node.ignored) {\n            var hasParaNode = function (childNode) {\n                return childNode && (isInlineNode(childNode) || isCustomHTMLInlineNode(state, childNode));\n            };\n            if (entering) {\n                var _b = state.schema.nodes, tableHeadCell = _b.tableHeadCell, tableBodyCell = _b.tableBodyCell, paragraph = _b.paragraph;\n                var tablePart = node.parent.parent;\n                var cell = tablePart.type === \'tableHead\' ? tableHeadCell : tableBodyCell;\n                var table = tablePart.parent;\n                var align = (table.columns[node.startIdx] || {}).align;\n                var attrs = __assign$1({}, node.attrs);\n                if (align) {\n                    attrs.align = align;\n                }\n                state.openNode(cell, attrs);\n                if (hasParaNode(node.firstChild)) {\n                    state.openNode(paragraph);\n                }\n            }\n            else {\n                if (hasParaNode(node.lastChild)) {\n                    state.closeNode();\n                }\n                state.closeNode();\n            }\n        }\n    },\n    strike: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var strike = state.schema.marks.strike;\n        if (entering) {\n            state.openMark(strike.create(customAttrs));\n        }\n        else {\n            state.closeMark(strike);\n        }\n    },\n    code: function (state, node, _, customAttrs) {\n        var code = state.schema.marks.code;\n        state.openMark(code.create(customAttrs));\n        state.addText(getTextWithoutTrailingNewline(node.literal || \'\'));\n        state.closeMark(code);\n    },\n    customBlock: function (state, node) {\n        var _a = state.schema.nodes, customBlock = _a.customBlock, paragraph = _a.paragraph;\n        var _b = node, info = _b.info, literal = _b.literal;\n        state.openNode(customBlock, { info: info });\n        state.addText(getTextWithoutTrailingNewline(literal || \'\'));\n        state.closeNode();\n        // add empty line to edit the content in next line\n        if (!node.next) {\n            state.openNode(paragraph);\n            state.closeNode();\n        }\n    },\n    frontMatter: function (state, node) {\n        state.openNode(state.schema.nodes.frontMatter);\n        state.addText(node.literal);\n        state.closeNode();\n    },\n    htmlInline: function (state, node) {\n        var html = node.literal;\n        var matched = html.match(reHTMLTag);\n        var openTagName = matched[1], closeTagName = matched[3];\n        var typeName = (openTagName || closeTagName).toLowerCase();\n        var markType = state.schema.marks[typeName];\n        var sanitizedHTML = sanitizeHTML(html);\n        // for user defined html schema\n        if (markType === null || markType === void 0 ? void 0 : markType.spec.attrs.htmlInline) {\n            if (openTagName) {\n                var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);\n                state.openMark(markType.create({ htmlAttrs: htmlAttrs }));\n            }\n            else {\n                state.closeMark(markType);\n            }\n        }\n        else {\n            var htmlToWwConvertor = htmlToWwConvertors[typeName];\n            if (htmlToWwConvertor) {\n                htmlToWwConvertor(state, node, openTagName);\n            }\n        }\n    },\n    htmlBlock: function (state, node) {\n        var html = node.literal;\n        var container = document.createElement(\'div\');\n        var isHTMLComment = reHTMLComment.test(html);\n        if (isHTMLComment) {\n            state.openNode(state.schema.nodes.htmlComment);\n            state.addText(node.literal);\n            state.closeNode();\n        }\n        else {\n            var matched = html.match(reHTMLTag);\n            var openTagName = matched[1], closeTagName = matched[3];\n            var typeName = (openTagName || closeTagName).toLowerCase();\n            var nodeType = state.schema.nodes[typeName];\n            var sanitizedHTML = sanitizeHTML(html);\n            // for user defined html schema\n            if (nodeType === null || nodeType === void 0 ? void 0 : nodeType.spec.attrs.htmlBlock) {\n                var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);\n                var childrenHTML = getChildrenHTML(node, typeName);\n                state.addNode(nodeType, { htmlAttrs: htmlAttrs, childrenHTML: childrenHTML });\n            }\n            else {\n                container.innerHTML = sanitizedHTML;\n                addRawHTMLAttributeToDOM(container);\n                state.convertByDOMParser(container);\n            }\n        }\n    },\n    customInline: function (state, node, _a) {\n        var entering = _a.entering, skipChildren = _a.skipChildren;\n        var _b = node, info = _b.info, firstChild = _b.firstChild;\n        var schema = state.schema;\n        if (info.indexOf(\'widget\') !== -1 && entering) {\n            var content = getWidgetContent(node);\n            skipChildren();\n            state.addNode(schema.nodes.widget, { info: info }, [\n                schema.text(createWidgetContent(info, content)),\n            ]);\n        }\n        else {\n            var text = \'$$\';\n            if (entering) {\n                text += firstChild ? info + " " : info;\n            }\n            state.addText(text);\n        }\n    },\n};\nfunction createWwConvertors(customConvertors) {\n    var customConvertorTypes = Object.keys(customConvertors);\n    var convertors = __assign$1({}, toWwConvertors);\n    var renderer = new Renderer({\n        gfm: true,\n        nodeId: true,\n        convertors: customConvertors,\n    });\n    var orgConvertors = renderer.getConvertors();\n    customConvertorTypes.forEach(function (type) {\n        var wwConvertor = toWwConvertors[type];\n        if (wwConvertor && !includes([\'htmlBlock\', \'htmlInline\'], type)) {\n            convertors[type] = function (state, node, context) {\n                context.origin = function () { return orgConvertors[type](node, context, orgConvertors); };\n                var tokens = customConvertors[type](node, context);\n                var attrs;\n                if (tokens) {\n                    var _a = Array.isArray(tokens) ? tokens[0] : tokens, htmlAttrs = _a.attributes, classNames = _a.classNames;\n                    attrs = { htmlAttrs: htmlAttrs, classNames: classNames };\n                }\n                wwConvertor(state, node, context, attrs);\n            };\n        }\n    });\n    return convertors;\n}\n\nfunction mergeMarkText(a, b) {\n    if (a.isText && b.isText && prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.sameSet(a.marks, b.marks)) {\n        // @ts-ignore\n        // type is not defined for "withText" in prosemirror-model\n        return a.withText(a.text + b.text);\n    }\n    return false;\n}\nvar ToWwConvertorState = /** @class */ (function () {\n    function ToWwConvertorState(schema, convertors) {\n        this.schema = schema;\n        this.convertors = convertors;\n        this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }];\n        this.marks = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.none;\n    }\n    ToWwConvertorState.prototype.top = function () {\n        return last$1(this.stack);\n    };\n    ToWwConvertorState.prototype.push = function (node) {\n        if (this.stack.length) {\n            this.top().content.push(node);\n        }\n    };\n    ToWwConvertorState.prototype.addText = function (text) {\n        if (text) {\n            var nodes = this.top().content;\n            var lastNode = last$1(nodes);\n            var node = this.schema.text(text, this.marks);\n            var merged = lastNode && mergeMarkText(lastNode, node);\n            if (merged) {\n                nodes[nodes.length - 1] = merged;\n            }\n            else {\n                nodes.push(node);\n            }\n        }\n    };\n    ToWwConvertorState.prototype.openMark = function (mark) {\n        this.marks = mark.addToSet(this.marks);\n    };\n    ToWwConvertorState.prototype.closeMark = function (mark) {\n        this.marks = mark.removeFromSet(this.marks);\n    };\n    ToWwConvertorState.prototype.addNode = function (type, attrs, content) {\n        var node = type.createAndFill(attrs, content, this.marks);\n        if (node) {\n            this.push(node);\n            return node;\n        }\n        return null;\n    };\n    ToWwConvertorState.prototype.openNode = function (type, attrs) {\n        this.stack.push({ type: type, attrs: attrs, content: [] });\n    };\n    ToWwConvertorState.prototype.closeNode = function () {\n        if (this.marks.length) {\n            this.marks = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.none;\n        }\n        var _a = this.stack.pop(), type = _a.type, attrs = _a.attrs, content = _a.content;\n        return this.addNode(type, attrs, content);\n    };\n    ToWwConvertorState.prototype.convertByDOMParser = function (root) {\n        var _this = this;\n        var doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(this.schema).parse(root);\n        doc.content.forEach(function (node) { return _this.push(node); });\n    };\n    ToWwConvertorState.prototype.closeUnmatchedHTMLInline = function (node, entering) {\n        var _a;\n        if (!entering && node.type !== \'htmlInline\') {\n            var length_1 = this.stack.length - 1;\n            for (var i = length_1; i >= 0; i -= 1) {\n                var nodeInfo = this.stack[i];\n                if ((_a = nodeInfo.attrs) === null || _a === void 0 ? void 0 : _a.rawHTML) {\n                    if (nodeInfo.content.length) {\n                        this.closeNode();\n                    }\n                    else {\n                        // just pop useless unmatched html inline node\n                        this.stack.pop();\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    };\n    ToWwConvertorState.prototype.convert = function (mdNode, infoForPosSync) {\n        var walker = mdNode.walker();\n        var event = walker.next();\n        var _loop_1 = function () {\n            var node = event.node, entering = event.entering;\n            var convertor = this_1.convertors[node.type];\n            var skipped = false;\n            if (convertor) {\n                var context = {\n                    entering: entering,\n                    leaf: !isContainer$2(node),\n                    getChildrenText: getChildrenText$1,\n                    options: { gfm: true, nodeId: false, tagFilter: false, softbreak: \'\\n\' },\n                    skipChildren: function () {\n                        skipped = true;\n                    },\n                };\n                this_1.closeUnmatchedHTMLInline(node, entering);\n                convertor(this_1, node, context);\n                if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node) {\n                    var pos = this_1.stack.reduce(function (nodeSize, stackItem) {\n                        return nodeSize +\n                            stackItem.content.reduce(function (contentSize, pmNode) { return contentSize + pmNode.nodeSize; }, 0);\n                    }, 0) + 1;\n                    infoForPosSync.setMappedPos(pos);\n                }\n            }\n            if (skipped) {\n                walker.resumeAt(node, false);\n                walker.next();\n            }\n            event = walker.next();\n        };\n        var this_1 = this;\n        while (event) {\n            _loop_1();\n        }\n    };\n    ToWwConvertorState.prototype.convertNode = function (mdNode, infoForPosSync) {\n        this.convert(mdNode, infoForPosSync);\n        if (this.stack.length) {\n            return this.closeNode();\n        }\n        return null;\n    };\n    return ToWwConvertorState;\n}());\n\nfunction convertToRawHTMLHavingInlines(state, node, _a) {\n    var openTag = _a[0], closeTag = _a[1];\n    state.write(openTag);\n    state.convertInline(node);\n    state.write(closeTag);\n}\nfunction convertToRawHTMLHavingBlocks(state, _a, _b) {\n    var node = _a.node, parent = _a.parent;\n    var openTag = _b[0], closeTag = _b[1];\n    state.stopNewline = true;\n    state.write(openTag);\n    state.convertNode(node);\n    state.write(closeTag);\n    if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === \'doc\') {\n        state.closeBlock(node);\n        state.stopNewline = false;\n    }\n}\nfunction createTableHeadDelim(textContent, columnAlign) {\n    var textLen = textContent.length;\n    var leftDelim = \'\';\n    var rightDelim = \'\';\n    if (columnAlign === \'left\') {\n        leftDelim = \':\';\n        textLen -= 1;\n    }\n    else if (columnAlign === \'right\') {\n        rightDelim = \':\';\n        textLen -= 1;\n    }\n    else if (columnAlign === \'center\') {\n        leftDelim = \':\';\n        rightDelim = \':\';\n        textLen -= 2;\n    }\n    return "" + leftDelim + repeat$1(\'-\', Math.max(textLen, 3)) + rightDelim;\n}\nvar nodeTypeWriters = {\n    text: function (state, _a) {\n        var _b;\n        var node = _a.node;\n        var text = (_b = node.text) !== null && _b !== void 0 ? _b : \'\';\n        if ((node.marks || []).some(function (mark) { return mark.type.name === \'link\'; })) {\n            state.text(escapeTextForLink(text), false);\n        }\n        else {\n            state.text(text);\n        }\n    },\n    paragraph: function (state, _a) {\n        var node = _a.node, parent = _a.parent, _b = _a.index, index = _b === void 0 ? 0 : _b;\n        if (state.stopNewline) {\n            state.convertInline(node);\n        }\n        else {\n            var firstChildNode = index === 0;\n            var prevNode = !firstChildNode && parent.child(index - 1);\n            var prevEmptyNode = prevNode && prevNode.childCount === 0;\n            var nextNode = index < parent.childCount - 1 && parent.child(index + 1);\n            var nextParaNode = nextNode && nextNode.type.name === \'paragraph\';\n            var emptyNode = node.childCount === 0;\n            if (emptyNode && prevEmptyNode) {\n                state.write(\'<br>\\n\');\n            }\n            else if (emptyNode && !prevEmptyNode && !firstChildNode) {\n                if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === \'listItem\') {\n                    var prevDelim = state.getDelim();\n                    state.setDelim(\'\');\n                    state.write(\'<br>\');\n                    state.setDelim(prevDelim);\n                }\n                state.write(\'\\n\');\n            }\n            else {\n                state.convertInline(node);\n                if (nextParaNode) {\n                    state.write(\'\\n\');\n                }\n                else {\n                    state.closeBlock(node);\n                }\n            }\n        }\n    },\n    heading: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        var headingType = node.attrs.headingType;\n        if (headingType === \'atx\') {\n            state.write(delim + " ");\n            state.convertInline(node);\n            state.closeBlock(node);\n        }\n        else {\n            state.convertInline(node);\n            state.ensureNewLine();\n            state.write(delim);\n            state.closeBlock(node);\n        }\n    },\n    codeBlock: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim, text = _b.text;\n        var _c = delim, openDelim = _c[0], closeDelim = _c[1];\n        state.write(openDelim);\n        state.ensureNewLine();\n        state.text(text, false);\n        state.ensureNewLine();\n        state.write(closeDelim);\n        state.closeBlock(node);\n    },\n    blockQuote: function (state, _a, _b) {\n        var node = _a.node, parent = _a.parent;\n        var delim = _b.delim;\n        if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === node.type.name) {\n            state.flushClose(1);\n        }\n        state.wrapBlock(delim, null, node, function () { return state.convertNode(node); });\n    },\n    bulletList: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        // soft-tab(4)\n        state.convertList(node, repeat$1(\' \', 4), function () { return delim + " "; });\n    },\n    orderedList: function (state, _a) {\n        var node = _a.node;\n        var start = node.attrs.order || 1;\n        // soft-tab(4)\n        state.convertList(node, repeat$1(\' \', 4), function (index) {\n            var orderedNum = String(start + index);\n            return orderedNum + ". ";\n        });\n    },\n    listItem: function (state, _a) {\n        var node = _a.node;\n        var _b = node.attrs, task = _b.task, checked = _b.checked;\n        if (task) {\n            state.write("[" + (checked ? \'x\' : \' \') + "] ");\n        }\n        state.convertNode(node);\n    },\n    image: function (state, _, _a) {\n        var attrs = _a.attrs;\n        state.write("![" + (attrs === null || attrs === void 0 ? void 0 : attrs.altText) + "](" + (attrs === null || attrs === void 0 ? void 0 : attrs.imageUrl) + ")");\n    },\n    thematicBreak: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        state.write(delim);\n        state.closeBlock(node);\n    },\n    table: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n        state.closeBlock(node);\n    },\n    tableHead: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        var row = node.firstChild;\n        state.convertNode(node);\n        var result = delim !== null && delim !== void 0 ? delim : \'\';\n        if (!delim && row) {\n            row.forEach(function (_a) {\n                var textContent = _a.textContent, attrs = _a.attrs;\n                var headDelim = createTableHeadDelim(textContent, attrs.align);\n                result += "| " + headDelim + " ";\n            });\n        }\n        state.write(result + "|");\n        state.ensureNewLine();\n    },\n    tableBody: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n    },\n    tableRow: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n        state.write(\'|\');\n        state.ensureNewLine();\n    },\n    tableHeadCell: function (state, _a, _b) {\n        var node = _a.node;\n        var _c = _b.delim, delim = _c === void 0 ? \'| \' : _c;\n        state.write(delim);\n        state.convertTableCell(node);\n        state.write(\' \');\n    },\n    tableBodyCell: function (state, _a, _b) {\n        var node = _a.node;\n        var _c = _b.delim, delim = _c === void 0 ? \'| \' : _c;\n        state.write(delim);\n        state.convertTableCell(node);\n        state.write(\' \');\n    },\n    customBlock: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim, text = _b.text;\n        var _c = delim, openDelim = _c[0], closeDelim = _c[1];\n        state.write(openDelim);\n        state.ensureNewLine();\n        state.text(text, false);\n        state.ensureNewLine();\n        state.write(closeDelim);\n        state.closeBlock(node);\n    },\n    frontMatter: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.text(text, false);\n        state.closeBlock(node);\n    },\n    widget: function (state, _, _a) {\n        var text = _a.text;\n        state.write(text);\n    },\n    html: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.write(text);\n        if (node.attrs.htmlBlock) {\n            state.closeBlock(node);\n        }\n    },\n    htmlComment: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.write(text);\n        state.closeBlock(node);\n    },\n};\nfunction write(type, _a) {\n    var state = _a.state, nodeInfo = _a.nodeInfo, params = _a.params;\n    var rawHTML = params.rawHTML;\n    if (rawHTML) {\n        if (inArray_1(type, [\'heading\', \'codeBlock\']) > -1) {\n            convertToRawHTMLHavingInlines(state, nodeInfo.node, rawHTML);\n        }\n        else if (inArray_1(type, [\'image\', \'thematicBreak\']) > -1) {\n            state.write(rawHTML);\n        }\n        else {\n            convertToRawHTMLHavingBlocks(state, nodeInfo, rawHTML);\n        }\n    }\n    else {\n        nodeTypeWriters[type](state, nodeInfo, params);\n    }\n}\n\nfunction addBackticks(node, side) {\n    var text = node.text;\n    var ticks = /`+/g;\n    var len = 0;\n    if (node.isText && text) {\n        var matched = ticks.exec(text);\n        while (matched) {\n            len = Math.max(len, matched[0].length);\n            matched = ticks.exec(text);\n        }\n    }\n    var result = len > 0 && side > 0 ? \' `\' : \'`\';\n    for (var i = 0; i < len; i += 1) {\n        result += \'`\';\n    }\n    if (len > 0 && side < 0) {\n        result += \' \';\n    }\n    return result;\n}\nfunction getPairRawHTML(rawHTML) {\n    return rawHTML ? ["<" + rawHTML + ">", "</" + rawHTML + ">"] : null;\n}\nfunction getOpenRawHTML(rawHTML) {\n    return rawHTML ? "<" + rawHTML + ">" : null;\n}\nfunction getCloseRawHTML(rawHTML) {\n    return rawHTML ? "</" + rawHTML + ">" : null;\n}\nvar toMdConvertors = {\n    heading: function (_a) {\n        var node = _a.node;\n        var attrs = node.attrs;\n        var level = attrs.level;\n        var delim = repeat$1(\'#\', level);\n        if (attrs.headingType === \'setext\') {\n            delim = level === 1 ? \'===\' : \'---\';\n        }\n        return {\n            delim: delim,\n            rawHTML: getPairRawHTML(attrs.rawHTML),\n        };\n    },\n    codeBlock: function (_a) {\n        var node = _a.node;\n        var _b = node, attrs = _b.attrs, textContent = _b.textContent;\n        return {\n            delim: ["```" + (attrs.language || \'\'), \'```\'],\n            rawHTML: getPairRawHTML(attrs.rawHTML),\n            text: textContent,\n        };\n    },\n    blockQuote: function (_a) {\n        var node = _a.node;\n        return {\n            delim: \'> \',\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    bulletList: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || \'ul\';\n        }\n        return {\n            delim: \'*\',\n            rawHTML: getPairRawHTML(rawHTML),\n        };\n    },\n    orderedList: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || \'ol\';\n        }\n        return {\n            rawHTML: getPairRawHTML(rawHTML),\n        };\n    },\n    listItem: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var _c = node.attrs, task = _c.task, checked = _c.checked;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || \'li\';\n        }\n        var className = task ? " class=\\"task-list-item" + (checked ? \' checked\' : \'\') + "\\"" : \'\';\n        var dataset = task ? " data-task" + (checked ? " data-task-checked" : \'\') : \'\';\n        return {\n            rawHTML: rawHTML ? ["<" + rawHTML + className + dataset + ">", "</" + rawHTML + ">"] : null,\n        };\n    },\n    table: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableHead: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableBody: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableRow: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableHeadCell: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableBodyCell: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    image: function (_a) {\n        var node = _a.node;\n        var attrs = node.attrs;\n        var rawHTML = attrs.rawHTML, altText = attrs.altText;\n        var imageUrl = attrs.imageUrl.replace(/&amp;/g, \'&\');\n        var altAttr = altText ? " alt=\\"" + escapeXml$1(altText) + "\\"" : \'\';\n        return {\n            rawHTML: rawHTML ? "<" + rawHTML + " src=\\"" + escapeXml$1(imageUrl) + "\\"" + altAttr + ">" : null,\n            attrs: {\n                altText: escapeTextForLink(altText || \'\'),\n                imageUrl: imageUrl,\n            },\n        };\n    },\n    thematicBreak: function (_a) {\n        var node = _a.node;\n        return {\n            delim: \'***\',\n            rawHTML: getOpenRawHTML(node.attrs.rawHTML),\n        };\n    },\n    customBlock: function (_a) {\n        var node = _a.node;\n        var _b = node, attrs = _b.attrs, textContent = _b.textContent;\n        return {\n            delim: ["$$" + attrs.info, \'$$\'],\n            text: textContent,\n        };\n    },\n    frontMatter: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    widget: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    strong: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: \'**\',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    emph: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: \'*\',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    strike: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: \'~~\',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    link: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var attrs = node.attrs;\n        var title = attrs.title, rawHTML = attrs.rawHTML;\n        var linkUrl = attrs.linkUrl.replace(/&amp;/g, \'&\');\n        var titleAttr = title ? " title=\\"" + escapeXml$1(title) + "\\"" : \'\';\n        if (entering) {\n            return {\n                delim: \'[\',\n                rawHTML: rawHTML ? "<" + rawHTML + " href=\\"" + escapeXml$1(linkUrl) + "\\"" + titleAttr + ">" : null,\n            };\n        }\n        return {\n            delim: "](" + linkUrl + (title ? " " + quote(escapeTextForLink(title)) : \'\') + ")",\n            rawHTML: getCloseRawHTML(rawHTML),\n        };\n    },\n    code: function (_a, _b) {\n        var node = _a.node, parent = _a.parent, _c = _a.index, index = _c === void 0 ? 0 : _c;\n        var entering = _b.entering;\n        var delim = entering\n            ? addBackticks(parent.child(index), -1)\n            : addBackticks(parent.child(index - 1), 1);\n        var rawHTML = entering\n            ? getOpenRawHTML(node.attrs.rawHTML)\n            : getCloseRawHTML(node.attrs.rawHTML);\n        return {\n            delim: delim,\n            rawHTML: rawHTML,\n        };\n    },\n    htmlComment: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    // html inline node, html block node\n    html: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var tagName = node.type.name;\n        var attrs = node.attrs.htmlAttrs;\n        var openTag = "<" + tagName;\n        var closeTag = "</" + tagName + ">";\n        Object.keys(attrs).forEach(function (attrName) {\n            // To prevent broken converting when attributes has double quote string\n            openTag += " " + attrName + "=\\"" + attrs[attrName].replace(/"/g, "\'") + "\\"";\n        });\n        openTag += \'>\';\n        if (node.attrs.htmlInline) {\n            return {\n                rawHTML: entering ? openTag : closeTag,\n            };\n        }\n        return {\n            text: "" + openTag + node.attrs.childrenHTML + closeTag,\n        };\n    },\n};\nvar markTypeOptions = {\n    strong: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    emph: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    strike: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    code: {\n        escape: false,\n    },\n    link: null,\n    html: null,\n};\nfunction createNodeTypeConvertors(convertors) {\n    var nodeTypeConvertors = {};\n    var nodeTypes = Object.keys(nodeTypeWriters);\n    nodeTypes.forEach(function (type) {\n        nodeTypeConvertors[type] = function (state, nodeInfo) {\n            var writer = nodeTypeWriters[type];\n            if (writer) {\n                var convertor = convertors[type];\n                var params = convertor\n                    ? convertor(nodeInfo, {\n                        inTable: state.inTable,\n                    })\n                    : {};\n                write(type, { state: state, nodeInfo: nodeInfo, params: params });\n            }\n        };\n    });\n    return nodeTypeConvertors;\n}\nfunction createMarkTypeConvertors(convertors) {\n    var markTypeConvertors = {};\n    var markTypes = Object.keys(markTypeOptions);\n    markTypes.forEach(function (type) {\n        markTypeConvertors[type] = function (nodeInfo, entering) {\n            var markOption = markTypeOptions[type];\n            var convertor = convertors[type];\n            // There are two ways to call the mark type converter\n            // in the `toMdConvertorState` module.\n            // When calling the converter without using `delim` and `rawHTML` values,\n            // the converter is called without parameters.\n            var runConvertor = convertor && nodeInfo && !isUndefined_1(entering);\n            var params = runConvertor ? convertor(nodeInfo, { entering: entering }) : {};\n            return __assign$1(__assign$1({}, params), markOption);\n        };\n    });\n    return markTypeConvertors;\n}\n// Step 1: Create the converter by overriding the custom converter\n//         to the original converter defined in the `toMdConvertors` module.\n//         If the node type is defined in the original converter,\n//         the `origin()` function is exported to the paramter of the converter.\n// Step 2: Create a converter for the node type of ProseMirror by combining the converter\n//         created in Step 1 with the writers defined in the`toMdNodeTypeWriters` module.\n//         Each writer converts the ProseMirror\'s node to a string with the value returned\n//         by the converter, and then stores the state in the`toMdConverterState` class.\n// Step 3: Create a converter for the mark type of ProseMirror by combining the converter\n//         created in Step 1 with `markTypeOptions`.\n// Step 4: The created node type converter and mark type converter are injected\n//         when creating an instance of the`toMdConverterState` class.\nfunction createMdConvertors(customConvertors) {\n    var customConvertorTypes = Object.keys(customConvertors);\n    customConvertorTypes.forEach(function (type) {\n        var baseConvertor = toMdConvertors[type];\n        var customConvertor = customConvertors[type];\n        if (baseConvertor) {\n            toMdConvertors[type] = function (nodeInfo, context) {\n                context.origin = function () { return baseConvertor(nodeInfo, context); };\n                return customConvertor(nodeInfo, context);\n            };\n        }\n        else {\n            toMdConvertors[type] = customConvertor;\n        }\n        delete customConvertors[type];\n    });\n    var nodeTypeConvertors = createNodeTypeConvertors(toMdConvertors);\n    var markTypeConvertors = createMarkTypeConvertors(toMdConvertors);\n    return {\n        nodeTypeConvertors: nodeTypeConvertors,\n        markTypeConvertors: markTypeConvertors,\n    };\n}\n\nvar ToMdConvertorState = /** @class */ (function () {\n    function ToMdConvertorState(_a) {\n        var nodeTypeConvertors = _a.nodeTypeConvertors, markTypeConvertors = _a.markTypeConvertors;\n        this.nodeTypeConvertors = nodeTypeConvertors;\n        this.markTypeConvertors = markTypeConvertors;\n        this.delim = \'\';\n        this.result = \'\';\n        this.closed = false;\n        this.tightList = false;\n        this.stopNewline = false;\n        this.inTable = false;\n    }\n    ToMdConvertorState.prototype.getMarkConvertor = function (mark) {\n        var type = mark.attrs.htmlInline ? \'html\' : mark.type.name;\n        return this.markTypeConvertors[type];\n    };\n    ToMdConvertorState.prototype.isInBlank = function () {\n        return /(^|\\n)$/.test(this.result);\n    };\n    ToMdConvertorState.prototype.markText = function (mark, entering, parent, index) {\n        var convertor = this.getMarkConvertor(mark);\n        if (convertor) {\n            var _a = convertor({ node: mark, parent: parent, index: index }, entering), delim = _a.delim, rawHTML = _a.rawHTML;\n            return rawHTML || delim;\n        }\n        return \'\';\n    };\n    ToMdConvertorState.prototype.setDelim = function (delim) {\n        this.delim = delim;\n    };\n    ToMdConvertorState.prototype.getDelim = function () {\n        return this.delim;\n    };\n    ToMdConvertorState.prototype.flushClose = function (size) {\n        if (!this.stopNewline && this.closed) {\n            if (!this.isInBlank()) {\n                this.result += \'\\n\';\n            }\n            if (!size) {\n                size = 2;\n            }\n            if (size > 1) {\n                var delimMin = this.delim;\n                var trim = /\\s+$/.exec(delimMin);\n                if (trim) {\n                    delimMin = delimMin.slice(0, delimMin.length - trim[0].length);\n                }\n                for (var i = 1; i < size; i += 1) {\n                    this.result += delimMin + "\\n";\n                }\n            }\n            this.closed = false;\n        }\n    };\n    ToMdConvertorState.prototype.wrapBlock = function (delim, firstDelim, node, fn) {\n        var old = this.getDelim();\n        this.write(firstDelim || delim);\n        this.setDelim(this.getDelim() + delim);\n        fn();\n        this.setDelim(old);\n        this.closeBlock(node);\n    };\n    ToMdConvertorState.prototype.ensureNewLine = function () {\n        if (!this.isInBlank()) {\n            this.result += \'\\n\';\n        }\n    };\n    ToMdConvertorState.prototype.write = function (content) {\n        if (content === void 0) { content = \'\'; }\n        this.flushClose();\n        if (this.delim && this.isInBlank()) {\n            this.result += this.delim;\n        }\n        if (content) {\n            this.result += content;\n        }\n    };\n    ToMdConvertorState.prototype.closeBlock = function (node) {\n        this.closed = node;\n    };\n    ToMdConvertorState.prototype.text = function (text, escaped) {\n        if (escaped === void 0) { escaped = true; }\n        var lines = text.split(\'\\n\');\n        for (var i = 0; i < lines.length; i += 1) {\n            this.write();\n            this.result += escaped ? escape$1(lines[i]) : lines[i];\n            if (i !== lines.length - 1) {\n                this.result += \'\\n\';\n            }\n        }\n    };\n    ToMdConvertorState.prototype.convertBlock = function (node, parent, index) {\n        var type = node.type.name;\n        var convertor = this.nodeTypeConvertors[type];\n        var nodeInfo = { node: node, parent: parent, index: index };\n        if (node.attrs.htmlBlock) {\n            this.nodeTypeConvertors.html(this, nodeInfo);\n        }\n        else if (convertor) {\n            convertor(this, nodeInfo);\n        }\n    };\n    ToMdConvertorState.prototype.convertInline = function (parent) {\n        var _this = this;\n        var active = [];\n        var trailing = \'\';\n        var progress = function (node, _, index) {\n            var marks = node ? node.marks : [];\n            var leading = trailing;\n            trailing = \'\';\n            // If whitespace has to be expelled from the node, adjust\n            // leading and trailing accordingly.\n            var removedWhitespace = node &&\n                node.isText &&\n                marks.some(function (mark) {\n                    var markConvertor = _this.getMarkConvertor(mark);\n                    var info = markConvertor && markConvertor();\n                    return info && info.removedEnclosingWhitespace;\n                });\n            if (removedWhitespace && node && node.text) {\n                var _a = /^(\\s*)(.*?)(\\s*)$/m.exec(node.text), lead = _a[1], mark = _a[2], trail = _a[3];\n                leading += lead;\n                trailing = trail;\n                if (lead || trail) {\n                    // @ts-ignore\n                    // type is not defined for "withText" in prosemirror-model\n                    node = mark ? node.withText(mark) : null;\n                    if (!node) {\n                        marks = active;\n                    }\n                }\n            }\n            var lastMark = marks.length && last$1(marks);\n            var markConvertor = lastMark && _this.getMarkConvertor(lastMark);\n            var markType = markConvertor && markConvertor();\n            var noEscape = markType && markType.escape === false;\n            var len = marks.length - (noEscape ? 1 : 0);\n            // Try to reorder \'mixable\' marks, such as em and strong, which\n            // in Markdown may be opened and closed in different order, so\n            // that order of the marks for the token matches the order in\n            // active.\n            for (var i = 0; i < len; i += 1) {\n                var mark = marks[i];\n                if (markType && !markType.mixable) {\n                    break;\n                }\n                for (var j = 0; j < active.length; j += 1) {\n                    var other = active[j];\n                    if (markType && !markType.mixable) {\n                        break;\n                    }\n                    if (mark.eq(other)) {\n                        // eslint-disable-next-line max-depth\n                        if (i > j) {\n                            marks = marks\n                                .slice(0, j)\n                                .concat(mark)\n                                .concat(marks.slice(j, i))\n                                .concat(marks.slice(i + 1, len));\n                        }\n                        else if (j > i) {\n                            marks = marks\n                                .slice(0, i)\n                                .concat(marks.slice(i + 1, j))\n                                .concat(mark)\n                                .concat(marks.slice(j, len));\n                        }\n                        break;\n                    }\n                }\n            }\n            // Find the prefix of the mark set that didn\'t change\n            var keep = 0;\n            while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) {\n                keep += 1;\n            }\n            // Close the marks that need to be closed\n            while (keep < active.length) {\n                var activedMark = active.pop();\n                if (activedMark) {\n                    _this.text(_this.markText(activedMark, false, parent, index), false);\n                }\n            }\n            // Output any previously expelled trailing whitespace outside the marks\n            if (leading) {\n                _this.text(leading);\n            }\n            // Open the marks that need to be opened\n            if (node) {\n                while (active.length < len) {\n                    var mark = marks[active.length];\n                    active.push(mark);\n                    _this.text(_this.markText(mark, true, parent, index), false);\n                }\n                // Render the node. Special case code marks, since their content\n                // may not be escaped.\n                if (noEscape && node.isText) {\n                    _this.text(_this.markText(lastMark, true, parent, index) +\n                        node.text +\n                        _this.markText(lastMark, false, parent, index + 1), false);\n                }\n                else {\n                    _this.convertBlock(node, parent, index);\n                }\n            }\n        };\n        parent.forEach(progress);\n        progress(null, null, parent.childCount);\n    };\n    // Render a node\'s content as a list. `delim` should be the extra\n    // indentation added to all lines except the first in an item,\n    // `firstDelimFn` is a function going from an item index to a\n    // delimiter for the first line of the item.\n    ToMdConvertorState.prototype.convertList = function (node, delim, firstDelimFn) {\n        var _this = this;\n        var _a;\n        if (this.closed && this.closed.type === node.type) {\n            this.flushClose(3);\n        }\n        else if (this.tightList) {\n            this.flushClose(1);\n        }\n        var tight = (_a = node.attrs.tight) !== null && _a !== void 0 ? _a : true;\n        var prevTight = this.tightList;\n        this.tightList = tight;\n        node.forEach(function (child, _, index) {\n            if (index && tight) {\n                _this.flushClose(1);\n            }\n            _this.wrapBlock(delim, firstDelimFn(index), node, function () { return _this.convertBlock(child, node, index); });\n        });\n        this.tightList = prevTight;\n    };\n    ToMdConvertorState.prototype.convertTableCell = function (node) {\n        var _this = this;\n        this.stopNewline = true;\n        this.inTable = true;\n        node.forEach(function (child, _, index) {\n            if (includes([\'bulletList\', \'orderedList\'], child.type.name)) {\n                _this.convertBlock(child, node, index);\n                _this.closed = false;\n            }\n            else {\n                _this.convertInline(child);\n                if (index < node.childCount - 1) {\n                    var nextChild = node.child(index + 1);\n                    if (nextChild.type.name === \'paragraph\') {\n                        _this.write(\'<br>\');\n                    }\n                }\n            }\n        });\n        this.stopNewline = false;\n        this.inTable = false;\n    };\n    ToMdConvertorState.prototype.convertNode = function (parent, infoForPosSync) {\n        var _this = this;\n        parent.forEach(function (node, _, index) {\n            _this.convertBlock(node, parent, index);\n            if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node) {\n                var lineTexts = _this.result.split(\'\\n\');\n                infoForPosSync.setMappedPos([lineTexts.length, last$1(lineTexts).length + 1]);\n            }\n        });\n        return this.result;\n    };\n    return ToMdConvertorState;\n}());\n\nvar Convertor = /** @class */ (function () {\n    function Convertor(schema, toMdConvertors, toHTMLConvertors, eventEmitter) {\n        var _this = this;\n        this.setMappedPos = function (pos) {\n            _this.mappedPosWhenConverting = pos;\n        };\n        this.schema = schema;\n        this.eventEmitter = eventEmitter;\n        this.focusedNode = null;\n        this.mappedPosWhenConverting = null;\n        this.toWwConvertors = createWwConvertors(toHTMLConvertors);\n        this.toMdConvertors = createMdConvertors(toMdConvertors || {});\n        this.eventEmitter.listen(\'setFocusedNode\', function (node) { return (_this.focusedNode = node); });\n    }\n    Convertor.prototype.getMappedPos = function () {\n        return this.mappedPosWhenConverting;\n    };\n    Convertor.prototype.getInfoForPosSync = function () {\n        return { node: this.focusedNode, setMappedPos: this.setMappedPos };\n    };\n    Convertor.prototype.toWysiwygModel = function (mdNode) {\n        var state = new ToWwConvertorState(this.schema, this.toWwConvertors);\n        return state.convertNode(mdNode, this.getInfoForPosSync());\n    };\n    Convertor.prototype.toMarkdownText = function (wwNode) {\n        var state = new ToMdConvertorState(this.toMdConvertors);\n        var markdownText = state.convertNode(wwNode, this.getInfoForPosSync());\n        markdownText = this.eventEmitter.emitReduce(\'beforeConvertWysiwygToMarkdown\', markdownText);\n        return markdownText;\n    };\n    return Convertor;\n}());\n\nfunction execPlugin(pluginInfo) {\n    var plugin = pluginInfo.plugin, eventEmitter = pluginInfo.eventEmitter, usageStatistics = pluginInfo.usageStatistics, instance = pluginInfo.instance;\n    var pmState = { Plugin: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin, PluginKey: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey, Selection: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection, TextSelection: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection };\n    var pmView = { Decoration: prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration, DecorationSet: prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet };\n    var pmModel = { Fragment: prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment };\n    var pmRules = { InputRule: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.InputRule, inputRules: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.inputRules, undoInputRule: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.undoInputRule };\n    var pmKeymap = { keymap: prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap };\n    var context = {\n        eventEmitter: eventEmitter,\n        usageStatistics: usageStatistics,\n        instance: instance,\n        pmState: pmState,\n        pmView: pmView,\n        pmModel: pmModel,\n        pmRules: pmRules,\n        pmKeymap: pmKeymap,\n        i18n: i18n,\n    };\n    if (isArray_1(plugin)) {\n        var pluginFn = plugin[0], _a = plugin[1], options = _a === void 0 ? {} : _a;\n        return pluginFn(context, options);\n    }\n    return plugin(context);\n}\nfunction getPluginInfo(pluginsInfo) {\n    var plugins = pluginsInfo.plugins, eventEmitter = pluginsInfo.eventEmitter, usageStatistics = pluginsInfo.usageStatistics, instance = pluginsInfo.instance;\n    eventEmitter.listen(\'mixinTableOffsetMapPrototype\', mixinTableOffsetMapPrototype);\n    return (plugins !== null && plugins !== void 0 ? plugins : []).reduce(function (acc, plugin) {\n        var pluginInfoResult = execPlugin({\n            plugin: plugin,\n            eventEmitter: eventEmitter,\n            usageStatistics: usageStatistics,\n            instance: instance,\n        });\n        if (!pluginInfoResult) {\n            throw new Error(\'The return value of the executed plugin is empty.\');\n        }\n        var markdownParsers = pluginInfoResult.markdownParsers, toHTMLRenderers = pluginInfoResult.toHTMLRenderers, toMarkdownRenderers = pluginInfoResult.toMarkdownRenderers, markdownPlugins = pluginInfoResult.markdownPlugins, wysiwygPlugins = pluginInfoResult.wysiwygPlugins, wysiwygNodeViews = pluginInfoResult.wysiwygNodeViews, markdownCommands = pluginInfoResult.markdownCommands, wysiwygCommands = pluginInfoResult.wysiwygCommands, toolbarItems = pluginInfoResult.toolbarItems;\n        if (toHTMLRenderers) {\n            acc.toHTMLRenderers = deepMergedCopy(acc.toHTMLRenderers, toHTMLRenderers);\n        }\n        if (toMarkdownRenderers) {\n            acc.toMarkdownRenderers = deepMergedCopy(acc.toMarkdownRenderers, toMarkdownRenderers);\n        }\n        if (markdownPlugins) {\n            acc.mdPlugins = acc.mdPlugins.concat(markdownPlugins);\n        }\n        if (wysiwygPlugins) {\n            acc.wwPlugins = acc.wwPlugins.concat(wysiwygPlugins);\n        }\n        if (wysiwygNodeViews) {\n            acc.wwNodeViews = __assign$1(__assign$1({}, acc.wwNodeViews), wysiwygNodeViews);\n        }\n        if (markdownCommands) {\n            acc.mdCommands = __assign$1(__assign$1({}, acc.mdCommands), markdownCommands);\n        }\n        if (wysiwygCommands) {\n            acc.wwCommands = __assign$1(__assign$1({}, acc.wwCommands), wysiwygCommands);\n        }\n        if (toolbarItems) {\n            acc.toolbarItems = acc.toolbarItems.concat(toolbarItems);\n        }\n        if (markdownParsers) {\n            acc.markdownParsers = __assign$1(__assign$1({}, acc.markdownParsers), markdownParsers);\n        }\n        return acc;\n    }, {\n        toHTMLRenderers: {},\n        toMarkdownRenderers: {},\n        mdPlugins: [],\n        wwPlugins: [],\n        wwNodeViews: {},\n        mdCommands: {},\n        wwCommands: {},\n        toolbarItems: [],\n        markdownParsers: {},\n    });\n}\n\nvar TASK_ATTR_NAME = \'data-task\';\nvar DISABLED_TASK_ATTR_NAME = \'data-task-disabled\';\nvar TASK_CHECKED_CLASS_NAME = \'checked\';\nfunction registerHTMLTagToWhitelist(convertorMap) {\n    [\'htmlBlock\', \'htmlInline\'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            // register tag white list for preventing to remove the html in sanitizer\n            Object.keys(convertorMap[htmlType]).forEach(function (type) { return registerTagWhitelistIfPossible(type); });\n        }\n    });\n}\n/**\n * Class ToastUIEditorViewer\n * @param {object} options Option object\n *     @param {HTMLElement} options.el - container element\n *     @param {string} [options.initialValue] Editor\'s initial value\n *     @param {Object} [options.events] - Events\n *         @param {function} [options.events.load] - It would be emitted when editor fully load\n *         @param {function} [options.events.change] - It would be emitted when content changed\n *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position\n *         @param {function} [options.events.focus] - It would be emitted when editor get focus\n *         @param {function} [options.events.blur] - It would be emitted when editor loose focus\n *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].\n *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec\n *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type\n *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node\n *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition\n *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer\n *     @param {boolean} [options.frontMatter=false] - whether use the front matter\n *     @param {string} [options.theme] - The theme to style the viewer with. The default is included in toastui-editor.css.\n */\nvar ToastUIEditorViewer = /** @class */ (function () {\n    function ToastUIEditorViewer(options) {\n        var _this = this;\n        this.options = extend_1({\n            linkAttributes: null,\n            extendedAutolinks: false,\n            customHTMLRenderer: null,\n            referenceDefinition: false,\n            customHTMLSanitizer: null,\n            frontMatter: false,\n            usageStatistics: true,\n            theme: \'light\',\n        }, options);\n        this.eventEmitter = new EventEmitter();\n        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);\n        var _a = getPluginInfo({\n            plugins: this.options.plugins,\n            eventEmitter: this.eventEmitter,\n            usageStatistics: this.options.usageStatistics,\n            instance: this,\n        }) || {}, toHTMLRenderers = _a.toHTMLRenderers, markdownParsers = _a.markdownParsers;\n        var _b = this.options, customHTMLRenderer = _b.customHTMLRenderer, extendedAutolinks = _b.extendedAutolinks, referenceDefinition = _b.referenceDefinition, frontMatter = _b.frontMatter, customHTMLSanitizer = _b.customHTMLSanitizer;\n        var rendererOptions = {\n            linkAttributes: linkAttributes,\n            customHTMLRenderer: __assign$1(__assign$1({}, toHTMLRenderers), customHTMLRenderer),\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            frontMatter: frontMatter,\n            sanitizer: customHTMLSanitizer || sanitizeHTML,\n        };\n        registerHTMLTagToWhitelist(rendererOptions.customHTMLRenderer);\n        if (this.options.events) {\n            forEachOwnProperties_1(this.options.events, function (fn, key) {\n                _this.on(key, fn);\n            });\n        }\n        var _c = this.options, el = _c.el, initialValue = _c.initialValue, theme = _c.theme;\n        var existingHTML = el.innerHTML;\n        if (theme !== \'light\') {\n            el.classList.add(cls(theme));\n        }\n        el.innerHTML = \'\';\n        this.toastMark = new ToastMark(\'\', {\n            disallowedHtmlBlockTags: [\'br\', \'img\'],\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            disallowDeepHeading: true,\n            frontMatter: frontMatter,\n            customParser: markdownParsers,\n        });\n        this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, rendererOptions), { isViewer: true }));\n        on_1(this.preview.previewContent, \'mousedown\', this.toggleTask.bind(this));\n        if (initialValue) {\n            this.setMarkdown(initialValue);\n        }\n        else if (existingHTML) {\n            this.preview.setHTML(existingHTML);\n        }\n        el.appendChild(this.preview.previewContent);\n        this.eventEmitter.emit(\'load\', this);\n    }\n    /**\n     * Toggle task by detecting mousedown event.\n     * @param {MouseEvent} ev - event\n     * @private\n     */\n    ToastUIEditorViewer.prototype.toggleTask = function (ev) {\n        var element = ev.target;\n        var style = getComputedStyle(element, \':before\');\n        if (!element.hasAttribute(DISABLED_TASK_ATTR_NAME) &&\n            element.hasAttribute(TASK_ATTR_NAME) &&\n            isPositionInBox(style, ev.offsetX, ev.offsetY)) {\n            toggleClass(element, TASK_CHECKED_CLASS_NAME);\n            this.eventEmitter.emit(\'change\', {\n                source: \'viewer\',\n                date: ev,\n            });\n        }\n    };\n    /**\n     * Set content for preview\n     * @param {string} markdown Markdown text\n     */\n    ToastUIEditorViewer.prototype.setMarkdown = function (markdown) {\n        var lineTexts = this.toastMark.getLineTexts();\n        var length = lineTexts.length;\n        var lastLine = last$1(lineTexts);\n        var endSourcepos = [length, lastLine.length + 1];\n        var editResult = this.toastMark.editMarkdown([1, 1], endSourcepos, markdown || \'\');\n        this.eventEmitter.emit(\'updatePreview\', editResult);\n    };\n    /**\n     * Bind eventHandler to event type\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.on = function (type, handler) {\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Unbind eventHandler from event type\n     * @param {string} type Event type\n     */\n    ToastUIEditorViewer.prototype.off = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Add hook to TUIEditor event\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.addHook = function (type, handler) {\n        this.eventEmitter.removeEventHandler(type);\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Remove Viewer preview from document\n     */\n    ToastUIEditorViewer.prototype.destroy = function () {\n        off_1(this.preview.el, \'mousedown\', this.toggleTask.bind(this));\n        this.preview.destroy();\n        this.eventEmitter.emit(\'destroy\');\n    };\n    /**\n     * Return true\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isViewer = function () {\n        return true;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isMarkdownMode = function () {\n        return false;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isWysiwygMode = function () {\n        return false;\n    };\n    return ToastUIEditorViewer;\n}());\n\nfunction isPmNode(node) {\n    return node instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Node;\n}\nfunction isContainer(type) {\n    var containerTypes = [\n        \'document\',\n        \'blockQuote\',\n        \'bulletList\',\n        \'orderedList\',\n        \'listItem\',\n        \'paragraph\',\n        \'heading\',\n        \'emph\',\n        \'strong\',\n        \'strike\',\n        \'link\',\n        \'image\',\n        \'table\',\n        \'tableHead\',\n        \'tableBody\',\n        \'tableRow\',\n        \'tableHeadCell\',\n        \'tableBodyCell\',\n    ];\n    return includes(containerTypes, type);\n}\nfunction createMdLikeNode(node) {\n    var attrs = node.attrs, type = node.type;\n    var nodeType = type.name;\n    var mdLikeNode = {\n        type: nodeType,\n        wysiwygNode: true,\n        literal: !isContainer(nodeType) && isPmNode(node) ? node.textContent : null,\n    };\n    var nodeTypeMap = {\n        heading: { level: attrs.level },\n        link: { destination: attrs.linkUrl, title: attrs.title },\n        image: { destination: attrs.imageUrl },\n        codeBlock: { info: attrs.language },\n        bulletList: { type: \'list\', listData: { type: \'bullet\' } },\n        orderedList: { type: \'list\', listData: { type: \'ordered\', start: attrs.order } },\n        listItem: { type: \'item\', listData: { task: attrs.task, checked: attrs.checked } },\n        tableHeadCell: { type: \'tableCell\', cellType: \'head\', align: attrs.align },\n        tableBodyCell: { type: \'tableCell\', cellType: \'body\', align: attrs.align },\n        customBlock: { info: attrs.info },\n    };\n    var nodeInfo = nodeTypeMap[nodeType];\n    var attributes = __assign$1(__assign$1({}, mdLikeNode), nodeInfo);\n    // html block, inline node\n    var _a = node.attrs, htmlAttrs = _a.htmlAttrs, childrenHTML = _a.childrenHTML;\n    if (htmlAttrs) {\n        return __assign$1(__assign$1({}, attributes), { attrs: htmlAttrs, childrenHTML: childrenHTML });\n    }\n    return attributes;\n}\n\nvar tokenToDOMNode = {\n    openTag: function (token, stack) {\n        var _a = token, tagName = _a.tagName, classNames = _a.classNames, attributes = _a.attributes;\n        var el = document.createElement(tagName);\n        var attrs = {};\n        if (classNames) {\n            el.className = classNames.join(\' \');\n        }\n        if (attributes) {\n            attrs = __assign$1(__assign$1({}, attrs), attributes);\n        }\n        setAttributes(attrs, el);\n        stack.push(el);\n    },\n    closeTag: function (_, stack) {\n        if (stack.length > 1) {\n            var el = stack.pop();\n            last$1(stack).appendChild(el);\n        }\n    },\n    html: function (token, stack) {\n        last$1(stack).insertAdjacentHTML(\'beforeend\', token.content);\n    },\n    text: function (token, stack) {\n        var textNode = document.createTextNode(token.content);\n        last$1(stack).appendChild(textNode);\n    },\n};\nvar WwToDOMAdaptor = /** @class */ (function () {\n    function WwToDOMAdaptor(linkAttributes, customRenderer) {\n        var convertors = getHTMLRenderConvertors(linkAttributes, customRenderer);\n        var customHTMLConvertor = __assign$1(__assign$1({}, customRenderer.htmlBlock), customRenderer.htmlInline);\n        // flatten the html block, inline convertor to other custom convertors\n        this.customConvertorKeys = Object.keys(customRenderer).concat(Object.keys(customHTMLConvertor));\n        this.renderer = new Renderer({\n            gfm: true,\n            convertors: __assign$1(__assign$1({}, convertors), customHTMLConvertor),\n        });\n        this.convertors = this.renderer.getConvertors();\n    }\n    WwToDOMAdaptor.prototype.generateTokens = function (node) {\n        var mdLikeNode = createMdLikeNode(node);\n        var context = {\n            entering: true,\n            leaf: isPmNode(node) ? node.isLeaf : false,\n            options: this.renderer.getOptions(),\n            getChildrenText: function () { return (isPmNode(node) ? node.textContent : \'\'); },\n            skipChildren: function () { return false; },\n        };\n        var convertor = this.convertors[node.type.name];\n        var converted = convertor(mdLikeNode, context, this.convertors);\n        var tokens = isArray_1(converted) ? converted : [converted];\n        if (isContainer(node.type.name) || node.attrs.htmlInline) {\n            context.entering = false;\n            tokens.push({ type: \'text\', content: isPmNode(node) ? node.textContent : \'\' });\n            tokens = tokens.concat(convertor(mdLikeNode, context, this.convertors));\n        }\n        return tokens;\n    };\n    WwToDOMAdaptor.prototype.toDOMNode = function (node) {\n        var tokens = this.generateTokens(node);\n        var stack = [];\n        tokens.forEach(function (token) { return tokenToDOMNode[token.type](token, stack); });\n        return stack[0];\n    };\n    WwToDOMAdaptor.prototype.getToDOMNode = function (name) {\n        if (includes(this.customConvertorKeys, name)) {\n            return this.toDOMNode.bind(this);\n        }\n        return null;\n    };\n    return WwToDOMAdaptor;\n}());\n\nvar ANIMATION_TIME = 100;\nvar SCROLL_BLOCKING_RESET_DELAY = 15;\nvar currentTimeoutId = null;\nvar releaseTimer = null;\nfunction run(deltaScrollTop, _a) {\n    var syncScrollTop = _a.syncScrollTop, releaseEventBlock = _a.releaseEventBlock;\n    if (releaseTimer) {\n        clearTimeout(releaseTimer);\n    }\n    syncScrollTop(deltaScrollTop);\n    releaseTimer = setTimeout(function () {\n        releaseEventBlock();\n    }, SCROLL_BLOCKING_RESET_DELAY);\n}\nfunction animate(curScrollTop, targetScrollTop, syncCallbacks) {\n    var diff = targetScrollTop - curScrollTop;\n    var startTime = Date.now();\n    var step = function () {\n        var stepTime = Date.now();\n        var progress = (stepTime - startTime) / ANIMATION_TIME;\n        var deltaValue;\n        if (currentTimeoutId) {\n            clearTimeout(currentTimeoutId);\n        }\n        if (progress < 1) {\n            deltaValue = curScrollTop + diff * Math.cos(((1 - progress) * Math.PI) / 2);\n            run(Math.ceil(deltaValue), syncCallbacks);\n            currentTimeoutId = setTimeout(step, 1);\n        }\n        else {\n            run(targetScrollTop, syncCallbacks);\n            currentTimeoutId = null;\n        }\n    };\n    step();\n}\n\nvar EDITOR_BOTTOM_PADDING = 18;\nvar ScrollSync = /** @class */ (function () {\n    function ScrollSync(mdEditor, preview, eventEmitter) {\n        this.latestEditorScrollTop = null;\n        this.latestPreviewScrollTop = null;\n        this.blockedScroll = null;\n        this.active = true;\n        this.timer = null;\n        var previewRoot = preview.previewContent, previewEl = preview.el;\n        this.previewRoot = previewRoot;\n        this.previewEl = previewEl;\n        this.mdEditor = mdEditor;\n        this.editorView = mdEditor.view;\n        this.toastMark = mdEditor.getToastMark();\n        this.eventEmitter = eventEmitter;\n        this.addScrollSyncEvent();\n    }\n    ScrollSync.prototype.addScrollSyncEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen(\'afterPreviewRender\', function () {\n            _this.clearTimer();\n            // Immediately after the \'afterPreviewRender\' event has occurred,\n            // browser rendering is not yet complete.\n            // So the size of elements can not be accurately measured.\n            _this.timer = setTimeout(function () {\n                _this.syncPreviewScrollTop(true);\n            }, 200);\n        });\n        this.eventEmitter.listen(\'scroll\', function (type, data) {\n            if (_this.active) {\n                if (type === \'editor\' && _this.blockedScroll !== \'editor\') {\n                    _this.syncPreviewScrollTop();\n                }\n                else if (type === \'preview\' && _this.blockedScroll !== \'preview\') {\n                    _this.syncEditorScrollTop(data);\n                }\n            }\n        });\n        this.eventEmitter.listen(\'toggleScrollSync\', function (active) {\n            _this.active = active;\n        });\n    };\n    ScrollSync.prototype.getMdNodeAtPos = function (doc, posInfo) {\n        var indexInfo = doc.content.findIndex(posInfo.pos);\n        var line = indexInfo.index;\n        return this.toastMark.findFirstNodeAtLine(line + 1);\n    };\n    ScrollSync.prototype.getScrollTopByCaretPos = function () {\n        var pos = this.mdEditor.getSelection();\n        var firstMdNode = this.toastMark.findFirstNodeAtLine(pos[0][0]);\n        var previewHeight = this.previewEl.clientHeight;\n        var el = getParentNodeObj(this.previewRoot, firstMdNode).el;\n        var totalOffsetTop = getTotalOffsetTop(el, this.previewRoot) || el.offsetTop;\n        var nodeHeight = el.clientHeight;\n        // multiply 0.5 for calculating the position in the middle of preview area\n        var targetScrollTop = totalOffsetTop + nodeHeight - previewHeight * 0.5;\n        this.latestEditorScrollTop = null;\n        var diff = el.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top;\n        return diff < previewHeight ? null : targetScrollTop;\n    };\n    ScrollSync.prototype.syncPreviewScrollTop = function (editing) {\n        if (editing === void 0) { editing = false; }\n        var _a = this, editorView = _a.editorView, previewEl = _a.previewEl, previewRoot = _a.previewRoot;\n        var _b = editorView.dom.getBoundingClientRect(), left = _b.left, top = _b.top;\n        var posInfo = editorView.posAtCoords({ left: left, top: top });\n        var doc = editorView.state.doc;\n        var firstMdNode = this.getMdNodeAtPos(doc, posInfo);\n        if (!firstMdNode || isHTMLNode(firstMdNode)) {\n            return;\n        }\n        var curScrollTop = previewEl.scrollTop;\n        var _c = editorView.dom, scrollTop = _c.scrollTop, scrollHeight = _c.scrollHeight, clientHeight = _c.clientHeight, children = _c.children;\n        var isBottomPos = scrollHeight - scrollTop <= clientHeight + EDITOR_BOTTOM_PADDING;\n        var targetScrollTop = isBottomPos ? previewEl.scrollHeight : 0;\n        if (scrollTop && !isBottomPos) {\n            if (editing) {\n                var scrollTopByEditing = this.getScrollTopByCaretPos();\n                if (!scrollTopByEditing) {\n                    return;\n                }\n                targetScrollTop = scrollTopByEditing;\n            }\n            else {\n                var _d = getParentNodeObj(this.previewRoot, firstMdNode), el = _d.el, mdNode = _d.mdNode;\n                var _e = getEditorRangeHeightInfo(doc, mdNode, children), height = _e.height, rect = _e.rect;\n                var totalOffsetTop = getTotalOffsetTop(el, previewRoot) || el.offsetTop;\n                var nodeHeight = el.clientHeight;\n                var ratio = top > rect.top ? Math.min((top - rect.top) / height, 1) : 0;\n                targetScrollTop = totalOffsetTop + nodeHeight * ratio;\n            }\n            targetScrollTop = this.getResolvedScrollTop(\'editor\', scrollTop, targetScrollTop, curScrollTop);\n            this.latestEditorScrollTop = scrollTop;\n        }\n        if (targetScrollTop !== curScrollTop) {\n            this.run(\'editor\', targetScrollTop, curScrollTop);\n        }\n    };\n    ScrollSync.prototype.syncEditorScrollTop = function (targetNode) {\n        var _a = this, toastMark = _a.toastMark, editorView = _a.editorView, previewRoot = _a.previewRoot, previewEl = _a.previewEl;\n        var dom = editorView.dom, state = editorView.state;\n        var scrollTop = previewEl.scrollTop, clientHeight = previewEl.clientHeight, scrollHeight = previewEl.scrollHeight;\n        var isBottomPos = scrollHeight - scrollTop <= clientHeight;\n        var curScrollTop = dom.scrollTop;\n        var targetScrollTop = isBottomPos ? dom.scrollHeight : 0;\n        if (scrollTop && targetNode && !isBottomPos) {\n            targetNode = findAncestorHavingId(targetNode, previewRoot);\n            if (!targetNode.getAttribute(\'data-nodeid\')) {\n                return;\n            }\n            var children = dom.children;\n            var mdNodeId = Number(targetNode.getAttribute(\'data-nodeid\'));\n            var _b = getParentNodeObj(this.previewRoot, toastMark.findNodeById(mdNodeId)), mdNode = _b.mdNode, el = _b.el;\n            var mdNodeStartLine = getMdStartLine(mdNode);\n            targetScrollTop = children[mdNodeStartLine - 1].offsetTop;\n            var height = getEditorRangeHeightInfo(state.doc, mdNode, children).height;\n            var _c = getAndSaveOffsetInfo(el, previewRoot, mdNodeId), nodeHeight = _c.nodeHeight, offsetTop = _c.offsetTop;\n            targetScrollTop += getAdditionalPos(scrollTop, offsetTop, nodeHeight, height);\n            targetScrollTop = this.getResolvedScrollTop(\'preview\', scrollTop, targetScrollTop, curScrollTop);\n            this.latestPreviewScrollTop = scrollTop;\n        }\n        if (targetScrollTop !== curScrollTop) {\n            this.run(\'preview\', targetScrollTop, curScrollTop);\n        }\n    };\n    ScrollSync.prototype.getResolvedScrollTop = function (from, scrollTop, targetScrollTop, curScrollTop) {\n        var latestScrollTop = from === \'editor\' ? this.latestEditorScrollTop : this.latestPreviewScrollTop;\n        if (latestScrollTop === null) {\n            return targetScrollTop;\n        }\n        return latestScrollTop < scrollTop\n            ? Math.max(targetScrollTop, curScrollTop)\n            : Math.min(targetScrollTop, curScrollTop);\n    };\n    ScrollSync.prototype.run = function (from, targetScrollTop, curScrollTop) {\n        var _this = this;\n        var scrollTarget;\n        if (from === \'editor\') {\n            scrollTarget = this.previewEl;\n            this.blockedScroll = \'preview\';\n        }\n        else {\n            scrollTarget = this.editorView.dom;\n            this.blockedScroll = \'editor\';\n        }\n        var syncCallbacks = {\n            syncScrollTop: function (scrollTop) { return (scrollTarget.scrollTop = scrollTop); },\n            releaseEventBlock: function () { return (_this.blockedScroll = null); },\n        };\n        animate(curScrollTop, targetScrollTop, syncCallbacks);\n    };\n    ScrollSync.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    ScrollSync.prototype.destroy = function () {\n        this.clearTimer();\n        this.eventEmitter.removeEventHandler(\'scroll\');\n        this.eventEmitter.removeEventHandler(\'afterPreviewRender\');\n    };\n    return ScrollSync;\n}());\n\nvar queryMap = {\n    getPopupInitialValues: function (editor, payload) {\n        var popupName = payload.popupName;\n        return popupName === \'link\' ? { linkText: editor.getSelectedText() } : {};\n    },\n};\nfunction buildQuery(editor) {\n    editor.eventEmitter.listen(\'query\', function (query, payload) {\n        return queryMap[query](editor, payload);\n    });\n}\n\n/**\n * ToastUIEditorCore\n * @param {Object} options Option object\n *     @param {HTMLElement} options.el - container element\n *     @param {string} [options.height=\'300px\'] - Editor\'s height style value. Height is applied as border-box ex) \'300px\', \'100%\', \'auto\'\n *     @param {string} [options.minHeight=\'200px\'] - Editor\'s min-height style value in pixel ex) \'300px\'\n *     @param {string} [options.initialValue] - Editor\'s initial value\n *     @param {string} [options.previewStyle] - Markdown editor\'s preview style (tab, vertical)\n *     @param {boolean} [options.previewHighlight = true] - Highlight a preview element corresponds to the cursor position in the markdown editor\n *     @param {string} [options.initialEditType] - Initial editor type (markdown, wysiwyg)\n *     @param {Object} [options.events] - Events\n *         @param {function} [options.events.load] - It would be emitted when editor fully load\n *         @param {function} [options.events.change] - It would be emitted when content changed\n *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position\n *         @param {function} [options.events.focus] - It would be emitted when editor get focus\n *         @param {function} [options.events.blur] - It would be emitted when editor loose focus\n *         @param {function} [options.events.keydown] - It would be emitted when the key is pressed in editor\n *         @param {function} [options.events.keyup] - It would be emitted when the key is released in editor\n *         @param {function} [options.events.beforePreviewRender] - It would be emitted before rendering the markdown preview with html string\n *         @param {function} [options.events.beforeConvertWysiwygToMarkdown] - It would be emitted before converting wysiwyg to markdown with markdown text\n *     @param {Object} [options.hooks] - Hooks\n *         @param {addImageBlobHook} [options.hooks.addImageBlobHook] - hook for image upload\n *     @param {string} [options.language=\'en-US\'] - language\n *     @param {boolean} [options.useCommandShortcut=true] - whether use keyboard shortcuts to perform commands\n *     @param {boolean} [options.usageStatistics=true] - send hostname to google analytics\n *     @param {Array.<string|toolbarItemsValue>} [options.toolbarItems] - toolbar items.\n *     @param {boolean} [options.hideModeSwitch=false] - hide mode switch tab bar\n *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].\n *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec\n *     @param {string} [options.placeholder] - The placeholder text of the editable element.\n *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type\n *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node\n *     @param {Object} [options.customMarkdownRenderer=null] - Object containing custom renderer functions correspond to change wysiwyg node to markdown text\n *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition\n *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer\n *     @param {boolean} [options.previewHighlight=false] - whether highlight preview area\n *     @param {boolean} [options.frontMatter=false] - whether use the front matter\n *     @param {Array.<object>} [options.widgetRules=[]] - The rules for replacing the text with widget node\n *     @param {string} [options.theme] - The theme to style the editor with. The default is included in toastui-editor.css.\n *     @param {autofocus} [options.autofocus=true] - automatically focus the editor on creation.\n */\nvar ToastUIEditorCore = /** @class */ (function () {\n    function ToastUIEditorCore(options) {\n        var _this = this;\n        this.initialHTML = options.el.innerHTML;\n        options.el.innerHTML = \'\';\n        this.options = extend_1({\n            previewStyle: \'tab\',\n            previewHighlight: true,\n            initialEditType: \'markdown\',\n            height: \'300px\',\n            minHeight: \'200px\',\n            language: \'en-US\',\n            useCommandShortcut: true,\n            usageStatistics: true,\n            toolbarItems: [\n                [\'heading\', \'bold\', \'italic\', \'strike\'],\n                [\'hr\', \'quote\'],\n                [\'ul\', \'ol\', \'task\', \'indent\', \'outdent\'],\n                [\'table\', \'image\', \'link\'],\n                [\'code\', \'codeblock\'],\n                [\'scrollSync\'],\n            ],\n            hideModeSwitch: false,\n            linkAttributes: null,\n            extendedAutolinks: false,\n            customHTMLRenderer: null,\n            customMarkdownRenderer: null,\n            referenceDefinition: false,\n            customHTMLSanitizer: null,\n            frontMatter: false,\n            widgetRules: [],\n            theme: \'light\',\n            autofocus: true,\n        }, options);\n        var _a = this.options, customHTMLRenderer = _a.customHTMLRenderer, extendedAutolinks = _a.extendedAutolinks, referenceDefinition = _a.referenceDefinition, frontMatter = _a.frontMatter, customMarkdownRenderer = _a.customMarkdownRenderer, useCommandShortcut = _a.useCommandShortcut, initialEditType = _a.initialEditType, widgetRules = _a.widgetRules, customHTMLSanitizer = _a.customHTMLSanitizer;\n        this.mode = initialEditType || \'markdown\';\n        this.mdPreviewStyle = this.options.previewStyle;\n        this.i18n = i18n;\n        this.i18n.setCode(this.options.language);\n        this.eventEmitter = new EventEmitter();\n        setWidgetRules(widgetRules);\n        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);\n        this.pluginInfo = getPluginInfo({\n            plugins: this.options.plugins,\n            eventEmitter: this.eventEmitter,\n            usageStatistics: this.options.usageStatistics,\n            instance: this,\n        });\n        var _b = this.pluginInfo, toHTMLRenderers = _b.toHTMLRenderers, toMarkdownRenderers = _b.toMarkdownRenderers, mdPlugins = _b.mdPlugins, wwPlugins = _b.wwPlugins, wwNodeViews = _b.wwNodeViews, mdCommands = _b.mdCommands, wwCommands = _b.wwCommands, markdownParsers = _b.markdownParsers;\n        var rendererOptions = {\n            linkAttributes: linkAttributes,\n            customHTMLRenderer: deepMergedCopy(toHTMLRenderers, customHTMLRenderer),\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            frontMatter: frontMatter,\n            sanitizer: customHTMLSanitizer || sanitizeHTML,\n        };\n        var wwToDOMAdaptor = new WwToDOMAdaptor(linkAttributes, rendererOptions.customHTMLRenderer);\n        var htmlSchemaMap = createHTMLSchemaMap(rendererOptions.customHTMLRenderer, rendererOptions.sanitizer, wwToDOMAdaptor);\n        this.toastMark = new ToastMark(\'\', {\n            disallowedHtmlBlockTags: [\'br\', \'img\'],\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            disallowDeepHeading: true,\n            frontMatter: frontMatter,\n            customParser: markdownParsers,\n        });\n        this.mdEditor = new MdEditor(this.eventEmitter, {\n            toastMark: this.toastMark,\n            useCommandShortcut: useCommandShortcut,\n            mdPlugins: mdPlugins,\n        });\n        this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, rendererOptions), { isViewer: false, highlight: this.options.previewHighlight }));\n        this.wwEditor = new WysiwygEditor(this.eventEmitter, {\n            toDOMAdaptor: wwToDOMAdaptor,\n            useCommandShortcut: useCommandShortcut,\n            htmlSchemaMap: htmlSchemaMap,\n            linkAttributes: linkAttributes,\n            wwPlugins: wwPlugins,\n            wwNodeViews: wwNodeViews,\n        });\n        this.convertor = new Convertor(this.wwEditor.getSchema(), __assign$1(__assign$1({}, toMarkdownRenderers), customMarkdownRenderer), getHTMLRenderConvertors(linkAttributes, rendererOptions.customHTMLRenderer), this.eventEmitter);\n        this.setMinHeight(this.options.minHeight);\n        this.setHeight(this.options.height);\n        this.setMarkdown(this.options.initialValue, false);\n        if (this.options.placeholder) {\n            this.setPlaceholder(this.options.placeholder);\n        }\n        if (!this.options.initialValue) {\n            this.setHTML(this.initialHTML, false);\n        }\n        this.commandManager = new CommandManager(this.eventEmitter, this.mdEditor.commands, this.wwEditor.commands, function () { return _this.mode; });\n        if (this.options.usageStatistics) {\n            sendHostName();\n        }\n        this.scrollSync = new ScrollSync(this.mdEditor, this.preview, this.eventEmitter);\n        this.addInitEvent();\n        this.addInitCommand(mdCommands, wwCommands);\n        buildQuery(this);\n        if (this.options.hooks) {\n            forEachOwnProperties_1(this.options.hooks, function (fn, key) { return _this.addHook(key, fn); });\n        }\n        if (this.options.events) {\n            forEachOwnProperties_1(this.options.events, function (fn, key) { return _this.on(key, fn); });\n        }\n        this.eventEmitter.emit(\'load\', this);\n        this.moveCursorToStart(this.options.autofocus);\n    }\n    ToastUIEditorCore.prototype.addInitEvent = function () {\n        var _this = this;\n        this.on(\'needChangeMode\', this.changeMode.bind(this));\n        this.on(\'loadUI\', function () {\n            if (_this.height !== \'auto\') {\n                // 75px equals default editor ui height - the editing area height\n                var minHeight = Math.min(parseInt(_this.minHeight, 10), parseInt(_this.height, 10) - 75) + "px";\n                _this.setMinHeight(minHeight);\n            }\n        });\n        addDefaultImageBlobHook(this.eventEmitter);\n    };\n    ToastUIEditorCore.prototype.addInitCommand = function (mdCommands, wwCommands) {\n        var _this = this;\n        var addPluginCommands = function (type, commandMap) {\n            Object.keys(commandMap).forEach(function (name) {\n                _this.addCommand(type, name, commandMap[name]);\n            });\n        };\n        this.addCommand(\'markdown\', \'toggleScrollSync\', function (payload) {\n            _this.eventEmitter.emit(\'toggleScrollSync\', payload.active);\n            return true;\n        });\n        addPluginCommands(\'markdown\', mdCommands);\n        addPluginCommands(\'wysiwyg\', wwCommands);\n    };\n    ToastUIEditorCore.prototype.getCurrentModeEditor = function () {\n        return (this.isMarkdownMode() ? this.mdEditor : this.wwEditor);\n    };\n    /**\n     * Factory method for Editor\n     * @param {object} options Option for initialize TUIEditor\n     * @returns {object} ToastUIEditorCore or ToastUIEditorViewer\n     */\n    ToastUIEditorCore.factory = function (options) {\n        return options.viewer ? new ToastUIEditorViewer(options) : new ToastUIEditorCore(options);\n    };\n    /**\n     * Set language\n     * @param {string|string[]} code - code for I18N language\n     * @param {object} data - language set\n     */\n    ToastUIEditorCore.setLanguage = function (code, data) {\n        i18n.setLanguage(code, data);\n    };\n    /**\n     * change preview style\n     * @param {string} style - \'tab\'|\'vertical\'\n     */\n    ToastUIEditorCore.prototype.changePreviewStyle = function (style) {\n        if (this.mdPreviewStyle !== style) {\n            this.mdPreviewStyle = style;\n            this.eventEmitter.emit(\'changePreviewStyle\', style);\n        }\n    };\n    /**\n     * execute editor command\n     * @param {string} name - command name\n     * @param {object} [payload] - payload for command\n     */\n    ToastUIEditorCore.prototype.exec = function (name, payload) {\n        this.commandManager.exec(name, payload);\n    };\n    /**\n     * @param {string} type - editor type\n     * @param {string} name - command name\n     * @param {function} command - command handler\n     */\n    ToastUIEditorCore.prototype.addCommand = function (type, name, command) {\n        var _this = this;\n        var commandHoc = function (paylaod) {\n            if (paylaod === void 0) { paylaod = {}; }\n            var view = (type === \'markdown\' ? _this.mdEditor : _this.wwEditor).view;\n            command(paylaod, view.state, view.dispatch, view);\n        };\n        this.commandManager.addCommand(type, name, commandHoc);\n    };\n    /**\n     * Bind eventHandler to event type\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorCore.prototype.on = function (type, handler) {\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Unbind eventHandler from event type\n     * @param {string} type Event type\n     */\n    ToastUIEditorCore.prototype.off = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Add hook to TUIEditor event\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorCore.prototype.addHook = function (type, handler) {\n        this.eventEmitter.removeEventHandler(type);\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Remove hook from TUIEditor event\n     * @param {string} type Event type\n     */\n    ToastUIEditorCore.prototype.removeHook = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Set focus to current Editor\n     */\n    ToastUIEditorCore.prototype.focus = function () {\n        this.getCurrentModeEditor().focus();\n    };\n    /**\n     * Remove focus of current Editor\n     */\n    ToastUIEditorCore.prototype.blur = function () {\n        this.getCurrentModeEditor().blur();\n    };\n    /**\n     * Set cursor position to end\n     * @param {boolean} [focus] - automatically focus the editor\n     */\n    ToastUIEditorCore.prototype.moveCursorToEnd = function (focus) {\n        if (focus === void 0) { focus = true; }\n        this.getCurrentModeEditor().moveCursorToEnd(focus);\n    };\n    /**\n     * Set cursor position to start\n     * @param {boolean} [focus] - automatically focus the editor\n     */\n    ToastUIEditorCore.prototype.moveCursorToStart = function (focus) {\n        if (focus === void 0) { focus = true; }\n        this.getCurrentModeEditor().moveCursorToStart(focus);\n    };\n    /**\n     * Set markdown syntax text.\n     * @param {string} markdown - markdown syntax text.\n     * @param {boolean} [cursorToEnd=true] - move cursor to contents end\n     */\n    ToastUIEditorCore.prototype.setMarkdown = function (markdown, cursorToEnd) {\n        if (markdown === void 0) { markdown = \'\'; }\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        this.mdEditor.setMarkdown(markdown, cursorToEnd);\n        if (this.isWysiwygMode()) {\n            var mdNode = this.toastMark.getRootNode();\n            var wwNode = this.convertor.toWysiwygModel(mdNode);\n            this.wwEditor.setModel(wwNode, cursorToEnd);\n        }\n    };\n    /**\n     * Set html value.\n     * @param {string} html - html syntax text\n     * @param {boolean} [cursorToEnd=true] - move cursor to contents end\n     */\n    ToastUIEditorCore.prototype.setHTML = function (html, cursorToEnd) {\n        if (html === void 0) { html = \'\'; }\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        var container = document.createElement(\'div\');\n        // the `br` tag should be replaced with empty block to separate between blocks\n        container.innerHTML = replaceBRWithEmptyBlock(html);\n        var wwNode = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(this.wwEditor.schema).parse(container);\n        if (this.isMarkdownMode()) {\n            this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), cursorToEnd);\n        }\n        else {\n            this.wwEditor.setModel(wwNode, cursorToEnd);\n        }\n    };\n    /**\n     * Get content to markdown\n     * @returns {string} markdown text\n     */\n    ToastUIEditorCore.prototype.getMarkdown = function () {\n        if (this.isMarkdownMode()) {\n            return this.mdEditor.getMarkdown();\n        }\n        return this.convertor.toMarkdownText(this.wwEditor.getModel());\n    };\n    /**\n     * Get content to html\n     * @returns {string} html string\n     */\n    ToastUIEditorCore.prototype.getHTML = function () {\n        var _this = this;\n        this.eventEmitter.holdEventInvoke(function () {\n            if (_this.isMarkdownMode()) {\n                var mdNode = _this.toastMark.getRootNode();\n                var wwNode = _this.convertor.toWysiwygModel(mdNode);\n                _this.wwEditor.setModel(wwNode);\n            }\n        });\n        var html = removeProseMirrorHackNodes(this.wwEditor.view.dom.innerHTML);\n        if (this.placeholder) {\n            var rePlaceholder = new RegExp("<span class=\\"placeholder[^>]+>" + this.placeholder + "</span>", \'i\');\n            return html.replace(rePlaceholder, \'\');\n        }\n        return html;\n    };\n    /**\n     * Insert text\n     * @param {string} text - text content\n     */\n    ToastUIEditorCore.prototype.insertText = function (text) {\n        this.getCurrentModeEditor().replaceSelection(text);\n    };\n    /**\n     * Set selection range\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     */\n    ToastUIEditorCore.prototype.setSelection = function (start, end) {\n        this.getCurrentModeEditor().setSelection(start, end);\n    };\n    /**\n     * Replace selection range with given text content\n     * @param {string} text - text content\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     */\n    ToastUIEditorCore.prototype.replaceSelection = function (text, start, end) {\n        this.getCurrentModeEditor().replaceSelection(text, start, end);\n    };\n    /**\n     * Delete the content of selection range\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     */\n    ToastUIEditorCore.prototype.deleteSelection = function (start, end) {\n        this.getCurrentModeEditor().deleteSelection(start, end);\n    };\n    /**\n     * Get selected text content\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     * @returns {string} - selected text content\n     */\n    ToastUIEditorCore.prototype.getSelectedText = function (start, end) {\n        return this.getCurrentModeEditor().getSelectedText(start, end);\n    };\n    /**\n     * Get range of the node\n     * @param {number|Array.<number>} [pos] - position\n     * @returns {Array.<number[]>|Array.<number>} - node [start, end] range\n     * @example\n     * // Markdown mode\n     * const rangeInfo = editor.getRangeInfoOfNode();\n     *\n     * console.log(rangeInfo); // { range: [[startLineOffset, startCurorOffset], [endLineOffset, endCurorOffset]], type: \'emph\' }\n     *\n     * // WYSIWYG mode\n     * const rangeInfo = editor.getRangeInfoOfNode();\n     *\n     * console.log(rangeInfo); // { range: [startCursorOffset, endCursorOffset], type: \'emph\' }\n     */\n    ToastUIEditorCore.prototype.getRangeInfoOfNode = function (pos) {\n        return this.getCurrentModeEditor().getRangeInfoOfNode(pos);\n    };\n    /**\n     * Add widget to selection\n     * @param {Node} node - widget node\n     * @param {string} style - Adding style "top" or "bottom"\n     * @param {number|Array.<number>} [pos] - position\n     */\n    ToastUIEditorCore.prototype.addWidget = function (node, style, pos) {\n        this.getCurrentModeEditor().addWidget(node, style, pos);\n    };\n    /**\n     * Replace node with widget to range\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     * @param {string} text - widget text content\n     */\n    ToastUIEditorCore.prototype.replaceWithWidget = function (start, end, text) {\n        this.getCurrentModeEditor().replaceWithWidget(start, end, text);\n    };\n    /**\n     * Set editor height\n     * @param {string} height - editor height in pixel\n     */\n    ToastUIEditorCore.prototype.setHeight = function (height) {\n        var el = this.options.el;\n        if (isString_1(height)) {\n            if (height === \'auto\') {\n                addClass_1(el, \'auto-height\');\n            }\n            else {\n                removeClass_1(el, \'auto-height\');\n            }\n            this.setMinHeight(this.getMinHeight());\n        }\n        css_1(el, { height: height });\n        this.height = height;\n    };\n    /**\n     * Get editor height\n     * @returns {string} editor height in pixel\n     */\n    ToastUIEditorCore.prototype.getHeight = function () {\n        return this.height;\n    };\n    /**\n     * Set minimum height to editor content\n     * @param {string} minHeight - min content height in pixel\n     */\n    ToastUIEditorCore.prototype.setMinHeight = function (minHeight) {\n        if (minHeight !== this.minHeight) {\n            var height = this.height || this.options.height;\n            if (height !== \'auto\' && this.options.el.querySelector("." + cls(\'main\'))) {\n                // 75px equals default editor ui height - the editing area height\n                minHeight = Math.min(parseInt(minHeight, 10), parseInt(height, 10) - 75) + "px";\n            }\n            var minHeightNum = parseInt(minHeight, 10);\n            this.minHeight = minHeight;\n            this.wwEditor.setMinHeight(minHeightNum);\n            this.mdEditor.setMinHeight(minHeightNum);\n            this.preview.setMinHeight(minHeightNum);\n        }\n    };\n    /**\n     * Get minimum height of editor content\n     * @returns {string} min height in pixel\n     */\n    ToastUIEditorCore.prototype.getMinHeight = function () {\n        return this.minHeight;\n    };\n    /**\n     * Return true if current editor mode is Markdown\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isMarkdownMode = function () {\n        return this.mode === \'markdown\';\n    };\n    /**\n     * Return true if current editor mode is WYSIWYG\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isWysiwygMode = function () {\n        return this.mode === \'wysiwyg\';\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isViewer = function () {\n        return false;\n    };\n    /**\n     * Get current Markdown editor\'s preview style\n     * @returns {string}\n     */\n    ToastUIEditorCore.prototype.getCurrentPreviewStyle = function () {\n        return this.mdPreviewStyle;\n    };\n    /**\n     * Change editor\'s mode to given mode string\n     * @param {string} mode - Editor mode name of want to change\n     * @param {boolean} [withoutFocus] - Change mode without focus\n     */\n    ToastUIEditorCore.prototype.changeMode = function (mode, withoutFocus) {\n        if (this.mode === mode) {\n            return;\n        }\n        this.mode = mode;\n        if (this.isWysiwygMode()) {\n            var mdNode = this.toastMark.getRootNode();\n            var wwNode = this.convertor.toWysiwygModel(mdNode);\n            this.wwEditor.setModel(wwNode);\n        }\n        else {\n            var wwNode = this.wwEditor.getModel();\n            this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), !withoutFocus);\n        }\n        this.eventEmitter.emit(\'removePopupWidget\');\n        this.eventEmitter.emit(\'changeMode\', mode);\n        if (!withoutFocus) {\n            var pos = this.convertor.getMappedPos();\n            this.focus();\n            if (this.isWysiwygMode() && isNumber_1(pos)) {\n                this.wwEditor.setSelection(pos);\n            }\n            else if (Array.isArray(pos)) {\n                this.mdEditor.setSelection(pos);\n            }\n        }\n    };\n    /**\n     * Destroy TUIEditor from document\n     */\n    ToastUIEditorCore.prototype.destroy = function () {\n        var _this = this;\n        this.wwEditor.destroy();\n        this.mdEditor.destroy();\n        this.preview.destroy();\n        this.scrollSync.destroy();\n        this.eventEmitter.emit(\'destroy\');\n        this.eventEmitter.getEvents().forEach(function (_, type) { return _this.off(type); });\n    };\n    /**\n     * Hide TUIEditor\n     */\n    ToastUIEditorCore.prototype.hide = function () {\n        this.eventEmitter.emit(\'hide\');\n    };\n    /**\n     * Show TUIEditor\n     */\n    ToastUIEditorCore.prototype.show = function () {\n        this.eventEmitter.emit(\'show\');\n    };\n    /**\n     * Move on scroll position of the editor container\n     * @param {number} value scrollTop value of editor container\n     */\n    ToastUIEditorCore.prototype.setScrollTop = function (value) {\n        this.getCurrentModeEditor().setScrollTop(value);\n    };\n    /**\n     * Get scroll position value of editor container\n     * @returns {number} scrollTop value of editor container\n     */\n    ToastUIEditorCore.prototype.getScrollTop = function () {\n        return this.getCurrentModeEditor().getScrollTop();\n    };\n    /**\n     * Reset TUIEditor\n     */\n    ToastUIEditorCore.prototype.reset = function () {\n        this.wwEditor.setModel([]);\n        this.mdEditor.setMarkdown(\'\');\n    };\n    /**\n     * Get current selection range\n     * @returns {Array.<number[]>|Array.<number>} Returns the range of the selection depending on the editor mode\n     * @example\n     * // Markdown mode\n     * const mdSelection = editor.getSelection();\n     *\n     * console.log(mdSelection); // [[startLineOffset, startCurorOffset], [endLineOffset, endCurorOffset]]\n     *\n     * // WYSIWYG mode\n     * const wwSelection = editor.getSelection();\n     *\n     * console.log(wwSelection); // [startCursorOffset, endCursorOffset]\n     */\n    ToastUIEditorCore.prototype.getSelection = function () {\n        return this.getCurrentModeEditor().getSelection();\n    };\n    /**\n     * Set the placeholder on all editors\n     * @param {string} placeholder - placeholder to set\n     */\n    ToastUIEditorCore.prototype.setPlaceholder = function (placeholder) {\n        this.placeholder = placeholder;\n        this.mdEditor.setPlaceholder(placeholder);\n        this.wwEditor.setPlaceholder(placeholder);\n    };\n    /**\n     * Get markdown editor, preview, wysiwyg editor DOM elements\n     */\n    ToastUIEditorCore.prototype.getEditorElements = function () {\n        return {\n            mdEditor: this.mdEditor.getElement(),\n            mdPreview: this.preview.getElement(),\n            wwEditor: this.wwEditor.getElement(),\n        };\n    };\n    /**\n     * Convert position to match editor mode\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     * @param {string} mode - Editor mode name of want to match converted position to\n     */\n    ToastUIEditorCore.prototype.convertPosToMatchEditorMode = function (start, end, mode) {\n        var _a, _b;\n        if (end === void 0) { end = start; }\n        if (mode === void 0) { mode = this.mode; }\n        var doc = this.mdEditor.view.state.doc;\n        var isFromArray = Array.isArray(start);\n        var isToArray = Array.isArray(end);\n        var convertedFrom = start;\n        var convertedTo = end;\n        if (isFromArray !== isToArray) {\n            throw new Error(\'Types of arguments must be same\');\n        }\n        if (mode === \'markdown\' && !isFromArray && !isToArray) {\n            _a = getEditorToMdPos(doc, start, end), convertedFrom = _a[0], convertedTo = _a[1];\n        }\n        else if (mode === \'wysiwyg\' && isFromArray && isToArray) {\n            _b = getMdToEditorPos(doc, start, end), convertedFrom = _b[0], convertedTo = _b[1];\n        }\n        return [convertedFrom, convertedTo];\n    };\n    return ToastUIEditorCore;\n}());\n\n// @TODO: change syntax with our convention\n/* eslint-disable */\nfunction html$1 (n) {\n  for (\n    var l,\n      e,\n      s = arguments,\n      t = 1,\n      r = \'\',\n      u = \'\',\n      a = [0],\n      c = function (n) {\n        t === 1 && (n || (r = r.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g, \'\')))\n          ? a.push(n ? s[n] : r)\n          : t === 3 && (n || r)\n          ? ((a[1] = n ? s[n] : r), (t = 2))\n          : t === 2 && r === \'...\' && n\n          ? (a[2] = assign(a[2] || {}, s[n]))\n          : t === 2 && r && !n\n          ? ((a[2] = a[2] || {})[r] = !0)\n          : t >= 5 &&\n            (t === 5\n              ? (((a[2] = a[2] || {})[e] = n ? (r ? r + s[n] : s[n]) : r), (t = 6))\n              : (n || r) && (a[2][e] += n ? r + s[n] : r)),\n          (r = \'\');\n      },\n      h = 0;\n    h < n.length;\n    h++\n  ) {\n    h && (t === 1 && c(), c(h));\n    for (let i = 0; i < n[h].length; i++)\n      (l = n[h][i]),\n        t === 1\n          ? l === \'<\'\n            ? (c(), (a = [a, \'\', null]), (t = 3))\n            : (r += l)\n          : t === 4\n          ? r === \'--\' && l === \'>\'\n            ? ((t = 1), (r = \'\'))\n            : (r = l + r[0])\n          : u\n          ? l === u\n            ? (u = \'\')\n            : (r += l)\n          : l === \'"\' || l === "\'"\n          ? (u = l)\n          : l === \'>\'\n          ? (c(), (t = 1))\n          : t &&\n            (l === \'=\'\n              ? ((t = 5), (e = r), (r = \'\'))\n              : l === \'/\' && (t < 5 || n[h][i + 1] === \'>\')\n              ? (c(),\n                t === 3 && (a = a[0]),\n                (t = a),\n                (a = a[0]).push(this.apply(null, t.slice(1))),\n                (t = 0))\n              : l === \' \' || l === \'\\t\' || l === \'\\n\' || l === \'\\r\'\n              ? (c(), (t = 2))\n              : (r += l)),\n        t === 3 && r === \'!--\' && ((t = 4), (a = a[0]));\n  }\n  return c(), a.length > 2 ? a.slice(1) : a[1];\n}\n\n/**\n * @fileoverview Check whether the given variable is a string or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a boolean or not.\n *  If the given variable is a boolean, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is boolean?\n * @memberof module:type\n */\nfunction isBoolean(obj) {\n  return typeof obj === \'boolean\' || obj instanceof Boolean;\n}\n\nvar isBoolean_1 = isBoolean;\n\nvar VNodeWalker = /** @class */ (function () {\n    function VNodeWalker(current) {\n        this.current = current;\n        this.root = current;\n        this.entering = true;\n    }\n    VNodeWalker.prototype.walk = function () {\n        var _a = this, entering = _a.entering, cur = _a.current;\n        if (!cur) {\n            return null;\n        }\n        if (entering) {\n            if (cur.firstChild) {\n                this.current = cur.firstChild;\n                this.entering = true;\n            }\n            else {\n                this.entering = false;\n            }\n        }\n        else if (cur === this.root) {\n            this.current = null;\n        }\n        else if (cur.next) {\n            this.current = cur.next;\n            this.entering = true;\n        }\n        else {\n            this.current = cur.parent;\n            this.entering = false;\n        }\n        return { vnode: cur, entering: entering };\n    };\n    return VNodeWalker;\n}());\nvar VNode = /** @class */ (function () {\n    function VNode(type, props, children) {\n        this.parent = null;\n        this.old = null;\n        this.firstChild = null;\n        this.next = null;\n        this.skip = false;\n        this.type = type;\n        this.props = props;\n        this.children = children;\n        this.props.children = children;\n        if (props.ref) {\n            this.ref = props.ref;\n            delete props.ref;\n        }\n        if (props.key) {\n            this.key = props.key;\n            delete props.key;\n        }\n    }\n    VNode.prototype.walker = function () {\n        return new VNodeWalker(this);\n    };\n    VNode.removalNodes = [];\n    return VNode;\n}());\n\nfunction createTextNode(text) {\n    return new VNode(\'TEXT_NODE\', { nodeValue: text }, []);\n}\nfunction excludeUnnecessaryChild(child, flatted) {\n    var vnode = child;\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    if (isBoolean_1(child) || child == null) {\n        vnode = null;\n    }\n    else if (isString_1(child) || isNumber_1(child)) {\n        vnode = createTextNode(String(child));\n    }\n    if (vnode) {\n        flatted.push(vnode);\n    }\n}\nfunction h(type, props) {\n    var children = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        children[_i - 2] = arguments[_i];\n    }\n    var flatted = [];\n    children.forEach(function (child) {\n        if (Array.isArray(child)) {\n            child.forEach(function (vnode) {\n                excludeUnnecessaryChild(vnode, flatted);\n            });\n        }\n        else {\n            excludeUnnecessaryChild(child, flatted);\n        }\n    });\n    return new VNode(type, props || {}, flatted);\n}\n// @ts-ignore\nvar html = html$1.bind(h);\n\n/**\n * @fileoverview Check whether the given variable is an object or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is an object or not.\n * If the given variable is an object, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is object?\n * @memberof module:type\n */\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\nvar isObject_1 = isObject;\n\n// @TODO: clearfy the type definition for CSSDeclaration\nfunction createNode(vnode) {\n    var node;\n    if (vnode.type === \'TEXT_NODE\') {\n        node = document.createTextNode(vnode.props.nodeValue);\n    }\n    else {\n        node = document.createElement(vnode.type);\n        setProps(node, {}, vnode.props);\n    }\n    return node;\n}\nfunction removeNode(vnode, parentNode) {\n    if (vnode.node) {\n        parentNode.removeChild(vnode.node);\n    }\n    else {\n        removeNode(vnode.firstChild, parentNode);\n    }\n}\nfunction innerDiff(node, prevProps, nextProps) {\n    Object.keys(prevProps).forEach(function (propName) {\n        if (/^on/.test(propName)) {\n            if (!nextProps[propName] || prevProps[propName] !== nextProps[propName]) {\n                var eventName = propName.slice(2).toLowerCase();\n                node.removeEventListener(eventName, prevProps[propName]);\n            }\n        }\n        else if (propName !== \'children\' && !nextProps[propName] && !isTextNode(node)) {\n            node.removeAttribute(propName);\n        }\n    });\n    setProps(node, prevProps, nextProps, function (propName) { return !shallowEqual(prevProps[propName], nextProps[propName]); });\n}\nvar reNonDimension = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\nfunction setProps(node, prevProps, props, condition) {\n    Object.keys(props).forEach(function (propName) {\n        if (!condition || condition(propName)) {\n            if (/^on/.test(propName)) {\n                var eventName = propName.slice(2).toLowerCase();\n                node.addEventListener(eventName, props[propName]);\n            }\n            else if (propName === \'nodeValue\') {\n                node[propName] = props[propName];\n            }\n            else if (propName === \'style\' && isObject_1(props[propName])) {\n                setStyleProps(node, prevProps[propName], props[propName]);\n            }\n            else if (propName !== \'children\') {\n                if (props[propName] === false) {\n                    node.removeAttribute(propName);\n                }\n                else {\n                    node.setAttribute(propName, props[propName]);\n                }\n            }\n        }\n    });\n}\nfunction setStyleProps(node, prevStyleProps, styleProps) {\n    if (prevStyleProps) {\n        Object.keys(prevStyleProps).forEach(function (styleProp) {\n            // @ts-ignore\n            node.style[styleProp] = \'\';\n        });\n    }\n    Object.keys(styleProps).forEach(function (styleProp) {\n        var value = styleProps[styleProp];\n        // @ts-ignore\n        node.style[styleProp] =\n            isNumber_1(value) && !reNonDimension.test(styleProp) ? value + "px" : value;\n    });\n}\n\nfunction commit(vnode) {\n    VNode.removalNodes.forEach(function (removalNode) { return diff(removalNode); });\n    if (vnode) {\n        var next = void 0;\n        var walker = vnode.walker();\n        while ((next = walker.walk())) {\n            vnode = next.vnode;\n            if (next.entering) {\n                diff(vnode);\n            }\n            else if (isFunction_1(vnode.type)) {\n                var comp = vnode.component;\n                // lifecycle method\n                if (!vnode.old && comp.mounted) {\n                    comp.mounted();\n                }\n                if (vnode.old && comp.updated) {\n                    var prevProps = comp.prevProps || {};\n                    comp.updated(prevProps);\n                }\n            }\n        }\n    }\n}\nfunction getParentNode(vnode) {\n    var parent = vnode.parent;\n    while (!parent.node) {\n        parent = parent.parent;\n    }\n    return parent.node;\n}\nfunction diff(vnode) {\n    if (!vnode || !vnode.parent) {\n        return;\n    }\n    if (vnode.node) {\n        var parentNode = getParentNode(vnode);\n        if (vnode.effect === \'A\') {\n            parentNode.appendChild(vnode.node);\n        }\n        else if (vnode.effect === \'U\') {\n            innerDiff(vnode.node, vnode.old.props, vnode.props);\n        }\n    }\n    if (vnode.effect === \'D\') {\n        var next = void 0;\n        var walker = vnode.walker();\n        while ((next = walker.walk())) {\n            vnode = next.vnode;\n            if (!next.entering) {\n                if (isFunction_1(vnode.type)) {\n                    var comp = vnode.component;\n                    // lifecycle method\n                    if (comp.beforeDestroy) {\n                        comp.beforeDestroy();\n                    }\n                }\n                else {\n                    var parentNode = getParentNode(vnode);\n                    removeNode(vnode, parentNode);\n                }\n            }\n        }\n    }\n    // apply ref\n    if (vnode.ref) {\n        if (vnode.component) {\n            vnode.ref(vnode.component);\n        }\n        else if (vnode.node) {\n            vnode.ref(vnode.node);\n        }\n    }\n}\n\nfunction createComponent(Comp, vnode) {\n    var props = vnode.props, component = vnode.component;\n    if (component) {\n        component.prevProps = component.props;\n        component.props = vnode.props;\n        return component;\n    }\n    return new Comp(props);\n}\nfunction buildVNode(vnode) {\n    var root = vnode;\n    while (vnode && !vnode.skip) {\n        if (isFunction_1(vnode.type)) {\n            var instance = createComponent(vnode.type, vnode);\n            instance.vnode = vnode;\n            vnode.component = instance;\n            vnode.props.children = vnode.children = [instance.render()];\n            buildChildrenVNode(vnode);\n        }\n        else {\n            if (!vnode.node) {\n                vnode.node = createNode(vnode);\n            }\n            buildChildrenVNode(vnode);\n        }\n        if (vnode.firstChild) {\n            vnode = vnode.firstChild;\n        }\n        else {\n            while (vnode && vnode.parent && !vnode.next) {\n                vnode = vnode.parent;\n                if (vnode === root) {\n                    break;\n                }\n            }\n            vnode = vnode.next;\n        }\n    }\n}\nfunction isSameType(old, vnode) {\n    return old && vnode && vnode.type === old.type && (!vnode.key || vnode.key === old.key);\n}\n// @TODO: add key diff algorithm\nfunction buildChildrenVNode(parent) {\n    var children = parent.children;\n    var old = parent.old ? parent.old.firstChild : null;\n    var prev = null;\n    children.forEach(function (vnode, index) {\n        var sameType = isSameType(old, vnode);\n        if (sameType) {\n            vnode.old = old;\n            vnode.parent = parent;\n            vnode.node = old.node;\n            vnode.component = old.component;\n            vnode.effect = \'U\';\n        }\n        if (vnode && !sameType) {\n            vnode.old = null;\n            vnode.parent = parent;\n            vnode.node = null;\n            vnode.effect = \'A\';\n        }\n        if (old && !sameType) {\n            VNode.removalNodes.push(old);\n            old.effect = \'D\';\n        }\n        if (old) {\n            old = old.next;\n        }\n        if (index === 0) {\n            parent.firstChild = vnode;\n        }\n        else if (vnode) {\n            prev.next = vnode;\n        }\n        prev = vnode;\n    });\n    var lastChild = last$1(children);\n    if (!children.length) {\n        while (old) {\n            VNode.removalNodes.push(old);\n            old.effect = \'D\';\n            old = old.next;\n        }\n    }\n    while (old && lastChild) {\n        if (old && lastChild.old !== old) {\n            VNode.removalNodes.push(old);\n            old.effect = \'D\';\n            old = old.next;\n        }\n    }\n}\n\nfunction destroy(vnode) {\n    vnode.effect = \'D\';\n    VNode.removalNodes = [vnode];\n    commit();\n    VNode.removalNodes = [];\n}\nfunction rerender(comp) {\n    var root = comp.vnode;\n    root.effect = \'U\';\n    root.old = root;\n    // skip for unnecessary reconciliation\n    if (root.next) {\n        root.next.skip = true;\n    }\n    VNode.removalNodes = [];\n    buildVNode(root);\n    commit(root);\n    if (root.next) {\n        root.next.skip = false;\n    }\n}\nfunction render(container, vnode) {\n    var root = new VNode(container.tagName.toLowerCase(), {}, [vnode]);\n    root.node = container;\n    VNode.removalNodes = [];\n    buildVNode(root);\n    commit(root);\n    return function () { return destroy(root.firstChild); };\n}\n\nvar Component = /** @class */ (function () {\n    function Component(props) {\n        this.props = props;\n        this.state = {};\n        this.refs = {};\n    }\n    Component.prototype.setState = function (state) {\n        var newState = __assign$1(__assign$1({}, this.state), state);\n        if (!shallowEqual(this.state, newState)) {\n            this.state = newState;\n            rerender(this);\n        }\n    };\n    return Component;\n}());\n\nvar Switch = /** @class */ (function (_super) {\n    __extends$1(Switch, _super);\n    function Switch(props) {\n        var _this = _super.call(this, props) || this;\n        _this.state = {\n            hide: false,\n        };\n        return _this;\n    }\n    Switch.prototype.show = function () {\n        this.setState({ hide: false });\n    };\n    Switch.prototype.hide = function () {\n        this.setState({ hide: true });\n    };\n    Switch.prototype.render = function () {\n        var _a = this.props, editorType = _a.editorType, eventEmitter = _a.eventEmitter;\n        return html(templateObject_1$h || (templateObject_1$h = __makeTemplateObject(["\\n      <div class=\\"", "\\" style=\\"display: ", "\\">\\n        <div\\n          class=\\"tab-item", "\\"\\n          onClick=", "\\n        >\\n          ", "\\n        </div>\\n        <div\\n          class=\\"tab-item", "\\"\\n          onClick=", "\\n        >\\n          ", "\\n        </div>\\n      </div>\\n    "], ["\\n      <div class=\\"", "\\" style=\\"display: ", "\\">\\n        <div\\n          class=\\"tab-item", "\\"\\n          onClick=",\n            "\\n        >\\n          ", "\\n        </div>\\n        <div\\n          class=\\"tab-item", "\\"\\n          onClick=",\n            "\\n        >\\n          ", "\\n        </div>\\n      </div>\\n    "])), cls(\'mode-switch\'), this.state.hide ? \'none\' : \'block\', editorType === \'markdown\' ? \' active\' : \'\', function () {\n            eventEmitter.emit(\'needChangeMode\', \'markdown\');\n        }, i18n.get(\'Markdown\'), editorType === \'wysiwyg\' ? \' active\' : \'\', function () {\n            eventEmitter.emit(\'needChangeMode\', \'wysiwyg\');\n        }, i18n.get(\'WYSIWYG\'));\n    };\n    return Switch;\n}(Component));\nvar templateObject_1$h;\n\n/**\n * @fileoverview Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed since the last time the debouced function was invoked.\n * @author NHN FE Development Lab <dl_javascript.nhn.com>\n */\n\n/**\n * @module tricks\n */\n\n/**\n * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed\n * since the last time the debouced function was invoked.\n * @param {function} fn The function to debounce.\n * @param {number} [delay=0] The number of milliseconds to delay\n * @returns {function} debounced function.\n * @memberof module:tricks\n * @example\n * // ES6\n * import debounce from \'tui-code-snippet/tricks/debounce\';\n * \n * // CommonJS\n * const debounce = require(\'tui-code-snippet/tricks/debounce\');\n *\n * function someMethodToInvokeDebounced() {}\n *\n * const debounced = debounce(someMethodToInvokeDebounced, 300);\n *\n * // invoke repeatedly\n * debounced();\n * debounced();\n * debounced();\n * debounced();\n * debounced();\n * debounced();    // last invoke of debounced()\n *\n * // invoke someMethodToInvokeDebounced() after 300 milliseconds.\n */\nfunction debounce$1(fn, delay) {\n  var timer, args;\n\n  /* istanbul ignore next */\n  delay = delay || 0;\n\n  function debounced() { // eslint-disable-line require-jsdoc\n    args = Array.prototype.slice.call(arguments);\n\n    window.clearTimeout(timer);\n    timer = window.setTimeout(function() {\n      fn.apply(null, args);\n    }, delay);\n  }\n\n  return debounced;\n}\n\nvar debounce_1 = debounce$1;\n\n/**\n * @fileoverview Creates a throttled function that only invokes fn at most once per every interval milliseconds.\n * @author NHN FE Development Lab <dl_javascript.nhn.com>\n */\n\nvar debounce = debounce_1;\n\n/**\n * Creates a throttled function that only invokes fn at most once per every interval milliseconds.\n * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)\n * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.\n * @param {function} fn function to throttle\n * @param {number} [interval=0] the number of milliseconds to throttle invocations to.\n * @returns {function} throttled function\n * @memberof module:tricks\n * @example\n * // ES6\n * import throttle from \'tui-code-snippet/tricks/throttle\';\n * \n * // CommonJS\n * const throttle = require(\'tui-code-snippet/tricks/throttle\');\n *\n * function someMethodToInvokeThrottled() {}\n *\n * const throttled = throttle(someMethodToInvokeThrottled, 300);\n *\n * // invoke repeatedly\n * throttled();    // invoke (leading)\n * throttled();\n * throttled();    // invoke (near 300 milliseconds)\n * throttled();\n * throttled();\n * throttled();    // invoke (near 600 milliseconds)\n * // ...\n * // invoke (trailing)\n *\n * // if you need reuse throttled method. then invoke reset()\n * throttled.reset();\n */\nfunction throttle$1(fn, interval) {\n  var base;\n  var isLeading = true;\n  var tick = function(_args) {\n    fn.apply(null, _args);\n    base = null;\n  };\n  var debounced, stamp, args;\n\n  /* istanbul ignore next */\n  interval = interval || 0;\n\n  debounced = debounce(tick, interval);\n\n  function throttled() { // eslint-disable-line require-jsdoc\n    args = Array.prototype.slice.call(arguments);\n\n    if (isLeading) {\n      tick(args);\n      isLeading = false;\n\n      return;\n    }\n\n    stamp = Number(new Date());\n\n    base = base || stamp;\n\n    // pass array directly because `debounce()`, `tick()` are already use\n    // `apply()` method to invoke developer\'s `fn` handler.\n    //\n    // also, this `debounced` line invoked every time for implements\n    // `trailing` features.\n    debounced(args);\n\n    if ((stamp - base) >= interval) {\n      tick(args);\n    }\n  }\n\n  function reset() { // eslint-disable-line require-jsdoc\n    isLeading = true;\n    base = null;\n  }\n\n  throttled.reset = reset;\n\n  return throttled;\n}\n\nvar throttle_1 = throttle$1;\n\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== \'undefined\') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, "size", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== \'undefined\' && typeof document !== \'undefined\' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof __webpack_require__.g !== \'undefined\' && __webpack_require__.g.Math === Math) {\r\n        return __webpack_require__.g;\r\n    }\r\n    if (typeof self !== \'undefined\' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== \'undefined\' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function(\'return this\')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests\' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === \'function\') {\r\n        // It\'s required to use a bounded function because IE sometimes throws\r\n        // an "Invalid calling object" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the "proxy" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for "transitions" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = [\'top\', \'right\', \'bottom\', \'left\', \'width\', \'height\', \'size\', \'weight\'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== \'undefined\';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven\'t been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it\'s present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns "true" if any observer has detected changes in\r\n     *      dimensions of it\'s elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the "Transitionend" event is used as a workaround for\r\n        // delayed transitions. This way it\'s possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener(\'transitionend\', this.onTransitionEnd_);\r\n        window.addEventListener(\'resize\', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener(\'DOMSubtreeModified\', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener(\'transitionend\', this.onTransitionEnd_);\r\n        window.removeEventListener(\'resize\', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener(\'DOMSubtreeModified\', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * "Transitionend" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? \'\' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller\'s instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the "ownerDocument" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it\'s not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles[\'border-\' + position + \'-width\'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = [\'top\', \'right\', \'bottom\', \'left\'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles[\'padding-\' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can\'t be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it\'s not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery\'s \':visible\' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it\'s data wasn\'t\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the \'border-box\' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === \'border-box\') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn\'t include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the "client"\r\n        // properties then it\'s either IE, and thus we don\'t need to subtract\r\n        // anything, or an element merely doesn\'t have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, \'left\', \'right\') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, \'top\', \'bottom\') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can\'t be applied to the document\'s root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it\'s as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and "client" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of "client" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn\'t happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don\'t have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== \'undefined\') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it\'s so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the "getBBox" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === \'function\'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle\'s x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== \'undefined\' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle\'s properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle\'s width.\r\n * @param {number} height - Rectangle\'s height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it\'s changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it\'s width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates \'broadcastWidth\' and \'broadcastHeight\' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element\'s content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they\'d require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don\'t support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it\'s content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== \'function\') {\r\n            throw new TypeError(\'The callback provided as parameter 1 is not a function.\');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError(\'1 argument required, but only 0 present.\');\r\n        }\r\n        // Do nothing if current environment doesn\'t have the Element interface.\r\n        if (typeof Element === \'undefined\' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError(\'parameter 1 is not of type "Element".\');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError(\'1 argument required, but only 0 present.\');\r\n        }\r\n        // Do nothing if current environment doesn\'t have the Element interface.\r\n        if (typeof Element === \'undefined\' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError(\'parameter 1 is not of type "Element".\');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it\'s content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn\'t have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can\'t be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== \'undefined\' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError(\'Cannot call a class as a function.\');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError(\'1 argument required, but only 0 present.\');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    \'observe\',\r\n    \'unobserve\',\r\n    \'disconnect\'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== \'undefined\') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\nvar HeadingPopupBody = /** @class */ (function (_super) {\n    __extends$1(HeadingPopupBody, _super);\n    function HeadingPopupBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    HeadingPopupBody.prototype.execCommand = function (ev) {\n        var el = closest(ev.target, \'li\');\n        this.props.execCommand(\'heading\', {\n            level: Number(el.getAttribute(\'data-level\')),\n        });\n    };\n    HeadingPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject(["\\n      <ul\\n        onClick=", "\\n        aria-role=\\"menu\\"\\n        aria-label=\\"", "\\"\\n      >\\n        ", "\\n        <li data-type=\\"Paragraph\\" aria-role=\\"menuitem\\">\\n          <div>", "</div>\\n        </li>\\n      </ul>\\n    "], ["\\n      <ul\\n        onClick=", "\\n        aria-role=\\"menu\\"\\n        aria-label=\\"", "\\"\\n      >\\n        ",\n            "\\n        <li data-type=\\"Paragraph\\" aria-role=\\"menuitem\\">\\n          <div>", "</div>\\n        </li>\\n      </ul>\\n    "])), function (ev) { return _this.execCommand(ev); }, i18n.get(\'Headings\'), [1, 2, 3, 4, 5, 6].map(function (level) {\n            return html(templateObject_1$g || (templateObject_1$g = __makeTemplateObject(["\\n              <li data-level=\\"", "\\" data-type=\\"Heading\\" aria-role=\\"menuitem\\">\\n                <", ">", " ", "</$>\\n              </li>\\n            "], ["\\n              <li data-level=\\"", "\\" data-type=\\"Heading\\" aria-role=\\"menuitem\\">\\n                <", ">", " ", "</$>\\n              </li>\\n            "])), level, "h" + level, i18n.get(\'Heading\'), level);\n        }), i18n.get(\'Paragraph\'));\n    };\n    return HeadingPopupBody;\n}(Component));\nvar templateObject_1$g, templateObject_2$8;\n\nvar Tabs = /** @class */ (function (_super) {\n    __extends$1(Tabs, _super);\n    function Tabs() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Tabs.prototype.toggleTab = function (ev, activeTab) {\n        this.props.onClick(ev, activeTab);\n    };\n    Tabs.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject(["\\n      <div class=\\"", "\\" aria-role=\\"tabpanel\\">\\n        ", "\\n      </div>\\n    "], ["\\n      <div class=\\"", "\\" aria-role=\\"tabpanel\\">\\n        ",\n            "\\n      </div>\\n    "])), cls(\'tabs\'), this.props.tabs.map(function (_a) {\n            var name = _a.name, text = _a.text;\n            var isActive = _this.props.activeTab === name;\n            return html(templateObject_1$f || (templateObject_1$f = __makeTemplateObject(["\\n            <div\\n              class=\\"tab-item", "\\"\\n              onClick=", "\\n              aria-role=\\"tab\\"\\n              aria-label=\\"", "\\"\\n              aria-selected=\\"", "\\"\\n              tabindex=\\"", "\\"\\n            >\\n              ", "\\n            </div>\\n          "], ["\\n            <div\\n              class=\\"tab-item", "\\"\\n              onClick=", "\\n              aria-role=\\"tab\\"\\n              aria-label=\\"", "\\"\\n              aria-selected=\\"", "\\"\\n              tabindex=\\"", "\\"\\n            >\\n              ", "\\n            </div>\\n          "])), isActive ? \' active\' : \'\', function (ev) { return _this.toggleTab(ev, name); }, i18n.get(text), isActive ? \'true\' : \'false\', isActive ? \'0\' : \'-1\', i18n.get(text));\n        }));\n    };\n    return Tabs;\n}(Component));\nvar templateObject_1$f, templateObject_2$7;\n\nvar TYPE_UI = \'ui\';\nvar ImagePopupBody = /** @class */ (function (_super) {\n    __extends$1(ImagePopupBody, _super);\n    function ImagePopupBody(props) {\n        var _this = _super.call(this, props) || this;\n        _this.initialize = function (activeTab) {\n            if (activeTab === void 0) { activeTab = \'file\'; }\n            var urlEl = _this.refs.url;\n            urlEl.value = \'\';\n            _this.refs.altText.value = \'\';\n            _this.refs.file.value = \'\';\n            removeClass_1(urlEl, \'wrong\');\n            _this.setState({ activeTab: activeTab, file: null, fileNameElClassName: \'\' });\n        };\n        _this.execCommand = function () {\n            if (_this.state.activeTab === \'file\') {\n                _this.emitAddImageBlob();\n            }\n            else {\n                _this.emitAddImage();\n            }\n        };\n        _this.toggleTab = function (_, activeTab) {\n            if (activeTab !== _this.state.activeTab) {\n                _this.initialize(activeTab);\n            }\n        };\n        _this.showFileSelectBox = function () {\n            _this.refs.file.click();\n        };\n        _this.changeFile = function (ev) {\n            var files = ev.target.files;\n            if (files === null || files === void 0 ? void 0 : files.length) {\n                _this.setState({ file: files[0] });\n            }\n        };\n        _this.state = { activeTab: \'file\', file: null, fileNameElClassName: \'\' };\n        _this.tabs = [\n            { name: \'file\', text: \'File\' },\n            { name: \'url\', text: \'URL\' },\n        ];\n        return _this;\n    }\n    ImagePopupBody.prototype.emitAddImageBlob = function () {\n        var _this = this;\n        var files = this.refs.file.files;\n        var altTextEl = this.refs.altText;\n        var fileNameElClassName = \' wrong\';\n        if (files === null || files === void 0 ? void 0 : files.length) {\n            fileNameElClassName = \'\';\n            var imageFile = files.item(0);\n            var hookCallback = function (url, text) {\n                return _this.props.execCommand(\'addImage\', { imageUrl: url, altText: text || altTextEl.value });\n            };\n            this.props.eventEmitter.emit(\'addImageBlobHook\', imageFile, hookCallback, TYPE_UI);\n        }\n        this.setState({ fileNameElClassName: fileNameElClassName });\n    };\n    ImagePopupBody.prototype.emitAddImage = function () {\n        var imageUrlEl = this.refs.url;\n        var altTextEl = this.refs.altText;\n        var imageUrl = imageUrlEl.value;\n        var altText = altTextEl.value || \'image\';\n        removeClass_1(imageUrlEl, \'wrong\');\n        if (!imageUrl.length) {\n            addClass_1(imageUrlEl, \'wrong\');\n            return;\n        }\n        if (imageUrl) {\n            this.props.execCommand(\'addImage\', { imageUrl: imageUrl, altText: altText });\n        }\n    };\n    ImagePopupBody.prototype.preventSelectStart = function (ev) {\n        ev.preventDefault();\n    };\n    ImagePopupBody.prototype.updated = function () {\n        if (!this.props.show) {\n            this.initialize();\n        }\n    };\n    ImagePopupBody.prototype.render = function () {\n        var _this = this;\n        var _a = this.state, activeTab = _a.activeTab, file = _a.file, fileNameElClassName = _a.fileNameElClassName;\n        return html(templateObject_1$e || (templateObject_1$e = __makeTemplateObject(["\\n      <div aria-label=\\"", "\\">\\n        <", " tabs=", " activeTab=", " onClick=", " />\\n        <div style=\\"display:", "\\">\\n          <label for=\\"toastuiImageUrlInput\\">", "</label>\\n          <input\\n            id=\\"toastuiImageUrlInput\\"\\n            type=\\"text\\"\\n            ref=", "\\n          />\\n        </div>\\n        <div style=\\"display:", ";position: relative;\\">\\n          <label for=\\"toastuiImageFileInput\\">", "</label>\\n          <span\\n            class=\\"", "", "\\"\\n            onClick=", "\\n            onSelectstart=", "\\n          >\\n            ", "\\n          </span>\\n          <button\\n            type=\\"button\\"\\n            class=\\"", "\\"\\n            onClick=", "\\n          >\\n            ", "\\n          </button>\\n          <input\\n            id=\\"toastuiImageFileInput\\"\\n            type=\\"file\\"\\n            accept=\\"image/*\\"\\n            onChange=", "\\n            ref=", "\\n          />\\n        </div>\\n        <label for=\\"toastuiAltTextInput\\">", "</label>\\n        <input\\n          id=\\"toastuiAltTextInput\\"\\n          type=\\"text\\"\\n          ref=", "\\n        />\\n        <div class=\\"", "\\">\\n          <button type=\\"button\\" class=\\"", "\\" onClick=", ">\\n            ", "\\n          </button>\\n          <button type=\\"button\\" class=\\"", "\\" onClick=", ">\\n            ", "\\n          </button>\\n        </div>\\n      </div>\\n    "], ["\\n      <div aria-label=\\"", "\\">\\n        <", " tabs=", " activeTab=", " onClick=", " />\\n        <div style=\\"display:", "\\">\\n          <label for=\\"toastuiImageUrlInput\\">", "</label>\\n          <input\\n            id=\\"toastuiImageUrlInput\\"\\n            type=\\"text\\"\\n            ref=", "\\n          />\\n        </div>\\n        <div style=\\"display:", ";position: relative;\\">\\n          <label for=\\"toastuiImageFileInput\\">", "</label>\\n          <span\\n            class=\\"", "", "\\"\\n            onClick=", "\\n            onSelectstart=", "\\n          >\\n            ", "\\n          </span>\\n          <button\\n            type=\\"button\\"\\n            class=\\"", "\\"\\n            onClick=", "\\n          >\\n            ", "\\n          </button>\\n          <input\\n            id=\\"toastuiImageFileInput\\"\\n            type=\\"file\\"\\n            accept=\\"image/*\\"\\n            onChange=", "\\n            ref=", "\\n          />\\n        </div>\\n        <label for=\\"toastuiAltTextInput\\">", "</label>\\n        <input\\n          id=\\"toastuiAltTextInput\\"\\n          type=\\"text\\"\\n          ref=", "\\n        />\\n        <div class=\\"", "\\">\\n          <button type=\\"button\\" class=\\"", "\\" onClick=", ">\\n            ", "\\n          </button>\\n          <button type=\\"button\\" class=\\"", "\\" onClick=", ">\\n            ", "\\n          </button>\\n        </div>\\n      </div>\\n    "])), i18n.get(\'Insert image\'), Tabs, this.tabs, activeTab, this.toggleTab, activeTab === \'url\' ? \'block\' : \'none\', i18n.get(\'Image URL\'), function (el) { return (_this.refs.url = el); }, activeTab === \'file\' ? \'block\' : \'none\', i18n.get(\'Select image file\'), cls(\'file-name\'), file ? \' has-file\' : fileNameElClassName, this.showFileSelectBox, this.preventSelectStart, file ? file.name : i18n.get(\'No file\'), cls(\'file-select-button\'), this.showFileSelectBox, i18n.get(\'Choose a file\'), this.changeFile, function (el) { return (_this.refs.file = el); }, i18n.get(\'Description\'), function (el) { return (_this.refs.altText = el); }, cls(\'button-container\'), cls(\'close-button\'), this.props.hidePopup, i18n.get(\'Cancel\'), cls(\'ok-button\'), this.execCommand, i18n.get(\'OK\'));\n    };\n    return ImagePopupBody;\n}(Component));\nvar templateObject_1$e;\n\nvar LinkPopupBody = /** @class */ (function (_super) {\n    __extends$1(LinkPopupBody, _super);\n    function LinkPopupBody() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.execCommand = function () {\n            var linkUrlEl = _this.refs.url;\n            var linkTextEl = _this.refs.text;\n            removeClass_1(linkUrlEl, \'wrong\');\n            removeClass_1(linkTextEl, \'wrong\');\n            if (linkUrlEl.value.length < 1) {\n                addClass_1(linkUrlEl, \'wrong\');\n                return;\n            }\n            var checkLinkText = isUndefined_1(_this.props.initialValues.linkUrl);\n            if (checkLinkText && linkTextEl.value.length < 1) {\n                addClass_1(linkTextEl, \'wrong\');\n                return;\n            }\n            _this.props.execCommand(\'addLink\', {\n                linkUrl: linkUrlEl.value,\n                linkText: linkTextEl.value,\n            });\n        };\n        return _this;\n    }\n    LinkPopupBody.prototype.initialize = function () {\n        var _a = this.props.initialValues, linkUrl = _a.linkUrl, linkText = _a.linkText;\n        var linkUrlEl = this.refs.url;\n        var linkTextEl = this.refs.text;\n        removeClass_1(linkUrlEl, \'wrong\');\n        removeClass_1(linkTextEl, \'wrong\', \'disabled\');\n        linkTextEl.removeAttribute(\'disabled\');\n        if (linkUrl) {\n            addClass_1(linkTextEl, \'disabled\');\n            linkTextEl.setAttribute(\'disabled\', \'disabled\');\n        }\n        linkUrlEl.value = linkUrl || \'\';\n        linkTextEl.value = linkText || \'\';\n    };\n    LinkPopupBody.prototype.mounted = function () {\n        this.initialize();\n    };\n    LinkPopupBody.prototype.updated = function (prevProps) {\n        if (!prevProps.show && this.props.show) {\n            this.initialize();\n        }\n    };\n    LinkPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_1$d || (templateObject_1$d = __makeTemplateObject(["\\n      <div aria-label=\\"", "\\">\\n        <label for=\\"toastuiLinkUrlInput\\">", "</label>\\n        <input\\n          id=\\"toastuiLinkUrlInput\\"\\n          type=\\"text\\"\\n          ref=", "\\n        />\\n        <label for=\\"toastuiLinkTextInput\\">", "</label>\\n        <input\\n          id=\\"toastuiLinkTextInput\\"\\n          type=\\"text\\"\\n          ref=", "\\n        />\\n        <div class=\\"", "\\">\\n          <button type=\\"button\\" class=\\"", "\\" onClick=", ">\\n            ", "\\n          </button>\\n          <button type=\\"button\\" class=\\"", "\\" onClick=", ">\\n            ", "\\n          </button>\\n        </div>\\n      </div>\\n    "], ["\\n      <div aria-label=\\"", "\\">\\n        <label for=\\"toastuiLinkUrlInput\\">", "</label>\\n        <input\\n          id=\\"toastuiLinkUrlInput\\"\\n          type=\\"text\\"\\n          ref=", "\\n        />\\n        <label for=\\"toastuiLinkTextInput\\">", "</label>\\n        <input\\n          id=\\"toastuiLinkTextInput\\"\\n          type=\\"text\\"\\n          ref=", "\\n        />\\n        <div class=\\"", "\\">\\n          <button type=\\"button\\" class=\\"", "\\" onClick=", ">\\n            ", "\\n          </button>\\n          <button type=\\"button\\" class=\\"", "\\" onClick=", ">\\n            ", "\\n          </button>\\n        </div>\\n      </div>\\n    "])), i18n.get(\'Insert link\'), i18n.get(\'URL\'), function (el) { return (_this.refs.url = el); }, i18n.get(\'Link text\'), function (el) { return (_this.refs.text = el); }, cls(\'button-container\'), cls(\'close-button\'), this.props.hidePopup, i18n.get(\'Cancel\'), cls(\'ok-button\'), this.execCommand, i18n.get(\'OK\'));\n    };\n    return LinkPopupBody;\n}(Component));\nvar templateObject_1$d;\n\nvar CELL_WIDTH = 20;\nvar CELL_HEIGHT = 20;\nvar MIN_ROW_INDEX = 5;\nvar MAX_ROW_INDEX = 14;\nvar MIN_COL_INDEX = 5;\nvar MAX_COL_INDEX = 9;\nvar MIN_ROW_SELECTION_INDEX = 1;\nvar MIN_COL_SELECTION_INDEX = 1;\nvar BORDER_WIDTH = 1;\nvar TablePopupBody = /** @class */ (function (_super) {\n    __extends$1(TablePopupBody, _super);\n    function TablePopupBody(props) {\n        var _this = _super.call(this, props) || this;\n        _this.extendSelectionRange = function (_a) {\n            var pageX = _a.pageX, pageY = _a.pageY;\n            var x = pageX - _this.offsetRect.left;\n            var y = pageY - _this.offsetRect.top;\n            var range = _this.getSelectionRangeByOffset(x, y);\n            _this.setState(__assign$1({}, range));\n        };\n        _this.execCommand = function () {\n            _this.props.execCommand(\'addTable\', {\n                rowCount: _this.state.rowIdx + 1,\n                columnCount: _this.state.colIdx + 1,\n            });\n        };\n        _this.state = {\n            rowIdx: -1,\n            colIdx: -1,\n        };\n        return _this;\n    }\n    TablePopupBody.prototype.getDescription = function () {\n        return this.state.colIdx === -1 ? \'\' : this.state.colIdx + 1 + " x " + (this.state.rowIdx + 1);\n    };\n    TablePopupBody.prototype.getBoundByRange = function (colIdx, rowIdx) {\n        return {\n            width: (colIdx + 1) * CELL_WIDTH,\n            height: (rowIdx + 1) * CELL_HEIGHT,\n        };\n    };\n    TablePopupBody.prototype.getRangeByOffset = function (x, y) {\n        return {\n            colIdx: Math.floor(x / CELL_WIDTH),\n            rowIdx: Math.floor(y / CELL_HEIGHT),\n        };\n    };\n    TablePopupBody.prototype.getTableRange = function () {\n        var _a = this.state, orgColIdx = _a.colIdx, orgRowIdx = _a.rowIdx;\n        var colIdx = Math.max(orgColIdx, MIN_COL_INDEX);\n        var rowIdx = Math.max(orgRowIdx, MIN_ROW_INDEX);\n        if (orgColIdx >= MIN_COL_INDEX && colIdx < MAX_COL_INDEX) {\n            colIdx += 1;\n        }\n        if (orgRowIdx >= MIN_ROW_INDEX && rowIdx < MAX_ROW_INDEX) {\n            rowIdx += 1;\n        }\n        return { colIdx: colIdx + 1, rowIdx: rowIdx + 1 };\n    };\n    TablePopupBody.prototype.getSelectionAreaBound = function () {\n        var _a = this.getBoundByRange(this.state.colIdx, this.state.rowIdx), width = _a.width, height = _a.height;\n        if (!width && !height) {\n            return { display: \'none\' };\n        }\n        return { width: width - BORDER_WIDTH, height: height - BORDER_WIDTH, display: \'block\' };\n    };\n    TablePopupBody.prototype.getSelectionRangeByOffset = function (x, y) {\n        var range = this.getRangeByOffset(x, y);\n        range.rowIdx = Math.min(Math.max(range.rowIdx, MIN_ROW_SELECTION_INDEX), MAX_ROW_INDEX);\n        range.colIdx = Math.min(Math.max(range.colIdx, MIN_COL_SELECTION_INDEX), MAX_COL_INDEX);\n        return range;\n    };\n    TablePopupBody.prototype.updated = function () {\n        if (!this.props.show) {\n            this.setState({ colIdx: -1, rowIdx: -1 });\n        }\n        else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {\n            var _a = this.refs.tableEl.getBoundingClientRect(), left = _a.left, top_1 = _a.top;\n            this.offsetRect = {\n                left: window.pageXOffset + left,\n                top: window.pageYOffset + top_1,\n            };\n        }\n    };\n    TablePopupBody.prototype.createTableArea = function (tableRange) {\n        var colIdx = tableRange.colIdx, rowIdx = tableRange.rowIdx;\n        var rows = [];\n        for (var i = 0; i < rowIdx; i += 1) {\n            var cells = [];\n            for (var j = 0; j < colIdx; j += 1) {\n                var cellClassNames = "" + cls(\'table-cell\') + (i > 0 ? \'\' : \' header\');\n                cells.push(html(templateObject_1$c || (templateObject_1$c = __makeTemplateObject(["<div class=\\"", "\\"></div>"], ["<div class=\\"", "\\"></div>"])), cellClassNames));\n            }\n            rows.push(html(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject(["<div class=\\"", "\\">", "</div>"], ["<div class=\\"", "\\">", "</div>"])), cls(\'table-row\'), cells));\n        }\n        return html(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject(["<div class=\\"", "\\">", "</div>"], ["<div class=\\"", "\\">", "</div>"])), cls(\'table\'), rows);\n    };\n    TablePopupBody.prototype.render = function () {\n        var _this = this;\n        var tableRange = this.getTableRange();\n        var selectionAreaBound = this.getSelectionAreaBound();\n        return html(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject(["\\n      <div aria-label=\\"", "\\">\\n        <div\\n          class=\\"", "\\"\\n          ref=", "\\n          onMousemove=", "\\n          onClick=", "\\n        >\\n          ", "\\n          <div class=\\"", "\\" style=", "></div>\\n        </div>\\n        <p class=\\"", "\\">", "</p>\\n      </div>\\n    "], ["\\n      <div aria-label=\\"", "\\">\\n        <div\\n          class=\\"", "\\"\\n          ref=", "\\n          onMousemove=", "\\n          onClick=", "\\n        >\\n          ", "\\n          <div class=\\"", "\\" style=", "></div>\\n        </div>\\n        <p class=\\"", "\\">", "</p>\\n      </div>\\n    "])), i18n.get(\'Insert table\'), cls(\'table-selection\'), function (el) { return (_this.refs.tableEl = el); }, this.extendSelectionRange, this.execCommand, this.createTableArea(tableRange), cls(\'table-selection-layer\'), selectionAreaBound, cls(\'table-description\'), this.getDescription());\n    };\n    return TablePopupBody;\n}(Component));\nvar templateObject_1$c, templateObject_2$6, templateObject_3$2, templateObject_4$1;\n\nvar CustomPopupBody = /** @class */ (function (_super) {\n    __extends$1(CustomPopupBody, _super);\n    function CustomPopupBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CustomPopupBody.prototype.mounted = function () {\n        // append the custom popup body element\n        this.refs.el.appendChild(this.props.body);\n    };\n    CustomPopupBody.prototype.updated = function (prevProps) {\n        // update custom popup element\n        this.refs.el.replaceChild(this.props.body, prevProps.body);\n    };\n    CustomPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_1$b || (templateObject_1$b = __makeTemplateObject(["<div ref=", "></div>"], ["<div ref=", "></div>"])), function (el) { return (_this.refs.el = el); });\n    };\n    return CustomPopupBody;\n}(Component));\nvar templateObject_1$b;\n\nfunction createToolbarItemInfo(type) {\n    return isString_1(type) ? createDefaultToolbarItemInfo(type) : type;\n}\nfunction createScrollSyncToolbarItem() {\n    var label = document.createElement(\'label\');\n    var checkbox = document.createElement(\'input\');\n    var toggleSwitch = document.createElement(\'span\');\n    label.className = \'scroll-sync active\';\n    checkbox.type = \'checkbox\';\n    checkbox.checked = true;\n    toggleSwitch.className = \'switch\';\n    var onMounted = function (execCommand) {\n        return checkbox.addEventListener(\'change\', function (ev) {\n            var checked = ev.target.checked;\n            if (checked) {\n                addClass_1(label, \'active\');\n            }\n            else {\n                removeClass_1(label, \'active\');\n            }\n            execCommand(\'toggleScrollSync\', { active: checked });\n        });\n    };\n    label.appendChild(checkbox);\n    label.appendChild(toggleSwitch);\n    return {\n        name: \'scrollSync\',\n        el: label,\n        onMounted: onMounted,\n    };\n}\nfunction createDefaultToolbarItemInfo(type) {\n    var info;\n    switch (type) {\n        case \'heading\':\n            info = {\n                name: \'heading\',\n                className: \'heading\',\n                tooltip: i18n.get(\'Headings\'),\n                state: \'heading\',\n            };\n            break;\n        case \'bold\':\n            info = {\n                name: \'bold\',\n                className: \'bold\',\n                command: \'bold\',\n                tooltip: i18n.get(\'Bold\'),\n                state: \'strong\',\n            };\n            break;\n        case \'italic\':\n            info = {\n                name: \'italic\',\n                className: \'italic\',\n                command: \'italic\',\n                tooltip: i18n.get(\'Italic\'),\n                state: \'emph\',\n            };\n            break;\n        case \'strike\':\n            info = {\n                name: \'strike\',\n                className: \'strike\',\n                command: \'strike\',\n                tooltip: i18n.get(\'Strike\'),\n                state: \'strike\',\n            };\n            break;\n        case \'hr\':\n            info = {\n                name: \'hr\',\n                className: \'hrline\',\n                command: \'hr\',\n                tooltip: i18n.get(\'Line\'),\n                state: \'thematicBreak\',\n            };\n            break;\n        case \'quote\':\n            info = {\n                name: \'quote\',\n                className: \'quote\',\n                command: \'blockQuote\',\n                tooltip: i18n.get(\'Blockquote\'),\n                state: \'blockQuote\',\n            };\n            break;\n        case \'ul\':\n            info = {\n                name: \'ul\',\n                className: \'bullet-list\',\n                command: \'bulletList\',\n                tooltip: i18n.get(\'Unordered list\'),\n                state: \'bulletList\',\n            };\n            break;\n        case \'ol\':\n            info = {\n                name: \'ol\',\n                className: \'ordered-list\',\n                command: \'orderedList\',\n                tooltip: i18n.get(\'Ordered list\'),\n                state: \'orderedList\',\n            };\n            break;\n        case \'task\':\n            info = {\n                name: \'task\',\n                className: \'task-list\',\n                command: \'taskList\',\n                tooltip: i18n.get(\'Task\'),\n                state: \'taskList\',\n            };\n            break;\n        case \'table\':\n            info = {\n                name: \'table\',\n                className: \'table\',\n                tooltip: i18n.get(\'Insert table\'),\n                state: \'table\',\n            };\n            break;\n        case \'image\':\n            info = {\n                name: \'image\',\n                className: \'image\',\n                tooltip: i18n.get(\'Insert image\'),\n            };\n            break;\n        case \'link\':\n            info = {\n                name: \'link\',\n                className: \'link\',\n                tooltip: i18n.get(\'Insert link\'),\n            };\n            break;\n        case \'code\':\n            info = {\n                name: \'code\',\n                className: \'code\',\n                command: \'code\',\n                tooltip: i18n.get(\'Code\'),\n                state: \'code\',\n            };\n            break;\n        case \'codeblock\':\n            info = {\n                name: \'codeblock\',\n                className: \'codeblock\',\n                command: \'codeBlock\',\n                tooltip: i18n.get(\'Insert CodeBlock\'),\n                state: \'codeBlock\',\n            };\n            break;\n        case \'indent\':\n            info = {\n                name: \'indent\',\n                className: \'indent\',\n                command: \'indent\',\n                tooltip: i18n.get(\'Indent\'),\n                state: \'indent\',\n            };\n            break;\n        case \'outdent\':\n            info = {\n                name: \'outdent\',\n                className: \'outdent\',\n                command: \'outdent\',\n                tooltip: i18n.get(\'Outdent\'),\n                state: \'outdent\',\n            };\n            break;\n        case \'scrollSync\':\n            info = createScrollSyncToolbarItem();\n            break;\n        case \'more\':\n            info = {\n                name: \'more\',\n                className: \'more\',\n                tooltip: i18n.get(\'More\'),\n            };\n            break;\n        // do nothing\n    }\n    if (info.name !== \'scrollSync\') {\n        info.className += " " + cls(\'toolbar-icons\');\n    }\n    return info;\n}\nfunction createPopupInfo(type, payload) {\n    var el = payload.el, pos = payload.pos, popup = payload.popup, initialValues = payload.initialValues;\n    switch (type) {\n        case \'heading\':\n            return {\n                render: function (props) { return html(templateObject_1$a || (templateObject_1$a = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), HeadingPopupBody, props); },\n                className: cls(\'popup-add-heading\'),\n                fromEl: el,\n                pos: pos,\n            };\n        case \'link\':\n            return {\n                render: function (props) { return html(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), LinkPopupBody, props); },\n                className: cls(\'popup-add-link\'),\n                fromEl: el,\n                pos: pos,\n                initialValues: initialValues,\n            };\n        case \'image\':\n            return {\n                render: function (props) { return html(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), ImagePopupBody, props); },\n                className: cls(\'popup-add-image\'),\n                fromEl: el,\n                pos: pos,\n            };\n        case \'table\':\n            return {\n                render: function (props) { return html(templateObject_4 || (templateObject_4 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), TablePopupBody, props); },\n                className: cls(\'popup-add-table\'),\n                fromEl: el,\n                pos: pos,\n            };\n        case \'customPopupBody\':\n            if (!popup) {\n                return null;\n            }\n            return __assign$1({ render: function (props) { return html(templateObject_5 || (templateObject_5 = __makeTemplateObject(["<", " ...", " body=", " />"], ["<", " ...", " body=", " />"])), CustomPopupBody, props, popup.body); }, fromEl: el, pos: pos }, popup);\n        default:\n            return null;\n    }\n}\nfunction setGroupState(group) {\n    group.hidden = group.length === group.filter(function (info) { return info.hidden; }).length;\n}\nfunction groupToolbarItems(toolbarItems, hiddenScrollSync) {\n    var toggleScrollSyncState = function (item) {\n        item.hidden = item.name === \'scrollSync\' && hiddenScrollSync;\n        return item;\n    };\n    return toolbarItems.reduce(function (acc, item) {\n        acc.push(item.map(function (type) { return toggleScrollSyncState(createToolbarItemInfo(type)); }));\n        var group = acc[(acc.length || 1) - 1];\n        if (group) {\n            setGroupState(group);\n        }\n        return acc;\n    }, []);\n}\nfunction toggleScrollSync(toolbarItems, hiddenScrollSync) {\n    toolbarItems.forEach(function (group) {\n        group.forEach(function (item) { return (item.hidden = item.name === \'scrollSync\' && hiddenScrollSync); });\n        setGroupState(group);\n    });\n}\nvar templateObject_1$a, templateObject_2$5, templateObject_3$1, templateObject_4, templateObject_5;\n\nvar MARGIN_FROM_RIGHT_SIDE = 20;\nvar Popup = /** @class */ (function (_super) {\n    __extends$1(Popup, _super);\n    function Popup() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleMousedown = function (ev) {\n            if (!closest(ev.target, "." + cls(\'popup\')) &&\n                !closest(ev.target, _this.props.info.fromEl)) {\n                _this.props.hidePopup();\n            }\n        };\n        return _this;\n    }\n    Popup.prototype.mounted = function () {\n        document.addEventListener(\'mousedown\', this.handleMousedown);\n        this.props.eventEmitter.listen(\'closePopup\', this.props.hidePopup);\n    };\n    Popup.prototype.beforeDestroy = function () {\n        document.removeEventListener(\'mousedown\', this.handleMousedown);\n    };\n    Popup.prototype.updated = function (prevProps) {\n        var _a = this.props, show = _a.show, info = _a.info;\n        if (show && info.pos && prevProps.show !== show) {\n            var popupPos = __assign$1({}, info.pos);\n            var offsetWidth = this.refs.el.offsetWidth;\n            var toolbarEl = closest(this.refs.el, "." + cls(\'toolbar\'));\n            var toolbarOffsetWidth = toolbarEl.offsetWidth;\n            if (popupPos.left + offsetWidth >= toolbarOffsetWidth) {\n                popupPos.left = toolbarOffsetWidth - offsetWidth - MARGIN_FROM_RIGHT_SIDE;\n            }\n            if (!shallowEqual(this.state.popupPos, popupPos)) {\n                this.setState({ popupPos: popupPos });\n            }\n        }\n    };\n    Popup.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, info = _a.info, show = _a.show, hidePopup = _a.hidePopup, eventEmitter = _a.eventEmitter, execCommand = _a.execCommand;\n        var _b = info || {}, _c = _b.className, className = _c === void 0 ? \'\' : _c, style = _b.style, render = _b.render, _d = _b.initialValues, initialValues = _d === void 0 ? {} : _d;\n        var popupStyle = __assign$1(__assign$1({ display: show ? \'block\' : \'none\' }, style), this.state.popupPos);\n        return html(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject(["\\n      <div\\n        class=\\"", " ", "\\"\\n        style=", "\\n        ref=", "\\n        aria-role=\\"dialog\\"\\n      >\\n        <div class=\\"", "\\">\\n          ", "\\n        </div>\\n      </div>\\n    "], ["\\n      <div\\n        class=\\"", " ", "\\"\\n        style=", "\\n        ref=", "\\n        aria-role=\\"dialog\\"\\n      >\\n        <div class=\\"", "\\">\\n          ", "\\n        </div>\\n      </div>\\n    "])), cls(\'popup\'), className, popupStyle, function (el) { return (_this.refs.el = el); }, cls(\'popup-body\'), render && render({ eventEmitter: eventEmitter, show: show, hidePopup: hidePopup, execCommand: execCommand, initialValues: initialValues }));\n    };\n    return Popup;\n}(Component));\nvar templateObject_1$9;\n\nvar TOOLTIP_INDENT = 6;\nfunction connectHOC(WrappedComponent) {\n    return /** @class */ (function (_super) {\n        __extends$1(ButtonHOC, _super);\n        function ButtonHOC(props) {\n            var _this = _super.call(this, props) || this;\n            _this.showTooltip = function (el) {\n                var tooltip = _this.props.item.tooltip;\n                if (!_this.props.disabled && tooltip) {\n                    var bound = _this.getBound(el);\n                    var left = bound.left + TOOLTIP_INDENT + "px";\n                    var top_1 = bound.top + TOOLTIP_INDENT + "px";\n                    css_1(_this.props.tooltipRef.current, { display: \'block\', left: left, top: top_1 });\n                    _this.props.tooltipRef.current.querySelector(\'.text\').textContent = tooltip;\n                }\n            };\n            _this.hideTooltip = function () {\n                css_1(_this.props.tooltipRef.current, \'display\', \'none\');\n            };\n            _this.state = { active: false, disabled: props.disabled };\n            _this.addEvent();\n            return _this;\n        }\n        ButtonHOC.prototype.addEvent = function () {\n            var _this = this;\n            var _a = this.props, item = _a.item, eventEmitter = _a.eventEmitter;\n            if (item.state) {\n                eventEmitter.listen(\'changeToolbarState\', function (_a) {\n                    var _b;\n                    var toolbarState = _a.toolbarState;\n                    var _c = (_b = toolbarState[item.state]) !== null && _b !== void 0 ? _b : {}, active = _c.active, disabled = _c.disabled;\n                    _this.setState({ active: !!active, disabled: disabled !== null && disabled !== void 0 ? disabled : _this.props.disabled });\n                });\n            }\n        };\n        ButtonHOC.prototype.getBound = function (el) {\n            var _a = getTotalOffset(el, closest(el, "." + cls(\'toolbar\'))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;\n            return { left: offsetLeft, top: el.offsetHeight + offsetTop };\n        };\n        ButtonHOC.prototype.render = function () {\n            return html(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject(["\\n        <", "\\n          ...", "\\n          active=", "\\n          showTooltip=", "\\n          hideTooltip=", "\\n          getBound=", "\\n          disabled=", "\\n        />\\n      "], ["\\n        <", "\\n          ...", "\\n          active=", "\\n          showTooltip=", "\\n          hideTooltip=", "\\n          getBound=", "\\n          disabled=", "\\n        />\\n      "])), WrappedComponent, this.props, this.state.active, this.showTooltip, this.hideTooltip, this.getBound, this.state.disabled || this.props.disabled);\n        };\n        return ButtonHOC;\n    }(Component));\n}\nvar templateObject_1$8;\n\nvar DEFAULT_WIDTH = 80;\nvar ToolbarButtonComp = /** @class */ (function (_super) {\n    __extends$1(ToolbarButtonComp, _super);\n    function ToolbarButtonComp() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.execCommand = function () {\n            var _a = _this.props, item = _a.item, execCommand = _a.execCommand, setPopupInfo = _a.setPopupInfo, getBound = _a.getBound, eventEmitter = _a.eventEmitter;\n            var command = item.command, name = item.name, popup = item.popup;\n            if (command) {\n                execCommand(command);\n            }\n            else {\n                var popupName = popup ? \'customPopupBody\' : name;\n                var initialValues = eventEmitter.emit(\'query\', \'getPopupInitialValues\', { popupName: popupName })[0];\n                var info = createPopupInfo(popupName, {\n                    el: _this.refs.el,\n                    pos: getBound(_this.refs.el),\n                    popup: popup,\n                    initialValues: initialValues,\n                });\n                if (info) {\n                    setPopupInfo(info);\n                }\n            }\n        };\n        return _this;\n    }\n    ToolbarButtonComp.prototype.mounted = function () {\n        this.setItemWidth();\n    };\n    ToolbarButtonComp.prototype.updated = function (prevProps) {\n        if (prevProps.item.name !== this.props.item.name) {\n            this.setItemWidth();\n        }\n    };\n    ToolbarButtonComp.prototype.setItemWidth = function () {\n        var _a = this.props, setItemWidth = _a.setItemWidth, item = _a.item;\n        // set width only if it is not a dropdown toolbar\n        if (setItemWidth) {\n            setItemWidth(item.name, getOuterWidth(this.refs.el) + (item.hidden ? DEFAULT_WIDTH : 0));\n        }\n    };\n    ToolbarButtonComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, hideTooltip = _a.hideTooltip, disabled = _a.disabled, item = _a.item, active = _a.active;\n        var style = __assign$1({ display: item.hidden ? \'none\' : null }, item.style);\n        var classNames = "" + (item.className || \'\') + (active ? \' active\' : \'\');\n        return html(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject(["\\n      <button\\n        ref=", "\\n        type=\\"button\\"\\n        style=", "\\n        class=", "\\n        onClick=", "\\n        onMouseover=", "\\n        onMouseout=", "\\n        disabled=", "\\n        aria-label=", "\\n      >\\n        ", "\\n      </button>\\n    "], ["\\n      <button\\n        ref=", "\\n        type=\\"button\\"\\n        style=", "\\n        class=", "\\n        onClick=", "\\n        onMouseover=", "\\n        onMouseout=", "\\n        disabled=", "\\n        aria-label=", "\\n      >\\n        ", "\\n      </button>\\n    "])), function (el) { return (_this.refs.el = el); }, style, classNames, this.execCommand, this.showTooltip, hideTooltip, !!disabled, item.text || item.tooltip || \'\', item.text || \'\');\n    };\n    return ToolbarButtonComp;\n}(Component));\nvar ToolbarButton = connectHOC(ToolbarButtonComp);\nvar templateObject_1$7;\n\nvar CustomToolbarItemComp = /** @class */ (function (_super) {\n    __extends$1(CustomToolbarItemComp, _super);\n    function CustomToolbarItemComp() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.showPopup = function () {\n            var info = createPopupInfo(\'customPopupBody\', {\n                el: _this.refs.el,\n                pos: _this.props.getBound(_this.refs.el),\n                popup: _this.props.item.popup,\n            });\n            if (info) {\n                _this.props.setPopupInfo(info);\n            }\n        };\n        return _this;\n    }\n    CustomToolbarItemComp.prototype.mounted = function () {\n        var _a = this.props, setItemWidth = _a.setItemWidth, item = _a.item;\n        // append the custom html element\n        this.refs.el.appendChild(item.el);\n        // set width only if it is not a dropdown toolbar\n        if (setItemWidth) {\n            setItemWidth(item.name, getOuterWidth(this.refs.el));\n        }\n        if (item.onMounted) {\n            item.onMounted(this.props.execCommand);\n        }\n    };\n    CustomToolbarItemComp.prototype.updated = function (prevProps) {\n        var _a;\n        var _b = this.props, item = _b.item, active = _b.active, disabled = _b.disabled;\n        if (prevProps.active !== active || prevProps.disabled !== disabled) {\n            (_a = item.onUpdated) === null || _a === void 0 ? void 0 : _a.call(item, { active: active, disabled: disabled });\n        }\n    };\n    CustomToolbarItemComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, disabled = _a.disabled, item = _a.item;\n        var style = { display: item.hidden ? \'none\' : \'inline-block\' };\n        var getListener = function (listener) { return (disabled ? null : listener); };\n        return html(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject(["\\n      <div\\n        ref=", "\\n        style=", "\\n        class=", "\\n        onClick=", "\\n        onMouseover=", "\\n        onMouseout=", "\\n      ></div>\\n    "], ["\\n      <div\\n        ref=", "\\n        style=", "\\n        class=", "\\n        onClick=", "\\n        onMouseover=", "\\n        onMouseout=", "\\n      ></div>\\n    "])), function (el) { return (_this.refs.el = el); }, style, cls(\'toolbar-item-wrapper\'), getListener(this.showPopup), getListener(this.showTooltip), getListener(this.props.hideTooltip));\n    };\n    return CustomToolbarItemComp;\n}(Component));\nvar CustomToolbarItem = connectHOC(CustomToolbarItemComp);\nvar templateObject_1$6;\n\nvar ToolbarGroup = /** @class */ (function (_super) {\n    __extends$1(ToolbarGroup, _super);\n    function ToolbarGroup() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ToolbarGroup.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, group = _a.group, hiddenDivider = _a.hiddenDivider;\n        var groupStyle = group.hidden ? { display: \'none\' } : null;\n        var dividerStyle = hiddenDivider ? { display: \'none\' } : null;\n        return html(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject(["\\n      <div class=\\"", "\\" style=", ">\\n        ", "\\n        <div class=\\"", "\\" style=", "></div>\\n      </div>\\n    "], ["\\n      <div class=\\"", "\\" style=", ">\\n        ",\n            "\\n        <div class=\\"", "\\" style=", "></div>\\n      </div>\\n    "])), cls(\'toolbar-group\'), groupStyle, group.map(function (item) {\n            var Comp = item.el ? CustomToolbarItem : ToolbarButton;\n            return html(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject(["<", " key=", " ...", " item=", " />"], ["<", " key=", " ...", " item=", " />"])), Comp, item.name, _this.props, item);\n        }), cls(\'toolbar-divider\'), dividerStyle);\n    };\n    return ToolbarGroup;\n}(Component));\nvar templateObject_1$5, templateObject_2$4;\n\nvar POPUP_INDENT = 4;\nvar DropdownToolbarButtonComp = /** @class */ (function (_super) {\n    __extends$1(DropdownToolbarButtonComp, _super);\n    function DropdownToolbarButtonComp(props) {\n        var _this = _super.call(this, props) || this;\n        _this.handleClickDocument = function (_a) {\n            var target = _a.target;\n            if (!closest(target, "." + cls(\'dropdown-toolbar\')) &&\n                !closest(target, \'.more\')) {\n                _this.setState({ showDropdown: false, dropdownPos: null });\n            }\n        };\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.state = { showDropdown: false, dropdownPos: null };\n        return _this;\n    }\n    DropdownToolbarButtonComp.prototype.getBound = function () {\n        var rect = this.props.getBound(this.refs.el);\n        rect.top += POPUP_INDENT;\n        return __assign$1(__assign$1({}, rect), { left: null, right: 10 });\n    };\n    DropdownToolbarButtonComp.prototype.mounted = function () {\n        document.addEventListener(\'click\', this.handleClickDocument);\n    };\n    DropdownToolbarButtonComp.prototype.updated = function () {\n        if (this.state.showDropdown && !this.state.dropdownPos) {\n            this.setState({ dropdownPos: this.getBound() });\n        }\n    };\n    DropdownToolbarButtonComp.prototype.beforeDestroy = function () {\n        document.removeEventListener(\'click\', this.handleClickDocument);\n    };\n    DropdownToolbarButtonComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.state, showDropdown = _a.showDropdown, dropdownPos = _a.dropdownPos;\n        var _b = this.props, disabled = _b.disabled, item = _b.item, items = _b.items, hideTooltip = _b.hideTooltip;\n        var visibleItems = items.filter(function (dropdownItem) { return !dropdownItem.hidden; });\n        var groupStyle = visibleItems.length ? null : { display: \'none\' };\n        var dropdownStyle = showDropdown ? null : { display: \'none\' };\n        return html(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject(["\\n      <div class=\\"", "\\" style=", ">\\n        <button\\n          ref=", "\\n          type=\\"button\\"\\n          class=", "\\n          onClick=", "\\n          onMouseover=", "\\n          onMouseout=", "\\n          disabled=", "\\n        ></button>\\n        <div\\n          class=\\"", "\\"\\n          style=", "\\n          ref=", "\\n        >\\n          ", "\\n        </div>\\n      </div>\\n    "], ["\\n      <div class=\\"", "\\" style=", ">\\n        <button\\n          ref=", "\\n          type=\\"button\\"\\n          class=", "\\n          onClick=", "\\n          onMouseover=", "\\n          onMouseout=", "\\n          disabled=", "\\n        ></button>\\n        <div\\n          class=\\"", "\\"\\n          style=", "\\n          ref=", "\\n        >\\n          ",\n            "\\n        </div>\\n      </div>\\n    "])), cls(\'toolbar-group\'), groupStyle, function (el) { return (_this.refs.el = el); }, item.className, function () { return _this.setState({ showDropdown: true }); }, this.showTooltip, hideTooltip, disabled, cls(\'dropdown-toolbar\'), __assign$1(__assign$1({}, dropdownStyle), dropdownPos), function (el) { return (_this.refs.dropdownEl = el); }, visibleItems.length\n            ? visibleItems.map(function (group, index) {\n                var _a;\n                return html(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject(["\\n                  <", "\\n                    group=", "\\n                    hiddenDivider=", "\\n                    ...", "\\n                  />\\n                "], ["\\n                  <", "\\n                    group=", "\\n                    hiddenDivider=",\n                    "\\n                    ...", "\\n                  />\\n                "])), ToolbarGroup, group, index === visibleItems.length - 1 ||\n                    ((_a = visibleItems[index + 1]) === null || _a === void 0 ? void 0 : _a.hidden), _this.props);\n            })\n            : null);\n    };\n    return DropdownToolbarButtonComp;\n}(Component));\nvar DropdownToolbarButton = connectHOC(DropdownToolbarButtonComp);\nvar templateObject_1$4, templateObject_2$3;\n\nvar INLINE_PADDING = 50;\nvar Toolbar = /** @class */ (function (_super) {\n    __extends$1(Toolbar, _super);\n    function Toolbar(props) {\n        var _this = _super.call(this, props) || this;\n        _this.toggleTab = function (_, activeTab) {\n            var eventEmitter = _this.props.eventEmitter;\n            if (_this.state.activeTab !== activeTab) {\n                var event_1 = activeTab === \'write\' ? \'changePreviewTabWrite\' : \'changePreviewTabPreview\';\n                eventEmitter.emit(event_1);\n                _this.setState({ activeTab: activeTab });\n            }\n        };\n        _this.setItemWidth = function (name, width) {\n            _this.itemWidthMap[name] = width;\n        };\n        _this.setPopupInfo = function (popupInfo) {\n            _this.setState({ showPopup: true, popupInfo: popupInfo });\n        };\n        _this.openPopup = function (popupName, initialValues) {\n            if (initialValues === void 0) { initialValues = {}; }\n            var el = _this.refs.el.querySelector("." + cls(\'toolbar-group\') + " ." + popupName);\n            if (el) {\n                var _a = getTotalOffset(el, closest(el, "." + cls(\'toolbar\'))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;\n                var info = createPopupInfo(popupName, {\n                    el: el,\n                    pos: { left: offsetLeft, top: el.offsetHeight + offsetTop },\n                    initialValues: initialValues,\n                });\n                if (info) {\n                    _this.setPopupInfo(info);\n                }\n            }\n        };\n        _this.hidePopup = function () {\n            if (_this.state.showPopup) {\n                _this.setState({ showPopup: false });\n            }\n        };\n        _this.execCommand = function (command, payload) {\n            var eventEmitter = _this.props.eventEmitter;\n            eventEmitter.emit(\'command\', command, payload);\n            _this.hidePopup();\n        };\n        _this.tabs = [\n            { name: \'write\', text: \'Write\' },\n            { name: \'preview\', text: \'Preview\' },\n        ];\n        _this.itemWidthMap = {};\n        _this.initialItems = groupToolbarItems(props.toolbarItems || [], _this.hiddenScrollSync());\n        _this.state = {\n            items: _this.initialItems,\n            dropdownItems: [],\n            showPopup: false,\n            popupInfo: {},\n            activeTab: \'write\',\n        };\n        _this.tooltipRef = { current: null };\n        _this.resizeObserver = new index(function () { return _this.handleResize(); });\n        _this.addEvent();\n        return _this;\n    }\n    Toolbar.prototype.insertToolbarItem = function (indexList, item) {\n        var groupIndex = indexList.groupIndex, itemIndex = indexList.itemIndex;\n        var group = this.initialItems[groupIndex];\n        item = createToolbarItemInfo(item);\n        if (group) {\n            group.splice(itemIndex, 0, item);\n        }\n        else {\n            this.initialItems.push([item]);\n        }\n        this.setState(this.classifyToolbarItems());\n    };\n    Toolbar.prototype.removeToolbarItem = function (name) {\n        var _this = this;\n        forEachArray_1(this.initialItems, function (group) {\n            var found = false;\n            forEachArray_1(group, function (item, index) {\n                if (item.name === name) {\n                    found = true;\n                    group.splice(index, 1);\n                    _this.setState(_this.classifyToolbarItems());\n                    return false;\n                }\n                return true;\n            });\n            return !found;\n        });\n    };\n    Toolbar.prototype.addEvent = function () {\n        var _this = this;\n        var eventEmitter = this.props.eventEmitter;\n        this.handleResize = throttle_1(function () {\n            // reset toolbar items to re-layout toolbar items with each clientWidth\n            _this.setState({ items: _this.initialItems, dropdownItems: [] });\n            _this.setState(_this.classifyToolbarItems());\n        }, 200);\n        eventEmitter.listen(\'openPopup\', this.openPopup);\n    };\n    Toolbar.prototype.appendTooltipToRoot = function () {\n        var tooltip = "<div class=\\"" + cls(\'tooltip\') + "\\" style=\\"display:none\\">\\n        <div class=\\"arrow\\"></div>\\n        <span class=\\"text\\"></span>\\n      </div>";\n        this.tooltipRef.current = createElementWith(tooltip, this.refs.el);\n    };\n    Toolbar.prototype.hiddenScrollSync = function () {\n        return this.props.editorType === \'wysiwyg\' || this.props.previewStyle === \'tab\';\n    };\n    Toolbar.prototype.movePrevItemToDropdownToolbar = function (itemIndex, items, group, dropdownGroup) {\n        var moveItem = function (targetGroup) {\n            var item = targetGroup.pop();\n            if (item) {\n                dropdownGroup.push(item);\n            }\n        };\n        if (itemIndex > 1) {\n            moveItem(group);\n        }\n        else {\n            var prevGroup = last$1(items);\n            if (prevGroup) {\n                moveItem(prevGroup);\n            }\n        }\n    };\n    Toolbar.prototype.classifyToolbarItems = function () {\n        var _this = this;\n        var totalWidth = 0;\n        var clientWidth = this.refs.el.clientWidth;\n        var divider = this.refs.el.querySelector("." + cls(\'toolbar-divider\'));\n        var dividerWidth = divider ? getOuterWidth(divider) : 0;\n        var items = [];\n        var dropdownItems = [];\n        var moved = false;\n        this.initialItems.forEach(function (initialGroup, groupIndex) {\n            var group = [];\n            var dropdownGroup = [];\n            initialGroup.forEach(function (item, itemIndex) {\n                if (!item.hidden) {\n                    totalWidth += _this.itemWidthMap[item.name];\n                    if (totalWidth > clientWidth - INLINE_PADDING) {\n                        // should move the prev item to dropdown toolbar for placing the more button\n                        if (!moved) {\n                            _this.movePrevItemToDropdownToolbar(itemIndex, items, group, dropdownGroup);\n                            moved = true;\n                        }\n                        dropdownGroup.push(item);\n                    }\n                    else {\n                        group.push(item);\n                    }\n                }\n            });\n            if (group.length) {\n                setGroupState(group);\n                items.push(group);\n            }\n            if (dropdownGroup.length) {\n                setGroupState(dropdownGroup);\n                dropdownItems.push(dropdownGroup);\n            }\n            // add divider width\n            if (groupIndex < _this.state.items.length - 1) {\n                totalWidth += dividerWidth;\n            }\n        });\n        return { items: items, dropdownItems: dropdownItems };\n    };\n    Toolbar.prototype.mounted = function () {\n        if (this.props.previewStyle === \'tab\') {\n            this.props.eventEmitter.emit(\'changePreviewTabWrite\', true);\n        }\n        // classify toolbar and dropdown toolbar after DOM has been rendered\n        this.setState(this.classifyToolbarItems());\n        this.appendTooltipToRoot();\n        this.resizeObserver.observe(this.refs.el);\n    };\n    Toolbar.prototype.updated = function (prevProps) {\n        var _a = this.props, editorType = _a.editorType, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter;\n        var changedStyle = previewStyle !== prevProps.previewStyle;\n        var changedType = editorType !== prevProps.editorType;\n        if (changedStyle || changedType) {\n            // show or hide scrollSync button\n            toggleScrollSync(this.initialItems, this.hiddenScrollSync());\n            var newState = this.classifyToolbarItems();\n            if (changedStyle || (previewStyle === \'tab\' && editorType === \'markdown\')) {\n                eventEmitter.emit(\'changePreviewTabWrite\');\n                newState.activeTab = \'write\';\n            }\n            this.setState(newState);\n        }\n    };\n    Toolbar.prototype.beforeDestroy = function () {\n        window.removeEventListener(\'resize\', this.handleResize);\n        this.resizeObserver.disconnect();\n        removeNode$1(this.tooltipRef.current);\n    };\n    Toolbar.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter, editorType = _a.editorType;\n        var _b = this.state, popupInfo = _b.popupInfo, showPopup = _b.showPopup, activeTab = _b.activeTab, items = _b.items, dropdownItems = _b.dropdownItems;\n        var props = {\n            eventEmitter: eventEmitter,\n            tooltipRef: this.tooltipRef,\n            disabled: editorType === \'markdown\' && previewStyle === \'tab\' && activeTab === \'preview\',\n            execCommand: this.execCommand,\n            setPopupInfo: this.setPopupInfo,\n        };\n        var toolbarStyle = previewStyle === \'tab\' ? { borderTopLeftRadius: 0 } : null;\n        return html(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject(["\\n      <div class=\\"", "\\">\\n        <div\\n          class=\\"", "\\"\\n          style=\\"display: ", "\\"\\n        >\\n          <", " tabs=", " activeTab=", " onClick=", " />\\n        </div>\\n        <div\\n          class=\\"", "\\"\\n          ref=", "\\n          style=", "\\n        >\\n          ", "\\n          <", "\\n            item=", "\\n            items=", "\\n            ...", "\\n          />\\n        </div>\\n        <", "\\n          info=", "\\n          show=", "\\n          eventEmitter=", "\\n          hidePopup=", "\\n          execCommand=", "\\n        />\\n      </div>\\n    "], ["\\n      <div class=\\"", "\\">\\n        <div\\n          class=\\"", "\\"\\n          style=\\"display: ",\n            "\\"\\n        >\\n          <", " tabs=", " activeTab=", " onClick=", " />\\n        </div>\\n        <div\\n          class=\\"", "\\"\\n          ref=", "\\n          style=", "\\n        >\\n          ",\n            "\\n          <", "\\n            item=", "\\n            items=", "\\n            ...", "\\n          />\\n        </div>\\n        <", "\\n          info=", "\\n          show=", "\\n          eventEmitter=", "\\n          hidePopup=", "\\n          execCommand=", "\\n        />\\n      </div>\\n    "])), cls(\'toolbar\'), cls(\'md-tab-container\'), editorType === \'wysiwyg\' || previewStyle === \'vertical\'\n            ? \'none\'\n            : \'block\', Tabs, this.tabs, activeTab, this.toggleTab, cls(\'defaultUI-toolbar\'), function (el) { return (_this.refs.el = el); }, toolbarStyle, items.map(function (group, index) {\n            var _a;\n            return html(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject(["\\n              <", "\\n                group=", "\\n                hiddenDivider=", "\\n                setItemWidth=", "\\n                ...", "\\n              />\\n            "], ["\\n              <", "\\n                group=", "\\n                hiddenDivider=", "\\n                setItemWidth=", "\\n                ...", "\\n              />\\n            "])), ToolbarGroup, group, index === items.length - 1 || ((_a = items[index + 1]) === null || _a === void 0 ? void 0 : _a.hidden), _this.setItemWidth, props);\n        }), DropdownToolbarButton, createToolbarItemInfo(\'more\'), dropdownItems, props, Popup, popupInfo, showPopup, eventEmitter, this.hidePopup, this.execCommand);\n    };\n    return Toolbar;\n}(Component));\nvar templateObject_1$3, templateObject_2$2;\n\nvar ContextMenu = /** @class */ (function (_super) {\n    __extends$1(ContextMenu, _super);\n    function ContextMenu(props) {\n        var _this = _super.call(this, props) || this;\n        _this.handleClickDocument = function (ev) {\n            if (!closest(ev.target, "." + cls(\'context-menu\'))) {\n                _this.setState({ pos: null });\n            }\n        };\n        _this.state = {\n            pos: null,\n            menuGroups: [],\n        };\n        _this.addEvent();\n        return _this;\n    }\n    ContextMenu.prototype.addEvent = function () {\n        var _this = this;\n        this.props.eventEmitter.listen(\'contextmenu\', function (_a) {\n            var pos = _a.pos, menuGroups = _a.menuGroups;\n            _this.setState({ pos: pos, menuGroups: menuGroups });\n        });\n    };\n    ContextMenu.prototype.mounted = function () {\n        document.addEventListener(\'click\', this.handleClickDocument);\n    };\n    ContextMenu.prototype.beforeDestroy = function () {\n        document.removeEventListener(\'click\', this.handleClickDocument);\n    };\n    ContextMenu.prototype.getMenuGroupElements = function () {\n        var _this = this;\n        var _a = this.state, pos = _a.pos, menuGroups = _a.menuGroups;\n        return pos\n            ? menuGroups.reduce(function (acc, group) {\n                var menuItem = [];\n                group.forEach(function (_a) {\n                    var label = _a.label, _b = _a.className, className = _b === void 0 ? false : _b, disabled = _a.disabled, onClick = _a.onClick;\n                    var handleClick = function () {\n                        if (!disabled) {\n                            onClick();\n                            _this.setState({ pos: null });\n                        }\n                    };\n                    menuItem.push(html(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject(["\\n                <li\\n                  onClick=", "\\n                  class=\\"menu-item", "\\"\\n                  aria-role=\\"menuitem\\"\\n                >\\n                  <span class=\\"", "\\">", "</span>\\n                </li>\\n              "], ["\\n                <li\\n                  onClick=", "\\n                  class=\\"menu-item", "\\"\\n                  aria-role=\\"menuitem\\"\\n                >\\n                  <span class=\\"", "\\">", "</span>\\n                </li>\\n              "])), handleClick, disabled ? \' disabled\' : \'\', className, label));\n                });\n                acc.push(html(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject(["<ul class=\\"menu-group\\">\\n              ", "\\n            </ul>"], ["<ul class=\\"menu-group\\">\\n              ", "\\n            </ul>"])), menuItem));\n                return acc;\n            }, [])\n            : [];\n    };\n    ContextMenu.prototype.render = function () {\n        var style = __assign$1({ display: this.state.pos ? \'block\' : \'none\' }, this.state.pos);\n        return html(templateObject_3 || (templateObject_3 = __makeTemplateObject(["<div class=\\"", "\\" style=", " aria-role=\\"menu\\">\\n      ", "\\n    </div>"], ["<div class=\\"", "\\" style=", " aria-role=\\"menu\\">\\n      ", "\\n    </div>"])), cls(\'context-menu\'), style, this.getMenuGroupElements());\n    };\n    return ContextMenu;\n}(Component));\nvar templateObject_1$2, templateObject_2$1, templateObject_3;\n\nvar Layout = /** @class */ (function (_super) {\n    __extends$1(Layout, _super);\n    function Layout(props) {\n        var _this = _super.call(this, props) || this;\n        _this.changeMode = function (editorType) {\n            if (editorType !== _this.state.editorType) {\n                _this.setState({ editorType: editorType });\n            }\n        };\n        _this.changePreviewStyle = function (previewStyle) {\n            if (previewStyle !== _this.state.previewStyle) {\n                _this.setState({ previewStyle: previewStyle });\n            }\n        };\n        _this.hide = function () {\n            _this.setState({ hide: true });\n        };\n        _this.show = function () {\n            _this.setState({ hide: false });\n        };\n        var editorType = props.editorType, previewStyle = props.previewStyle;\n        _this.state = {\n            editorType: editorType,\n            previewStyle: previewStyle,\n            hide: false,\n        };\n        _this.addEvent();\n        return _this;\n    }\n    Layout.prototype.mounted = function () {\n        var _a = this.props.slots, wwEditor = _a.wwEditor, mdEditor = _a.mdEditor, mdPreview = _a.mdPreview;\n        this.refs.wwContainer.appendChild(wwEditor);\n        this.refs.mdContainer.insertAdjacentElement(\'afterbegin\', mdEditor);\n        this.refs.mdContainer.appendChild(mdPreview);\n    };\n    Layout.prototype.insertToolbarItem = function (indexList, item) {\n        this.toolbar.insertToolbarItem(indexList, item);\n    };\n    Layout.prototype.removeToolbarItem = function (name) {\n        this.toolbar.removeToolbarItem(name);\n    };\n    Layout.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, eventEmitter = _a.eventEmitter, hideModeSwitch = _a.hideModeSwitch, toolbarItems = _a.toolbarItems, theme = _a.theme;\n        var _b = this.state, hide = _b.hide, previewStyle = _b.previewStyle, editorType = _b.editorType;\n        var displayClassName = hide ? \' hidden\' : \'\';\n        var editorTypeClassName = cls(editorType === \'markdown\' ? \'md-mode\' : \'ww-mode\');\n        var previewClassName = cls(\'md\') + "-" + previewStyle + "-style";\n        var themeClassName = cls([theme !== \'light\', theme + " "]);\n        return html(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\\n      <div\\n        class=\\"", "", "", "\\"\\n        ref=", "\\n      >\\n        <", "\\n          ref=", "\\n          eventEmitter=", "\\n          previewStyle=", "\\n          toolbarItems=", "\\n          editorType=", "\\n        />\\n        <div\\n          class=\\"", " ", "\\"\\n          ref=", "\\n        >\\n          <div class=\\"", "\\">\\n            <div\\n              class=\\"", " ", "\\"\\n              ref=", "\\n            >\\n              <div class=\\"", "\\"></div>\\n            </div>\\n            <div\\n              class=\\"", "\\"\\n              ref=", "\\n            />\\n          </div>\\n        </div>\\n        ", "\\n        <", " eventEmitter=", " />\\n      </div>\\n    "], ["\\n      <div\\n        class=\\"", "", "", "\\"\\n        ref=", "\\n      >\\n        <", "\\n          ref=", "\\n          eventEmitter=", "\\n          previewStyle=", "\\n          toolbarItems=", "\\n          editorType=", "\\n        />\\n        <div\\n          class=\\"", " ", "\\"\\n          ref=", "\\n        >\\n          <div class=\\"", "\\">\\n            <div\\n              class=\\"", " ", "\\"\\n              ref=", "\\n            >\\n              <div class=\\"", "\\"></div>\\n            </div>\\n            <div\\n              class=\\"", "\\"\\n              ref=", "\\n            />\\n          </div>\\n        </div>\\n        ",\n            "\\n        <", " eventEmitter=", " />\\n      </div>\\n    "])), themeClassName, cls(\'defaultUI\'), displayClassName, function (el) { return (_this.refs.el = el); }, Toolbar, function (toolbar) { return (_this.toolbar = toolbar); }, eventEmitter, previewStyle, toolbarItems, editorType, cls(\'main\'), editorTypeClassName, function (el) { return (_this.refs.editorSection = el); }, cls(\'main-container\'), cls(\'md-container\'), previewClassName, function (el) { return (_this.refs.mdContainer = el); }, cls(\'md-splitter\'), cls(\'ww-container\'), function (el) { return (_this.refs.wwContainer = el); }, !hideModeSwitch && html(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject(["<", " eventEmitter=", " editorType=", " />"], ["<", " eventEmitter=", " editorType=", " />"])), Switch, eventEmitter, editorType), ContextMenu, eventEmitter);\n    };\n    Layout.prototype.addEvent = function () {\n        var eventEmitter = this.props.eventEmitter;\n        eventEmitter.listen(\'hide\', this.hide);\n        eventEmitter.listen(\'show\', this.show);\n        eventEmitter.listen(\'changeMode\', this.changeMode);\n        eventEmitter.listen(\'changePreviewStyle\', this.changePreviewStyle);\n    };\n    return Layout;\n}(Component));\nvar templateObject_1$1, templateObject_2;\n\n/**\n * ToastUI Editor\n * @extends ToastUIEditorCore\n */\nvar ToastUIEditor = /** @class */ (function (_super) {\n    __extends$1(ToastUIEditor, _super);\n    function ToastUIEditor(options) {\n        var _a;\n        var _this = _super.call(this, options) || this;\n        var layoutComp;\n        var destroy = render(_this.options.el, html(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\\n        <", "\\n          ref=", "\\n          eventEmitter=", "\\n          slots=", "\\n          hideModeSwitch=", "\\n          toolbarItems=", "\\n          previewStyle=", "\\n          editorType=", "\\n          theme=", "\\n        />\\n      "], ["\\n        <", "\\n          ref=", "\\n          eventEmitter=", "\\n          slots=", "\\n          hideModeSwitch=", "\\n          toolbarItems=", "\\n          previewStyle=", "\\n          editorType=", "\\n          theme=", "\\n        />\\n      "])), Layout, function (layout) { return (layoutComp = layout); }, _this.eventEmitter, _this.getEditorElements(), _this.options.hideModeSwitch, _this.options.toolbarItems, _this.options.previewStyle, _this.options.initialEditType, _this.options.theme));\n        _this.setMinHeight(_this.options.minHeight);\n        _this.setHeight(_this.options.height);\n        _this.defaultUI = {\n            insertToolbarItem: layoutComp.insertToolbarItem.bind(layoutComp),\n            removeToolbarItem: layoutComp.removeToolbarItem.bind(layoutComp),\n            destroy: destroy,\n        };\n        (_a = _this.pluginInfo.toolbarItems) === null || _a === void 0 ? void 0 : _a.forEach(function (toolbarItem) {\n            var groupIndex = toolbarItem.groupIndex, itemIndex = toolbarItem.itemIndex, item = toolbarItem.item;\n            _this.defaultUI.insertToolbarItem({ groupIndex: groupIndex, itemIndex: itemIndex }, item);\n        });\n        _this.eventEmitter.emit(\'loadUI\', _this);\n        return _this;\n    }\n    /**\n     * Factory method for Editor\n     * @param {object} options Option for initialize TUIEditor\n     * @returns {object} ToastUIEditor or ToastUIEditorViewer\n     */\n    ToastUIEditor.factory = function (options) {\n        return options.viewer ? new ToastUIEditorViewer(options) : new ToastUIEditor(options);\n    };\n    /**\n     * add toolbar item\n     * @param {Object} indexInfo group index and item index of the toolbar item\n     * @param {string|Object} item toolbar item\n     */\n    ToastUIEditor.prototype.insertToolbarItem = function (indexInfo, item) {\n        this.defaultUI.insertToolbarItem(indexInfo, item);\n    };\n    /**\n     * Remove toolbar item\n     * @param {string} itemName toolbar item name\n     */\n    ToastUIEditor.prototype.removeToolbarItem = function (itemName) {\n        this.defaultUI.removeToolbarItem(itemName);\n    };\n    /**\n     * Destroy TUIEditor from document\n     */\n    ToastUIEditor.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        this.defaultUI.destroy();\n    };\n    return ToastUIEditor;\n}(ToastUIEditorCore));\nvar templateObject_1;\n\n/**\n * @fileoverview I18N for English\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n */\nToastUIEditorCore.setLanguage([\'en\', \'en-US\'], {\n    Markdown: \'Markdown\',\n    WYSIWYG: \'WYSIWYG\',\n    Write: \'Write\',\n    Preview: \'Preview\',\n    Headings: \'Headings\',\n    Paragraph: \'Paragraph\',\n    Bold: \'Bold\',\n    Italic: \'Italic\',\n    Strike: \'Strike\',\n    Code: \'Inline code\',\n    Line: \'Line\',\n    Blockquote: \'Blockquote\',\n    \'Unordered list\': \'Unordered list\',\n    \'Ordered list\': \'Ordered list\',\n    Task: \'Task\',\n    Indent: \'Indent\',\n    Outdent: \'Outdent\',\n    \'Insert link\': \'Insert link\',\n    \'Insert CodeBlock\': \'Insert codeBlock\',\n    \'Insert table\': \'Insert table\',\n    \'Insert image\': \'Insert image\',\n    Heading: \'Heading\',\n    \'Image URL\': \'Image URL\',\n    \'Select image file\': \'Select image file\',\n    \'Choose a file\': \'Choose a file\',\n    \'No file\': \'No file\',\n    Description: \'Description\',\n    OK: \'OK\',\n    More: \'More\',\n    Cancel: \'Cancel\',\n    File: \'File\',\n    URL: \'URL\',\n    \'Link text\': \'Link text\',\n    \'Add row to up\': \'Add row to up\',\n    \'Add row to down\': \'Add row to down\',\n    \'Add column to left\': \'Add column to left\',\n    \'Add column to right\': \'Add column to right\',\n    \'Remove row\': \'Remove row\',\n    \'Remove column\': \'Remove column\',\n    \'Align column to left\': \'Align column to left\',\n    \'Align column to center\': \'Align column to center\',\n    \'Align column to right\': \'Align column to right\',\n    \'Remove table\': \'Remove table\',\n    \'Would you like to paste as table?\': \'Would you like to paste as table?\',\n    \'Text color\': \'Text color\',\n    \'Auto scroll enabled\': \'Auto scroll enabled\',\n    \'Auto scroll disabled\': \'Auto scroll disabled\',\n    \'Choose language\': \'Choose language\',\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2VkaXRvci9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vbm9kZV9tb2R1bGVzL0B0b2FzdC11aS9lZGl0b3IvZGlzdC9lc20vaW5kZXguanM/NTg2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0b2FzdC11aS9lZGl0b3JcbiAqIEB2ZXJzaW9uIDMuMi4yIHwgRnJpIEZlYiAxNyAyMDIzXG4gKiBAYXV0aG9yIE5ITiBDbG91ZCBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbmltcG9ydCB7IEZyYWdtZW50LCBTY2hlbWEsIFNsaWNlLCBOb2RlUmFuZ2UsIE1hcmsgYXMgTWFyayQxLCBET01QYXJzZXIsIE5vZGUgYXMgTm9kZSQzIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCwgRGVjb3JhdGlvbiwgRWRpdG9yVmlldyB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuaW1wb3J0IHsgUmVwbGFjZUFyb3VuZFN0ZXAsIGxpZnRUYXJnZXQsIGNhblNwbGl0LCBTdGVwTWFwIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24sIFBsdWdpbiwgUGx1Z2luS2V5LCBFZGl0b3JTdGF0ZSwgQWxsU2VsZWN0aW9uLCBTZWxlY3Rpb24sIFNlbGVjdGlvblJhbmdlLCBOb2RlU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsga2V5bWFwIH0gZnJvbSAncHJvc2VtaXJyb3Ita2V5bWFwJztcbmltcG9ydCB7IGRlbGV0ZVNlbGVjdGlvbiwgc2VsZWN0QWxsLCBiYXNlS2V5bWFwLCBjaGFpbkNvbW1hbmRzLCBqb2luRm9yd2FyZCwgbmV3bGluZUluQ29kZSwgc2V0QmxvY2tUeXBlLCB3cmFwSW4sIHRvZ2dsZU1hcmsgYXMgdG9nZ2xlTWFyayQxLCBleGl0Q29kZSB9IGZyb20gJ3Byb3NlbWlycm9yLWNvbW1hbmRzJztcbmltcG9ydCB7IElucHV0UnVsZSwgaW5wdXRSdWxlcywgdW5kb0lucHV0UnVsZSB9IGZyb20gJ3Byb3NlbWlycm9yLWlucHV0cnVsZXMnO1xuaW1wb3J0IHsgdW5kbywgcmVkbywgaGlzdG9yeSwgdW5kb0RlcHRoIH0gZnJvbSAncHJvc2VtaXJyb3ItaGlzdG9yeSc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyQxID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyQxID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyQxKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzJDEoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzJDEoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduJDEgPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduJDEgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkkMSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdCB3aGljaCBhY3R1YWxseSBleGlzdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qgd2hpY2ggYWN0dWFsbHkgZXhpc3QuXG4gKiBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgdGhlIGxvb3Agd2lsbCBiZSBzdG9wcGVkLlxuICogQ2FsbGJhY2sgZnVuY3Rpb24oaXRlcmF0ZWUpIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgMSkgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICogIDIpIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICogIDMpIFRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQodGhpcykgb2YgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGZvckVhY2hPd25Qcm9wZXJ0aWVzIGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoT3duUHJvcGVydGllcyc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBmb3JFYWNoT3duUHJvcGVydGllcyA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoT3duUHJvcGVydGllcycpOyBcbiAqXG4gKiBsZXQgc3VtID0gMDtcbiAqXG4gKiBmb3JFYWNoT3duUHJvcGVydGllcyh7YToxLGI6MixjOjN9LCBmdW5jdGlvbih2YWx1ZSl7XG4gKiAgIHN1bSArPSB2YWx1ZTtcbiAqIH0pO1xuICogYWxlcnQoc3VtKTsgLy8gNlxuICovXG5mdW5jdGlvbiBmb3JFYWNoT3duUHJvcGVydGllcyQyKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgdmFyIGtleTtcblxuICBjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xuXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgaWYgKGl0ZXJhdGVlLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmb3JFYWNoT3duUHJvcGVydGllc18xID0gZm9yRWFjaE93blByb3BlcnRpZXMkMjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4dGVuZCB0aGUgdGFyZ2V0IG9iamVjdCBmcm9tIG90aGVyIG9iamVjdHMuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIEBtb2R1bGUgb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBFeHRlbmQgdGhlIHRhcmdldCBvYmplY3QgZnJvbSBvdGhlciBvYmplY3RzLlxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIE9iamVjdCB0aGF0IHdpbGwgYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7Li4ub2JqZWN0fSBvYmplY3RzIC0gT2JqZWN0cyBhcyBzb3VyY2VzXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBFeHRlbmRlZCBvYmplY3RcbiAqIEBtZW1iZXJvZiBtb2R1bGU6b2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIG9iamVjdHMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgaGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBzb3VyY2UsIHByb3AsIGksIGxlbjtcblxuICBmb3IgKGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgaWYgKGhhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgZXh0ZW5kXzEgPSBleHRlbmQ7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZyBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgc3RyaW5nIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZywgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBzdHJpbmc/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmckMyhvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IG9iaiBpbnN0YW5jZW9mIFN0cmluZztcbn1cblxudmFyIGlzU3RyaW5nXzEgPSBpc1N0cmluZyQzO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgQXJyYXkgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBBcnJheSBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgQXJyYXksIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgYXJyYXkgaW5zdGFuY2U/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSQzKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXk7XG59XG5cbnZhciBpc0FycmF5XzEgPSBpc0FycmF5JDM7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkob3IgQXJyYXktbGlrZSBvYmplY3QpIGluIGFzY2VuZGluZyBvcmRlci5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBlbGVtZW50IHByZXNlbnRcbiAqIGluIHRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgaW4gYXNjZW5kaW5nIG9yZGVyLlxuICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC5cbiAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogIDEpIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudFxuICogIDIpIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudFxuICogIDMpIFRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgYmVpbmcgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c3xOb2RlTGlzdH0gYXJyIFRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgZm9yRWFjaEFycmF5IGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoQXJyYXknO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgZm9yRWFjaEFycmF5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2hBcnJheScpOyBcbiAqXG4gKiBsZXQgc3VtID0gMDtcbiAqXG4gKiBmb3JFYWNoQXJyYXkoWzEsMiwzXSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqIGFsZXJ0KHN1bSk7IC8vIDZcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEFycmF5JDMoYXJyLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblxuICBjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xuXG4gIGZvciAoOyBpbmRleCA8IGxlbjsgaW5kZXggKz0gMSkge1xuICAgIGlmIChpdGVyYXRlZS5jYWxsKGNvbnRleHQsIGFycltpbmRleF0sIGluZGV4LCBhcnIpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbnZhciBmb3JFYWNoQXJyYXlfMSA9IGZvckVhY2hBcnJheSQzO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qob3IgZWxlbWVudCBvZiBhcnJheSkgd2hpY2ggYWN0dWFsbHkgZXhpc3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNBcnJheSQyID0gaXNBcnJheV8xO1xudmFyIGZvckVhY2hBcnJheSQyID0gZm9yRWFjaEFycmF5XzE7XG52YXIgZm9yRWFjaE93blByb3BlcnRpZXMkMSA9IGZvckVhY2hPd25Qcm9wZXJ0aWVzXzE7XG5cbi8qKlxuICogQG1vZHVsZSBjb2xsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdChvciBlbGVtZW50IG9mIGFycmF5KSB3aGljaCBhY3R1YWxseSBleGlzdC5cbiAqIElmIHRoZSBvYmplY3QgaXMgQXJyYXktbGlrZSBvYmplY3QoZXgtYXJndW1lbnRzIG9iamVjdCksIEl0IG5lZWRzIHRvIHRyYW5zZm9ybSB0byBBcnJheS4oc2VlICdleDInIG9mIGV4YW1wbGUpLlxuICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC5cbiAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogIDEpIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkob3IgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50KVxuICogIDIpIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eShvciBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQpXG4gKiAgMykgVGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBDYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBmb3JFYWNoIGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoJzsgXG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBmb3JFYWNoID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2gnKTsgXG4gKlxuICogbGV0IHN1bSA9IDA7XG4gKlxuICogZm9yRWFjaChbMSwyLDNdLCBmdW5jdGlvbih2YWx1ZSl7XG4gKiAgIHN1bSArPSB2YWx1ZTtcbiAqIH0pO1xuICogYWxlcnQoc3VtKTsgLy8gNlxuICpcbiAqIC8vIEluIGNhc2Ugb2YgQXJyYXktbGlrZSBvYmplY3RcbiAqIGNvbnN0IGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTsgLy8gY2hhbmdlIHRvIGFycmF5XG4gKiBmb3JFYWNoKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gKiAgIHN1bSArPSB2YWx1ZTtcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmb3JFYWNoJDQob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICBpZiAoaXNBcnJheSQyKG9iaikpIHtcbiAgICBmb3JFYWNoQXJyYXkkMihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoT3duUHJvcGVydGllcyQxKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9XG59XG5cbnZhciBmb3JFYWNoXzEgPSBmb3JFYWNoJDQ7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTZXR0aW5nIGVsZW1lbnQgc3R5bGVcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc1N0cmluZyQyID0gaXNTdHJpbmdfMTtcbnZhciBmb3JFYWNoJDMgPSBmb3JFYWNoXzE7XG5cbi8qKlxuICogU2V0dGluZyBlbGVtZW50IHN0eWxlXG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIGVsZW1lbnQgdG8gc2V0dGluZyBzdHlsZVxuICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IGtleSAtIHN0eWxlIHByb3AgbmFtZSBvciB7cHJvcDogdmFsdWV9IHBhaXIgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSAtIHN0eWxlIHZhbHVlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gY3NzKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblxuICBpZiAoaXNTdHJpbmckMihrZXkpKSB7XG4gICAgc3R5bGVba2V5XSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaCQzKGtleSwgZnVuY3Rpb24odiwgaykge1xuICAgIHN0eWxlW2tdID0gdjtcbiAgfSk7XG59XG5cbnZhciBjc3NfMSA9IGNzcztcblxuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuXG52YXIgaXNBcnJheSQxID0gaXNBcnJheV8xO1xuXG4vKipcbiAqIEBtb2R1bGUgYXJyYXlcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIGFycmF5XG4gKiBmcm9tIHN0YXJ0IGluZGV4KGRlZmF1bHQgMCksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICogSXQgY29tcGFyZXMgc2VhcmNoRWxlbWVudCB0byBlbGVtZW50cyBvZiB0aGUgQXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gKiAodGhlIHNhbWUgbWV0aG9kIHVzZWQgYnkgdGhlID09PSwgb3IgdHJpcGxlLWVxdWFscywgb3BlcmF0b3IpLlxuICogQHBhcmFtIHsqfSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gbG9jYXRlIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IFN0YXJ0IGluZGV4IGluIGFycmF5IGZvciBzZWFyY2hpbmcgKGRlZmF1bHQgMClcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBGaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmFycmF5XG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgaW5BcnJheSBmcm9tICd0dWktY29kZS1zbmlwcGV0L2FycmF5L2luQXJyYXknO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgaW5BcnJheSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvYXJyYXkvaW5BcnJheScpO1xuICpcbiAqIGNvbnN0IGFyciA9IFsnb25lJywgJ3R3bycsICd0aHJlZScsICdmb3VyJ107XG4gKiBjb25zdCBpZHgxID0gaW5BcnJheSgnb25lJywgYXJyLCAzKTsgLy8gLTFcbiAqIGNvbnN0IGlkeDIgPSBpbkFycmF5KCdvbmUnLCBhcnIpOyAvLyAwXG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkkNChzZWFyY2hFbGVtZW50LCBhcnJheSwgc3RhcnRJbmRleCkge1xuICB2YXIgaTtcbiAgdmFyIGxlbmd0aDtcbiAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcblxuICBpZiAoIWlzQXJyYXkkMShhcnJheSkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgc2VhcmNoRWxlbWVudCwgc3RhcnRJbmRleCk7XG4gIH1cblxuICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGZvciAoaSA9IHN0YXJ0SW5kZXg7IHN0YXJ0SW5kZXggPj0gMCAmJiBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxudmFyIGluQXJyYXlfMSA9IGluQXJyYXkkNDtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdW5kZWZpbmVkLCByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyB1bmRlZmluZWQ/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQkNChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmaW5lZFxufVxuXG52YXIgaXNVbmRlZmluZWRfMSA9IGlzVW5kZWZpbmVkJDQ7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBHZXQgSFRNTCBlbGVtZW50J3MgZGVzaWduIGNsYXNzZXMuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNVbmRlZmluZWQkMyA9IGlzVW5kZWZpbmVkXzE7XG5cbi8qKlxuICogR2V0IEhUTUwgZWxlbWVudCdzIGRlc2lnbiBjbGFzc2VzLlxuICogQHBhcmFtIHsoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCl9IGVsZW1lbnQgdGFyZ2V0IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGVsZW1lbnQgY3NzIGNsYXNzIG5hbWVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBnZXRDbGFzcyQzKGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LmNsYXNzTmFtZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChpc1VuZGVmaW5lZCQzKGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWw7XG59XG5cbnZhciBnZXRDbGFzc18xID0gZ2V0Q2xhc3MkMztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNldCBjbGFzc05hbWUgdmFsdWVcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc0FycmF5ID0gaXNBcnJheV8xO1xudmFyIGlzVW5kZWZpbmVkJDIgPSBpc1VuZGVmaW5lZF8xO1xuXG4vKipcbiAqIFNldCBjbGFzc05hbWUgdmFsdWVcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7KHN0cmluZ3xzdHJpbmdbXSl9IGNzc0NsYXNzIC0gY2xhc3MgbmFtZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldENsYXNzTmFtZSQyKGVsZW1lbnQsIGNzc0NsYXNzKSB7XG4gIGNzc0NsYXNzID0gaXNBcnJheShjc3NDbGFzcykgPyBjc3NDbGFzcy5qb2luKCcgJykgOiBjc3NDbGFzcztcblxuICBjc3NDbGFzcyA9IGNzc0NsYXNzLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG5cbiAgaWYgKGlzVW5kZWZpbmVkJDIoZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCA9IGNzc0NsYXNzO1xufVxuXG52YXIgX3NldENsYXNzTmFtZSA9IHNldENsYXNzTmFtZSQyO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQWRkIGNzcyBjbGFzcyB0byBlbGVtZW50XG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgZm9yRWFjaCQyID0gZm9yRWFjaF8xO1xudmFyIGluQXJyYXkkMyA9IGluQXJyYXlfMTtcbnZhciBnZXRDbGFzcyQyID0gZ2V0Q2xhc3NfMTtcbnZhciBzZXRDbGFzc05hbWUkMSA9IF9zZXRDbGFzc05hbWU7XG5cbi8qKlxuICogZG9tVXRpbCBtb2R1bGVcbiAqIEBtb2R1bGUgZG9tVXRpbFxuICovXG5cbi8qKlxuICogQWRkIGNzcyBjbGFzcyB0byBlbGVtZW50XG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0gey4uLnN0cmluZ30gY3NzQ2xhc3MgLSBjc3MgY2xhc3NlcyB0byBhZGRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50KSB7XG4gIHZhciBjc3NDbGFzcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcbiAgdmFyIG5ld0NsYXNzID0gW107XG4gIHZhciBvcmlnaW47XG5cbiAgaWYgKGNsYXNzTGlzdCkge1xuICAgIGZvckVhY2gkMihjc3NDbGFzcywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3JpZ2luID0gZ2V0Q2xhc3MkMihlbGVtZW50KTtcblxuICBpZiAob3JpZ2luKSB7XG4gICAgY3NzQ2xhc3MgPSBbXS5jb25jYXQob3JpZ2luLnNwbGl0KC9cXHMrLyksIGNzc0NsYXNzKTtcbiAgfVxuXG4gIGZvckVhY2gkMihjc3NDbGFzcywgZnVuY3Rpb24oY2xzKSB7XG4gICAgaWYgKGluQXJyYXkkMyhjbHMsIG5ld0NsYXNzKSA8IDApIHtcbiAgICAgIG5ld0NsYXNzLnB1c2goY2xzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNldENsYXNzTmFtZSQxKGVsZW1lbnQsIG5ld0NsYXNzKTtcbn1cblxudmFyIGFkZENsYXNzXzEgPSBhZGRDbGFzcztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlbW92ZSBjc3MgY2xhc3MgZnJvbSBlbGVtZW50XG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgZm9yRWFjaEFycmF5JDEgPSBmb3JFYWNoQXJyYXlfMTtcbnZhciBpbkFycmF5JDIgPSBpbkFycmF5XzE7XG52YXIgZ2V0Q2xhc3MkMSA9IGdldENsYXNzXzE7XG52YXIgc2V0Q2xhc3NOYW1lID0gX3NldENsYXNzTmFtZTtcblxuLyoqXG4gKiBSZW1vdmUgY3NzIGNsYXNzIGZyb20gZWxlbWVudFxuICogQHBhcmFtIHsoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCl9IGVsZW1lbnQgLSB0YXJnZXQgZWxlbWVudFxuICogQHBhcmFtIHsuLi5zdHJpbmd9IGNzc0NsYXNzIC0gY3NzIGNsYXNzZXMgdG8gcmVtb3ZlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCkge1xuICB2YXIgY3NzQ2xhc3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG4gIHZhciBvcmlnaW4sIG5ld0NsYXNzO1xuXG4gIGlmIChjbGFzc0xpc3QpIHtcbiAgICBmb3JFYWNoQXJyYXkkMShjc3NDbGFzcywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9yaWdpbiA9IGdldENsYXNzJDEoZWxlbWVudCkuc3BsaXQoL1xccysvKTtcbiAgbmV3Q2xhc3MgPSBbXTtcbiAgZm9yRWFjaEFycmF5JDEob3JpZ2luLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKGluQXJyYXkkMihuYW1lLCBjc3NDbGFzcykgPCAwKSB7XG4gICAgICBuZXdDbGFzcy5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgc2V0Q2xhc3NOYW1lKGVsZW1lbnQsIG5ld0NsYXNzKTtcbn1cblxudmFyIHJlbW92ZUNsYXNzXzEgPSByZW1vdmVDbGFzcztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgbnVtYmVyIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBudW1iZXIgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgbnVtYmVyLCByZXR1cm4gdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIG51bWJlcj9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIE51bWJlcjtcbn1cblxudmFyIGlzTnVtYmVyXzEgPSBpc051bWJlcjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG51bGwgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBudWxsIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZShhcmd1bWVudHNbMF0pIGlzIG51bGwsIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIG51bGw/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNOdWxsJDEob2JqKSB7XG4gIHJldHVybiBvYmogPT09IG51bGw7XG59XG5cbnZhciBpc051bGxfMSA9IGlzTnVsbCQxO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWVzdCBpbWFnZSBwaW5nLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGZvckVhY2hPd25Qcm9wZXJ0aWVzID0gZm9yRWFjaE93blByb3BlcnRpZXNfMTtcblxuLyoqXG4gKiBAbW9kdWxlIHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgaW1hZ2UgcGluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgdXJsIGZvciBwaW5nIHJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFja2luZ0luZm8gaW5mb3MgZm9yIG1ha2UgcXVlcnkgc3RyaW5nXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnJlcXVlc3RcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBpbWFnZVBpbmcgZnJvbSAndHVpLWNvZGUtc25pcHBldC9yZXF1ZXN0L2ltYWdlUGluZyc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBpbWFnZVBpbmcgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L3JlcXVlc3QvaW1hZ2VQaW5nJyk7XG4gKlxuICogaW1hZ2VQaW5nKCdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9jb2xsZWN0Jywge1xuICogICB2OiAxLFxuICogICB0OiAnZXZlbnQnLFxuICogICB0aWQ6ICd0cmFja2luZ2lkJyxcbiAqICAgY2lkOiAnY2lkJyxcbiAqICAgZHA6ICdkcCcsXG4gKiAgIGRoOiAnZGgnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gaW1hZ2VQaW5nJDEodXJsLCB0cmFja2luZ0luZm8pIHtcbiAgdmFyIHRyYWNraW5nRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICB2YXIgcXVlcnlTdHJpbmcgPSAnJztcbiAgZm9yRWFjaE93blByb3BlcnRpZXModHJhY2tpbmdJbmZvLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcXVlcnlTdHJpbmcgKz0gJyYnICsga2V5ICsgJz0nICsgdmFsdWU7XG4gIH0pO1xuICBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnN1YnN0cmluZygxKTtcblxuICB0cmFja2luZ0VsZW1lbnQuc3JjID0gdXJsICsgJz8nICsgcXVlcnlTdHJpbmc7XG5cbiAgdHJhY2tpbmdFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodHJhY2tpbmdFbGVtZW50KTtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0cmFja2luZ0VsZW1lbnQpO1xuXG4gIHJldHVybiB0cmFja2luZ0VsZW1lbnQ7XG59XG5cbnZhciBpbWFnZVBpbmdfMSA9IGltYWdlUGluZyQxO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2VuZCBob3N0bmFtZSBvbiBET01Db250ZW50TG9hZGVkLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzVW5kZWZpbmVkJDEgPSBpc1VuZGVmaW5lZF8xO1xudmFyIGltYWdlUGluZyA9IGltYWdlUGluZ18xO1xuXG52YXIgbXM3ZGF5cyA9IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkYXRlIGhhcyBwYXNzZWQgNyBkYXlzXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0ZSAtIG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0V4cGlyZWQoZGF0ZSkge1xuICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgcmV0dXJuIG5vdyAtIGRhdGUgPiBtczdkYXlzO1xufVxuXG4vKipcbiAqIFNlbmQgaG9zdG5hbWUgb24gRE9NQ29udGVudExvYWRlZC5cbiAqIFRvIHByZXZlbnQgaG9zdG5hbWUgc2V0IHR1aS51c2FnZVN0YXRpc3RpY3MgdG8gZmFsc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwTmFtZSAtIGFwcGxpY2F0aW9uIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja2luZ0lkIC0gR0EgdHJhY2tpbmcgSURcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gc2VuZEhvc3RuYW1lKGFwcE5hbWUsIHRyYWNraW5nSWQpIHtcbiAgdmFyIHVybCA9ICdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9jb2xsZWN0JztcbiAgdmFyIGhvc3RuYW1lID0gbG9jYXRpb24uaG9zdG5hbWU7XG4gIHZhciBoaXRUeXBlID0gJ2V2ZW50JztcbiAgdmFyIGV2ZW50Q2F0ZWdvcnkgPSAndXNlJztcbiAgdmFyIGFwcGxpY2F0aW9uS2V5Rm9yU3RvcmFnZSA9ICdUT0FTVCBVSSAnICsgYXBwTmFtZSArICcgZm9yICcgKyBob3N0bmFtZSArICc6IFN0YXRpc3RpY3MnO1xuICB2YXIgZGF0ZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShhcHBsaWNhdGlvbktleUZvclN0b3JhZ2UpO1xuXG4gIC8vIHNraXAgaWYgdGhlIGZsYWcgaXMgZGVmaW5lZCBhbmQgaXMgc2V0IHRvIGZhbHNlIGV4cGxpY2l0bHlcbiAgaWYgKCFpc1VuZGVmaW5lZCQxKHdpbmRvdy50dWkpICYmIHdpbmRvdy50dWkudXNhZ2VTdGF0aXN0aWNzID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNraXAgaWYgbm90IHBhc3Mgc2V2ZW4gZGF5cyBvbGRcbiAgaWYgKGRhdGUgJiYgIWlzRXhwaXJlZChkYXRlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShhcHBsaWNhdGlvbktleUZvclN0b3JhZ2UsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGltYWdlUGluZyh1cmwsIHtcbiAgICAgICAgdjogMSxcbiAgICAgICAgdDogaGl0VHlwZSxcbiAgICAgICAgdGlkOiB0cmFja2luZ0lkLFxuICAgICAgICBjaWQ6IGhvc3RuYW1lLFxuICAgICAgICBkcDogaG9zdG5hbWUsXG4gICAgICAgIGRoOiBhcHBOYW1lLFxuICAgICAgICBlbDogYXBwTmFtZSxcbiAgICAgICAgZWM6IGV2ZW50Q2F0ZWdvcnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgMTAwMCk7XG59XG5cbnZhciBzZW5kSG9zdG5hbWVfMSA9IHNlbmRIb3N0bmFtZTtcblxuL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xudmFyIHJlU3BhY2VNb3JlVGhhbk9uZSA9IC9bXFx1MDAyMF0rL2c7XG52YXIgcmVFc2NhcGVDaGFycyQxID0gL1s+KCl7fVtcXF0rLS4hI3xdL2c7XG52YXIgcmVFc2NhcGVIVE1MID0gLzwoW2EtekEtWl9dW2EtekEtWjAtOVxcLS5fXSopKFxcc3xbXlxcXFw+XSkqXFwvPz58PChcXC8pKFthLXpBLVpfXVthLXpBLVowLTlcXC0uX10qKVxccypcXC8/Pnw8IS0tW14tXSstLT58PChbYS16QS1aX11bYS16QS1aMC05XFwtLjovXSopPi9nO1xudmFyIHJlRXNjYXBlQmFja1NsYXNoID0gL1xcXFxbIVwiIyQlJicoKSorLC0uLzo7PD0+P0BbXFxdXl9ge3x9flxcXFxdL2c7XG52YXIgcmVFc2NhcGVQYWlyZWRDaGFycyA9IC9bKl9+YF0vZztcbnZhciByZU1kSW1hZ2VTeW50YXggPSAvIVxcWy4qXFxdXFwoLipcXCkvZztcbnZhciByZUVzY2FwZWRDaGFySW5MaW5rU3ludGF4ID0gL1tbXFxdXS9nO1xudmFyIHJlRXNjYXBlQmFja1NsYXNoSW5TZW50ZW5jZSA9IC8oPzpefFteXFxcXF0pXFxcXCg/IVxcXFwpL2c7XG52YXIgWE1MU1BFQ0lBTCQxID0gJ1smPD5cIl0nO1xudmFyIHJlWG1sU3BlY2lhbCQxID0gbmV3IFJlZ0V4cChYTUxTUEVDSUFMJDEsICdnJyk7XG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhciQxKGNoYXIpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICByZXR1cm4gJyZhbXA7JztcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiAnJnF1b3Q7JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjaGFyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzY2FwZVhtbCQxKHRleHQpIHtcbiAgICBpZiAocmVYbWxTcGVjaWFsJDEudGVzdCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlWG1sU3BlY2lhbCQxLCByZXBsYWNlVW5zYWZlQ2hhciQxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiBzZW5kSG9zdE5hbWUoKSB7XG4gICAgc2VuZEhvc3RuYW1lXzEoJ2VkaXRvcicsICdVQS0xMjk5NjY5MjktMScpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXMoYXJyLCB0YXJnZXRJdGVtKSB7XG4gICAgcmV0dXJuIGFyci5pbmRleE9mKHRhcmdldEl0ZW0pICE9PSAtMTtcbn1cbnZhciBhdmFpbGFibGVMaW5rQXR0cmlidXRlcyA9IFsncmVsJywgJ3RhcmdldCcsICdocmVmbGFuZycsICd0eXBlJ107XG52YXIgcmVNYXJrZG93blRleHRUb0VzY2FwZU1hcCA9IHtcbiAgICBjb2RlYmxvY2s6IC8oXiB7NH1bXlxcbl0rXFxuKikrLyxcbiAgICB0aGVtYXRpY0JyZWFrOiAvXiAqKChcXCogKil7Myx9fCgtICopezMsfSAqfChfICopezMsfSkgKi8sXG4gICAgYXR4SGVhZGluZzogL14oI3sxLDZ9KSArW1xcc1xcU10rLyxcbiAgICBzZVRleHRoZWFkaW5nOiAvXihbXlxcbl0rKVxcbiAqKD18LSl7Mix9ICovLFxuICAgIGJsb2NrcXVvdGU6IC9eKCAqPlteXFxuXSsuKikrLyxcbiAgICBsaXN0OiAvXiAqKFxcKit8LSt8XFxkK1xcLikgW1xcc1xcU10rLyxcbiAgICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArW1wiKF0oW15cXG5dKylbXCIpXSk/ICovLFxuICAgIGxpbms6IC8hP1xcWy4qXFxdXFwoLipcXCkvLFxuICAgIHJlZmxpbms6IC8hP1xcWy4qXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8sXG4gICAgdmVydGljYWxCYXI6IC9cXHUwMDdDLyxcbiAgICBmZW5jZWRDb2RlYmxvY2s6IC9eKChgfH4pezMsfSkvLFxufTtcbmZ1bmN0aW9uIHNhbml0aXplTGlua0F0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICBpZiAoIWF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGxpbmtBdHRyaWJ1dGVzID0ge307XG4gICAgYXZhaWxhYmxlTGlua0F0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWRfMShhdHRyaWJ1dGVba2V5XSkpIHtcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzW2tleV0gPSBhdHRyaWJ1dGVba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsaW5rQXR0cmlidXRlcztcbn1cbmZ1bmN0aW9uIHJlcGVhdCQxKHRleHQsIGNvdW50KSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgICByZXN1bHQgKz0gdGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzTmVlZEVzY2FwZVRleHQodGV4dCkge1xuICAgIHZhciBuZWVkRXNjYXBlID0gZmFsc2U7XG4gICAgZm9yRWFjaE93blByb3BlcnRpZXNfMShyZU1hcmtkb3duVGV4dFRvRXNjYXBlTWFwLCBmdW5jdGlvbiAocmVNYXJrZG93blRleHRUb0VzY2FwZSkge1xuICAgICAgICBpZiAocmVNYXJrZG93blRleHRUb0VzY2FwZS50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICBuZWVkRXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIW5lZWRFc2NhcGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5lZWRFc2NhcGU7XG59XG5mdW5jdGlvbiBlc2NhcGVUZXh0Rm9yTGluayh0ZXh0KSB7XG4gICAgdmFyIGltYWdlU3ludGF4UmFuZ2VzID0gW107XG4gICAgdmFyIHJlc3VsdCA9IHJlTWRJbWFnZVN5bnRheC5leGVjKHRleHQpO1xuICAgIHdoaWxlIChyZXN1bHQpIHtcbiAgICAgICAgaW1hZ2VTeW50YXhSYW5nZXMucHVzaChbcmVzdWx0LmluZGV4LCByZXN1bHQuaW5kZXggKyByZXN1bHRbMF0ubGVuZ3RoXSk7XG4gICAgICAgIHJlc3VsdCA9IHJlTWRJbWFnZVN5bnRheC5leGVjKHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlRXNjYXBlZENoYXJJbkxpbmtTeW50YXgsIGZ1bmN0aW9uIChtYXRjaGVkLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGlzRGVsaW1pdGVyID0gaW1hZ2VTeW50YXhSYW5nZXMuc29tZShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIG9mZnNldCA+IHJhbmdlWzBdICYmIG9mZnNldCA8IHJhbmdlWzFdOyB9KTtcbiAgICAgICAgcmV0dXJuIGlzRGVsaW1pdGVyID8gbWF0Y2hlZCA6IFwiXFxcXFwiICsgbWF0Y2hlZDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVzY2FwZSQxKHRleHQpIHtcbiAgICB2YXIgYWhlYWRSZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaGVkKSB7IHJldHVybiBcIlxcXFxcIiArIG1hdGNoZWQ7IH07XG4gICAgdmFyIGJlaGluZFJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoZWQpIHsgcmV0dXJuIG1hdGNoZWQgKyBcIlxcXFxcIjsgfTtcbiAgICB2YXIgZXNjYXBlZFRleHQgPSB0ZXh0LnJlcGxhY2UocmVTcGFjZU1vcmVUaGFuT25lLCAnICcpO1xuICAgIGlmIChyZUVzY2FwZUJhY2tTbGFzaC50ZXN0KGVzY2FwZWRUZXh0KSkge1xuICAgICAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVCYWNrU2xhc2gsIGFoZWFkUmVwbGFjZXIpO1xuICAgIH1cbiAgICBpZiAocmVFc2NhcGVCYWNrU2xhc2hJblNlbnRlbmNlLnRlc3QoZXNjYXBlZFRleHQpKSB7XG4gICAgICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShyZUVzY2FwZUJhY2tTbGFzaEluU2VudGVuY2UsIGJlaGluZFJlcGxhY2VyKTtcbiAgICB9XG4gICAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKHJlRXNjYXBlUGFpcmVkQ2hhcnMsIGFoZWFkUmVwbGFjZXIpO1xuICAgIGlmIChyZUVzY2FwZUhUTUwudGVzdChlc2NhcGVkVGV4dCkpIHtcbiAgICAgICAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKHJlRXNjYXBlSFRNTCwgYWhlYWRSZXBsYWNlcik7XG4gICAgfVxuICAgIGlmIChpc05lZWRFc2NhcGVUZXh0KGVzY2FwZWRUZXh0KSkge1xuICAgICAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVDaGFycyQxLCBhaGVhZFJlcGxhY2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xufVxuZnVuY3Rpb24gcXVvdGUodGV4dCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHRleHQuaW5kZXhPZignXCInKSA9PT0gLTEpIHtcbiAgICAgICAgcmVzdWx0ID0gJ1wiXCInO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGV4dC5pbmRleE9mKFwiJ1wiKSA9PT0gLTEgPyBcIicnXCIgOiAnKCknO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0WzBdICsgdGV4dCArIHJlc3VsdFsxXTtcbn1cbmZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTnVsbF8xKHZhbHVlKSB8fCBpc1VuZGVmaW5lZF8xKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvMSwgbzIpIHtcbiAgICBpZiAobzEgPT09IG51bGwgJiYgbzEgPT09IG8yKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8xICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbzIgIT09ICdvYmplY3QnIHx8IGlzTmlsKG8xKSB8fCBpc05pbChvMikpIHtcbiAgICAgICAgcmV0dXJuIG8xID09PSBvMjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG8xKSB7XG4gICAgICAgIGlmIChvMVtrZXldICE9PSBvMltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG8yKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBvMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGxhc3QkMShhcnIpIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGJldHdlZW4kMSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0JDEob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZXBNZXJnZWRDb3B5KHRhcmdldE9iaiwgb2JqKSB7XG4gICAgdmFyIHJlc3VsdE9iaiA9IF9fYXNzaWduJDEoe30sIHRhcmdldE9iaik7XG4gICAgaWYgKHRhcmdldE9iaiAmJiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QkMShyZXN1bHRPYmpbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwQ29weUFycmF5KG9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdE9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwTWVyZ2VkQ29weShyZXN1bHRPYmpbcHJvcF0sIG9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwQ29weShvYmpbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRPYmo7XG59XG5mdW5jdGlvbiBkZWVwQ29weUFycmF5KGl0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXNPYmplY3QkMShpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBkZWVwQ29weUFycmF5KGl0ZW0pIDogZGVlcENvcHkoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcCkge1xuICAgICAgICBpZiAoaXNPYmplY3QkMShvYmpbcHJvcF0pKSB7XG4gICAgICAgICAgICBhY2NbcHJvcF0gPSBBcnJheS5pc0FycmF5KG9ialtwcm9wXSkgPyBkZWVwQ29weUFycmF5KG9ialtwcm9wXSkgOiBkZWVwQ29weShvYmpbcHJvcF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWNjW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldE9iaiwgb2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdm9pZCAwKSB7IG9iaiA9IHt9OyB9XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmICh0YXJnZXRPYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgdHlwZW9mIHRhcmdldE9ialtwcm9wXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRPYmpbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NpZ24odGFyZ2V0T2JqW3Byb3BdLCBvYmpbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0T2JqW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldE9iajtcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZE51bVBhaXIodmFsdWVBLCB2YWx1ZUIpIHtcbiAgICByZXR1cm4gdmFsdWVBID4gdmFsdWVCID8gW3ZhbHVlQiwgdmFsdWVBXSA6IFt2YWx1ZUEsIHZhbHVlQl07XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUcmFuc2Zvcm0gdGhlIEFycmF5LWxpa2Ugb2JqZWN0IHRvIEFycmF5LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGZvckVhY2hBcnJheSA9IGZvckVhY2hBcnJheV8xO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgQXJyYXktbGlrZSBvYmplY3QgdG8gQXJyYXkuXG4gKiBJbiBsb3cgSUUgKGJlbG93IDgpLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCBpcyBub3QgcGVyZmVjdC4gU28sIHRyeS1jYXRjaCBzdGF0ZW1lbnQgaXMgdXNlZC5cbiAqIEBwYXJhbSB7Kn0gYXJyYXlMaWtlIEFycmF5LWxpa2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCB0b0FycmF5IGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi90b0FycmF5JzsgXG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL3RvQXJyYXknKTsgXG4gKlxuICogY29uc3QgYXJyYXlMaWtlID0ge1xuICogICAwOiAnb25lJyxcbiAqICAgMTogJ3R3bycsXG4gKiAgIDI6ICd0aHJlZScsXG4gKiAgIDM6ICdmb3VyJyxcbiAqICAgbGVuZ3RoOiA0XG4gKiB9O1xuICogY29uc3QgcmVzdWx0ID0gdG9BcnJheShhcnJheUxpa2UpO1xuICpcbiAqIGFsZXJ0KHJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KTsgLy8gdHJ1ZVxuICogYWxlcnQocmVzdWx0KTsgLy8gb25lLHR3byx0aHJlZSxmb3VyXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkkMShhcnJheUxpa2UpIHtcbiAgdmFyIGFycjtcbiAgdHJ5IHtcbiAgICBhcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheUxpa2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgYXJyID0gW107XG4gICAgZm9yRWFjaEFycmF5KGFycmF5TGlrZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbnZhciB0b0FycmF5XzEgPSB0b0FycmF5JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFncmFwaChzY2hlbWEsIGNvbnRlbnQpIHtcbiAgICB2YXIgcGFyYWdyYXBoID0gc2NoZW1hLm5vZGVzLnBhcmFncmFwaDtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFncmFwaC5jcmVhdGVBbmRGaWxsKCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhZ3JhcGguY3JlYXRlKG51bGwsIGlzU3RyaW5nXzEoY29udGVudCkgPyBzY2hlbWEudGV4dChjb250ZW50KSA6IGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIHRleHQsIG1hcmtzKSB7XG4gICAgcmV0dXJuIHNjaGVtYS50ZXh0KHRleHQsIG1hcmtzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIGZyb20sIHRvKSB7XG4gICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBmcm9tOyB9XG4gICAgdmFyIGNvbnRlbnRTaXplID0gdHIuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICB2YXIgc2l6ZSA9IGNvbnRlbnRTaXplID4gMCA/IGNvbnRlbnRTaXplIC0gMSA6IDE7XG4gICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgTWF0aC5taW4oZnJvbSwgc2l6ZSksIE1hdGgubWluKHRvLCBzaXplKSk7XG59XG5mdW5jdGlvbiBhZGRQYXJhZ3JhcGgodHIsIF9hLCBzY2hlbWEpIHtcbiAgICB2YXIgcG9zID0gX2EucG9zO1xuICAgIHRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCBjcmVhdGVQYXJhZ3JhcGgoc2NoZW1hKSk7XG4gICAgcmV0dXJuIHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBwb3MgKyAxKSk7XG59XG5mdW5jdGlvbiByZXBsYWNlVGV4dE5vZGUoX2EpIHtcbiAgICB2YXIgc3RhdGUgPSBfYS5zdGF0ZSwgZnJvbSA9IF9hLmZyb20sIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9hLmVuZEluZGV4LCBjcmVhdGVUZXh0ID0gX2EuY3JlYXRlVGV4dDtcbiAgICB2YXIgdHIgPSBzdGF0ZS50ciwgZG9jID0gc3RhdGUuZG9jLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPD0gZW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgX2IgPSBkb2MuY2hpbGQoaSksIG5vZGVTaXplID0gX2Iubm9kZVNpemUsIHRleHRDb250ZW50ID0gX2IudGV4dENvbnRlbnQsIGNvbnRlbnQgPSBfYi5jb250ZW50O1xuICAgICAgICB2YXIgdGV4dCA9IGNyZWF0ZVRleHQodGV4dENvbnRlbnQpO1xuICAgICAgICB2YXIgbm9kZSA9IHRleHQgPyBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgdGV4dCkgOiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgdmFyIG1hcHBlZEZyb20gPSB0ci5tYXBwaW5nLm1hcChmcm9tKTtcbiAgICAgICAgdmFyIG1hcHBlZFRvID0gbWFwcGVkRnJvbSArIGNvbnRlbnQuc2l6ZTtcbiAgICAgICAgdHIucmVwbGFjZVdpdGgobWFwcGVkRnJvbSwgbWFwcGVkVG8sIG5vZGUpO1xuICAgICAgICBmcm9tICs9IG5vZGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBzcGxpdEFuZEV4dGVuZEJsb2NrKHRyLCBwb3MsIHRleHQsIG5vZGUpIHtcbiAgICB2YXIgdGV4dExlbiA9IHRleHQubGVuZ3RoO1xuICAgIHRyLnNwbGl0KHBvcylcbiAgICAgICAgLmRlbGV0ZShwb3MgLSB0ZXh0TGVuLCBwb3MpXG4gICAgICAgIC5pbnNlcnQodHIubWFwcGluZy5tYXAocG9zKSwgbm9kZSlcbiAgICAgICAgLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChwb3MpIC0gdGV4dExlbikpO1xufVxuXG5mdW5jdGlvbiBnZXRNZFN0YXJ0TGluZShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlLnNvdXJjZXBvc1swXVswXTtcbn1cbmZ1bmN0aW9uIGdldE1kRW5kTGluZShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlLnNvdXJjZXBvc1sxXVswXTtcbn1cbmZ1bmN0aW9uIGdldE1kU3RhcnRDaChtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlLnNvdXJjZXBvc1swXVsxXTtcbn1cbmZ1bmN0aW9uIGdldE1kRW5kQ2gobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZS5zb3VyY2Vwb3NbMV1bMV07XG59XG5mdW5jdGlvbiBpc0hUTUxOb2RlKG1kTm9kZSkge1xuICAgIHZhciB0eXBlID0gbWROb2RlLnR5cGU7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdodG1sQmxvY2snIHx8IHR5cGUgPT09ICdodG1sSW5saW5lJztcbn1cbmZ1bmN0aW9uIGlzU3R5bGVkSW5saW5lTm9kZShtZE5vZGUpIHtcbiAgICB2YXIgdHlwZSA9IG1kTm9kZS50eXBlO1xuICAgIHJldHVybiAodHlwZSA9PT0gJ3N0cmlrZScgfHxcbiAgICAgICAgdHlwZSA9PT0gJ3N0cm9uZycgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2VtcGgnIHx8XG4gICAgICAgIHR5cGUgPT09ICdjb2RlJyB8fFxuICAgICAgICB0eXBlID09PSAnbGluaycgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2ltYWdlJyk7XG59XG5mdW5jdGlvbiBpc0NvZGVCbG9ja05vZGUobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZSAmJiBtZE5vZGUudHlwZSA9PT0gJ2NvZGVCbG9jayc7XG59XG5mdW5jdGlvbiBpc0xpc3ROb2RlJDEobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZSAmJiAobWROb2RlLnR5cGUgPT09ICdpdGVtJyB8fCBtZE5vZGUudHlwZSA9PT0gJ2xpc3QnKTtcbn1cbmZ1bmN0aW9uIGlzT3JkZXJlZExpc3ROb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBpc0xpc3ROb2RlJDEobWROb2RlKSAmJiBtZE5vZGUubGlzdERhdGEudHlwZSA9PT0gJ29yZGVyZWQnO1xufVxuZnVuY3Rpb24gaXNCdWxsZXRMaXN0Tm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gaXNMaXN0Tm9kZSQxKG1kTm9kZSkgJiYgbWROb2RlLmxpc3REYXRhLnR5cGUgIT09ICdvcmRlcmVkJztcbn1cbmZ1bmN0aW9uIGlzVGFibGVDZWxsTm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlICYmIChtZE5vZGUudHlwZSA9PT0gJ3RhYmxlQ2VsbCcgfHwgbWROb2RlLnR5cGUgPT09ICd0YWJsZURlbGltQ2VsbCcpO1xufVxuZnVuY3Rpb24gaXNJbmxpbmVOb2RlJDEobWROb2RlKSB7XG4gICAgc3dpdGNoIChtZE5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIGNhc2UgJ2VtcGgnOlxuICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICBjYXNlICdodG1sSW5saW5lJzpcbiAgICAgICAgY2FzZSAnbGluZWJyZWFrJzpcbiAgICAgICAgY2FzZSAnc29mdGJyZWFrJzpcbiAgICAgICAgY2FzZSAnY3VzdG9tSW5saW5lJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0Tm9kZShtZE5vZGUsIGNvbmRpdGlvbiwgaW5jbHVkZVNlbGYpIHtcbiAgICBpZiAoaW5jbHVkZVNlbGYgPT09IHZvaWQgMCkgeyBpbmNsdWRlU2VsZiA9IHRydWU7IH1cbiAgICBtZE5vZGUgPSBpbmNsdWRlU2VsZiA/IG1kTm9kZSA6IG1kTm9kZS5wYXJlbnQ7XG4gICAgd2hpbGUgKG1kTm9kZSAmJiBtZE5vZGUudHlwZSAhPT0gJ2RvY3VtZW50Jykge1xuICAgICAgICBpZiAoY29uZGl0aW9uKG1kTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVBhcmVudE5vZGVzKG1kTm9kZSwgaXRlcmF0ZWUsIGluY2x1ZGVTZWxmKSB7XG4gICAgaWYgKGluY2x1ZGVTZWxmID09PSB2b2lkIDApIHsgaW5jbHVkZVNlbGYgPSB0cnVlOyB9XG4gICAgbWROb2RlID0gaW5jbHVkZVNlbGYgPyBtZE5vZGUgOiBtZE5vZGUucGFyZW50O1xuICAgIHdoaWxlIChtZE5vZGUgJiYgbWROb2RlLnR5cGUgIT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgaXRlcmF0ZWUobWROb2RlKTtcbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRPZmZzZXRQb3Mob3JpZ2luUG9zLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gW29yaWdpblBvc1swXSwgb3JpZ2luUG9zWzFdICsgb2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIHNldE9mZnNldFBvcyhvcmlnaW5Qb3MsIG5ld09mZnNldCkge1xuICAgIHJldHVybiBbb3JpZ2luUG9zWzBdLCBuZXdPZmZzZXRdO1xufVxuZnVuY3Rpb24gZ2V0SW5saW5lTWFya2Rvd25UZXh0KG1kTm9kZSkge1xuICAgIHZhciB0ZXh0ID0gbWROb2RlLmZpcnN0Q2hpbGQubGl0ZXJhbDtcbiAgICBzd2l0Y2ggKG1kTm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2VtcGgnOlxuICAgICAgICAgICAgcmV0dXJuIFwiKlwiICsgdGV4dCArIFwiKlwiO1xuICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICAgICAgcmV0dXJuIFwiKipcIiArIHRleHQgKyBcIioqXCI7XG4gICAgICAgIGNhc2UgJ3N0cmlrZSc6XG4gICAgICAgICAgICByZXR1cm4gXCJ+flwiICsgdGV4dCArIFwifn5cIjtcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAgICByZXR1cm4gXCJgXCIgKyB0ZXh0ICsgXCJgXCI7XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuICAgICAgICAgICAgdmFyIF9hID0gbWROb2RlLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uLCB0aXRsZSA9IF9hLnRpdGxlO1xuICAgICAgICAgICAgdmFyIGRlbGltID0gbWROb2RlLnR5cGUgPT09ICdsaW5rJyA/ICcnIDogJyEnO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGltICsgXCJbXCIgKyB0ZXh0ICsgXCJdKFwiICsgZGVzdGluYXRpb24gKyAodGl0bGUgPyBcIiBcXFwiXCIgKyB0aXRsZSArIFwiXFxcIlwiIDogJycpICsgXCIpXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5lciQyKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrUXVvdGUnOlxuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgY2FzZSAnaXRlbSc6XG4gICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgIGNhc2UgJ2hlYWRpbmcnOlxuICAgICAgICBjYXNlICdlbXBoJzpcbiAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICBjYXNlICd0YWJsZUhlYWQnOlxuICAgICAgICBjYXNlICd0YWJsZUJvZHknOlxuICAgICAgICBjYXNlICd0YWJsZVJvdyc6XG4gICAgICAgIGNhc2UgJ3RhYmxlQ2VsbCc6XG4gICAgICAgIGNhc2UgJ3RhYmxlRGVsaW1Sb3cnOlxuICAgICAgICBjYXNlICdjdXN0b21JbmxpbmUnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW5UZXh0JDEobm9kZSkge1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgd2Fsa2VyID0gbm9kZS53YWxrZXIoKTtcbiAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gZXZlbnQubm9kZTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGNoaWxkTm9kZS5saXRlcmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xufVxuXG52YXIgd2lkZ2V0UnVsZXMgPSBbXTtcbnZhciB3aWRnZXRSdWxlTWFwID0ge307XG52YXIgcmVXaWRnZXRQcmVmaXggPSAvXFwkXFwkd2lkZ2V0XFxkK1xccy87XG5mdW5jdGlvbiB1bndyYXBXaWRnZXRTeW50YXgodGV4dCkge1xuICAgIHZhciBpbmRleCA9IHRleHQuc2VhcmNoKHJlV2lkZ2V0UHJlZml4KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGV4dC5zdWJzdHJpbmcoaW5kZXgpO1xuICAgICAgICB2YXIgcmVwbGFjZWQgPSByZXN0LnJlcGxhY2UocmVXaWRnZXRQcmVmaXgsICcnKS5yZXBsYWNlKCckJCcsICcnKTtcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgdGV4dCArPSB1bndyYXBXaWRnZXRTeW50YXgocmVwbGFjZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpZGdldENvbnRlbnQoaW5mbywgdGV4dCkge1xuICAgIHJldHVybiBcIiQkXCIgKyBpbmZvICsgXCIgXCIgKyB0ZXh0ICsgXCIkJFwiO1xufVxuZnVuY3Rpb24gd2lkZ2V0VG9ET00oaW5mbywgdGV4dCkge1xuICAgIHZhciBfYSA9IHdpZGdldFJ1bGVNYXBbaW5mb10sIHJ1bGUgPSBfYS5ydWxlLCB0b0RPTSA9IF9hLnRvRE9NO1xuICAgIHZhciBtYXRjaGVzID0gdW53cmFwV2lkZ2V0U3ludGF4KHRleHQpLm1hdGNoKHJ1bGUpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHRleHQgPSBtYXRjaGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdG9ET00odGV4dCk7XG59XG5mdW5jdGlvbiBnZXRXaWRnZXRSdWxlcygpIHtcbiAgICByZXR1cm4gd2lkZ2V0UnVsZXM7XG59XG5mdW5jdGlvbiBzZXRXaWRnZXRSdWxlcyhydWxlcykge1xuICAgIHdpZGdldFJ1bGVzID0gcnVsZXM7XG4gICAgd2lkZ2V0UnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSwgaW5kZXgpIHtcbiAgICAgICAgd2lkZ2V0UnVsZU1hcFtcIndpZGdldFwiICsgaW5kZXhdID0gcnVsZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1lcmdlTm9kZXMobm9kZXMsIHRleHQsIHNjaGVtYSwgcnVsZUluZGV4KSB7XG4gICAgcmV0dXJuIG5vZGVzLmNvbmNhdChjcmVhdGVOb2Rlc1dpdGhXaWRnZXQodGV4dCwgc2NoZW1hLCBydWxlSW5kZXgpKTtcbn1cbi8qKlxuICogY3JlYXRlIG5vZGVzIHdpdGggcGxhaW4gdGV4dCBhbmQgcmVwbGFjZSB0ZXh0IG1hdGNoZWQgdG8gdGhlIHdpZGdldCBydWxlcyB3aXRoIHRoZSB3aWRnZXQgbm9kZVxuICogRm9yIGV4YW1wbGUsIGluIGNhc2UgdGhlIHRleHQgYW5kIHdpZGdldCBydWxlcyBhcyBiZWxvd1xuICpcbiAqIHRleHQ6ICR0ZXN0IHBsYWluIHRleHQgI3Rlc3RcbiAqIHdpZGdldCBydWxlczogW3sgcnVsZTogLyQuKy8gfSwgeyBydWxlOiAvIy4rLyB9XVxuICpcbiAqIFRoZSBjcmVhdGluZyBub2RlIHByb2Nlc3MgaXMgcmVjdXJzaXZlIGFuZCBpcyBhcyBmb2xsb3dzLlxuICpcbiAqIGluIGZpcnN0IHdpZGdldCBydWxlKC8kLisvKVxuICogICR0ZXN0IC0+IHdpZGdldCBub2RlXG4gKiAgcGxhaW4gdGV4dCAtPiBtYXRjaCB3aXRoIG5leHQgd2lkZ2V0IHJ1bGVcbiAqICAjdGVzdCAtPiBtYXRjaCB3aXRoIG5leHQgd2lkZ2V0IHJ1bGVcbiAqXG4gKiBpbiBzZWNvbmQgd2lkZ2V0IHJ1bGUoLyMuKy8pXG4gKiAgcGxhaW4gdGV4dCAtPiB0ZXh0IG5vZGUobm8gcnVsZSBmb3IgbWF0Y2hpbmcpXG4gKiAgI3Rlc3QgLT4gd2lkZ2V0IG5vZGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KHRleHQsIHNjaGVtYSwgcnVsZUluZGV4KSB7XG4gICAgaWYgKHJ1bGVJbmRleCA9PT0gdm9pZCAwKSB7IHJ1bGVJbmRleCA9IDA7IH1cbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgcnVsZSA9ICh3aWRnZXRSdWxlc1tydWxlSW5kZXhdIHx8IHt9KS5ydWxlO1xuICAgIHZhciBuZXh0UnVsZUluZGV4ID0gcnVsZUluZGV4ICsgMTtcbiAgICB0ZXh0ID0gdW53cmFwV2lkZ2V0U3ludGF4KHRleHQpO1xuICAgIGlmIChydWxlICYmIHJ1bGUudGVzdCh0ZXh0KSkge1xuICAgICAgICB2YXIgaW5kZXggPSB2b2lkIDA7XG4gICAgICAgIHdoaWxlICgoaW5kZXggPSB0ZXh0LnNlYXJjaChydWxlKSkgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRleHQuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIC8vIGdldCB3aWRnZXQgbm9kZSBvbiBmaXJzdCBzcGxpdHRlZCB0ZXh0IHVzaW5nIG5leHQgd2lkZ2V0IHJ1bGVcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgbm9kZXMgPSBtZXJnZU5vZGVzKG5vZGVzLCBwcmV2LCBzY2hlbWEsIG5leHRSdWxlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnVpbGQgd2lkZ2V0IG5vZGUgdXNpbmcgY3VycmVudCB3aWRnZXQgcnVsZVxuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKGluZGV4KTtcbiAgICAgICAgICAgIHZhciBsaXRlcmFsID0gdGV4dC5tYXRjaChydWxlKVswXTtcbiAgICAgICAgICAgIHZhciBpbmZvID0gXCJ3aWRnZXRcIiArIHJ1bGVJbmRleDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goc2NoZW1hLm5vZGVzLndpZGdldC5jcmVhdGUoeyBpbmZvOiBpbmZvIH0sIHNjaGVtYS50ZXh0KGNyZWF0ZVdpZGdldENvbnRlbnQoaW5mbywgbGl0ZXJhbCkpKSk7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCB3aWRnZXQgbm9kZSBvbiBsYXN0IHNwbGl0dGVkIHRleHQgdXNpbmcgbmV4dCB3aWRnZXQgcnVsZVxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgbm9kZXMgPSBtZXJnZU5vZGVzKG5vZGVzLCB0ZXh0LCBzY2hlbWEsIG5leHRSdWxlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRleHQpIHtcbiAgICAgICAgbm9kZXMgPVxuICAgICAgICAgICAgcnVsZUluZGV4IDwgd2lkZ2V0UnVsZXMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgID8gbWVyZ2VOb2Rlcyhub2RlcywgdGV4dCwgc2NoZW1hLCBuZXh0UnVsZUluZGV4KVxuICAgICAgICAgICAgICAgIDogW3NjaGVtYS50ZXh0KHRleHQpXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuZnVuY3Rpb24gZ2V0V2lkZ2V0Q29udGVudCh3aWRnZXROb2RlKSB7XG4gICAgdmFyIGV2ZW50O1xuICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgdmFyIHdhbGtlciA9IHdpZGdldE5vZGUud2Fsa2VyKCk7XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gd2lkZ2V0Tm9kZSAmJiBub2RlLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gZ2V0SW5saW5lTWFya2Rvd25UZXh0KG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgd2Fsa2VyLnJlc3VtZUF0KHdpZGdldE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGV0ZVNlbGVjdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVsZXRlU2VsZWN0aW9uOyB9LFxuICAgICAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGVjdEFsbDsgfSxcbiAgICAgICAgdW5kbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kbzsgfSxcbiAgICAgICAgcmVkbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVkbzsgfSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBzdGF0ZS5kb2M7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBkb2MuY2hpbGRDb3VudCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBkb2MuZmlyc3RDaGlsZC5pc1RleHRibG9jayAmJlxuICAgICAgICAgICAgICAgICAgICBkb2MuZmlyc3RDaGlsZC5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlSG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzc18xKHBsYWNlSG9sZGVyLCAncGxhY2Vob2xkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzc18xKHBsYWNlSG9sZGVyLCBvcHRpb25zLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGxhY2VIb2xkZXIudGV4dENvbnRlbnQgPSBvcHRpb25zLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIFtEZWNvcmF0aW9uLndpZGdldCgxLCBwbGFjZUhvbGRlcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgZWxlbWVudCBoYXMgc3BlY2lmaWMgY3NzIGNsYXNzXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaW5BcnJheSQxID0gaW5BcnJheV8xO1xudmFyIGdldENsYXNzID0gZ2V0Q2xhc3NfMTtcblxuLyoqXG4gKiBDaGVjayBlbGVtZW50IGhhcyBzcGVjaWZpYyBjc3MgY2xhc3NcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NDbGFzcyAtIGNzcyBjbGFzc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgdmFyIG9yaWdpbjtcblxuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY3NzQ2xhc3MpO1xuICB9XG5cbiAgb3JpZ2luID0gZ2V0Q2xhc3MoZWxlbWVudCkuc3BsaXQoL1xccysvKTtcblxuICByZXR1cm4gaW5BcnJheSQxKGNzc0NsYXNzLCBvcmlnaW4pID4gLTE7XG59XG5cbnZhciBoYXNDbGFzc18xID0gaGFzQ2xhc3M7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayBlbGVtZW50IG1hdGNoIHNlbGVjdG9yXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaW5BcnJheSA9IGluQXJyYXlfMTtcbnZhciB0b0FycmF5ID0gdG9BcnJheV8xO1xuXG52YXIgZWxQcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xudmFyIG1hdGNoU2VsZWN0b3IgPSBlbFByb3RvLm1hdGNoZXMgfHxcbiAgICBlbFByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgIGVsUHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZWxQcm90by5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZG9jID0gdGhpcy5kb2N1bWVudCB8fCB0aGlzLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgIHJldHVybiBpbkFycmF5KHRoaXMsIHRvQXJyYXkoZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSkgPiAtMTtcbiAgICB9O1xuXG4vKipcbiAqIENoZWNrIGVsZW1lbnQgbWF0Y2ggc2VsZWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBzZWxlY3RvciB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IGlzIHNlbGVjdG9yIG1hdGNoZWQgdG8gZWxlbWVudD9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBtYXRjaFNlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xufVxuXG52YXIgbWF0Y2hlc18xID0gbWF0Y2hlcztcblxudmFyIFRBR19OQU1FID0gJ1tBLVphLXpdW0EtWmEtejAtOS1dKic7XG52YXIgQVRUUklCVVRFX05BTUUgPSAnW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSonO1xudmFyIFVOUVVPVEVEX1ZBTFVFID0gJ1teXCJcXCc9PD5gXFxcXHgwMC1cXFxceDIwXSsnO1xudmFyIFNJTkdMRV9RVU9URURfVkFMVUUgPSBcIidbXiddKidcIjtcbnZhciBET1VCTEVfUVVPVEVEX1ZBTFVFID0gJ1wiW15cIl0qXCInO1xudmFyIEFUVFJJQlVURV9WQUxVRSA9IFwiKD86XCIgKyBVTlFVT1RFRF9WQUxVRSArIFwifFwiICsgU0lOR0xFX1FVT1RFRF9WQUxVRSArIFwifFwiICsgRE9VQkxFX1FVT1RFRF9WQUxVRSArIFwiKVwiO1xudmFyIEFUVFJJQlVURV9WQUxVRV9TUEVDID0gXCJcIiArICcoPzpcXFxccyo9XFxcXHMqJyArIEFUVFJJQlVURV9WQUxVRSArIFwiKVwiO1xudmFyIEFUVFJJQlVURSQxID0gXCJcIiArICcoPzpcXFxccysnICsgQVRUUklCVVRFX05BTUUgKyBBVFRSSUJVVEVfVkFMVUVfU1BFQyArIFwiPylcIjtcbnZhciBPUEVOX1RBRyA9IFwiPChcIiArIFRBR19OQU1FICsgXCIpKFwiICsgQVRUUklCVVRFJDEgKyBcIikqXFxcXHMqLz8+XCI7XG52YXIgQ0xPU0VfVEFHID0gXCI8LyhcIiArIFRBR19OQU1FICsgXCIpXFxcXHMqWz5dXCI7XG52YXIgSFRNTF9UQUcgPSBcIig/OlwiICsgT1BFTl9UQUcgKyBcInxcIiArIENMT1NFX1RBRyArIFwiKVwiO1xudmFyIHJlSFRNTFRhZyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBIVE1MX1RBRywgJ2knKTtcbnZhciByZUJSID0gLzxiclxccypcXC8qPi9pO1xudmFyIHJlSFRNTENvbW1lbnQgPSAvPCEgLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT4vO1xudmFyIEFMVEVSTkFUSVZFX1RBR19GT1JfQlIgPSAnPC9wPjxwPic7XG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25JbkJveChzdHlsZSwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgIHZhciBsZWZ0ID0gcGFyc2VJbnQoc3R5bGUubGVmdCwgMTApO1xuICAgIHZhciB0b3AgPSBwYXJzZUludChzdHlsZS50b3AsIDEwKTtcbiAgICB2YXIgd2lkdGggPSBwYXJzZUludChzdHlsZS53aWR0aCwgMTApICsgcGFyc2VJbnQoc3R5bGUucGFkZGluZ0xlZnQsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCwgMTApO1xuICAgIHZhciBoZWlnaHQgPSBwYXJzZUludChzdHlsZS5oZWlnaHQsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3AsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20sIDEwKTtcbiAgICByZXR1cm4gb2Zmc2V0WCA+PSBsZWZ0ICYmIG9mZnNldFggPD0gbGVmdCArIHdpZHRoICYmIG9mZnNldFkgPj0gdG9wICYmIG9mZnNldFkgPD0gdG9wICsgaGVpZ2h0O1xufVxudmFyIENMU19QUkVGSVggPSAndG9hc3R1aS1lZGl0b3ItJztcbmZ1bmN0aW9uIGNscygpIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBuYW1lc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgX2EgPSAwLCBuYW1lc18xID0gbmFtZXM7IF9hIDwgbmFtZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIG5hbWVfMSA9IG5hbWVzXzFbX2FdO1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdm9pZCAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lXzEpKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBuYW1lXzFbMF0gPyBuYW1lXzFbMV0gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gbmFtZV8xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiXCIgKyBDTFNfUFJFRklYICsgY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGNsc1dpdGhNZFByZWZpeCgpIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBuYW1lc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMubWFwKGZ1bmN0aW9uIChjbGFzc05hbWUpIHsgcmV0dXJuIENMU19QUkVGSVggKyBcIm1kLVwiICsgY2xhc3NOYW1lOyB9KS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5ub2RlVHlwZSkgPT09IE5vZGUuVEVYVF9OT0RFO1xufVxuZnVuY3Rpb24gaXNFbGVtTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG59XG5mdW5jdGlvbiBmaW5kTm9kZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbm9kZUxpc3QgPSB0b0FycmF5XzEoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgaWYgKG5vZGVMaXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbm9kZUxpc3Q7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGFwcGVuZE5vZGVzKG5vZGUsIG5vZGVzVG9BcHBlbmQpIHtcbiAgICBub2Rlc1RvQXBwZW5kID0gaXNBcnJheV8xKG5vZGVzVG9BcHBlbmQpID8gdG9BcnJheV8xKG5vZGVzVG9BcHBlbmQpIDogW25vZGVzVG9BcHBlbmRdO1xuICAgIG5vZGVzVG9BcHBlbmQuZm9yRWFjaChmdW5jdGlvbiAobm9kZVRvQXBwZW5kKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobm9kZVRvQXBwZW5kKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZU5vZGUoaW5zZXJ0ZWROb2RlLCBub2RlKSB7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGluc2VydGVkTm9kZSwgbm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlTm9kZSQxKG5vZGUpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bndyYXBOb2RlKG5vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICByZXN1bHQucHVzaChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUuZmlyc3RDaGlsZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTm9kZSQxKG5vZGUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUsIHN0YXRlKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkXzEoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlID0gIWhhc0NsYXNzXzEoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgdmFyIHRvZ2dsZUZuID0gc3RhdGUgPyBhZGRDbGFzc18xIDogcmVtb3ZlQ2xhc3NfMTtcbiAgICB0b2dnbGVGbihlbGVtZW50LCBjbGFzc05hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGgoY29udGVudHMsIHRhcmdldCkge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpZiAoaXNTdHJpbmdfMShjb250ZW50cykpIHtcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGNvbnRlbnRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRlbnRzKTtcbiAgICB9XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBnZXRPdXRlcldpZHRoKGVsKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHJldHVybiAoWydtYXJnaW4tbGVmdCcsICdtYXJnaW4tcmlnaHQnXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHlwZSkgeyByZXR1cm4gYWNjICsgcGFyc2VJbnQoY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSh0eXBlKSwgMTApOyB9LCAwKSArIGVsLm9mZnNldFdpZHRoKTtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3Qobm9kZSwgZm91bmQpIHtcbiAgICB2YXIgY29uZGl0aW9uO1xuICAgIGlmIChpc1N0cmluZ18xKGZvdW5kKSkge1xuICAgICAgICBjb25kaXRpb24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiBtYXRjaGVzXzEodGFyZ2V0LCBmb3VuZCk7IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25kaXRpb24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQgPT09IGZvdW5kOyB9O1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSBkb2N1bWVudCkge1xuICAgICAgICBpZiAoaXNFbGVtTm9kZShub2RlKSAmJiBjb25kaXRpb24obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VG90YWxPZmZzZXQoZWwsIHJvb3QpIHtcbiAgICB2YXIgb2Zmc2V0VG9wID0gMDtcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IDA7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSByb290KSB7XG4gICAgICAgIHZhciB0b3BfMSA9IGVsLm9mZnNldFRvcCwgbGVmdCA9IGVsLm9mZnNldExlZnQsIG9mZnNldFBhcmVudCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICAgICAgb2Zmc2V0VG9wICs9IHRvcF8xO1xuICAgICAgICBvZmZzZXRMZWZ0ICs9IGxlZnQ7XG4gICAgICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IHJvb3Qub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHsgb2Zmc2V0VG9wOiBvZmZzZXRUb3AsIG9mZnNldExlZnQ6IG9mZnNldExlZnQgfTtcbn1cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcywgZWxlbWVudCkge1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIGlmIChpc05pbChhdHRyaWJ1dGVzW2F0dHJOYW1lXSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyaWJ1dGVzW2F0dHJOYW1lXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VCUldpdGhFbXB0eUJsb2NrKGh0bWwpIHtcbiAgICAvLyByZW1vdmUgYnIgaW4gcGFyYWdyYXBoIHRvIGNvbXBhdGlibGUgd2l0aCBtYXJrZG93blxuICAgIHZhciByZXBsYWNlZEhUTUwgPSBodG1sLnJlcGxhY2UoLzxwPjxiclxccypcXC8qPjxcXC9wPi9naSwgJzxwPjwvcD4nKTtcbiAgICB2YXIgcmVIVE1MVGFnID0gbmV3IFJlZ0V4cChIVE1MX1RBRywgJ2lnJyk7XG4gICAgdmFyIGh0bWxUYWdNYXRjaGVkID0gcmVwbGFjZWRIVE1MLm1hdGNoKHJlSFRNTFRhZyk7XG4gICAgaHRtbFRhZ01hdGNoZWQgPT09IG51bGwgfHwgaHRtbFRhZ01hdGNoZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0bWxUYWdNYXRjaGVkLmZvckVhY2goZnVuY3Rpb24gKGh0bWxUYWcsIGluZGV4KSB7XG4gICAgICAgIGlmIChyZUJSLnRlc3QoaHRtbFRhZykpIHtcbiAgICAgICAgICAgIHZhciBhbHRlcm5hdGl2ZVRhZyA9IEFMVEVSTkFUSVZFX1RBR19GT1JfQlI7XG4gICAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlRhZyA9IGh0bWxUYWdNYXRjaGVkW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIG9wZW5UYWdNYXRjaGVkID0gcHJldlRhZy5tYXRjaChPUEVOX1RBRyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5UYWdNYXRjaGVkICYmICEvYnIvaS50ZXN0KG9wZW5UYWdNYXRjaGVkWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnTmFtZSA9IG9wZW5UYWdNYXRjaGVkWzFdO1xuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZVRhZyA9IFwiPC9cIiArIHRhZ05hbWUgKyBcIj48XCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwbGFjZWRIVE1MID0gcmVwbGFjZWRIVE1MLnJlcGxhY2UocmVCUiwgYWx0ZXJuYXRpdmVUYWcpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcGxhY2VkSFRNTDtcbn1cbmZ1bmN0aW9uIHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKGh0bWwpIHtcbiAgICB2YXIgcmVQcm9zZU1pcnJvckltYWdlID0gLzxpbWcgY2xhc3M9XCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIiBhbHQ9XCJcIj4vZztcbiAgICB2YXIgcmVQcm9zZU1pcnJvclRyYWlsaW5nQnJlYWsgPSAvIGNsYXNzPVwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiL2c7XG4gICAgdmFyIHJlc3VsdEhUTUwgPSBodG1sO1xuICAgIHJlc3VsdEhUTUwgPSByZXN1bHRIVE1MLnJlcGxhY2UocmVQcm9zZU1pcnJvckltYWdlLCAnJyk7XG4gICAgcmVzdWx0SFRNTCA9IHJlc3VsdEhUTUwucmVwbGFjZShyZVByb3NlTWlycm9yVHJhaWxpbmdCcmVhaywgJycpO1xuICAgIHJldHVybiByZXN1bHRIVE1MO1xufVxuXG52YXIgcGx1Z2luS2V5JDEgPSBuZXcgUGx1Z2luS2V5KCd3aWRnZXQnKTtcbnZhciBNQVJHSU4gPSA1O1xudmFyIFBvcHVwV2lkZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvcHVwV2lkZ2V0KHZpZXcsIGV2ZW50RW1pdHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW1vdmVXaWRnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucG9wdXApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yb290RWwucmVtb3ZlQ2hpbGQoX3RoaXMucG9wdXApO1xuICAgICAgICAgICAgICAgIF90aGlzLnBvcHVwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yb290RWwgPSB2aWV3LmRvbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdibHVyJywgdGhpcy5yZW1vdmVXaWRnZXQpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2xvYWRVSScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJvb3RFbCA9IGNsb3Nlc3Qodmlldy5kb20ucGFyZW50RWxlbWVudCwgXCIuXCIgKyBjbHMoJ2RlZmF1bHRVSScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbigncmVtb3ZlUG9wdXBXaWRnZXQnLCB0aGlzLnJlbW92ZVdpZGdldCk7XG4gICAgfVxuICAgIFBvcHVwV2lkZ2V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodmlldykge1xuICAgICAgICB2YXIgd2lkZ2V0ID0gcGx1Z2luS2V5JDEuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMucmVtb3ZlV2lkZ2V0KCk7XG4gICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gd2lkZ2V0Lm5vZGUsIHN0eWxlID0gd2lkZ2V0LnN0eWxlO1xuICAgICAgICAgICAgdmFyIF9hID0gdmlldy5jb29yZHNBdFBvcyh3aWRnZXQucG9zKSwgdG9wXzEgPSBfYS50b3AsIGxlZnQgPSBfYS5sZWZ0LCBib3R0b20gPSBfYS5ib3R0b207XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wXzE7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMucm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHJlbFRvcFBvcyA9IHRvcF8xIC0gcmVjdC50b3A7XG4gICAgICAgICAgICBjc3NfMShub2RlLCB7IG9wYWNpdHk6ICcwJyB9KTtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgY3NzXzEobm9kZSwge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQgLSByZWN0LmxlZnQgKyBNQVJHSU4gKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgdG9wOiAoc3R5bGUgPT09ICdib3R0b20nID8gcmVsVG9wUG9zICsgaGVpZ2h0IC0gTUFSR0lOIDogcmVsVG9wUG9zIC0gaGVpZ2h0KSArIFwicHhcIixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAnMScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucG9wdXAgPSBub2RlO1xuICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb3B1cFdpZGdldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKCdibHVyJywgdGhpcy5yZW1vdmVXaWRnZXQpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcHVwV2lkZ2V0O1xufSgpKTtcbmZ1bmN0aW9uIGFkZFdpZGdldChldmVudEVtaXR0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogcGx1Z2luS2V5JDEsXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHk6IGZ1bmN0aW9uICh0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ci5nZXRNZXRhKCd3aWRnZXQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uIChlZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvcHVwV2lkZ2V0KGVkaXRvclZpZXcsIGV2ZW50RW1pdHRlcik7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERlZmF1bHRJbWFnZUJsb2JIb29rKGV2ZW50RW1pdHRlcikge1xuICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ2FkZEltYWdlQmxvYkhvb2snLCBmdW5jdGlvbiAoYmxvYiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW1pdEltYWdlQmxvYkhvb2soZXZlbnRFbWl0dGVyLCBibG9iLCB0eXBlKSB7XG4gICAgdmFyIGhvb2sgPSBmdW5jdGlvbiAoaW1hZ2VVcmwsIGFsdFRleHQpIHtcbiAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2NvbW1hbmQnLCAnYWRkSW1hZ2UnLCB7XG4gICAgICAgICAgICBpbWFnZVVybDogaW1hZ2VVcmwsXG4gICAgICAgICAgICBhbHRUZXh0OiBhbHRUZXh0IHx8IGJsb2IubmFtZSB8fCAnaW1hZ2UnLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGV2ZW50RW1pdHRlci5lbWl0KCdhZGRJbWFnZUJsb2JIb29rJywgYmxvYiwgaG9vaywgdHlwZSk7XG59XG5mdW5jdGlvbiBwYXN0ZUltYWdlT25seShpdGVtcykge1xuICAgIHZhciBpbWFnZXMgPSB0b0FycmF5XzEoaXRlbXMpLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICByZXR1cm4gdHlwZS5pbmRleE9mKCdpbWFnZScpICE9PSAtMTtcbiAgICB9KTtcbiAgICBpZiAoaW1hZ2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgaXRlbSA9IGltYWdlc1swXTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmdldEFzRmlsZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBkcm9wSW1hZ2UoX2EpIHtcbiAgICB2YXIgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyO1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgIGRyb3A6IGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IChfYSA9IGV2LmRhdGFUcmFuc2ZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbGVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2hBcnJheV8xKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUuaW5kZXhPZignaW1hZ2UnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRJbWFnZUJsb2JIb29rKGV2ZW50RW1pdHRlciwgaXRlbSwgZXYudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxudmFyIE5vZGUkMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKCkge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdub2RlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5vZGUucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xuXG5mdW5jdGlvbiB3aWRnZXROb2RlVmlldyhwbU5vZGUpIHtcbiAgICB2YXIgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHZhciBub2RlID0gd2lkZ2V0VG9ET00ocG1Ob2RlLmF0dHJzLmluZm8sIHBtTm9kZS50ZXh0Q29udGVudCk7XG4gICAgZG9tLmNsYXNzTmFtZSA9ICd0dWktd2lkZ2V0JztcbiAgICBkb20uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIHsgZG9tOiBkb20gfTtcbn1cbmZ1bmN0aW9uIGlzV2lkZ2V0Tm9kZShwbU5vZGUpIHtcbiAgICByZXR1cm4gcG1Ob2RlLnR5cGUubmFtZSA9PT0gJ3dpZGdldCc7XG59XG52YXIgV2lkZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFdpZGdldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaWRnZXQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpZGdldC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd3aWRnZXQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdpZGdldC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAndGV4dConLFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF0b206IHRydWUsXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6ICd0dWktd2lkZ2V0JyB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ3NwYW4udHVpLXdpZGdldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gZG9tLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IHRleHQubWF0Y2goL1xcJFxcJCh3aWRnZXRcXGQrKS8pLCBpbmZvID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5mbzogaW5mbyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBXaWRnZXQ7XG59KE5vZGUkMikpO1xuXG52YXIgRWRpdG9yQmFzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFZGl0b3JCYXNlKGV2ZW50RW1pdHRlcikge1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTmFtZSA9ICd0b2FzdHVpLWVkaXRvcic7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0geyB0ZXh0OiAnJyB9O1xuICAgIH1cbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5jcmVhdGVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgcGx1Z2luczogdGhpcy5jcmVhdGVQbHVnaW5zKCksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXIsIHZpZXcgPSBfYS52aWV3LCBlZGl0b3JUeXBlID0gX2EuZWRpdG9yVHlwZTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudEVtaXR0ZXIuZW1pdCgnZm9jdXMnLCBlZGl0b3JUeXBlKTsgfSk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudEVtaXR0ZXIuZW1pdCgnYmx1cicsIGVkaXRvclR5cGUpOyB9KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmVtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICh0cikge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjYXJldENoYW5nZScsIHRoaXMuZWRpdG9yVHlwZSk7XG4gICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB0aGlzLmVkaXRvclR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWRpdG9yQmFzZS5wcm90b3R5cGUsIFwiZGVmYXVsdFBsdWdpbnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBydWxlcyA9IHRoaXMuY3JlYXRlSW5wdXRSdWxlcygpO1xuICAgICAgICAgICAgdmFyIHBsdWdpbnMgPSBfX3NwcmVhZEFycmF5JDEoX19zcHJlYWRBcnJheSQxKFtdLCB0aGlzLmtleW1hcHMpLCBbXG4gICAgICAgICAgICAgICAga2V5bWFwKF9fYXNzaWduJDEoeyAnU2hpZnQtRW50ZXInOiBiYXNlS2V5bWFwLkVudGVyIH0sIGJhc2VLZXltYXApKSxcbiAgICAgICAgICAgICAgICBoaXN0b3J5KCksXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIodGhpcy5wbGFjZWhvbGRlciksXG4gICAgICAgICAgICAgICAgYWRkV2lkZ2V0KHRoaXMuZXZlbnRFbWl0dGVyKSxcbiAgICAgICAgICAgICAgICBkcm9wSW1hZ2UodGhpcy5jb250ZXh0KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzID8gcGx1Z2lucy5jb25jYXQocnVsZXMpIDogcGx1Z2lucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmNyZWF0ZUlucHV0UnVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3aWRnZXRSdWxlcyA9IGdldFdpZGdldFJ1bGVzKCk7XG4gICAgICAgIHZhciBydWxlcyA9IHdpZGdldFJ1bGVzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBydWxlID0gX2EucnVsZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5wdXRSdWxlKHJ1bGUsIGZ1bmN0aW9uIChzdGF0ZSwgbWF0Y2gsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCB0ciA9IHN0YXRlLnRyLCBkb2MgPSBzdGF0ZS5kb2M7XG4gICAgICAgICAgICAgICAgdmFyIGFsbE1hdGNoZWQgPSBtYXRjaC5pbnB1dC5tYXRjaChuZXcgUmVnRXhwKHJ1bGUsICdnJykpO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBkb2MucmVzb2x2ZShzdGFydCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBvcy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaXNXaWRnZXROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcG9zLm5vZGUocG9zLmRlcHRoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gaXNXaWRnZXROb2RlKGNoaWxkKSAmJiAoY291bnQgKz0gMSk7IH0pO1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGNvbnRlbnQgb25seSBpZiB0aGUgY291bnQgb2YgbWF0Y2hlZCBydWxlcyBpbiB3aG9sZSB0ZXh0IGlzIGdyZWF0ZXIgdGhhbiBjdXJyZW50IHdpZGdldCBub2RlIGNvdW50XG4gICAgICAgICAgICAgICAgaWYgKGFsbE1hdGNoZWQubGVuZ3RoID4gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBsYXN0JDEoYWxsTWF0Y2hlZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IGNyZWF0ZU5vZGVzV2l0aFdpZGdldChjb250ZW50LCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3Qgc3RhcnQgcG9zaXRpb24gYmFzZWQgb24gd2lkZ2V0IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2VXaXRoKGVuZCAtIGNvbnRlbnQubGVuZ3RoICsgMSwgZW5kLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnVsZXMubGVuZ3RoID8gaW5wdXRSdWxlcyh7IHJ1bGVzOiBydWxlcyB9KSA6IG51bGw7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmNyZWF0ZVNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgICAgICAgICAgbm9kZXM6IHRoaXMuc3BlY3Mubm9kZXMsXG4gICAgICAgICAgICBtYXJrczogdGhpcy5zcGVjcy5tYXJrcyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5jcmVhdGVLZXltYXBzID0gZnVuY3Rpb24gKHVzZUNvbW1hbmRTaG9ydGN1dCkge1xuICAgICAgICB2YXIgX2EgPSBnZXREZWZhdWx0Q29tbWFuZHMoKSwgdW5kbyA9IF9hLnVuZG8sIHJlZG8gPSBfYS5yZWRvO1xuICAgICAgICB2YXIgYWxsS2V5bWFwcyA9IHRoaXMuc3BlY3Mua2V5bWFwcyh1c2VDb21tYW5kU2hvcnRjdXQpO1xuICAgICAgICB2YXIgaGlzdG9yeUtleW1hcCA9IHtcbiAgICAgICAgICAgICdNb2Qteic6IHVuZG8oKSxcbiAgICAgICAgICAgICdTaGlmdC1Nb2Qteic6IHJlZG8oKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHVzZUNvbW1hbmRTaG9ydGN1dCA/IGFsbEtleW1hcHMuY29uY2F0KGtleW1hcChoaXN0b3J5S2V5bWFwKSkgOiBhbGxLZXltYXBzO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuY3JlYXRlQ29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWNzLmNvbW1hbmRzKHRoaXMudmlldyk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5jcmVhdGVQbHVnaW5Qcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFQbHVnaW5zLm1hcChmdW5jdGlvbiAocGx1Z2luKSB7IHJldHVybiBwbHVnaW4oX3RoaXMuZXZlbnRFbWl0dGVyKTsgfSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgIC8vIHByZXZlbnQgdGhlIGVycm9yIGZvciBJRTExXG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIF90aGlzLnZpZXcuZGlzcGF0Y2goX3RoaXMudmlldy5zdGF0ZS50ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLmJsdXIoKTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICB0aGlzLnZpZXcuZGVzdHJveSgpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXNbcHJvcF07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUubW92ZUN1cnNvclRvU3RhcnQgPSBmdW5jdGlvbiAoZm9jdXMpIHtcbiAgICAgICAgdmFyIHRyID0gdGhpcy52aWV3LnN0YXRlLnRyO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIDEpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLm1vdmVDdXJzb3JUb0VuZCA9IGZ1bmN0aW9uIChmb2N1cykge1xuICAgICAgICB2YXIgdHIgPSB0aGlzLnZpZXcuc3RhdGUudHI7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgdHIuZG9jLmNvbnRlbnQuc2l6ZSAtIDEpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICh0b3ApIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5zY3JvbGxUb3AgPSB0b3A7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZG9tLnNjcm9sbFRvcDtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLnNldFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlci50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRoaXMudmlldy5zdGF0ZS50ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgY3NzXzEodGhpcy5lbCwgeyBoZWlnaHQ6IGhlaWdodCArIFwicHhcIiB9KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLnNldE1pbkhlaWdodCA9IGZ1bmN0aW9uIChtaW5IZWlnaHQpIHtcbiAgICAgICAgY3NzXzEodGhpcy5lbCwgeyBtaW5IZWlnaHQ6IG1pbkhlaWdodCArIFwicHhcIiB9KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsO1xuICAgIH07XG4gICAgcmV0dXJuIEVkaXRvckJhc2U7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvbiBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24gb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24sIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgZnVuY3Rpb24/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuXG52YXIgaXNGdW5jdGlvbl8xID0gaXNGdW5jdGlvbjtcblxudmFyIGRlZmF1bHRDb21tYW5kU2hvcnRjdXRzID0gW1xuICAgICdFbnRlcicsXG4gICAgJ1NoaWZ0LUVudGVyJyxcbiAgICAnTW9kLUVudGVyJyxcbiAgICAnVGFiJyxcbiAgICAnU2hpZnQtVGFiJyxcbiAgICAnRGVsZXRlJyxcbiAgICAnQmFja3NwYWNlJyxcbiAgICAnTW9kLURlbGV0ZScsXG4gICAgJ01vZC1CYWNrc3BhY2UnLFxuICAgICdBcnJvd1VwJyxcbiAgICAnQXJyb3dEb3duJyxcbiAgICAnQXJyb3dMZWZ0JyxcbiAgICAnQXJyb3dSaWdodCcsXG4gICAgJ01vZC1kJyxcbiAgICAnTW9kLUQnLFxuICAgICdBbHQtQXJyb3dVcCcsXG4gICAgJ0FsdC1BcnJvd0Rvd24nLFxuXTtcbmZ1bmN0aW9uIGV4ZWNDb21tYW5kKHZpZXcsIGNvbW1hbmQsIHBheWxvYWQpIHtcbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgcmV0dXJuIGNvbW1hbmQocGF5bG9hZCkodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldyk7XG59XG52YXIgU3BlY01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3BlY01hbmFnZXIoc3BlY3MpIHtcbiAgICAgICAgdGhpcy5zcGVjcyA9IHNwZWNzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3BlY01hbmFnZXIucHJvdG90eXBlLCBcIm5vZGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGVjc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHNwZWMpIHsgcmV0dXJuIHNwZWMudHlwZSA9PT0gJ25vZGUnOyB9KVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG5vZGVzLCBfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBub2RlcyksIChfYiA9IHt9LCBfYltuYW1lXSA9IHNjaGVtYSwgX2IpKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcGVjTWFuYWdlci5wcm90b3R5cGUsIFwibWFya3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwZWNzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc3BlYykgeyByZXR1cm4gc3BlYy50eXBlID09PSAnbWFyayc7IH0pXG4gICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAobWFya3MsIF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIG1hcmtzKSwgKF9iID0ge30sIF9iW25hbWVdID0gc2NoZW1hLCBfYikpO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3BlY01hbmFnZXIucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKHZpZXcsIGFkZGVkQ29tbWFuZHMpIHtcbiAgICAgICAgdmFyIHNwZWNDb21tYW5kcyA9IHRoaXMuc3BlY3NcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY29tbWFuZHMgPSBfYS5jb21tYW5kcztcbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFsbENvbW1hbmRzLCBzcGVjKSB7XG4gICAgICAgICAgICB2YXIgY29tbWFuZHMgPSB7fTtcbiAgICAgICAgICAgIHZhciBzcGVjQ29tbWFuZCA9IHNwZWMuY29tbWFuZHMoKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uXzEoc3BlY0NvbW1hbmQpKSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZHNbc3BlYy5uYW1lXSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBleGVjQ29tbWFuZCh2aWV3LCBzcGVjQ29tbWFuZCwgcGF5bG9hZCk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzcGVjQ29tbWFuZCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1tuYW1lXSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBleGVjQ29tbWFuZCh2aWV3LCBzcGVjQ29tbWFuZFtuYW1lXSwgcGF5bG9hZCk7IH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhbGxDb21tYW5kcyksIGNvbW1hbmRzKTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgZGVmYXVsdENvbW1hbmRzID0gZ2V0RGVmYXVsdENvbW1hbmRzKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRDb21tYW5kcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgc3BlY0NvbW1hbmRzW25hbWVdID0gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGV4ZWNDb21tYW5kKHZpZXcsIGRlZmF1bHRDb21tYW5kc1tuYW1lXSwgcGF5bG9hZCk7IH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWRkZWRDb21tYW5kcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYWRkZWRDb21tYW5kcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHNwZWNDb21tYW5kc1tuYW1lXSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBleGVjQ29tbWFuZCh2aWV3LCBhZGRlZENvbW1hbmRzW25hbWVdLCBwYXlsb2FkKTsgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGVjQ29tbWFuZHM7XG4gICAgfTtcbiAgICBTcGVjTWFuYWdlci5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICh1c2VDb21tYW5kU2hvcnRjdXQpIHtcbiAgICAgICAgdmFyIHNwZWNLZXltYXBzID0gdGhpcy5zcGVjcy5maWx0ZXIoZnVuY3Rpb24gKHNwZWMpIHsgcmV0dXJuIHNwZWMua2V5bWFwczsgfSkubWFwKGZ1bmN0aW9uIChzcGVjKSB7IHJldHVybiBzcGVjLmtleW1hcHMoKTsgfSk7XG4gICAgICAgIHJldHVybiBzcGVjS2V5bWFwcy5tYXAoZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIGlmICghdXNlQ29tbWFuZFNob3J0Y3V0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoa2V5cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5jbHVkZXMoZGVmYXVsdENvbW1hbmRTaG9ydGN1dHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBrZXlzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXltYXAoa2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3BlY01hbmFnZXIucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB0aGlzLnNwZWNzLmZvckVhY2goZnVuY3Rpb24gKHNwZWMpIHtcbiAgICAgICAgICAgIHNwZWMuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3BlY01hbmFnZXI7XG59KCkpO1xuXG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0aW9uUG9zKHNlbGVjdGlvbikge1xuICAgIHZhciBmcm9tID0gc2VsZWN0aW9uLmZyb20sIHRvID0gc2VsZWN0aW9uLnRvO1xuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFtmcm9tICsgMSwgdG8gLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIFtmcm9tLCB0b107XG59XG5mdW5jdGlvbiBnZXRNZExpbmUocmVzb2x2ZWRQb3MpIHtcbiAgICByZXR1cm4gcmVzb2x2ZWRQb3MuaW5kZXgoMCkgKyAxO1xufVxuZnVuY3Rpb24gZ2V0V2lkZ2V0Tm9kZVBvcyhub2RlLCBjaFBvcywgZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdm9pZCAwKSB7IGRpcmVjdGlvbiA9IDE7IH1cbiAgICB2YXIgYWRkaXRpb25hbFBvcyA9IDA7XG4gICAgbm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgcG9zKSB7XG4gICAgICAgIC8vIGFkZCBvciBzdWJ0cmFjdCB3aWRnZXQgbm9kZSB0YWdcbiAgICAgICAgaWYgKGlzV2lkZ2V0Tm9kZShjaGlsZCkgJiYgcG9zICsgMiA8IGNoUG9zKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsUG9zICs9IDIgKiBkaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWRkaXRpb25hbFBvcztcbn1cbmZ1bmN0aW9uIGdldEVkaXRvclRvTWRQb3MoZG9jLCBmcm9tLCB0bykge1xuICAgIGlmICh0byA9PT0gdm9pZCAwKSB7IHRvID0gZnJvbTsgfVxuICAgIHZhciBjb2xsYXBzZWQgPSBmcm9tID09PSB0bztcbiAgICB2YXIgc3RhcnRSZXNvbHZlZFBvcyA9IGRvYy5yZXNvbHZlKGZyb20pO1xuICAgIHZhciBzdGFydExpbmUgPSBnZXRNZExpbmUoc3RhcnRSZXNvbHZlZFBvcyk7XG4gICAgdmFyIGVuZExpbmUgPSBzdGFydExpbmU7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gc3RhcnRSZXNvbHZlZFBvcy5zdGFydCgxKTtcbiAgICB2YXIgZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgLy8gcHJldmVudCB0aGUgZW5kIG9mZnNldCBmcm9tIHBvaW50aW5nIHRvIHRoZSByb290IGRvY3VtZW50IHBvc2l0aW9uXG4gICAgICAgIHZhciBlbmRSZXNvbHZlZFBvcyA9IGRvYy5yZXNvbHZlKHRvID09PSBkb2MuY29udGVudC5zaXplID8gdG8gLSAxIDogdG8pO1xuICAgICAgICBlbmRPZmZzZXQgPSBlbmRSZXNvbHZlZFBvcy5zdGFydCgxKTtcbiAgICAgICAgZW5kTGluZSA9IGdldE1kTGluZShlbmRSZXNvbHZlZFBvcyk7XG4gICAgICAgIC8vIFRvIHJlc29sdmUgdGhlIGVuZCBvZmZzZXQgZXhjbHVkaW5nIGRvY3VtZW50IHRhZyBzaXplXG4gICAgICAgIGlmIChlbmRSZXNvbHZlZFBvcy5wb3MgPT09IGRvYy5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIHRvID0gZG9jLmNvbnRlbnQuc2l6ZSAtIDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0YXJ0Q2ggPSBNYXRoLm1heChmcm9tIC0gc3RhcnRPZmZzZXQgKyAxLCAxKTtcbiAgICB2YXIgZW5kQ2ggPSBNYXRoLm1heCh0byAtIGVuZE9mZnNldCArIDEsIDEpO1xuICAgIHJldHVybiBbXG4gICAgICAgIFtzdGFydExpbmUsIHN0YXJ0Q2ggKyBnZXRXaWRnZXROb2RlUG9zKGRvYy5jaGlsZChzdGFydExpbmUgLSAxKSwgc3RhcnRDaCwgLTEpXSxcbiAgICAgICAgW2VuZExpbmUsIGVuZENoICsgZ2V0V2lkZ2V0Tm9kZVBvcyhkb2MuY2hpbGQoZW5kTGluZSAtIDEpLCBlbmRDaCwgLTEpXSxcbiAgICBdO1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRQb3NMaXN0UGVyTGluZShkb2MsIGVuZEluZGV4KSB7XG4gICAgdmFyIHN0YXJ0UG9zTGlzdFBlckxpbmUgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgaSA8IGVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gZG9jLmNoaWxkKGkpO1xuICAgICAgICBzdGFydFBvc0xpc3RQZXJMaW5lW2ldID0gcG9zO1xuICAgICAgICBwb3MgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiBzdGFydFBvc0xpc3RQZXJMaW5lO1xufVxuZnVuY3Rpb24gZ2V0TWRUb0VkaXRvclBvcyhkb2MsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICB2YXIgc3RhcnRQb3NMaXN0UGVyTGluZSA9IGdldFN0YXJ0UG9zTGlzdFBlckxpbmUoZG9jLCBlbmRQb3NbMF0pO1xuICAgIHZhciBzdGFydEluZGV4ID0gc3RhcnRQb3NbMF0gLSAxO1xuICAgIHZhciBlbmRJbmRleCA9IGVuZFBvc1swXSAtIDE7XG4gICAgdmFyIHN0YXJ0Tm9kZSA9IGRvYy5jaGlsZChzdGFydEluZGV4KTtcbiAgICB2YXIgZW5kTm9kZSA9IGRvYy5jaGlsZChlbmRJbmRleCk7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBsaW5lXG4gICAgdmFyIGZyb20gPSBzdGFydFBvc0xpc3RQZXJMaW5lW3N0YXJ0SW5kZXhdO1xuICAgIHZhciB0byA9IHN0YXJ0UG9zTGlzdFBlckxpbmVbZW5kSW5kZXhdO1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgY2hhcmFjdGVyIG9mZnNldCBvZiB0aGUgbGluZVxuICAgIGZyb20gKz0gc3RhcnRQb3NbMV0gKyBnZXRXaWRnZXROb2RlUG9zKHN0YXJ0Tm9kZSwgc3RhcnRQb3NbMV0gLSAxKTtcbiAgICB0byArPSBlbmRQb3NbMV0gKyBnZXRXaWRnZXROb2RlUG9zKGVuZE5vZGUsIGVuZFBvc1sxXSAtIDEpO1xuICAgIHJldHVybiBbZnJvbSwgTWF0aC5taW4odG8sIGRvYy5jb250ZW50LnNpemUpXTtcbn1cbmZ1bmN0aW9uIGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pIHtcbiAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgdmFyIGZyb20gPSBzZWxlY3Rpb24uZnJvbSwgdG8gPSBzZWxlY3Rpb24udG87XG4gICAgdmFyIGRvYyA9ICRmcm9tLmRvYztcbiAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uKSB7XG4gICAgICAgICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSArIDEpO1xuICAgICAgICAkdG8gPSBkb2MucmVzb2x2ZSh0byAtIDEpO1xuICAgIH1cbiAgICBpZiAoJGZyb20uZGVwdGggPT09IDApIHtcbiAgICAgICAgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tIC0gMSk7XG4gICAgICAgICR0byA9ICRmcm9tO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydEZyb21PZmZzZXQ6ICRmcm9tLnN0YXJ0KDEpLFxuICAgICAgICBlbmRGcm9tT2Zmc2V0OiAkdG8uc3RhcnQoMSksXG4gICAgICAgIHN0YXJ0VG9PZmZzZXQ6ICRmcm9tLmVuZCgxKSxcbiAgICAgICAgZW5kVG9PZmZzZXQ6ICR0by5lbmQoMSksXG4gICAgICAgIHN0YXJ0SW5kZXg6ICRmcm9tLmluZGV4KDApLFxuICAgICAgICBlbmRJbmRleDogJHRvLmluZGV4KDApLFxuICAgICAgICBmcm9tOiAkZnJvbS5wb3MsXG4gICAgICAgIHRvOiAkdG8ucG9zLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXROb2RlQ29udGVudE9mZnNldFJhbmdlKGRvYywgdGFyZ2V0SW5kZXgpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSAxO1xuICAgIHZhciBlbmRPZmZzZXQgPSAxO1xuICAgIGZvciAodmFyIGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgZG9jLmNoaWxkQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbm9kZVNpemUgPSBkb2MuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBjb250ZW50IHN0YXJ0LCBlbmQgb2Zmc2V0KG5vdCBub2RlIG9mZnNldClcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBvZmZzZXQgKyAxO1xuICAgICAgICBlbmRPZmZzZXQgPSBvZmZzZXQgKyBub2RlU2l6ZSAtIDE7XG4gICAgICAgIGlmIChpID09PSB0YXJnZXRJbmRleCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IG5vZGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsIGVuZE9mZnNldDogZW5kT2Zmc2V0IH07XG59XG5cbnZhciBIRUFESU5HID0gJ2hlYWRpbmcnO1xudmFyIEJMT0NLX1FVT1RFID0gJ2Jsb2NrUXVvdGUnO1xudmFyIExJU1RfSVRFTSA9ICdsaXN0SXRlbSc7XG52YXIgVEFCTEUgPSAndGFibGUnO1xudmFyIFRBQkxFX0NFTEwgPSAndGFibGVDZWxsJztcbnZhciBDT0RFX0JMT0NLID0gJ2NvZGVCbG9jayc7XG52YXIgVEhFTUFUSUNfQlJFQUsgPSAndGhlbWF0aWNCcmVhayc7XG52YXIgTElOSyA9ICdsaW5rJztcbnZhciBDT0RFID0gJ2NvZGUnO1xudmFyIE1FVEEgPSAnbWV0YSc7XG52YXIgREVMSU0gPSAnZGVsaW1pdGVyJztcbnZhciBUQVNLX0RFTElNID0gJ3Rhc2tEZWxpbWl0ZXInO1xudmFyIFRFWFQgPSAnbWFya2VkVGV4dCc7XG52YXIgSFRNTCA9ICdodG1sJztcbnZhciBDVVNUT01fQkxPQ0sgPSAnY3VzdG9tQmxvY2snO1xudmFyIGRlbGltU2l6ZSA9IHtcbiAgICBzdHJvbmc6IDIsXG4gICAgZW1waDogMSxcbiAgICBzdHJpa2U6IDIsXG59O1xuZnVuY3Rpb24gbWFya0luZm8oc3RhcnQsIGVuZCwgdHlwZSwgYXR0cnMpIHtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBzcGVjOiB7IHR5cGU6IHR5cGUsIGF0dHJzOiBhdHRycyB9IH07XG59XG5mdW5jdGlvbiBoZWFkaW5nJDEoX2EsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbGV2ZWwgPSBfYS5sZXZlbCwgaGVhZGluZ1R5cGUgPSBfYS5oZWFkaW5nVHlwZTtcbiAgICB2YXIgbWFya3MgPSBbbWFya0luZm8oc3RhcnQsIGVuZCwgSEVBRElORywgeyBsZXZlbDogbGV2ZWwgfSldO1xuICAgIGlmIChoZWFkaW5nVHlwZSA9PT0gJ2F0eCcpIHtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhzdGFydCwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBsZXZlbCksIERFTElNKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKHNldE9mZnNldFBvcyhlbmQsIDApLCBlbmQsIEhFQURJTkcsIHsgc2VUZXh0OiB0cnVlIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtzO1xufVxuZnVuY3Rpb24gZW1waGFzaXNBbmRTdHJpa2V0aHJvdWdoKF9hLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgIHZhciBzdGFydERlbGltUG9zID0gYWRkT2Zmc2V0UG9zKHN0YXJ0LCBkZWxpbVNpemVbdHlwZV0pO1xuICAgIHZhciBlbmREZWxpbVBvcyA9IGFkZE9mZnNldFBvcyhlbmQsIC1kZWxpbVNpemVbdHlwZV0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIG1hcmtJbmZvKHN0YXJ0RGVsaW1Qb3MsIGVuZERlbGltUG9zLCB0eXBlKSxcbiAgICAgICAgbWFya0luZm8oc3RhcnQsIHN0YXJ0RGVsaW1Qb3MsIERFTElNKSxcbiAgICAgICAgbWFya0luZm8oZW5kRGVsaW1Qb3MsIGVuZCwgREVMSU0pLFxuICAgIF07XG59XG5mdW5jdGlvbiBtYXJrTGluayhzdGFydCwgZW5kLCBsaW5rVGV4dFN0YXJ0LCBsYXN0Q2hpbGRDaCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG1hcmtJbmZvKHN0YXJ0LCBlbmQsIExJTkspLFxuICAgICAgICBtYXJrSW5mbyhzZXRPZmZzZXRQb3Moc3RhcnQsIGxpbmtUZXh0U3RhcnRbMV0gKyAxKSwgc2V0T2Zmc2V0UG9zKGVuZCwgbGFzdENoaWxkQ2gpLCBMSU5LLCB7XG4gICAgICAgICAgICBkZXNjOiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgbWFya0luZm8oc2V0T2Zmc2V0UG9zKGVuZCwgbGFzdENoaWxkQ2ggKyAyKSwgYWRkT2Zmc2V0UG9zKGVuZCwgLTEpLCBMSU5LLCB7IHVybDogdHJ1ZSB9KSxcbiAgICBdO1xufVxuZnVuY3Rpb24gaW1hZ2UkMShfYSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBsYXN0Q2hpbGQgPSBfYS5sYXN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RDaGlsZENoID0gbGFzdENoaWxkID8gZ2V0TWRFbmRDaChsYXN0Q2hpbGQpICsgMSA6IDM7IC8vIDM6IGxlbmd0aCBvZiAnIVtdJ1xuICAgIHZhciBsaW5rVGV4dEVuZCA9IGFkZE9mZnNldFBvcyhzdGFydCwgMSk7XG4gICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkkMShbbWFya0luZm8oc3RhcnQsIGxpbmtUZXh0RW5kLCBNRVRBKV0sIG1hcmtMaW5rKHN0YXJ0LCBlbmQsIGxpbmtUZXh0RW5kLCBsYXN0Q2hpbGRDaCkpO1xufVxuZnVuY3Rpb24gbGluayhfYSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBsYXN0Q2hpbGQgPSBfYS5sYXN0Q2hpbGQsIGV4dGVuZGVkQXV0b2xpbmsgPSBfYS5leHRlbmRlZEF1dG9saW5rO1xuICAgIHZhciBsYXN0Q2hpbGRDaCA9IGxhc3RDaGlsZCA/IGdldE1kRW5kQ2gobGFzdENoaWxkKSArIDEgOiAyOyAvLyAyOiBsZW5ndGggb2YgJ1tdJ1xuICAgIHJldHVybiBleHRlbmRlZEF1dG9saW5rXG4gICAgICAgID8gW21hcmtJbmZvKHN0YXJ0LCBlbmQsIExJTkssIHsgZGVzYzogdHJ1ZSB9KV1cbiAgICAgICAgOiBtYXJrTGluayhzdGFydCwgZW5kLCBzdGFydCwgbGFzdENoaWxkQ2gpO1xufVxuZnVuY3Rpb24gY29kZShfYSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciB0aWNrQ291bnQgPSBfYS50aWNrQ291bnQ7XG4gICAgdmFyIG9wZW5EZWxpbUVuZCA9IGFkZE9mZnNldFBvcyhzdGFydCwgdGlja0NvdW50KTtcbiAgICB2YXIgY2xvc2VEZWxpbVN0YXJ0ID0gYWRkT2Zmc2V0UG9zKGVuZCwgLXRpY2tDb3VudCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbWFya0luZm8oc3RhcnQsIGVuZCwgQ09ERSksXG4gICAgICAgIG1hcmtJbmZvKHN0YXJ0LCBvcGVuRGVsaW1FbmQsIENPREUsIHsgc3RhcnQ6IHRydWUgfSksXG4gICAgICAgIG1hcmtJbmZvKG9wZW5EZWxpbUVuZCwgY2xvc2VEZWxpbVN0YXJ0LCBDT0RFLCB7IG1hcmtlZDogdHJ1ZSB9KSxcbiAgICAgICAgbWFya0luZm8oY2xvc2VEZWxpbVN0YXJ0LCBlbmQsIENPREUsIHsgZW5kOiB0cnVlIH0pLFxuICAgIF07XG59XG5mdW5jdGlvbiBsaW5lQmFja2dyb3VuZChwYXJlbnQsIHN0YXJ0LCBlbmQsIHByZWZpeCkge1xuICAgIHZhciBkZWZhdWx0QmFja2dyb3VuZCA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgc3BlYzoge1xuICAgICAgICAgICAgYXR0cnM6IHsgY2xhc3NOYW1lOiBwcmVmaXggKyBcIi1saW5lLWJhY2tncm91bmRcIiwgY29kZVN0YXJ0OiBzdGFydFswXSwgY29kZUVuZDogZW5kWzBdIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVCYWNrZ3JvdW5kOiB0cnVlLFxuICAgIH07XG4gICAgcmV0dXJuIHBhcmVudC50eXBlICE9PSAnaXRlbScgJiYgcGFyZW50LnR5cGUgIT09ICdibG9ja1F1b3RlJ1xuICAgICAgICA/IFtcbiAgICAgICAgICAgIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgZGVmYXVsdEJhY2tncm91bmQpLCB7IGVuZDogc3RhcnQsIHNwZWM6IHsgYXR0cnM6IHsgY2xhc3NOYW1lOiBwcmVmaXggKyBcIi1saW5lLWJhY2tncm91bmQgc3RhcnRcIiB9IH0gfSksXG4gICAgICAgICAgICBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGRlZmF1bHRCYWNrZ3JvdW5kKSwgeyBzdGFydDogW01hdGgubWluKHN0YXJ0WzBdICsgMSwgZW5kWzBdKSwgc3RhcnRbMV1dIH0pLFxuICAgICAgICBdXG4gICAgICAgIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNvZGVCbG9jayQxKG5vZGUsIHN0YXJ0LCBlbmQsIGVuZExpbmUpIHtcbiAgICB2YXIgZmVuY2VPZmZzZXQgPSBub2RlLmZlbmNlT2Zmc2V0LCBmZW5jZUxlbmd0aCA9IG5vZGUuZmVuY2VMZW5ndGgsIGZlbmNlQ2hhciA9IG5vZGUuZmVuY2VDaGFyLCBpbmZvID0gbm9kZS5pbmZvLCBpbmZvUGFkZGluZyA9IG5vZGUuaW5mb1BhZGRpbmcsIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIHZhciBmZW5jZUVuZCA9IGZlbmNlT2Zmc2V0ICsgZmVuY2VMZW5ndGg7XG4gICAgdmFyIG1hcmtzID0gW21hcmtJbmZvKHNldE9mZnNldFBvcyhzdGFydCwgMSksIGVuZCwgQ09ERV9CTE9DSyldO1xuICAgIGlmIChmZW5jZUNoYXIpIHtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhzdGFydCwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBmZW5jZUVuZCksIERFTElNKSk7XG4gICAgfVxuICAgIGlmIChpbmZvKSB7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oYWRkT2Zmc2V0UG9zKHN0YXJ0LCBmZW5jZUxlbmd0aCksIGFkZE9mZnNldFBvcyhzdGFydCwgZmVuY2VMZW5ndGggKyBpbmZvUGFkZGluZyArIGluZm8ubGVuZ3RoKSwgTUVUQSkpO1xuICAgIH1cbiAgICB2YXIgY29kZUJsb2NrRW5kID0gXCJeKFxcXFxzezAsNH0pKFwiICsgZmVuY2VDaGFyICsgXCJ7XCIgKyBmZW5jZUxlbmd0aCArIFwiLH0pXCI7XG4gICAgdmFyIHJlQ29kZUJsb2NrRW5kID0gbmV3IFJlZ0V4cChjb2RlQmxvY2tFbmQpO1xuICAgIGlmIChyZUNvZGVCbG9ja0VuZC50ZXN0KGVuZExpbmUpKSB7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oc2V0T2Zmc2V0UG9zKGVuZCwgMSksIGVuZCwgREVMSU0pKTtcbiAgICB9XG4gICAgdmFyIGxpbmVCYWNrZ3JvdW5kTWFya0luZm8gPSBsaW5lQmFja2dyb3VuZChwYXJlbnQsIHN0YXJ0LCBlbmQsICdjb2RlLWJsb2NrJyk7XG4gICAgcmV0dXJuIGxpbmVCYWNrZ3JvdW5kTWFya0luZm8gPyBtYXJrcy5jb25jYXQobGluZUJhY2tncm91bmRNYXJrSW5mbykgOiBtYXJrcztcbn1cbmZ1bmN0aW9uIGN1c3RvbUJsb2NrJDIobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBfYSA9IG5vZGUsIG9mZnNldCA9IF9hLm9mZnNldCwgc3ludGF4TGVuZ3RoID0gX2Euc3ludGF4TGVuZ3RoLCBpbmZvID0gX2EuaW5mbywgcGFyZW50ID0gX2EucGFyZW50O1xuICAgIHZhciBzeW50YXhFbmQgPSBvZmZzZXQgKyBzeW50YXhMZW5ndGg7XG4gICAgdmFyIG1hcmtzID0gW21hcmtJbmZvKHNldE9mZnNldFBvcyhzdGFydCwgMSksIGVuZCwgQ1VTVE9NX0JMT0NLKV07XG4gICAgbWFya3MucHVzaChtYXJrSW5mbyhzdGFydCwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBzeW50YXhFbmQpLCBERUxJTSkpO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oYWRkT2Zmc2V0UG9zKHN0YXJ0LCBzeW50YXhFbmQpLCBhZGRPZmZzZXRQb3Moc3RhcnQsIHN5bnRheExlbmd0aCArIGluZm8ubGVuZ3RoKSwgTUVUQSkpO1xuICAgIH1cbiAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKHNldE9mZnNldFBvcyhlbmQsIDEpLCBlbmQsIERFTElNKSk7XG4gICAgdmFyIGxpbmVCYWNrZ3JvdW5kTWFya0luZm8gPSBsaW5lQmFja2dyb3VuZChwYXJlbnQsIHN0YXJ0LCBlbmQsICdjdXN0b20tYmxvY2snKTtcbiAgICByZXR1cm4gbGluZUJhY2tncm91bmRNYXJrSW5mbyA/IG1hcmtzLmNvbmNhdChsaW5lQmFja2dyb3VuZE1hcmtJbmZvKSA6IG1hcmtzO1xufVxuZnVuY3Rpb24gbWFya0xpc3RJdGVtQ2hpbGRyZW4obm9kZSwgbWFya1R5cGUpIHtcbiAgICB2YXIgbWFya3MgPSBbXTtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IHR5cGUgPT09ICdjb2RlQmxvY2snKSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKFtnZXRNZFN0YXJ0TGluZShub2RlKSwgZ2V0TWRTdGFydENoKG5vZGUpIC0gMV0sIFtnZXRNZEVuZExpbmUobm9kZSksIGdldE1kRW5kQ2gobm9kZSkgKyAxXSwgbWFya1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbWFya3M7XG59XG5mdW5jdGlvbiBtYXJrUGFyYWdyYXBoSW5CbG9ja1F1b3RlKG5vZGUpIHtcbiAgICB2YXIgbWFya3MgPSBbXTtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKFtnZXRNZFN0YXJ0TGluZShub2RlKSwgZ2V0TWRTdGFydENoKG5vZGUpXSwgW2dldE1kRW5kTGluZShub2RlKSwgZ2V0TWRFbmRDaChub2RlKSArIDFdLCBURVhUKSk7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBtYXJrcztcbn1cbmZ1bmN0aW9uIGJsb2NrUXVvdGUkMihub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIG1hcmtzID0gbm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2Jsb2NrUXVvdGUnID8gW21hcmtJbmZvKHN0YXJ0LCBlbmQsIEJMT0NLX1FVT1RFKV0gOiBbXTtcbiAgICBpZiAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZE1hcmtzID0gW107XG4gICAgICAgIGlmIChub2RlLmZpcnN0Q2hpbGQudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgIGNoaWxkTWFya3MgPSBtYXJrUGFyYWdyYXBoSW5CbG9ja1F1b3RlKG5vZGUuZmlyc3RDaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLmZpcnN0Q2hpbGQudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICBjaGlsZE1hcmtzID0gbWFya0xpc3RJdGVtQ2hpbGRyZW4obm9kZS5maXJzdENoaWxkLCBURVhUKTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrcyA9IF9fc3ByZWFkQXJyYXkkMShfX3NwcmVhZEFycmF5JDEoW10sIG1hcmtzKSwgY2hpbGRNYXJrcyk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrcztcbn1cbmZ1bmN0aW9uIGdldFNwZWNPZkxpc3RJdGVtU3R5bGUobm9kZSkge1xuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgd2hpbGUgKG5vZGUucGFyZW50LnBhcmVudCAmJiBub2RlLnBhcmVudC5wYXJlbnQudHlwZSA9PT0gJ2l0ZW0nKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudC5wYXJlbnQ7XG4gICAgICAgIGRlcHRoICs9IDE7XG4gICAgfVxuICAgIHZhciBhdHRycyA9IFt7IG9kZDogdHJ1ZSB9LCB7IGV2ZW46IHRydWUgfV1bZGVwdGggJSAyXTtcbiAgICByZXR1cm4gW0xJU1RfSVRFTSwgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhdHRycyksIHsgbGlzdFN0eWxlOiB0cnVlIH0pXTtcbn1cbmZ1bmN0aW9uIGl0ZW0kMShub2RlLCBzdGFydCkge1xuICAgIHZhciBfYSA9IG5vZGUubGlzdERhdGEsIHBhZGRpbmcgPSBfYS5wYWRkaW5nLCB0YXNrID0gX2EudGFzaztcbiAgICB2YXIgc3BlYyA9IGdldFNwZWNPZkxpc3RJdGVtU3R5bGUobm9kZSk7XG4gICAgdmFyIG1hcmtzID0gW21hcmtJbmZvLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheSQxKFtzdGFydCwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBwYWRkaW5nKV0sIHNwZWMpKV07XG4gICAgaWYgKHRhc2spIHtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhhZGRPZmZzZXRQb3Moc3RhcnQsIHBhZGRpbmcpLCBhZGRPZmZzZXRQb3Moc3RhcnQsIHBhZGRpbmcgKyAzKSwgVEFTS19ERUxJTSkpO1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKGFkZE9mZnNldFBvcyhzdGFydCwgcGFkZGluZyArIDEpLCBhZGRPZmZzZXRQb3Moc3RhcnQsIHBhZGRpbmcgKyAyKSwgTUVUQSkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3MuY29uY2F0KG1hcmtMaXN0SXRlbUNoaWxkcmVuKG5vZGUuZmlyc3RDaGlsZCwgVEVYVCkpO1xufVxudmFyIG1hcmtOb2RlRnVuY01hcCA9IHtcbiAgICBoZWFkaW5nOiBoZWFkaW5nJDEsXG4gICAgc3Ryb25nOiBlbXBoYXNpc0FuZFN0cmlrZXRocm91Z2gsXG4gICAgZW1waDogZW1waGFzaXNBbmRTdHJpa2V0aHJvdWdoLFxuICAgIHN0cmlrZTogZW1waGFzaXNBbmRTdHJpa2V0aHJvdWdoLFxuICAgIGxpbms6IGxpbmssXG4gICAgaW1hZ2U6IGltYWdlJDEsXG4gICAgY29kZTogY29kZSxcbiAgICBjb2RlQmxvY2s6IGNvZGVCbG9jayQxLFxuICAgIGJsb2NrUXVvdGU6IGJsb2NrUXVvdGUkMixcbiAgICBpdGVtOiBpdGVtJDEsXG4gICAgY3VzdG9tQmxvY2s6IGN1c3RvbUJsb2NrJDIsXG59O1xudmFyIHNpbXBsZU1hcmtDbGFzc05hbWVNYXAgPSB7XG4gICAgdGhlbWF0aWNCcmVhazogVEhFTUFUSUNfQlJFQUssXG4gICAgdGFibGU6IFRBQkxFLFxuICAgIHRhYmxlQ2VsbDogVEFCTEVfQ0VMTCxcbiAgICBodG1sSW5saW5lOiBIVE1MLFxufTtcbmZ1bmN0aW9uIGdldE1hcmtJbmZvKG5vZGUsIHN0YXJ0LCBlbmQsIGVuZExpbmUpIHtcbiAgICB2YXIgdHlwZSA9IG5vZGUudHlwZTtcbiAgICBpZiAoaXNGdW5jdGlvbl8xKG1hcmtOb2RlRnVuY01hcFt0eXBlXSkpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gbWFya05vZGVGdW5jTWFwW3R5cGVdKG5vZGUsIHN0YXJ0LCBlbmQsIGVuZExpbmUpO1xuICAgIH1cbiAgICBpZiAoc2ltcGxlTWFya0NsYXNzTmFtZU1hcFt0eXBlXSkge1xuICAgICAgICByZXR1cm4gW21hcmtJbmZvKHN0YXJ0LCBlbmQsIHNpbXBsZU1hcmtDbGFzc05hbWVNYXBbdHlwZV0pXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbnZhciByZW1vdmluZ0JhY2tncm91bmRJbmRleE1hcCA9IHt9O1xuZnVuY3Rpb24gc3ludGF4SGlnaGxpZ2h0KF9hKSB7XG4gICAgdmFyIHNjaGVtYSA9IF9hLnNjaGVtYSwgdG9hc3RNYXJrID0gX2EudG9hc3RNYXJrO1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246IGZ1bmN0aW9uICh0cmFuc2FjdGlvbnMsIF8sIG5ld1N0YXRlKSB7XG4gICAgICAgICAgICB2YXIgdHIgPSB0cmFuc2FjdGlvbnNbMF07XG4gICAgICAgICAgICB2YXIgbmV3VHIgPSBuZXdTdGF0ZS50cjtcbiAgICAgICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtJbmZvXzEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdFJlc3VsdCA9IHRyLmdldE1ldGEoJ2VkaXRSZXN1bHQnKTtcbiAgICAgICAgICAgICAgICBlZGl0UmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSByZXN1bHQubm9kZXMsIHJlbW92ZWROb2RlUmFuZ2UgPSByZXN1bHQucmVtb3ZlZE5vZGVSYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya0luZm9fMSA9IG1hcmtJbmZvXzEuY29uY2F0KGdldE1hcmtGb3JSZW1vdmluZyhuZXdUciwgbm9kZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbm9kZXNfMSA9IG5vZGVzOyBfaSA8IG5vZGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gbm9kZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhbGtlciA9IHBhcmVudF8xLndhbGtlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0gd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZXZlbnRfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGV2ZW50XzEubm9kZSwgZW50ZXJpbmcgPSBldmVudF8xLmVudGVyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtJbmZvXzEgPSBtYXJrSW5mb18xLmNvbmNhdChnZXRNYXJrRm9yQWRkaW5nKG5vZGUsIHRvYXN0TWFyaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzEgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZW1vdmVkTm9kZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4SW5kZXggPSBuZXdUci5kb2MuY2hpbGRDb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSByZW1vdmVkTm9kZVJhbmdlLmxpbmUsIHN0YXJ0TGluZSA9IF9hWzBdLCBlbmRMaW5lID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0TGluZSwgbWF4SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gTWF0aC5taW4oZW5kTGluZSwgbWF4SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FjaGUgdGhlIGluZGV4IHRvIHJlbW92ZSBjb2RlIGJsb2NrLCBjdXN0b20gYmxvY2sgYmFja2dyb3VuZCB3aGVuIHRoZXJlIGFyZSBubyBhZGRpbmcgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmluZ0JhY2tncm91bmRJbmRleE1hcFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhcHBlbmRNYXJrVHIobmV3VHIsIHNjaGVtYSwgbWFya0luZm9fMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3VHIuc2V0TWV0YSgnd2lkZ2V0JywgdHIuZ2V0TWV0YSgnd2lkZ2V0JykpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNEaWZmZXJlbnRCbG9jayhkb2MsIGluZGV4LCBhdHRycykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRycykuc29tZShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gYXR0cnNbbmFtZV0gIT09IGRvYy5jaGlsZChpbmRleCkuYXR0cnNbbmFtZV07IH0pO1xufVxuZnVuY3Rpb24gYWRkTGluZUJhY2tncm91bmQodHIsIGRvYywgcGFyYWdyYXBoLCBibG9ja1Bvc0luZm8sIGF0dHJzKSB7XG4gICAgaWYgKGF0dHJzID09PSB2b2lkIDApIHsgYXR0cnMgPSB7fTsgfVxuICAgIHZhciBzdGFydEluZGV4ID0gYmxvY2tQb3NJbmZvLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gYmxvY2tQb3NJbmZvLmVuZEluZGV4LCBmcm9tID0gYmxvY2tQb3NJbmZvLmZyb20sIHRvID0gYmxvY2tQb3NJbmZvLnRvO1xuICAgIHZhciBzaG91bGRDaGFuZ2VCbG9ja1R5cGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8PSBlbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgIC8vIHByZXZlbnQgdG8gcmVtb3ZlIGJhY2tncm91bmQgb2YgdGhlIG5vZGUgdGhhdCBuZWVkIHRvIGhhdmUgYmFja2dyb3VuZFxuICAgICAgICBkZWxldGUgcmVtb3ZpbmdCYWNrZ3JvdW5kSW5kZXhNYXBbaV07XG4gICAgICAgIHNob3VsZENoYW5nZUJsb2NrVHlwZSA9IGlzRGlmZmVyZW50QmxvY2soZG9jLCBpLCBhdHRycyk7XG4gICAgfVxuICAgIGlmIChzaG91bGRDaGFuZ2VCbG9ja1R5cGUpIHtcbiAgICAgICAgdHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBwYXJhZ3JhcGgsIGF0dHJzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmRNYXJrVHIodHIsIHNjaGVtYSwgbWFya3MpIHtcbiAgICB2YXIgZG9jID0gdHIuZG9jO1xuICAgIHZhciBwYXJhZ3JhcGggPSBzY2hlbWEubm9kZXMucGFyYWdyYXBoO1xuICAgIC8vIGdldCBzdGFydCBwb3NpdGlvbiBwZXIgbGluZSBmb3IgbGF6eSBjYWxjdWxhdGlvblxuICAgIHZhciBzdGFydFBvc0xpc3RQZXJMaW5lID0gZ2V0U3RhcnRQb3NMaXN0UGVyTGluZShkb2MsIGRvYy5jaGlsZENvdW50KTtcbiAgICBtYXJrcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBfYS5zdGFydCwgZW5kID0gX2EuZW5kLCBzcGVjID0gX2Euc3BlYywgbGluZUJhY2tncm91bmQgPSBfYS5saW5lQmFja2dyb3VuZDtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydFswXSwgZG9jLmNoaWxkQ291bnQpIC0gMTtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gTWF0aC5taW4oZW5kWzBdLCBkb2MuY2hpbGRDb3VudCkgLSAxO1xuICAgICAgICB2YXIgc3RhcnROb2RlID0gZG9jLmNoaWxkKHN0YXJ0SW5kZXgpO1xuICAgICAgICB2YXIgZW5kTm9kZSA9IGRvYy5jaGlsZChlbmRJbmRleCk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgbGluZVxuICAgICAgICB2YXIgZnJvbSA9IHN0YXJ0UG9zTGlzdFBlckxpbmVbc3RhcnRJbmRleF07XG4gICAgICAgIHZhciB0byA9IHN0YXJ0UG9zTGlzdFBlckxpbmVbZW5kSW5kZXhdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNoYXJhY3RlciBvZmZzZXQgb2YgdGhlIGxpbmVcbiAgICAgICAgZnJvbSArPSBzdGFydFsxXSArIGdldFdpZGdldE5vZGVQb3Moc3RhcnROb2RlLCBzdGFydFsxXSAtIDEpO1xuICAgICAgICB0byArPSBlbmRbMV0gKyBnZXRXaWRnZXROb2RlUG9zKGVuZE5vZGUsIGVuZFsxXSAtIDEpO1xuICAgICAgICBpZiAoc3BlYykge1xuICAgICAgICAgICAgaWYgKGxpbmVCYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc0luZm8gPSB7IGZyb206IGZyb20sIHRvOiB0bywgc3RhcnRJbmRleDogc3RhcnRJbmRleCwgZW5kSW5kZXg6IGVuZEluZGV4IH07XG4gICAgICAgICAgICAgICAgYWRkTGluZUJhY2tncm91bmQodHIsIGRvYywgcGFyYWdyYXBoLCBwb3NJbmZvLCBzcGVjLmF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoZnJvbSwgdG8sIHNjaGVtYS5tYXJrKHNwZWMudHlwZSwgc3BlYy5hdHRycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZW1vdmVCbG9ja0JhY2tncm91bmQodHIsIHN0YXJ0UG9zTGlzdFBlckxpbmUsIHBhcmFncmFwaCk7XG59XG5mdW5jdGlvbiByZW1vdmVCbG9ja0JhY2tncm91bmQodHIsIHN0YXJ0UG9zTGlzdFBlckxpbmUsIHBhcmFncmFwaCkge1xuICAgIE9iamVjdC5rZXlzKHJlbW92aW5nQmFja2dyb3VuZEluZGV4TWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IE51bWJlcihpbmRleCk7XG4gICAgICAgIC8vIGdldCB0aGUgZW5kIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgd2l0aCB0aGUgbmV4dCBub2RlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAgICB2YXIgZW5kSW5kZXggPSBNYXRoLm1pbihOdW1iZXIoaW5kZXgpICsgMSwgdHIuZG9jLmNoaWxkQ291bnQgLSAxKTtcbiAgICAgICAgdmFyIGZyb20gPSBzdGFydFBvc0xpc3RQZXJMaW5lW3N0YXJ0SW5kZXhdO1xuICAgICAgICAvLyBzdWJ0cmFjdCAnMScgZm9yIGdldHRpbmcgZW5kIHBvc2l0aW9uIG9mIHRoZSBsaW5lXG4gICAgICAgIHZhciB0byA9IHN0YXJ0UG9zTGlzdFBlckxpbmVbZW5kSW5kZXhdIC0gMTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IGVuZEluZGV4KSB7XG4gICAgICAgICAgICB0byArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHRyLnNldEJsb2NrVHlwZShmcm9tLCB0bywgcGFyYWdyYXBoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNhY2hlSW5kZXhUb1JlbW92ZUJhY2tncm91bmQoZG9jLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHNraXBMaW5lcyA9IFtdO1xuICAgIHJlbW92aW5nQmFja2dyb3VuZEluZGV4TWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0WzBdIC0gMTsgaSA8IGVuZFswXTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9jLmNoaWxkKGkpO1xuICAgICAgICB2YXIgY29kZUVuZCA9IG5vZGUuYXR0cnMuY29kZUVuZDtcbiAgICAgICAgdmFyIGNvZGVTdGFydCA9IG5vZGUuYXR0cnMuY29kZVN0YXJ0O1xuICAgICAgICBpZiAoY29kZVN0YXJ0ICYmIGNvZGVFbmQgJiYgIWluY2x1ZGVzKHNraXBMaW5lcywgY29kZVN0YXJ0KSkge1xuICAgICAgICAgICAgc2tpcExpbmVzLnB1c2goY29kZVN0YXJ0KTtcbiAgICAgICAgICAgIGNvZGVFbmQgPSBNYXRoLm1pbihjb2RlRW5kLCBkb2MuY2hpbGRDb3VudCk7XG4gICAgICAgICAgICAvLyBzaG91bGQgc3VidHJhY3QgJzEnIHRvIG1hcmtkb3duIGxpbmUgcG9zaXRpb25cbiAgICAgICAgICAgIC8vIGJlY2F1c2UgbWFya2Rvd24gcGFyc2VyIGhhcyAnMScobm90IHplcm8pIGFzIHRoZSBzdGFydCBudW1iZXJcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gY29kZVN0YXJ0IC0gMTtcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IGVuZFswXTtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPCBlbmRJbmRleDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgICAgIHJlbW92aW5nQmFja2dyb3VuZEluZGV4TWFwW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNYXJrRm9yUmVtb3ZpbmcoX2EsIG5vZGVzKSB7XG4gICAgdmFyIGRvYyA9IF9hLmRvYztcbiAgICB2YXIgc3RhcnQgPSBub2Rlc1swXS5zb3VyY2Vwb3NbMF07XG4gICAgdmFyIF9iID0gbGFzdCQxKG5vZGVzKS5zb3VyY2Vwb3MsIGVuZCA9IF9iWzFdO1xuICAgIHZhciBzdGFydFBvcyA9IFtzdGFydFswXSwgc3RhcnRbMV1dO1xuICAgIHZhciBlbmRQb3MgPSBbZW5kWzBdLCBlbmRbMV0gKyAxXTtcbiAgICB2YXIgbWFya3MgPSBbXTtcbiAgICBjYWNoZUluZGV4VG9SZW1vdmVCYWNrZ3JvdW5kKGRvYywgc3RhcnQsIGVuZCk7XG4gICAgbWFya3MucHVzaCh7IHN0YXJ0OiBzdGFydFBvcywgZW5kOiBlbmRQb3MgfSk7XG4gICAgcmV0dXJuIG1hcmtzO1xufVxuZnVuY3Rpb24gZ2V0TWFya0ZvckFkZGluZyhub2RlLCB0b2FzdE1hcmspIHtcbiAgICB2YXIgbGluZVRleHRzID0gdG9hc3RNYXJrLmdldExpbmVUZXh0cygpO1xuICAgIHZhciBzdGFydFBvcyA9IFtnZXRNZFN0YXJ0TGluZShub2RlKSwgZ2V0TWRTdGFydENoKG5vZGUpXTtcbiAgICB2YXIgZW5kUG9zID0gW2dldE1kRW5kTGluZShub2RlKSwgZ2V0TWRFbmRDaChub2RlKSArIDFdO1xuICAgIHZhciBtYXJrSW5mbyA9IGdldE1hcmtJbmZvKG5vZGUsIHN0YXJ0UG9zLCBlbmRQb3MsIGxpbmVUZXh0c1tlbmRQb3NbMF0gLSAxXSk7XG4gICAgcmV0dXJuIG1hcmtJbmZvICE9PSBudWxsICYmIG1hcmtJbmZvICE9PSB2b2lkIDAgPyBtYXJrSW5mbyA6IFtdO1xufVxuXG52YXIgZGVmYXVsdFRvb2xiYXJTdGF0ZUtleXMgPSBbXG4gICAgJ3Rhc2tMaXN0JyxcbiAgICAnb3JkZXJlZExpc3QnLFxuICAgICdidWxsZXRMaXN0JyxcbiAgICAndGFibGUnLFxuICAgICdzdHJvbmcnLFxuICAgICdlbXBoJyxcbiAgICAnc3RyaWtlJyxcbiAgICAnaGVhZGluZycsXG4gICAgJ3RoZW1hdGljQnJlYWsnLFxuICAgICdibG9ja1F1b3RlJyxcbiAgICAnY29kZScsXG4gICAgJ2NvZGVCbG9jaycsXG4gICAgJ2luZGVudCcsXG4gICAgJ291dGRlbnQnLFxuXTtcbmZ1bmN0aW9uIGdldFRvb2xiYXJTdGF0ZVR5cGUkMShtZE5vZGUpIHtcbiAgICB2YXIgdHlwZSA9IG1kTm9kZS50eXBlO1xuICAgIGlmIChpc0xpc3ROb2RlJDEobWROb2RlKSkge1xuICAgICAgICBpZiAobWROb2RlLmxpc3REYXRhLnRhc2spIHtcbiAgICAgICAgICAgIHJldHVybiAndGFza0xpc3QnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZE5vZGUubGlzdERhdGEudHlwZSA9PT0gJ29yZGVyZWQnID8gJ29yZGVyZWRMaXN0JyA6ICdidWxsZXRMaXN0JztcbiAgICB9XG4gICAgaWYgKHR5cGUuaW5kZXhPZigndGFibGUnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuICd0YWJsZSc7XG4gICAgfVxuICAgIGlmICghaW5jbHVkZXMoZGVmYXVsdFRvb2xiYXJTdGF0ZUtleXMsIHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbmZ1bmN0aW9uIGdldFRvb2xiYXJTdGF0ZSQxKHRhcmdldE5vZGUpIHtcbiAgICB2YXIgdG9vbGJhclN0YXRlID0ge1xuICAgICAgICBpbmRlbnQ6IHsgYWN0aXZlOiBmYWxzZSwgZGlzYWJsZWQ6IHRydWUgfSxcbiAgICAgICAgb3V0ZGVudDogeyBhY3RpdmU6IGZhbHNlLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgIH07XG4gICAgdmFyIGxpc3RFbmFibGVkID0gdHJ1ZTtcbiAgICB0cmF2ZXJzZVBhcmVudE5vZGVzKHRhcmdldE5vZGUsIGZ1bmN0aW9uIChtZE5vZGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUb29sYmFyU3RhdGVUeXBlJDEobWROb2RlKTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdidWxsZXRMaXN0JyB8fCB0eXBlID09PSAnb3JkZXJlZExpc3QnKSB7XG4gICAgICAgICAgICAvLyB0byBhcHBseSB0aGUgbmVhcmxpc3QgbGlzdCBzdGF0ZSBpbiB0aGUgbmVzdGVkIGxpc3RcbiAgICAgICAgICAgIGlmIChsaXN0RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRvb2xiYXJTdGF0ZVt0eXBlXSA9IHsgYWN0aXZlOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgdG9vbGJhclN0YXRlLmluZGVudC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRvb2xiYXJTdGF0ZS5vdXRkZW50LmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGlzdEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvb2xiYXJTdGF0ZVt0eXBlXSA9IHsgYWN0aXZlOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdG9vbGJhclN0YXRlO1xufVxuZnVuY3Rpb24gcHJldmlld0hpZ2hsaWdodChfYSkge1xuICAgIHZhciB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcmssIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlcjtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodmlldywgcHJldlN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSBzdGF0ZS5kb2MsIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZTdGF0ZSAmJiBwcmV2U3RhdGUuZG9jLmVxKGRvYykgJiYgcHJldlN0YXRlLnNlbGVjdGlvbi5lcShzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyb20gPSBzZWxlY3Rpb24uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q2hPZmZzZXQgPSBzdGF0ZS5kb2MucmVzb2x2ZShmcm9tKS5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHN0YXRlLmRvYy5jb250ZW50LmZpbmRJbmRleChmcm9tKS5pbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IGZyb20gLSBzdGFydENoT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gc3RhcnRDaE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yUG9zID0gW2xpbmUsIGNoXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kTm9kZUF0UG9zaXRpb24oY3Vyc29yUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvb2xiYXJTdGF0ZSA9IGdldFRvb2xiYXJTdGF0ZSQxKG1kTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2VUb29sYmFyU3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JQb3M6IGN1cnNvclBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1kTm9kZTogbWROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbGJhclN0YXRlOiB0b29sYmFyU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnc2V0Rm9jdXNlZE5vZGUnLCBtZE5vZGUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG52YXIgRG9jJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoRG9jLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvYygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ2Jsb2NrKycsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIERvYztcbn0oTm9kZSQyKSk7XG5cbnZhciBNYXJrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcmsoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXJrLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21hcmsnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWFyay5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gTWFyaztcbn0oKSk7XG5cbmZ1bmN0aW9uIGdldFRleHRCeU1kTGluZShkb2MsIG1kTGluZSkge1xuICAgIHJldHVybiBnZXRUZXh0Q29udGVudChkb2MsIG1kTGluZSAtIDEpO1xufVxuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnQoZG9jLCBpbmRleCkge1xuICAgIHJldHVybiBkb2MuY2hpbGQoaW5kZXgpLnRleHRDb250ZW50O1xufVxuXG52YXIgcmVCbG9ja1F1b3RlID0gL15cXHMqPiA/LztcbnZhciBCbG9ja1F1b3RlJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQmxvY2tRdW90ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja1F1b3RlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9ja1F1b3RlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Jsb2NrUXVvdGUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2NrUXVvdGUucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdibG9jay1xdW90ZScpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQmxvY2tRdW90ZS5wcm90b3R5cGUuY3JlYXRlQmxvY2tRdW90ZVRleHQgPSBmdW5jdGlvbiAodGV4dCwgaXNCbG9ja1F1b3RlKSB7XG4gICAgICAgIHJldHVybiBpc0Jsb2NrUXVvdGUgPyB0ZXh0LnJlcGxhY2UocmVCbG9ja1F1b3RlLCAnJykudHJpbSgpIDogXCI+IFwiICsgdGV4dC50cmltKCk7XG4gICAgfTtcbiAgICBCbG9ja1F1b3RlLnByb3RvdHlwZS5leHRlbmRCbG9ja1F1b3RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgZG9jID0gX2EuZG9jLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgZW5kRnJvbU9mZnNldCA9IF9iLmVuZEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2IuZW5kVG9PZmZzZXQsIGVuZEluZGV4ID0gX2IuZW5kSW5kZXgsIHRvID0gX2IudG87XG4gICAgICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChkb2MsIGVuZEluZGV4KTtcbiAgICAgICAgICAgIHZhciBpc0Jsb2NrUXVvdGUgPSByZUJsb2NrUXVvdGUudGVzdCh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICBpZiAoaXNCbG9ja1F1b3RlICYmIHRvID4gZW5kRnJvbU9mZnNldCAmJiBzZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNFbXB0eSA9ICF0ZXh0Q29udGVudC5yZXBsYWNlKHJlQmxvY2tRdW90ZSwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGVSYW5nZShlbmRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCkuc3BsaXQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGljZWRUZXh0ID0gdGV4dENvbnRlbnQuc2xpY2UodG8gLSBlbmRGcm9tT2Zmc2V0KS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIF90aGlzLmNyZWF0ZUJsb2NrUXVvdGVUZXh0KHNsaWNlZFRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRBbmRFeHRlbmRCbG9jayh0ciwgZW5kVG9PZmZzZXQsIHNsaWNlZFRleHQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBCbG9ja1F1b3RlLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIGRvYyA9IHN0YXRlLmRvYztcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQsIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9hLmVuZEluZGV4O1xuICAgICAgICAgICAgdmFyIGlzQmxvY2tRdW90ZSA9IHJlQmxvY2tRdW90ZS50ZXN0KGdldFRleHRDb250ZW50KGRvYywgc3RhcnRJbmRleCkpO1xuICAgICAgICAgICAgdmFyIHRyID0gcmVwbGFjZVRleHROb2RlKHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgICAgICBlbmRJbmRleDogZW5kSW5kZXgsXG4gICAgICAgICAgICAgICAgZnJvbTogc3RhcnRGcm9tT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGNyZWF0ZVRleHQ6IGZ1bmN0aW9uICh0ZXh0Q29udGVudCkgeyByZXR1cm4gX3RoaXMuY3JlYXRlQmxvY2tRdW90ZVRleHQodGV4dENvbnRlbnQsIGlzQmxvY2tRdW90ZSk7IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIEJsb2NrUXVvdGUucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBibG9ja1F1b3RlQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2FsdC1xJzogYmxvY2tRdW90ZUNvbW1hbmQsXG4gICAgICAgICAgICAnYWx0LVEnOiBibG9ja1F1b3RlQ29tbWFuZCxcbiAgICAgICAgICAgIEVudGVyOiB0aGlzLmV4dGVuZEJsb2NrUXVvdGUoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja1F1b3RlO1xufShNYXJrKSk7XG5cbnZhciByZUxpc3QgPSAvKF5cXHMqKShbLSorXSB8W1xcZF0rXFwuICkvO1xudmFyIHJlT3JkZXJlZExpc3QgPSAvKF5cXHMqKShbXFxkXSkrXFwuKCBcXFtbIHhYXV0pPyAvO1xudmFyIHJlT3JkZXJlZExpc3RHcm91cCA9IC9eKFxccyopKChcXGQrKShbLildXFxzKD86XFxbKD86eHxcXHMpXFxdXFxzKT8pKSguKikvO1xudmFyIHJlQ2FuQmVUYXNrTGlzdCA9IC8oXlxccyopKFstKitdfFtcXGRdK1xcLikoIFxcW1sgeFhdXSk/IC87XG52YXIgcmVCdWxsZXRMaXN0R3JvdXAgPSAvXihcXHMqKShbLSorXSsoXFxzKD86XFxbKD86eHxcXHMpXFxdXFxzKT8pKSguKikvO1xudmFyIHJlVGFza0xpc3QgPSAvKF5cXHMqKShbLSorXSB8W1xcZF0rXFwuICkoXFxbWyB4WF1dICkvO1xudmFyIHJlQnVsbGV0VGFza0xpc3QgPSAvKF5cXHMqKShbLSorXSkoIFxcW1sgeFhdXSkgLztcbmZ1bmN0aW9uIGdldExpc3RUeXBlKHRleHQpIHtcbiAgICByZXR1cm4gcmVPcmRlcmVkTGlzdC50ZXN0KHRleHQpID8gJ29yZGVyZWQnIDogJ2J1bGxldCc7XG59XG5mdW5jdGlvbiBnZXRMaXN0RGVwdGgobWROb2RlKSB7XG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICB3aGlsZSAobWROb2RlICYmIG1kTm9kZS50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgIGlmIChtZE5vZGUudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICBkZXB0aCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBkZXB0aDtcbn1cbmZ1bmN0aW9uIGZpbmRTYW1lRGVwdGhMaXN0KHRvYXN0TWFyaywgY3VycmVudExpbmUsIGRlcHRoLCBiYWNrd2FyZCkge1xuICAgIHZhciBsaW5lVGV4dHMgPSB0b2FzdE1hcmsuZ2V0TGluZVRleHRzKCk7XG4gICAgdmFyIGxpbmVMZW4gPSBsaW5lVGV4dHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbGluZSA9IGN1cnJlbnRMaW5lO1xuICAgIHdoaWxlIChiYWNrd2FyZCA/IGxpbmUgPCBsaW5lTGVuIDogbGluZSA+IDEpIHtcbiAgICAgICAgbGluZSA9IGJhY2t3YXJkID8gbGluZSArIDEgOiBsaW5lIC0gMTtcbiAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKGxpbmUpO1xuICAgICAgICB2YXIgY3VycmVudExpc3REZXB0aCA9IGdldExpc3REZXB0aChtZE5vZGUpO1xuICAgICAgICBpZiAoY3VycmVudExpc3REZXB0aCA9PT0gZGVwdGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgbGluZTogbGluZSwgZGVwdGg6IGRlcHRoLCBtZE5vZGU6IG1kTm9kZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50TGlzdERlcHRoIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRTYW1lRGVwdGhJdGVtcyhfYSkge1xuICAgIHZhciB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcmssIG1kTm9kZSA9IF9hLm1kTm9kZSwgbGluZSA9IF9hLmxpbmU7XG4gICAgdmFyIGRlcHRoID0gZ2V0TGlzdERlcHRoKG1kTm9kZSk7XG4gICAgdmFyIGZvcndhcmRMaXN0ID0gZmluZFNhbWVEZXB0aExpc3QodG9hc3RNYXJrLCBsaW5lLCBkZXB0aCwgZmFsc2UpLnJldmVyc2UoKTtcbiAgICB2YXIgYmFja3dhcmRMaXN0ID0gZmluZFNhbWVEZXB0aExpc3QodG9hc3RNYXJrLCBsaW5lLCBkZXB0aCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZvcndhcmRMaXN0LmNvbmNhdChbeyBsaW5lOiBsaW5lLCBkZXB0aDogZGVwdGgsIG1kTm9kZTogbWROb2RlIH1dKS5jb25jYXQoYmFja3dhcmRMaXN0KTtcbn1cbmZ1bmN0aW9uIHRleHRUb0J1bGxldCh0ZXh0KSB7XG4gICAgaWYgKCFyZUxpc3QudGVzdCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gXCIqIFwiICsgdGV4dDtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBnZXRMaXN0VHlwZSh0ZXh0KTtcbiAgICBpZiAodHlwZSA9PT0gJ2J1bGxldCcgJiYgcmVDYW5CZVRhc2tMaXN0LnRlc3QodGV4dCkpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZUJ1bGxldFRhc2tMaXN0LCAnJDEkMiAnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ29yZGVyZWQnKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVPcmRlcmVkTGlzdCwgJyQxKiAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiB0ZXh0VG9PcmRlcmVkKHRleHQsIG9yZGluYWxOdW0pIHtcbiAgICBpZiAoIXJlTGlzdC50ZXN0KHRleHQpKSB7XG4gICAgICAgIHJldHVybiBvcmRpbmFsTnVtICsgXCIuIFwiICsgdGV4dDtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBnZXRMaXN0VHlwZSh0ZXh0KTtcbiAgICBpZiAodHlwZSA9PT0gJ2J1bGxldCcgfHwgKHR5cGUgPT09ICdvcmRlcmVkJyAmJiByZUNhbkJlVGFza0xpc3QudGVzdCh0ZXh0KSkpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZUNhbkJlVGFza0xpc3QsIFwiJDFcIiArIG9yZGluYWxOdW0gKyBcIi4gXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnb3JkZXJlZCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBzdGFydCA9IHJlT3JkZXJlZExpc3RHcm91cC5leGVjKHRleHQpWzNdO1xuICAgICAgICBpZiAoTnVtYmVyKHN0YXJ0KSAhPT0gb3JkaW5hbE51bSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZU9yZGVyZWRMaXN0LCBcIiQxXCIgKyBvcmRpbmFsTnVtICsgXCIuIFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIGdldENoYW5nZWRJbmZvKGRvYywgc2FtZURlcHRoSXRlbXMsIHR5cGUsIHN0YXJ0KSB7XG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XG4gICAgdmFyIGZpcnN0SW5kZXggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgIHZhciBjaGFuZ2VkUmVzdWx0cyA9IHNhbWVEZXB0aEl0ZW1zLm1hcChmdW5jdGlvbiAoX2EsIGluZGV4KSB7XG4gICAgICAgIHZhciBsaW5lID0gX2EubGluZTtcbiAgICAgICAgZmlyc3RJbmRleCA9IE1hdGgubWluKGxpbmUgLSAxLCBmaXJzdEluZGV4KTtcbiAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgobGluZSAtIDEsIGxhc3RJbmRleCk7XG4gICAgICAgIHZhciB0ZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIHRleHQgPSB0eXBlID09PSAnYnVsbGV0JyA/IHRleHRUb0J1bGxldCh0ZXh0KSA6IHRleHRUb09yZGVyZWQodGV4dCwgaW5kZXggKyAxICsgc3RhcnQpO1xuICAgICAgICByZXR1cm4geyB0ZXh0OiB0ZXh0LCBsaW5lOiBsaW5lIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgY2hhbmdlZFJlc3VsdHM6IGNoYW5nZWRSZXN1bHRzLCBmaXJzdEluZGV4OiBmaXJzdEluZGV4LCBsYXN0SW5kZXg6IGxhc3RJbmRleCB9O1xufVxuZnVuY3Rpb24gZ2V0QnVsbGV0T3JPcmRlcmVkKHR5cGUsIGNvbnRleHQpIHtcbiAgICB2YXIgc2FtZURlcHRoTGlzdEluZm8gPSBnZXRTYW1lRGVwdGhJdGVtcyhjb250ZXh0KTtcbiAgICByZXR1cm4gZ2V0Q2hhbmdlZEluZm8oY29udGV4dC5kb2MsIHNhbWVEZXB0aExpc3RJbmZvLCB0eXBlKTtcbn1cbnZhciBvdGhlckxpc3RUb0xpc3QgPSB7XG4gICAgYnVsbGV0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZ2V0QnVsbGV0T3JPcmRlcmVkKCdidWxsZXQnLCBjb250ZXh0KTtcbiAgICB9LFxuICAgIG9yZGVyZWQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBnZXRCdWxsZXRPck9yZGVyZWQoJ29yZGVyZWQnLCBjb250ZXh0KTtcbiAgICB9LFxuICAgIHRhc2s6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbWROb2RlID0gX2EubWROb2RlLCBkb2MgPSBfYS5kb2MsIGxpbmUgPSBfYS5saW5lO1xuICAgICAgICB2YXIgdGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgICAgICBpZiAobWROb2RlLmxpc3REYXRhLnRhc2spIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVUYXNrTGlzdCwgJyQxJDInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xpc3ROb2RlJDEobWROb2RlKSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZUxpc3QsICckMSQyWyBdICcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZWRSZXN1bHRzOiBbeyB0ZXh0OiB0ZXh0LCBsaW5lOiBsaW5lIH1dIH07XG4gICAgfSxcbn07XG52YXIgb3RoZXJOb2RlVG9MaXN0ID0ge1xuICAgIGJ1bGxldDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBkb2MgPSBfYS5kb2MsIGxpbmUgPSBfYS5saW5lO1xuICAgICAgICB2YXIgbGluZVRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBsaW5lKTtcbiAgICAgICAgdmFyIGNoYW5nZWRSZXN1bHRzID0gW3sgdGV4dDogXCIqIFwiICsgbGluZVRleHQsIGxpbmU6IGxpbmUgfV07XG4gICAgICAgIHJldHVybiB7IGNoYW5nZWRSZXN1bHRzOiBjaGFuZ2VkUmVzdWx0cyB9O1xuICAgIH0sXG4gICAgb3JkZXJlZDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcmssIGRvYyA9IF9hLmRvYywgbGluZSA9IF9hLmxpbmUsIHN0YXJ0TGluZSA9IF9hLnN0YXJ0TGluZTtcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIHZhciBmaXJzdE9yZGVyZWRMaXN0TnVtID0gMTtcbiAgICAgICAgdmFyIGZpcnN0T3JkZXJlZExpc3RMaW5lID0gc3RhcnRMaW5lO1xuICAgICAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydExpbmUgLSAxOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUoaSk7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGkpO1xuICAgICAgICAgICAgdmFyIGNhbkJlTGlzdE5vZGUgPSB0ZXh0ICYmICEhZmluZENsb3Nlc3ROb2RlKG1kTm9kZSwgZnVuY3Rpb24gKHRhcmdldE5vZGUpIHsgcmV0dXJuIGlzTGlzdE5vZGUkMSh0YXJnZXROb2RlKTsgfSk7XG4gICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gcmVPcmRlcmVkTGlzdEdyb3VwLmV4ZWMoZ2V0VGV4dEJ5TWRMaW5lKGRvYywgaSkpO1xuICAgICAgICAgICAgaWYgKCFzZWFyY2hSZXN1bHQgJiYgIWNhbkJlTGlzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VhcmNoUmVzdWx0ICYmIGNhbkJlTGlzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkICs9IDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBzZWFyY2hSZXN1bHQsIGluZGVudCA9IF9iWzFdLCBzdGFydCA9IF9iWzNdO1xuICAgICAgICAgICAgLy8gYmFzaXMgb24gb25lIGRlcHRoIGxpc3RcbiAgICAgICAgICAgIGlmICghaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RPcmRlcmVkTGlzdE51bSA9IE51bWJlcihzdGFydCk7XG4gICAgICAgICAgICAgICAgZmlyc3RPcmRlcmVkTGlzdExpbmUgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvcmRpbmFsTnVtID0gZmlyc3RPcmRlcmVkTGlzdE51bSArIGxpbmUgLSBmaXJzdE9yZGVyZWRMaXN0TGluZSAtIHNraXBwZWQ7XG4gICAgICAgIHZhciBjaGFuZ2VkUmVzdWx0cyA9IFt7IHRleHQ6IG9yZGluYWxOdW0gKyBcIi4gXCIgKyBsaW5lVGV4dCwgbGluZTogbGluZSB9XTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlZFJlc3VsdHM6IGNoYW5nZWRSZXN1bHRzIH07XG4gICAgfSxcbiAgICB0YXNrOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRvYyA9IF9hLmRvYywgbGluZSA9IF9hLmxpbmU7XG4gICAgICAgIHZhciBsaW5lVGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgICAgICB2YXIgY2hhbmdlZFJlc3VsdHMgPSBbeyB0ZXh0OiBcIiogWyBdIFwiICsgbGluZVRleHQsIGxpbmU6IGxpbmUgfV07XG4gICAgICAgIHJldHVybiB7IGNoYW5nZWRSZXN1bHRzOiBjaGFuZ2VkUmVzdWx0cyB9O1xuICAgIH0sXG59O1xudmFyIGV4dGVuZExpc3QgPSB7XG4gICAgYnVsbGV0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBfYS5saW5lLCBkb2MgPSBfYS5kb2M7XG4gICAgICAgIHZhciBsaW5lVGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgICAgICB2YXIgX2IgPSByZUJ1bGxldExpc3RHcm91cC5leGVjKGxpbmVUZXh0KSwgaW5kZW50ID0gX2JbMV0sIGRlbGltaXRlciA9IF9iWzJdO1xuICAgICAgICByZXR1cm4geyBsaXN0U3ludGF4OiBcIlwiICsgaW5kZW50ICsgZGVsaW1pdGVyIH07XG4gICAgfSxcbiAgICBvcmRlcmVkOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHRvYXN0TWFyayA9IF9hLnRvYXN0TWFyaywgbGluZSA9IF9hLmxpbmUsIG1kTm9kZSA9IF9hLm1kTm9kZSwgZG9jID0gX2EuZG9jO1xuICAgICAgICB2YXIgZGVwdGggPSBnZXRMaXN0RGVwdGgobWROb2RlKTtcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIHZhciBfYiA9IHJlT3JkZXJlZExpc3RHcm91cC5leGVjKGxpbmVUZXh0KSwgaW5kZW50ID0gX2JbMV0sIHN0YXJ0ID0gX2JbM10sIGRlbGltaXRlciA9IF9iWzRdO1xuICAgICAgICB2YXIgb3JkaW5hbE51bSA9IE51bWJlcihzdGFydCkgKyAxO1xuICAgICAgICB2YXIgbGlzdFN5bnRheCA9IFwiXCIgKyBpbmRlbnQgKyBvcmRpbmFsTnVtICsgZGVsaW1pdGVyO1xuICAgICAgICB2YXIgYmFja3dhcmRMaXN0ID0gZmluZFNhbWVEZXB0aExpc3QodG9hc3RNYXJrLCBsaW5lLCBkZXB0aCwgdHJ1ZSk7XG4gICAgICAgIHZhciBmaWx0ZXJlZExpc3QgPSBiYWNrd2FyZExpc3QuZmlsdGVyKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICB2YXIgc2VhcmNoUmVzdWx0ID0gcmVPcmRlcmVkTGlzdEdyb3VwLmV4ZWMoZ2V0VGV4dEJ5TWRMaW5lKGRvYywgaW5mby5saW5lKSk7XG4gICAgICAgICAgICByZXR1cm4gKHNlYXJjaFJlc3VsdCAmJlxuICAgICAgICAgICAgICAgIHNlYXJjaFJlc3VsdFsxXS5sZW5ndGggPT09IGluZGVudC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAhIWZpbmRDbG9zZXN0Tm9kZShpbmZvLm1kTm9kZSwgZnVuY3Rpb24gKHRhcmdldE5vZGUpIHsgcmV0dXJuIGlzT3JkZXJlZExpc3ROb2RlKHRhcmdldE5vZGUpOyB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7IGxpc3RTeW50YXg6IGxpc3RTeW50YXggfSwgZ2V0Q2hhbmdlZEluZm8oZG9jLCBmaWx0ZXJlZExpc3QsICdvcmRlcmVkJywgb3JkaW5hbE51bSkpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gZ2V0UmVvcmRlcmVkTGlzdEluZm8oZG9jLCBzY2hlbWEsIGxpbmUsIG9yZGluYWxOdW0sIHByZXZJbmRlbnRMZW5ndGgpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgbGluZVRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBsaW5lKTtcbiAgICB2YXIgc2VhcmNoUmVzdWx0ID0gcmVPcmRlcmVkTGlzdEdyb3VwLmV4ZWMobGluZVRleHQpO1xuICAgIHdoaWxlIChzZWFyY2hSZXN1bHQpIHtcbiAgICAgICAgdmFyIGluZGVudCA9IHNlYXJjaFJlc3VsdFsxXSwgZGVsaW1pdGVyID0gc2VhcmNoUmVzdWx0WzRdLCB0ZXh0ID0gc2VhcmNoUmVzdWx0WzVdO1xuICAgICAgICB2YXIgaW5kZW50TGVuZ3RoID0gaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluZGVudExlbmd0aCA9PT0gcHJldkluZGVudExlbmd0aCkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgXCJcIiArIGluZGVudCArIG9yZGluYWxOdW0gKyBkZWxpbWl0ZXIgKyB0ZXh0KSk7XG4gICAgICAgICAgICBvcmRpbmFsTnVtICs9IDE7XG4gICAgICAgICAgICBsaW5lICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZW50TGVuZ3RoID4gcHJldkluZGVudExlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5lc3RlZExpc3RJbmZvID0gZ2V0UmVvcmRlcmVkTGlzdEluZm8oZG9jLCBzY2hlbWEsIGxpbmUsIDEsIGluZGVudExlbmd0aCk7XG4gICAgICAgICAgICBsaW5lID0gbmVzdGVkTGlzdEluZm8ubGluZTtcbiAgICAgICAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KG5lc3RlZExpc3RJbmZvLm5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZW50TGVuZ3RoIDwgcHJldkluZGVudExlbmd0aCB8fCBsaW5lID4gZG9jLmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVUZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIHNlYXJjaFJlc3VsdCA9IHJlT3JkZXJlZExpc3RHcm91cC5leGVjKGxpbmVUZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZXM6IG5vZGVzLCBsaW5lOiBsaW5lIH07XG59XG5cbnZhciByZVN0YXJ0U3BhY2UgPSAvKF5cXHN7MSw0fSkoLiopLztcbmZ1bmN0aW9uIGlzQmxvY2tVbml0KGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgcmV0dXJuIGZyb20gPCB0byB8fCByZUxpc3QudGVzdCh0ZXh0KSB8fCByZUJsb2NrUXVvdGUudGVzdCh0ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzSW5UYWJsZUNlbGxOb2RlKGRvYywgc2NoZW1hLCBzZWxlY3Rpb24pIHtcbiAgICB2YXIgJHBvcyA9IHNlbGVjdGlvbi4kZnJvbTtcbiAgICBpZiAoJHBvcy5kZXB0aCA9PT0gMCkge1xuICAgICAgICAkcG9zID0gZG9jLnJlc29sdmUoJHBvcy5wb3MgLSAxKTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSAkcG9zLm5vZGUoMSk7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gJHBvcy5zdGFydCgxKTtcbiAgICB2YXIgY29udGVudFNpemUgPSBub2RlLmNvbnRlbnQuc2l6ZTtcbiAgICByZXR1cm4gKG5vZGUucmFuZ2VIYXNNYXJrKDAsIGNvbnRlbnRTaXplLCBzY2hlbWEubWFya3MudGFibGUpICYmXG4gICAgICAgICRwb3MucG9zIC0gc3RhcnRPZmZzZXQgIT09IGNvbnRlbnRTaXplICYmXG4gICAgICAgICRwb3MucG9zICE9PSBzdGFydE9mZnNldCk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb24odHIsIHBvc0luZm8pIHtcbiAgICB2YXIgZnJvbSA9IHBvc0luZm8uZnJvbSwgdG8gPSBwb3NJbmZvLnRvO1xuICAgIGlmIChwb3NJbmZvLnR5cGUgPT09ICdpbmRlbnQnKSB7XG4gICAgICAgIHZhciBzb2Z0VGFiTGVuID0gNDtcbiAgICAgICAgZnJvbSArPSBzb2Z0VGFiTGVuO1xuICAgICAgICB0byArPSAocG9zSW5mby5saW5lTGVuICsgMSkgKiBzb2Z0VGFiTGVuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHNwYWNlTGVuTGlzdCA9IHBvc0luZm8uc3BhY2VMZW5MaXN0O1xuICAgICAgICBmcm9tIC09IHNwYWNlTGVuTGlzdFswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZUxlbkxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRvIC09IHNwYWNlTGVuTGlzdFtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgZnJvbSwgdG8pO1xufVxudmFyIFBhcmFncmFwaCQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFBhcmFncmFwaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJhZ3JhcGgoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFncmFwaC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdwYXJhZ3JhcGgnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFncmFwaC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdpbmxpbmUqJyxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBjb2RlU3RhcnQ6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBjb2RlRW5kOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbeyB0YWc6ICdkaXYnIH1dLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRycy5jbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gWydkaXYnLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoYXR0cnMuY2xhc3NOYW1lKSB9LCAwXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbJ2RpdicsIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS5yZW9yZGVyTGlzdCA9IGZ1bmN0aW9uIChzdGFydExpbmUsIGVuZExpbmUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCB2aWV3ID0gX2EudmlldywgdG9hc3RNYXJrID0gX2EudG9hc3RNYXJrLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgIHZhciBfYiA9IHZpZXcuc3RhdGUsIHRyID0gX2IudHIsIHNlbGVjdGlvbiA9IF9iLnNlbGVjdGlvbiwgZG9jID0gX2IuZG9jO1xuICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUoc3RhcnRMaW5lKTtcbiAgICAgICAgdmFyIHRvcExpc3ROb2RlID0gbWROb2RlO1xuICAgICAgICB3aGlsZSAobWROb2RlICYmICFpc0J1bGxldExpc3ROb2RlKG1kTm9kZSkgJiYgbWROb2RlLnBhcmVudC50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICBtZE5vZGUgPSBtZE5vZGUucGFyZW50O1xuICAgICAgICAgICAgaWYgKGlzT3JkZXJlZExpc3ROb2RlKG1kTm9kZSkpIHtcbiAgICAgICAgICAgICAgICB0b3BMaXN0Tm9kZSA9IG1kTm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodG9wTGlzdE5vZGUpIHtcbiAgICAgICAgICAgIHN0YXJ0TGluZSA9IHRvcExpc3ROb2RlLnNvdXJjZXBvc1swXVswXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2MgPSByZU9yZGVyZWRMaXN0R3JvdXAuZXhlYyhnZXRUZXh0QnlNZExpbmUoZG9jLCBzdGFydExpbmUpKSwgaW5kZW50ID0gX2NbMV0sIHN0YXJ0ID0gX2NbM107XG4gICAgICAgIHZhciBpbmRlbnRMZW4gPSBpbmRlbnQubGVuZ3RoO1xuICAgICAgICB2YXIgX2QgPSBnZXRSZW9yZGVyZWRMaXN0SW5mbyhkb2MsIHNjaGVtYSwgc3RhcnRMaW5lLCBOdW1iZXIoc3RhcnQpLCBpbmRlbnRMZW4pLCBsaW5lID0gX2QubGluZSwgbm9kZXMgPSBfZC5ub2RlcztcbiAgICAgICAgZW5kTGluZSA9IE1hdGgubWF4KGVuZExpbmUsIGxpbmUgLSAxKTtcbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZ2V0Tm9kZUNvbnRlbnRPZmZzZXRSYW5nZShkb2MsIHN0YXJ0TGluZSAtIDEpLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lIC0gMTsgaSA8PSBlbmRMaW5lIC0gMTsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgX2UgPSBkb2MuY2hpbGQoaSksIG5vZGVTaXplID0gX2Uubm9kZVNpemUsIGNvbnRlbnQgPSBfZS5jb250ZW50O1xuICAgICAgICAgICAgdmFyIG1hcHBlZEZyb20gPSB0ci5tYXBwaW5nLm1hcChzdGFydE9mZnNldCk7XG4gICAgICAgICAgICB2YXIgbWFwcGVkVG8gPSBtYXBwZWRGcm9tICsgY29udGVudC5zaXplO1xuICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgobWFwcGVkRnJvbSwgbWFwcGVkVG8sIG5vZGVzW2kgLSBzdGFydExpbmUgKyAxXSk7XG4gICAgICAgICAgICBzdGFydE9mZnNldCArPSBub2RlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0gY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgc2VsZWN0aW9uLmZyb20sIHNlbGVjdGlvbi50byk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbikpO1xuICAgIH07XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbiAodGFiS2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0YWJLZXkgPT09IHZvaWQgMCkgeyB0YWJLZXkgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBkb2MgPSBzdGF0ZS5kb2M7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG8sIHN0YXJ0RnJvbU9mZnNldCA9IF9hLnN0YXJ0RnJvbU9mZnNldCwgc3RhcnRJbmRleCA9IF9hLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gX2EuZW5kSW5kZXg7XG4gICAgICAgICAgICBpZiAodGFiS2V5ICYmIGlzSW5UYWJsZUNlbGxOb2RlKGRvYywgc2NoZW1hLCBzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0TGluZVRleHQgPSBnZXRUZXh0Q29udGVudChkb2MsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKCh0YWJLZXkgJiYgaXNCbG9ja1VuaXQoZnJvbSwgdG8sIHN0YXJ0TGluZVRleHQpKSB8fFxuICAgICAgICAgICAgICAgICghdGFiS2V5ICYmIHJlTGlzdC50ZXN0KHN0YXJ0TGluZVRleHQpKSkge1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IHJlcGxhY2VUZXh0Tm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogc3RhcnRGcm9tT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBlbmRJbmRleDogZW5kSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVRleHQ6IGZ1bmN0aW9uICh0ZXh0Q29udGVudCkgeyByZXR1cm4gXCIgICAgXCIgKyB0ZXh0Q29udGVudDsgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2luZGVudCcsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgICAgICAgICAgbGluZUxlbjogZW5kSW5kZXggLSBzdGFydEluZGV4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVNlbGVjdGlvbih0ciwgcG9zSW5mbykpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVPcmRlcmVkTGlzdEdyb3VwLnRlc3Qoc3RhcnRMaW5lVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVvcmRlckxpc3Qoc3RhcnRJbmRleCArIDEsIGVuZEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFiS2V5KSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuaW5zZXJ0KHRvLCBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgJyAgICAnKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBQYXJhZ3JhcGgucHJvdG90eXBlLm91dGRlbnQgPSBmdW5jdGlvbiAodGFiS2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0YWJLZXkgPT09IHZvaWQgMCkgeyB0YWJLZXkgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgZG9jID0gc3RhdGUuZG9jLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG8sIHN0YXJ0RnJvbU9mZnNldCA9IF9hLnN0YXJ0RnJvbU9mZnNldCwgc3RhcnRJbmRleCA9IF9hLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gX2EuZW5kSW5kZXg7XG4gICAgICAgICAgICBpZiAodGFiS2V5ICYmIGlzSW5UYWJsZUNlbGxOb2RlKGRvYywgc2NoZW1hLCBzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0TGluZVRleHQgPSBnZXRUZXh0Q29udGVudChkb2MsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKCh0YWJLZXkgJiYgaXNCbG9ja1VuaXQoZnJvbSwgdG8sIHN0YXJ0TGluZVRleHQpKSB8fFxuICAgICAgICAgICAgICAgICghdGFiS2V5ICYmIHJlTGlzdC50ZXN0KHN0YXJ0TGluZVRleHQpKSkge1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZUxlbkxpc3RfMSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IHJlcGxhY2VUZXh0Tm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogc3RhcnRGcm9tT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBlbmRJbmRleDogZW5kSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVRleHQ6IGZ1bmN0aW9uICh0ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlYXJjaFJlc3VsdCA9IHJlU3RhcnRTcGFjZS5leGVjKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlTGVuTGlzdF8xLnB1c2goc2VhcmNoUmVzdWx0ID8gc2VhcmNoUmVzdWx0WzFdLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHRDb250ZW50LnJlcGxhY2UocmVTdGFydFNwYWNlLCAnJDInKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zSW5mbyA9IHsgdHlwZTogJ291dGRlbnQnLCBmcm9tOiBmcm9tLCB0bzogdG8sIHNwYWNlTGVuTGlzdDogc3BhY2VMZW5MaXN0XzEgfTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlU2VsZWN0aW9uKHRyLCBwb3NJbmZvKSkpO1xuICAgICAgICAgICAgICAgIGlmIChyZU9yZGVyZWRMaXN0R3JvdXAudGVzdChzdGFydExpbmVUZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW9yZGVyTGlzdChzdGFydEluZGV4ICsgMSwgZW5kSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0YWJLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUZXh0ID0gc3RhcnRMaW5lVGV4dC5zbGljZSgwLCB0byAtIHN0YXJ0RnJvbU9mZnNldCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGV4dFdpdGhvdXRTcGFjZSA9IHN0YXJ0VGV4dC5yZXBsYWNlKC9cXHN7MSw0fSQvLCAnJyk7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGV0U3RhcnQgPSB0byAtIChzdGFydFRleHQubGVuZ3RoIC0gc3RhcnRUZXh0V2l0aG91dFNwYWNlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKGRlbGV0U3RhcnQsIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUuZGVsZXRlTGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IF90aGlzLmNvbnRleHQudmlldztcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzdGF0ZS5zZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQ7XG4gICAgICAgICAgICB2YXIgZGVsZXRlUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlUmFuZ2Uoc3RhcnRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbkNvbW1hbmRzKGRlbGV0ZVJhbmdlLCBqb2luRm9yd2FyZCkoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUubW92ZURvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gc3RhdGUuZG9jLCB0ciA9IHN0YXRlLnRyLCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQsIGVuZEluZGV4ID0gX2EuZW5kSW5kZXg7XG4gICAgICAgICAgICBpZiAoZW5kSW5kZXggPCBkb2MuY29udGVudC5jaGlsZENvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGRvYy5jaGlsZChlbmRJbmRleCArIDEpLCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplLCB0ZXh0Q29udGVudCA9IF9iLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShlbmRUb09mZnNldCwgZW5kVG9PZmZzZXQgKyBub2RlU2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KHN0YXJ0RnJvbU9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgMihzdGFydCwgZW5kIHRhZyBsZW5ndGgpIHRvIGluc2VydCBwcmV2IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgLmluc2VydCh0ci5tYXBwaW5nLm1hcChzdGFydEZyb21PZmZzZXQpIC0gMiwgY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIHRleHRDb250ZW50KSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS5tb3ZlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgdHIgPSBzdGF0ZS50ciwgZG9jID0gc3RhdGUuZG9jLCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQsIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4O1xuICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gZG9jLmNoaWxkKHN0YXJ0SW5kZXggLSAxKSwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZSwgdGV4dENvbnRlbnQgPSBfYi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB0ci5kZWxldGUoc3RhcnRGcm9tT2Zmc2V0IC0gbm9kZVNpemUsIHN0YXJ0RnJvbU9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSlcbiAgICAgICAgICAgICAgICAgICAgLmluc2VydCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCksIGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCB0ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50KCksXG4gICAgICAgICAgICBvdXRkZW50OiB0aGlzLm91dGRlbnQoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFRhYjogdGhpcy5pbmRlbnQodHJ1ZSkoKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiB0aGlzLm91dGRlbnQodHJ1ZSkoKSxcbiAgICAgICAgICAgICdNb2QtZCc6IHRoaXMuZGVsZXRlTGluZXMoKSxcbiAgICAgICAgICAgICdNb2QtRCc6IHRoaXMuZGVsZXRlTGluZXMoKSxcbiAgICAgICAgICAgICdBbHQtQXJyb3dVcCc6IHRoaXMubW92ZVVwKCksXG4gICAgICAgICAgICAnQWx0LUFycm93RG93bic6IHRoaXMubW92ZURvd24oKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJhZ3JhcGg7XG59KE5vZGUkMikpO1xuXG52YXIgVGV4dCQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0ZXh0JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUZXh0O1xufShOb2RlJDIpKTtcblxudmFyIHJlSGVhZGluZyA9IC9eI3sxLDZ9XFxzLztcbnZhciBIZWFkaW5nJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoSGVhZGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkaW5nKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWFkaW5nLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2hlYWRpbmcnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlYWRpbmcucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbDogeyBkZWZhdWx0OiAxIH0sXG4gICAgICAgICAgICAgICAgICAgIHNlVGV4dDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxldmVsID0gYXR0cnMubGV2ZWwsIHNlVGV4dCA9IGF0dHJzLnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBcImhlYWRpbmd8aGVhZGluZ1wiICsgbGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xkZWxpbWl0ZXJ8c2V0ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4LmFwcGx5KHZvaWQgMCwgY2xhc3NOYW1lcy5zcGxpdCgnfCcpKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEhlYWRpbmcucHJvdG90eXBlLmNyZWF0ZUhlYWRpbmdUZXh0ID0gZnVuY3Rpb24gKGxldmVsLCB0ZXh0LCBjdXJIZWFkaW5nU3ludGF4KSB7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IHRleHQucmVwbGFjZShjdXJIZWFkaW5nU3ludGF4LCAnJykudHJpbSgpO1xuICAgICAgICB2YXIgaGVhZGluZ1RleHQgPSAnJztcbiAgICAgICAgd2hpbGUgKGxldmVsID4gMCkge1xuICAgICAgICAgICAgaGVhZGluZ1RleHQgKz0gJyMnO1xuICAgICAgICAgICAgbGV2ZWwgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGluZ1RleHQgKyBcIiBcIiArIHRleHRDb250ZW50O1xuICAgIH07XG4gICAgSGVhZGluZy5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gcGF5bG9hZC5sZXZlbDtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzdGF0ZS5zZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQsIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9hLmVuZEluZGV4O1xuICAgICAgICAgICAgdmFyIHRyID0gcmVwbGFjZVRleHROb2RlKHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgZnJvbTogc3RhcnRGcm9tT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgZW5kSW5kZXg6IGVuZEluZGV4LFxuICAgICAgICAgICAgICAgIGNyZWF0ZVRleHQ6IGZ1bmN0aW9uICh0ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZEhlYWRpbmcgPSB0ZXh0Q29udGVudC5tYXRjaChyZUhlYWRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VySGVhZGluZ1N5bnRheCA9IG1hdGNoZWRIZWFkaW5nID8gbWF0Y2hlZEhlYWRpbmdbMF0gOiAnJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZUhlYWRpbmdUZXh0KGxldmVsLCB0ZXh0Q29udGVudCwgY3VySGVhZGluZ1N5bnRheCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgcmV0dXJuIEhlYWRpbmc7XG59KE1hcmspKTtcblxudmFyIGZlbmNlZENvZGVCbG9ja1N5bnRheCA9ICdgYGAnO1xudmFyIENvZGVCbG9jayQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKENvZGVCbG9jaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2RlQmxvY2soKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGVCbG9jay5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdjb2RlQmxvY2snO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGVCbG9jay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ2NvZGUtYmxvY2snKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvZGVCbG9jay5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWEsIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgc3RhcnRGcm9tT2Zmc2V0ID0gX2Euc3RhcnRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCA9IF9hLmVuZFRvT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGZlbmNlZE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgZmVuY2VkQ29kZUJsb2NrU3ludGF4KTtcbiAgICAgICAgICAgIC8vIGFkZCBmZW5jZWQgc3RhcnQgYmxvY2tcbiAgICAgICAgICAgIHRyLmluc2VydChzdGFydEZyb21PZmZzZXQsIGZlbmNlZE5vZGUpLnNwbGl0KHN0YXJ0RnJvbU9mZnNldCArIGZlbmNlZENvZGVCbG9ja1N5bnRheC5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gYWRkIGZlbmNlZCBlbmQgYmxvY2tcbiAgICAgICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSkuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSwgZmVuY2VkTm9kZSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oXG4gICAgICAgICAgICAvLyBzdWJ0cmFjdCBmZW5jZWQgc3ludGF4IGxlbmd0aCBhbmQgb3BlbiwgY2xvc2UgdGFnKDIpXG4gICAgICAgICAgICBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkgLSAoZmVuY2VkQ29kZUJsb2NrU3ludGF4Lmxlbmd0aCArIDIpKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBDb2RlQmxvY2sucHJvdG90eXBlLmtlZXBJbmRlbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHIsIGRvYyA9IF9hLmRvYywgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgdmFyIHRvYXN0TWFyayA9IF90aGlzLmNvbnRleHQudG9hc3RNYXJrO1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIHN0YXJ0RnJvbU9mZnNldCA9IF9iLnN0YXJ0RnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYi5lbmRUb09mZnNldCwgZW5kSW5kZXggPSBfYi5lbmRJbmRleCwgZnJvbSA9IF9iLmZyb20sIHRvID0gX2IudG87XG4gICAgICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChkb2MsIGVuZEluZGV4KTtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0byAmJiB0ZXh0Q29udGVudC50cmltKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IHRleHRDb250ZW50Lm1hdGNoKC9eXFxzKy8pO1xuICAgICAgICAgICAgICAgIHZhciBtZE5vZGUgPSB0b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShlbmRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NvZGVCbG9ja05vZGUobWROb2RlKSAmJiBtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZXMgPSBtYXRjaGVkWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpY2VkVGV4dCA9IHRleHRDb250ZW50LnNsaWNlKHRvIC0gc3RhcnRGcm9tT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgc3BhY2VzICsgc2xpY2VkVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0QW5kRXh0ZW5kQmxvY2sodHIsIGVuZFRvT2Zmc2V0LCBzbGljZWRUZXh0LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb2RlQmxvY2sucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2RlQmxvY2tDb21tYW5kID0gdGhpcy5jb21tYW5kcygpKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnU2hpZnQtTW9kLXAnOiBjb2RlQmxvY2tDb21tYW5kLFxuICAgICAgICAgICAgJ1NoaWZ0LU1vZC1QJzogY29kZUJsb2NrQ29tbWFuZCxcbiAgICAgICAgICAgIEVudGVyOiB0aGlzLmtlZXBJbmRlbnRhdGlvbigpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvZGVCbG9jaztcbn0oTWFyaykpO1xuXG52YXIgcmVFbXB0eVRhYmxlID0gL1xcfHxcXHMvZztcbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlSGVhZGVyKGNvbHVtbkNvdW50KSB7XG4gICAgcmV0dXJuIFtjcmVhdGVUYWJsZVJvdyhjb2x1bW5Db3VudCksIGNyZWF0ZVRhYmxlUm93KGNvbHVtbkNvdW50LCB0cnVlKV07XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZUJvZHkkMShjb2x1bW5Db3VudCwgcm93Q291bnQpIHtcbiAgICB2YXIgYm9keVJvd3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgYm9keVJvd3MucHVzaChjcmVhdGVUYWJsZVJvdyhjb2x1bW5Db3VudCkpO1xuICAgIH1cbiAgICByZXR1cm4gYm9keVJvd3M7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZVJvdyhjb2x1bW5Db3VudCwgZGVsaW0pIHtcbiAgICB2YXIgcm93ID0gJ3wnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICByb3cgKz0gZGVsaW0gPyAnIC0tLSB8JyA6ICcgIHwnO1xuICAgIH1cbiAgICByZXR1cm4gcm93O1xufVxuZnVuY3Rpb24gY3JlYXRlVGFyZ2V0VHlwZXMobW92ZU5leHQpIHtcbiAgICByZXR1cm4gbW92ZU5leHRcbiAgICAgICAgPyB7IHR5cGU6ICduZXh0JywgcGFyZW50VHlwZTogJ3RhYmxlSGVhZCcsIGNoaWxkVHlwZTogJ2ZpcnN0Q2hpbGQnIH1cbiAgICAgICAgOiB7IHR5cGU6ICdwcmV2JywgcGFyZW50VHlwZTogJ3RhYmxlQm9keScsIGNoaWxkVHlwZTogJ2xhc3RDaGlsZCcgfTtcbn1cbnZhciBUYWJsZSQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGUucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCd0YWJsZScpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGFibGUucHJvdG90eXBlLmV4dGVuZFRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgZG9jID0gX2EuZG9jLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYiA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBlbmRGcm9tT2Zmc2V0ID0gX2IuZW5kRnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYi5lbmRUb09mZnNldCwgZW5kSW5kZXggPSBfYi5lbmRJbmRleCwgdG8gPSBfYi50bztcbiAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGRvYywgZW5kSW5kZXgpO1xuICAgICAgICAgICAgLy8gc2hvdWxkIGFkZCBgMWAgdG8gbGluZSBmb3IgdGhlIG1hcmtkb3duIHBhcnNlclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBtYXJrZG93biBwYXJzZXIgaGFzIGAxYChub3QgemVybykgYXMgdGhlIHN0YXJ0IG51bWJlclxuICAgICAgICAgICAgdmFyIG1kUG9zID0gW2VuZEluZGV4ICsgMSwgdG8gLSBlbmRGcm9tT2Zmc2V0ICsgMV07XG4gICAgICAgICAgICB2YXIgbWROb2RlID0gX3RoaXMuY29udGV4dC50b2FzdE1hcmsuZmluZE5vZGVBdFBvc2l0aW9uKG1kUG9zKTtcbiAgICAgICAgICAgIHZhciBjZWxsTm9kZSA9IGZpbmRDbG9zZXN0Tm9kZShtZE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVGFibGVDZWxsTm9kZShub2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ3RhYmxlRGVsaW1Sb3cnIHx8IG5vZGUucGFyZW50LnBhcmVudC50eXBlID09PSAndGFibGVCb2R5Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjZWxsTm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gIXRleHRDb250ZW50LnJlcGxhY2UocmVFbXB0eVRhYmxlLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IGNlbGxOb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uQ291bnQgPSBwYXJlbnRfMS5wYXJlbnQucGFyZW50LmNvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBjcmVhdGVUYWJsZVJvdyhjb2x1bW5Db3VudCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlUmFuZ2UoZW5kRnJvbU9mZnNldCwgZW5kVG9PZmZzZXQpLnNwbGl0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0clxuICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KGVuZFRvT2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmluc2VydCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCksIGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCByb3cpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIHN1YnRyYWN0IGAyYCB0byBzZWxlY3Rpb24gZW5kIHBvc2l0aW9uIGNvbnNpZGVyaW5nIGAgfGAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkgLSAyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5tb3ZlVGFibGVDZWxsID0gZnVuY3Rpb24gKG1vdmVOZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyO1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIGVuZEZyb21PZmZzZXQgPSBfYi5lbmRGcm9tT2Zmc2V0LCBlbmRJbmRleCA9IF9iLmVuZEluZGV4LCB0byA9IF9iLnRvO1xuICAgICAgICAgICAgdmFyIG1kUG9zID0gW2VuZEluZGV4ICsgMSwgdG8gLSBlbmRGcm9tT2Zmc2V0XTtcbiAgICAgICAgICAgIHZhciBtZE5vZGUgPSBfdGhpcy5jb250ZXh0LnRvYXN0TWFyay5maW5kTm9kZUF0UG9zaXRpb24obWRQb3MpO1xuICAgICAgICAgICAgdmFyIGNlbGxOb2RlID0gZmluZENsb3Nlc3ROb2RlKG1kTm9kZSwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGlzVGFibGVDZWxsTm9kZShub2RlKTsgfSk7XG4gICAgICAgICAgICBpZiAoY2VsbE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzIgPSBjZWxsTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gY3JlYXRlVGFyZ2V0VHlwZXMobW92ZU5leHQpLCB0eXBlID0gX2MudHlwZSwgcGFyZW50VHlwZSA9IF9jLnBhcmVudFR5cGUsIGNoaWxkVHlwZSA9IF9jLmNoaWxkVHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgY2hPZmZzZXQgPSBnZXRNZEVuZENoKGNlbGxOb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbE5vZGVbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hPZmZzZXQgPSBnZXRNZEVuZENoKGNlbGxOb2RlW3R5cGVdKSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gIXBhcmVudF8yW3R5cGVdICYmIHBhcmVudF8yLnBhcmVudC50eXBlID09PSBwYXJlbnRUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmVudF8yLnBhcmVudFt0eXBlXVtjaGlsZFR5cGVdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmVudF8yW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ25leHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBuZXh0IHJvdywgdGhlIGJhc2Ugb2Zmc2V0IHdvdWxkIGJlIGVuZCBwb3NpdGlvbiBvZiB0aGUgbmV4dCByb3cncyBmaXJzdCBjaGlsZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGJhc2Ugb2Zmc2V0IGlzIHplcm8uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZU9mZnNldCA9IHJvdyA/IGdldE1kRW5kQ2gocm93W2NoaWxkVHlwZV0pIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0YWcob3BlbiwgY2xvc2UpIHBvc2l0aW9uKCcyJykgZm9yIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY2hPZmZzZXQgKz0gYmFzZU9mZnNldCArIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3ByZXYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBwcmV2IHJvdywgdGhlIHRhcmdldCBwb3NpdGlvbiB3b3VsZCBiZSAnLTQnIGZvciBjYWxjdWxhdGluZyAnIHwnIGNoYXJhY3RlcnMgYW5kIHRhZyhvcGVuLCBjbG9zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHRhcmdldCBwb3NpdGlvbiBpcyB6ZXJvLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hPZmZzZXQgPSByb3cgPyAtNCA6IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIGVuZEZyb21PZmZzZXQgKyBjaE9mZnNldCkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5hZGRUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2IgPSBwYXlsb2FkLCBjb2x1bW5Db3VudCA9IF9iLmNvbHVtbkNvdW50LCByb3dDb3VudCA9IF9iLnJvd0NvdW50O1xuICAgICAgICAgICAgdmFyIGVuZFRvT2Zmc2V0ID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbikuZW5kVG9PZmZzZXQ7XG4gICAgICAgICAgICB2YXIgaGVhZGVyUm93cyA9IGNyZWF0ZVRhYmxlSGVhZGVyKGNvbHVtbkNvdW50KTtcbiAgICAgICAgICAgIHZhciBib2R5Um93cyA9IGNyZWF0ZVRhYmxlQm9keSQxKGNvbHVtbkNvdW50LCByb3dDb3VudCAtIDEpO1xuICAgICAgICAgICAgdmFyIHJvd3MgPSBfX3NwcmVhZEFycmF5JDEoX19zcHJlYWRBcnJheSQxKFtdLCBoZWFkZXJSb3dzKSwgYm9keVJvd3MpO1xuICAgICAgICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpLmluc2VydCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCksIGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCByb3cpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gc2hvdWxkIGFkZCBgNGAgdG8gc2VsZWN0aW9uIHBvc2l0aW9uIGNvbnNpZGVyaW5nIGB8IGAgdGV4dCBhbmQgc3RhcnQgYmxvY2sgdGFnIGxlbmd0aFxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIGVuZFRvT2Zmc2V0ICsgNCkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBhZGRUYWJsZTogdGhpcy5hZGRUYWJsZSgpIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEVudGVyOiB0aGlzLmV4dGVuZFRhYmxlKCksXG4gICAgICAgICAgICBUYWI6IHRoaXMubW92ZVRhYmxlQ2VsbCh0cnVlKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiB0aGlzLm1vdmVUYWJsZUNlbGwoZmFsc2UpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlO1xufShNYXJrKSk7XG5cbnZhciB0aGVtYXRpY0JyZWFrU3ludGF4ID0gJyoqKic7XG52YXIgVGhlbWF0aWNCcmVhayQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRoZW1hdGljQnJlYWssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGhlbWF0aWNCcmVhaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGhlbWF0aWNCcmVhay5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0aGVtYXRpY0JyZWFrJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaGVtYXRpY0JyZWFrLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgndGhlbWF0aWMtYnJlYWsnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRoZW1hdGljQnJlYWsucHJvdG90eXBlLmhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvLCBlbmRUb09mZnNldCA9IF9hLmVuZFRvT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgdGhlbWF0aWNCcmVha1N5bnRheCk7XG4gICAgICAgICAgICB0clxuICAgICAgICAgICAgICAgIC5zcGxpdChmcm9tKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlV2l0aCh0ci5tYXBwaW5nLm1hcChmcm9tKSwgdHIubWFwcGluZy5tYXAodG8pLCBub2RlKVxuICAgICAgICAgICAgICAgIC5zcGxpdCh0ci5tYXBwaW5nLm1hcCh0bykpLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGhlbWF0aWNCcmVhay5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGhyOiB0aGlzLmhyKCkgfTtcbiAgICB9O1xuICAgIFRoZW1hdGljQnJlYWsucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaW5lQ29tbWFuZCA9IHRoaXMuaHIoKSgpO1xuICAgICAgICByZXR1cm4geyAnTW9kLWwnOiBsaW5lQ29tbWFuZCwgJ01vZC1MJzogbGluZUNvbW1hbmQgfTtcbiAgICB9O1xuICAgIHJldHVybiBUaGVtYXRpY0JyZWFrO1xufShNYXJrKSk7XG5cbmZ1bmN0aW9uIGNhbm5vdEJlTGlzdE5vZGUoX2EsIGxpbmUpIHtcbiAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIHNvdXJjZXBvcyA9IF9hLnNvdXJjZXBvcztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICB2YXIgc3RhcnRMaW5lID0gc291cmNlcG9zWzBdWzBdO1xuICAgIHJldHVybiBsaW5lIDw9IHN0YXJ0TGluZSAmJiAodHlwZSA9PT0gJ2NvZGVCbG9jaycgfHwgdHlwZSA9PT0gJ2hlYWRpbmcnIHx8IHR5cGUubWF0Y2goJ3RhYmxlJykpO1xufVxudmFyIExpc3RJdGVtJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoTGlzdEl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGlzdEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RJdGVtLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xpc3RJdGVtJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0SXRlbS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIG9kZDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICBldmVuOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgIGxpc3RTdHlsZTogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9kZCA9IGF0dHJzLm9kZCwgZXZlbiA9IGF0dHJzLmV2ZW4sIGxpc3RTdHlsZSA9IGF0dHJzLmxpc3RTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSAnbGlzdC1pdGVtJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfGxpc3QtaXRlbS1zdHlsZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9kZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfGxpc3QtaXRlbS1vZGQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8bGlzdC1pdGVtLWV2ZW4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXguYXBwbHkodm9pZCAwLCBjbGFzc05hbWVzLnNwbGl0KCd8JykpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLmV4dGVuZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCBkb2MgPSBfYS5kb2MsIHNjaGVtYSA9IF9hLnNjaGVtYSwgdHIgPSBfYS50cjtcbiAgICAgICAgICAgIHZhciB0b2FzdE1hcmsgPSBfdGhpcy5jb250ZXh0LnRvYXN0TWFyaztcbiAgICAgICAgICAgIHZhciBfYiA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCB0byA9IF9iLnRvLCBzdGFydEZyb21PZmZzZXQgPSBfYi5zdGFydEZyb21PZmZzZXQsIGVuZEZyb21PZmZzZXQgPSBfYi5lbmRGcm9tT2Zmc2V0LCBlbmRJbmRleCA9IF9iLmVuZEluZGV4LCBlbmRUb09mZnNldCA9IF9iLmVuZFRvT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gZ2V0VGV4dENvbnRlbnQoZG9jLCBlbmRJbmRleCk7XG4gICAgICAgICAgICB2YXIgaXNMaXN0ID0gcmVMaXN0LnRlc3QodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFpc0xpc3QgfHwgc2VsZWN0aW9uLmZyb20gPT09IHN0YXJ0RnJvbU9mZnNldCB8fCAhc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlzRW1wdHkgPSAhdGV4dENvbnRlbnQucmVwbGFjZShyZUNhbkJlVGFza0xpc3QsICcnKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVJhbmdlKGVuZEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0KS5zcGxpdCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1hbmRUeXBlID0gZ2V0TGlzdFR5cGUodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhZGQgYDFgIHRvIGxpbmUgZm9yIHRoZSBtYXJrZG93biBwYXJzZXJcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIG1hcmtkb3duIHBhcnNlciBoYXMgYDFgKG5vdCB6ZXJvKSBhcyB0aGUgc3RhcnQgbnVtYmVyXG4gICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKGVuZEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIHNsaWNlZFRleHQgPSB0ZXh0Q29udGVudC5zbGljZSh0byAtIGVuZEZyb21PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0geyB0b2FzdE1hcms6IHRvYXN0TWFyaywgbWROb2RlOiBtZE5vZGUsIGRvYzogZG9jLCBsaW5lOiBlbmRJbmRleCArIDEgfTtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBleHRlbmRMaXN0W2NvbW1hbmRUeXBlXShjb250ZXh0KSwgbGlzdFN5bnRheCA9IF9jLmxpc3RTeW50YXgsIGNoYW5nZWRSZXN1bHRzID0gX2MuY2hhbmdlZFJlc3VsdHM7XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlIG9yZGluYWwgbnVtYmVyIG9mIGJhY2t3YXJkIG9yZGVyZWQgbGlzdFxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkUmVzdWx0cyA9PT0gbnVsbCB8fCBjaGFuZ2VkUmVzdWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbmdlZFJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICB0ci5zcGxpdCh0byk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBmaXJzdCBvcmRlcmVkIGxpc3QgaW5mb1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkUmVzdWx0cy51bnNoaWZ0KHsgdGV4dDogbGlzdFN5bnRheCArIHNsaWNlZFRleHQsIGxpbmU6IGVuZEluZGV4ICsgMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlVG9MaXN0UGVyTGluZSh0ciwgY2hhbmdlZFJlc3VsdHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3VidHJhY3QgMSBiZWNhdXNlIHRoZSBsaW5lIGhhcyBpbmNyZWFzZWQgdGhyb3VnaCAnc3BsaXQnIGNvbW1hbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydExpbmU6IGNoYW5nZWRSZXN1bHRzWzBdLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRMaW5lOiBsYXN0JDEoY2hhbmdlZFJlc3VsdHMpLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gdHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpIC0gc2xpY2VkVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBwb3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIGxpc3RTeW50YXggKyBzbGljZWRUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRBbmRFeHRlbmRCbG9jayh0ciwgZW5kVG9PZmZzZXQsIHNsaWNlZFRleHQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLnRvTGlzdCA9IGZ1bmN0aW9uIChjb21tYW5kVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IF9hLmRvYywgdHIgPSBfYS50ciwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICAgICAgdmFyIHRvYXN0TWFyayA9IF90aGlzLmNvbnRleHQudG9hc3RNYXJrO1xuICAgICAgICAgICAgdmFyIHJhbmdlSW5mbyA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pO1xuICAgICAgICAgICAgLy8gc2hvdWxkIGFkZCBgMWAgdG8gbGluZSBmb3IgdGhlIG1hcmtkb3duIHBhcnNlclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBtYXJrZG93biBwYXJzZXIgaGFzIGAxYChub3QgemVybykgYXMgdGhlIHN0YXJ0IG51bWJlclxuICAgICAgICAgICAgdmFyIHN0YXJ0TGluZSA9IHJhbmdlSW5mby5zdGFydEluZGV4ICsgMTtcbiAgICAgICAgICAgIHZhciBlbmRMaW5lID0gcmFuZ2VJbmZvLmVuZEluZGV4ICsgMTtcbiAgICAgICAgICAgIHZhciBlbmRUb09mZnNldCA9IHJhbmdlSW5mby5lbmRUb09mZnNldDtcbiAgICAgICAgICAgIHZhciBza2lwTGluZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGxpbmUgPSBzdGFydExpbmU7IGxpbmUgPD0gZW5kTGluZTsgbGluZSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgIGlmIChtZE5vZGUgJiYgY2Fubm90QmVMaXN0Tm9kZShtZE5vZGUsIGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0byBza2lwIHVubmVjZXNzYXJ5IHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICBpZiAoc2tpcExpbmVzLmluZGV4T2YobGluZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHsgdG9hc3RNYXJrOiB0b2FzdE1hcmssIG1kTm9kZTogbWROb2RlLCBkb2M6IGRvYywgbGluZTogbGluZSwgc3RhcnRMaW5lOiBzdGFydExpbmUgfTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZFJlc3VsdHMgPSAoaXNMaXN0Tm9kZSQxKG1kTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgPyBvdGhlckxpc3RUb0xpc3RbY29tbWFuZFR5cGVdKGNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgIDogb3RoZXJOb2RlVG9MaXN0W2NvbW1hbmRUeXBlXShjb250ZXh0KSkuY2hhbmdlZFJlc3VsdHM7XG4gICAgICAgICAgICAgICAgdmFyIGVuZE9mZnNldCA9IF90aGlzLmNoYW5nZVRvTGlzdFBlckxpbmUodHIsIGNoYW5nZWRSZXN1bHRzLCB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IGdldE5vZGVDb250ZW50T2Zmc2V0UmFuZ2UoZG9jLCBjaGFuZ2VkUmVzdWx0c1swXS5saW5lIC0gMSkuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGluZTogY2hhbmdlZFJlc3VsdHNbMF0ubGluZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kTGluZTogbGFzdCQxKGNoYW5nZWRSZXN1bHRzKS5saW5lLFxuICAgICAgICAgICAgICAgICAgICBpbmRleERpZmY6IDEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZW5kVG9PZmZzZXQgPSBNYXRoLm1heChlbmRPZmZzZXQsIGVuZFRvT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZFJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcExpbmVzID0gc2tpcExpbmVzLmNvbmNhdChjaGFuZ2VkUmVzdWx0cy5tYXAoZnVuY3Rpb24gKGluZm8pIHsgcmV0dXJuIGluZm8ubGluZTsgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIExpc3RJdGVtLnByb3RvdHlwZS5jaGFuZ2VUb0xpc3RQZXJMaW5lID0gZnVuY3Rpb24gKHRyLCBjaGFuZ2VkUmVzdWx0cywgX2EpIHtcbiAgICAgICAgdmFyIGZyb20gPSBfYS5mcm9tLCBzdGFydExpbmUgPSBfYS5zdGFydExpbmUsIGVuZExpbmUgPSBfYS5lbmRMaW5lLCBfYiA9IF9hLmluZGV4RGlmZiwgaW5kZXhEaWZmID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYjtcbiAgICAgICAgdmFyIG1heEVuZE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBfYyA9IHRyLmRvYy5jaGlsZChpKSwgbm9kZVNpemUgPSBfYy5ub2RlU2l6ZSwgY29udGVudCA9IF9jLmNvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgbWFwcGVkRnJvbSA9IHRyLm1hcHBpbmcubWFwKGZyb20pO1xuICAgICAgICAgICAgdmFyIG1hcHBlZFRvID0gbWFwcGVkRnJvbSArIGNvbnRlbnQuc2l6ZTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkUmVzdWx0ID0gY2hhbmdlZFJlc3VsdHMuZmlsdGVyKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5saW5lIC0gaW5kZXhEaWZmID09PSBpOyB9KVswXTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgobWFwcGVkRnJvbSwgbWFwcGVkVG8sIGNyZWF0ZVRleHROb2RlJDEodGhpc18xLmNvbnRleHQuc2NoZW1hLCBjaGFuZ2VkUmVzdWx0LnRleHQpKTtcbiAgICAgICAgICAgICAgICBtYXhFbmRPZmZzZXQgPSBNYXRoLm1heChtYXhFbmRPZmZzZXQsIGZyb20gKyBjb250ZW50LnNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbSArPSBub2RlU2l6ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydExpbmUgLSBpbmRleERpZmY7IGkgPD0gZW5kTGluZSAtIGluZGV4RGlmZjsgaSArPSAxKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhFbmRPZmZzZXQ7XG4gICAgfTtcbiAgICBMaXN0SXRlbS5wcm90b3R5cGUudG9nZ2xlVGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHIsIGRvYyA9IF9hLmRvYywgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgdmFyIHRvYXN0TWFyayA9IF90aGlzLmNvbnRleHQudG9hc3RNYXJrO1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIHN0YXJ0SW5kZXggPSBfYi5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9iLmVuZEluZGV4O1xuICAgICAgICAgICAgdmFyIG5ld1RyID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUoaSArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChpc0xpc3ROb2RlJDEobWROb2RlKSAmJiBtZE5vZGUubGlzdERhdGEudGFzaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBtZE5vZGUubGlzdERhdGEsIGNoZWNrZWQgPSBfYy5jaGVja2VkLCBwYWRkaW5nID0gX2MucGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlQ2hhciA9IGNoZWNrZWQgPyAnICcgOiAneCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZFBvcyA9IG1kTm9kZS5zb3VyY2Vwb3NbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IGdldE5vZGVDb250ZW50T2Zmc2V0UmFuZ2UoZG9jLCBtZFBvc1swXSAtIDEpLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBzdGFydE9mZnNldCArPSBtZFBvc1sxXSArIHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RyID0gdHIucmVwbGFjZVdpdGgoc3RhcnRPZmZzZXQsIHN0YXJ0T2Zmc2V0ICsgMSwgc2NoZW1hLnRleHQoc3RhdGVDaGFyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1RyKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnVsbGV0TGlzdDogdGhpcy50b0xpc3QoJ2J1bGxldCcpLFxuICAgICAgICAgICAgb3JkZXJlZExpc3Q6IHRoaXMudG9MaXN0KCdvcmRlcmVkJyksXG4gICAgICAgICAgICB0YXNrTGlzdDogdGhpcy50b0xpc3QoJ3Rhc2snKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExpc3RJdGVtLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVsbGV0Q29tbWFuZCA9IHRoaXMudG9MaXN0KCdidWxsZXQnKSgpO1xuICAgICAgICB2YXIgb3JkZXJlZENvbW1hbmQgPSB0aGlzLnRvTGlzdCgnb3JkZXJlZCcpKCk7XG4gICAgICAgIHZhciB0YXNrQ29tbWFuZCA9IHRoaXMudG9MaXN0KCd0YXNrJykoKTtcbiAgICAgICAgdmFyIHRvZ2xlVGFza0NvbW1hbmQgPSB0aGlzLnRvZ2dsZVRhc2soKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtdSc6IGJ1bGxldENvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLVUnOiBidWxsZXRDb21tYW5kLFxuICAgICAgICAgICAgJ01vZC1vJzogb3JkZXJlZENvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLU8nOiBvcmRlcmVkQ29tbWFuZCxcbiAgICAgICAgICAgICdhbHQtdCc6IHRhc2tDb21tYW5kLFxuICAgICAgICAgICAgJ2FsdC1UJzogdGFza0NvbW1hbmQsXG4gICAgICAgICAgICAnU2hpZnQtQ3RybC14JzogdG9nbGVUYXNrQ29tbWFuZCxcbiAgICAgICAgICAgICdTaGlmdC1DdHJsLVgnOiB0b2dsZVRhc2tDb21tYW5kLFxuICAgICAgICAgICAgRW50ZXI6IHRoaXMuZXh0ZW5kTGlzdCgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIExpc3RJdGVtO1xufShNYXJrKSk7XG5cbmZ1bmN0aW9uIHRvZ2dsZU1hcmsoY29uZGl0aW9uLCBzeW50YXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICB2YXIgdHIgPSBfYS50ciwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgY29uZGl0aW9uRm4gPSAhaXNGdW5jdGlvbl8xKGNvbmRpdGlvbilcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIGNvbmRpdGlvbi50ZXN0KHRleHQpOyB9XG4gICAgICAgICAgICA6IGNvbmRpdGlvbjtcbiAgICAgICAgdmFyIHN5bnRheExlbiA9IHN5bnRheC5sZW5ndGg7XG4gICAgICAgIHZhciBkb2MgPSB0ci5kb2M7XG4gICAgICAgIHZhciBfYiA9IHJlc29sdmVTZWxlY3Rpb25Qb3Moc2VsZWN0aW9uKSwgZnJvbSA9IF9iWzBdLCB0byA9IF9iWzFdO1xuICAgICAgICB2YXIgcHJldlBvcyA9IE1hdGgubWF4KGZyb20gLSBzeW50YXhMZW4sIDEpO1xuICAgICAgICB2YXIgbmV4dFBvcyA9IE1hdGgubWluKHRvICsgc3ludGF4TGVuLCBkb2MuY29udGVudC5zaXplIC0gMSk7XG4gICAgICAgIHZhciBzbGljZSA9IHNlbGVjdGlvbi5jb250ZW50KCk7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IHNsaWNlLmNvbnRlbnQudGV4dEJldHdlZW4oMCwgc2xpY2UuY29udGVudC5zaXplLCAnXFxuJyk7XG4gICAgICAgIHZhciBwcmV2VGV4dCA9IGRvYy50ZXh0QmV0d2VlbihwcmV2UG9zLCBmcm9tLCAnXFxuJyk7XG4gICAgICAgIHZhciBuZXh0VGV4dCA9IGRvYy50ZXh0QmV0d2Vlbih0bywgbmV4dFBvcywgJ1xcbicpO1xuICAgICAgICB0ZXh0Q29udGVudCA9IFwiXCIgKyBwcmV2VGV4dCArIHRleHRDb250ZW50ICsgbmV4dFRleHQ7XG4gICAgICAgIGlmIChwcmV2VGV4dCAmJiBuZXh0VGV4dCAmJiBjb25kaXRpb25Gbih0ZXh0Q29udGVudCkpIHtcbiAgICAgICAgICAgIHRyLmRlbGV0ZShuZXh0UG9zIC0gc3ludGF4TGVuLCBuZXh0UG9zKS5kZWxldGUocHJldlBvcywgcHJldlBvcyArIHN5bnRheExlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ci5pbnNlcnRUZXh0KHN5bnRheCwgdG8pLmluc2VydFRleHQoc3ludGF4LCBmcm9tKTtcbiAgICAgICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSBzZWxlY3Rpb24uZW1wdHlcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIGZyb20gKyBzeW50YXhMZW4pXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBmcm9tICsgc3ludGF4TGVuLCB0byArIHN5bnRheExlbik7XG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07IH07XG59XG5cbnZhciByZVN0cm9uZyA9IC9eKFxcKnsyfXxfezJ9KS4qKFtcXHNcXFNdKilcXDEkL207XG52YXIgc3Ryb25nU3ludGF4ID0gJyoqJztcbnZhciBTdHJvbmckMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShTdHJvbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Ryb25nKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJvbmcucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3Ryb25nJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJvbmcucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdzdHJvbmcnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0cm9uZy5wcm90b3R5cGUuYm9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRvZ2dsZU1hcmsocmVTdHJvbmcsIHN0cm9uZ1N5bnRheCk7XG4gICAgfTtcbiAgICBTdHJvbmcucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBib2xkOiB0aGlzLmJvbGQoKSB9O1xuICAgIH07XG4gICAgU3Ryb25nLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9sZENvbW1hbmQgPSB0aGlzLmJvbGQoKSgpO1xuICAgICAgICByZXR1cm4geyAnTW9kLWInOiBib2xkQ29tbWFuZCwgJ01vZC1CJzogYm9sZENvbW1hbmQgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJvbmc7XG59KE1hcmspKTtcblxudmFyIHJlU3RyaWtlID0gL14ofnsyfSkuKihbXFxzXFxTXSopXFwxJC9tO1xudmFyIHN0cmlrZVN5bnRheCA9ICd+fic7XG52YXIgU3RyaWtlJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoU3RyaWtlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0cmlrZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaWtlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3N0cmlrZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaWtlLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnc3RyaWtlJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHJpa2UucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9nZ2xlTWFyayhyZVN0cmlrZSwgc3RyaWtlU3ludGF4KTtcbiAgICB9O1xuICAgIFN0cmlrZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0cmlrZUNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgcmV0dXJuIHsgJ01vZC1zJzogc3RyaWtlQ29tbWFuZCwgJ01vZC1TJzogc3RyaWtlQ29tbWFuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmlrZTtcbn0oTWFyaykpO1xuXG52YXIgcmVFbXBoID0gL14oXFwqfF8pLiooW1xcc1xcU10qKVxcMSQvbTtcbnZhciBlbXBoU3ludGF4ID0gJyonO1xudmFyIEVtcGgkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShFbXBoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcGgoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtcGgucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnZW1waCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1waC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ2VtcGgnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEVtcGgucHJvdG90eXBlLml0YWxpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRvZ2dsZU1hcmsocmVFbXBoLCBlbXBoU3ludGF4KTtcbiAgICB9O1xuICAgIEVtcGgucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBpdGFsaWM6IHRoaXMuaXRhbGljKCkgfTtcbiAgICB9O1xuICAgIEVtcGgucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGFsaWNDb21tYW5kID0gdGhpcy5pdGFsaWMoKSgpO1xuICAgICAgICByZXR1cm4geyAnTW9kLWknOiBpdGFsaWNDb21tYW5kLCAnTW9kLUknOiBpdGFsaWNDb21tYW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4gRW1waDtcbn0oTWFyaykpO1xuXG52YXIgcmVDb2RlID0gL14oYCkuKihbXFxzXFxTXSopXFwxJC9tO1xudmFyIGNvZGVTeW50YXggPSAnYCc7XG52YXIgQ29kZSQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKENvZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdjb2RlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2RlLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlZDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChtYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IG1hcmsuYXR0cnMsIHN0YXJ0ID0gX2Euc3RhcnQsIGVuZCA9IF9hLmVuZCwgbWFya2VkID0gX2EubWFya2VkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9ICdjb2RlJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8ZGVsaW1pdGVyfHN0YXJ0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8ZGVsaW1pdGVyfGVuZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfG1hcmtlZC10ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4LmFwcGx5KHZvaWQgMCwgY2xhc3NOYW1lcy5zcGxpdCgnfCcpKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvZGUucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdG9nZ2xlTWFyayhyZUNvZGUsIGNvZGVTeW50YXgpO1xuICAgIH07XG4gICAgQ29kZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvZGVDb21tYW5kID0gdGhpcy5jb21tYW5kcygpKCk7XG4gICAgICAgIHJldHVybiB7ICdTaGlmdC1Nb2QtYyc6IGNvZGVDb21tYW5kLCAnU2hpZnQtTW9kLUMnOiBjb2RlQ29tbWFuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvZGU7XG59KE1hcmspKTtcblxudmFyIExpbmskMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShMaW5rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmsucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGluayc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGluay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gYXR0cnMudXJsLCBkZXNjID0gYXR0cnMuZGVzYztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSAnbGluayc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xsaW5rLXVybHxtYXJrZWQtdGV4dCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xsaW5rLWRlc2N8bWFya2VkLXRleHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXguYXBwbHkodm9pZCAwLCBjbGFzc05hbWVzLnNwbGl0KCd8JykpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGluay5wcm90b3R5cGUuYWRkTGlua09ySW1hZ2UgPSBmdW5jdGlvbiAoY29tbWFuZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2IgPSByZXNvbHZlU2VsZWN0aW9uUG9zKHNlbGVjdGlvbiksIGZyb20gPSBfYlswXSwgdG8gPSBfYlsxXTtcbiAgICAgICAgICAgIHZhciBfYyA9IHBheWxvYWQsIGxpbmtUZXh0ID0gX2MubGlua1RleHQsIGFsdFRleHQgPSBfYy5hbHRUZXh0LCBsaW5rVXJsID0gX2MubGlua1VybCwgaW1hZ2VVcmwgPSBfYy5pbWFnZVVybDtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gbGlua1RleHQ7XG4gICAgICAgICAgICB2YXIgdXJsID0gbGlua1VybDtcbiAgICAgICAgICAgIHZhciBzeW50YXggPSAnJztcbiAgICAgICAgICAgIGlmIChjb21tYW5kVHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBhbHRUZXh0O1xuICAgICAgICAgICAgICAgIHVybCA9IGltYWdlVXJsO1xuICAgICAgICAgICAgICAgIHN5bnRheCA9ICchJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgPSBlc2NhcGVUZXh0Rm9yTGluayh0ZXh0KTtcbiAgICAgICAgICAgIHN5bnRheCArPSBcIltcIiArIHRleHQgKyBcIl0oXCIgKyB1cmwgKyBcIilcIjtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnJlcGxhY2VXaXRoKGZyb20sIHRvLCBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgc3ludGF4KSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBMaW5rLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZEltYWdlOiB0aGlzLmFkZExpbmtPckltYWdlKCdpbWFnZScpLFxuICAgICAgICAgICAgYWRkTGluazogdGhpcy5hZGRMaW5rT3JJbWFnZSgnbGluaycpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIExpbms7XG59KE1hcmspKTtcblxudmFyIFRhc2tEZWxpbWl0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFza0RlbGltaXRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYXNrRGVsaW1pdGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYXNrRGVsaW1pdGVyLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Rhc2tEZWxpbWl0ZXInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhc2tEZWxpbWl0ZXIucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdkZWxpbWl0ZXInLCAnbGlzdC1pdGVtJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGFza0RlbGltaXRlcjtcbn0oTWFyaykpO1xudmFyIERlbGltaXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShEZWxpbWl0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVsaW1pdGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWxpbWl0ZXIucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGVsaW1pdGVyJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWxpbWl0ZXIucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdkZWxpbWl0ZXInKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBEZWxpbWl0ZXI7XG59KE1hcmspKTtcbnZhciBNZXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKE1ldGEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWV0YSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWV0YS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdtZXRhJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXRhLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnbWV0YScpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE1ldGE7XG59KE1hcmspKTtcbnZhciBNYXJrZWRUZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKE1hcmtlZFRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFya2VkVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFya2VkVGV4dC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdtYXJrZWRUZXh0JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXJrZWRUZXh0LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnbWFya2VkLXRleHQnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBNYXJrZWRUZXh0O1xufShNYXJrKSk7XG52YXIgVGFibGVDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlQ2VsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUNlbGwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlQ2VsbC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZUNlbGwnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlQ2VsbC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ3RhYmxlLWNlbGwnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUYWJsZUNlbGw7XG59KE1hcmspKTtcblxudmFyIEh0bWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoSHRtbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIdG1sKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIdG1sLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2h0bWwnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEh0bWwucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdodG1sJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gSHRtbDtcbn0oTWFyaykpO1xuXG52YXIgY3VzdG9tQmxvY2tTeW50YXggPSAnJCQnO1xudmFyIEN1c3RvbUJsb2NrJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ3VzdG9tQmxvY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tQmxvY2soKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUJsb2NrLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2N1c3RvbUJsb2NrJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21CbG9jay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ2N1c3RvbS1ibG9jaycpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ3VzdG9tQmxvY2sucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2EuZW5kVG9PZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIShwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQuaW5mbykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VzdG9tQmxvY2sgPSBcIlwiICsgY3VzdG9tQmxvY2tTeW50YXggKyBwYXlsb2FkLmluZm87XG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIGN1c3RvbUJsb2NrKTtcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIGN1c3RvbUJsb2NrU3ludGF4KTtcbiAgICAgICAgICAgIHRyLmluc2VydChzdGFydEZyb21PZmZzZXQsIHN0YXJ0Tm9kZSkuc3BsaXQoc3RhcnRGcm9tT2Zmc2V0ICsgY3VzdG9tQmxvY2subGVuZ3RoKTtcbiAgICAgICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSkuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSwgZW5kTm9kZSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgdHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpIC0gKGN1c3RvbUJsb2NrU3ludGF4Lmxlbmd0aCArIDIpKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICByZXR1cm4gQ3VzdG9tQmxvY2s7XG59KE1hcmspKTtcblxudmFyIHJlVGFza01hcmtlcktleSA9IC94fGJhY2tzcGFjZS9pO1xudmFyIHJlVGFza01hcmtlciA9IC9eXFxbKFxccyopKHg/KShcXHMqKVxcXSg/OlxccyspL2k7XG5mdW5jdGlvbiBzbWFydFRhc2soX2EpIHtcbiAgICB2YXIgc2NoZW1hID0gX2Euc2NoZW1hLCB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcms7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAga2V5dXA6IGZ1bmN0aW9uICh2aWV3LCBldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IHZpZXcuc3RhdGUsIGRvYyA9IF9iLmRvYywgdHIgPSBfYi50ciwgc2VsZWN0aW9uID0gX2Iuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmVtcHR5ICYmIHJlVGFza01hcmtlcktleS50ZXN0KGV2LmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYyA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEluZGV4ID0gX2Muc3RhcnRJbmRleCwgc3RhcnRGcm9tT2Zmc2V0ID0gX2Muc3RhcnRGcm9tT2Zmc2V0LCBmcm9tID0gX2MuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhZGQgYDFgIHRvIGxpbmUgZm9yIHRoZSBtYXJrZG93biBwYXJzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgbWFya2Rvd24gcGFyc2VyIGhhcyBgMWAobm90IHplcm8pIGFzIHRoZSBzdGFydCBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZFBvcyA9IFtzdGFydEluZGV4ICsgMSwgZnJvbSAtIHN0YXJ0RnJvbU9mZnNldCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kTm9kZUF0UG9zaXRpb24obWRQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFOb2RlID0gZmluZENsb3Nlc3ROb2RlKG1kTm9kZSwgZnVuY3Rpb24gKG5vZGUpIHsgdmFyIF9hOyByZXR1cm4gbm9kZS50eXBlID09PSAncGFyYWdyYXBoJyAmJiAoKF9hID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gJ2l0ZW0nOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBwYXJhTm9kZSA9PT0gbnVsbCB8fCBwYXJhTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYU5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IHBhcmFOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBmaXJzdENoaWxkLmxpdGVyYWwubWF0Y2gocmVUYXNrTWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRNZFBvcyA9IGZpcnN0Q2hpbGQuc291cmNlcG9zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRTcGFjZXMgPSBtYXRjaGVkWzFdLCBzdGF0ZUNoYXIgPSBtYXRjaGVkWzJdLCBsYXN0U3BhY2VzID0gbWF0Y2hlZFszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwYWNlcyA9IHN0YXJ0U3BhY2VzLmxlbmd0aCArIGxhc3RTcGFjZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBnZXROb2RlQ29udGVudE9mZnNldFJhbmdlKGRvYywgc3RhcnRNZFBvc1swXSAtIDEpLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSBzdGFydE1kUG9zWzFdICsgc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZUNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRlZFBvcyA9IHNwYWNlcyA/IHNwYWNlcyArIDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgoc3RhcnRQb3MsIGFkZGVkUG9zICsgc3RhcnRQb3MsIHNjaGVtYS50ZXh0KHN0YXRlQ2hhcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNwYWNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuaW5zZXJ0VGV4dCgnICcsIHN0YXJ0UG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxudmFyIEVWRU5UX1RZUEUgPSAnY3V0JztcbnZhciByZUxpbmVFbmRpbmckMiA9IC9cXHJcXG58XFxufFxcci87XG52YXIgTWRFZGl0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoTWRFZGl0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRFZGl0b3IoZXZlbnRFbWl0dGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGV2ZW50RW1pdHRlcikgfHwgdGhpcztcbiAgICAgICAgdmFyIHRvYXN0TWFyayA9IG9wdGlvbnMudG9hc3RNYXJrLCBfYSA9IG9wdGlvbnMudXNlQ29tbWFuZFNob3J0Y3V0LCB1c2VDb21tYW5kU2hvcnRjdXQgPSBfYSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9hLCBfYiA9IG9wdGlvbnMubWRQbHVnaW5zLCBtZFBsdWdpbnMgPSBfYiA9PT0gdm9pZCAwID8gW10gOiBfYjtcbiAgICAgICAgX3RoaXMuZWRpdG9yVHlwZSA9ICdtYXJrZG93bic7XG4gICAgICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ21kLW1vZGUnKTtcbiAgICAgICAgX3RoaXMudG9hc3RNYXJrID0gdG9hc3RNYXJrO1xuICAgICAgICBfdGhpcy5leHRyYVBsdWdpbnMgPSBtZFBsdWdpbnM7XG4gICAgICAgIF90aGlzLnNwZWNzID0gX3RoaXMuY3JlYXRlU3BlY3MoKTtcbiAgICAgICAgX3RoaXMuc2NoZW1hID0gX3RoaXMuY3JlYXRlU2NoZW1hKCk7XG4gICAgICAgIF90aGlzLmNvbnRleHQgPSBfdGhpcy5jcmVhdGVDb250ZXh0KCk7XG4gICAgICAgIF90aGlzLmtleW1hcHMgPSBfdGhpcy5jcmVhdGVLZXltYXBzKHVzZUNvbW1hbmRTaG9ydGN1dCk7XG4gICAgICAgIF90aGlzLnZpZXcgPSBfdGhpcy5jcmVhdGVWaWV3KCk7XG4gICAgICAgIF90aGlzLmNvbW1hbmRzID0gX3RoaXMuY3JlYXRlQ29tbWFuZHMoKTtcbiAgICAgICAgX3RoaXMuc3BlY3Muc2V0Q29udGV4dChfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIF90aGlzLmNvbnRleHQpLCB7IHZpZXc6IF90aGlzLnZpZXcgfSkpO1xuICAgICAgICBfdGhpcy5jcmVhdGVDbGlwYm9hcmQoKTtcbiAgICAgICAgLy8gVG8gcHJldmVudCB1bm5lY2Vzc2FyeSBmb2N1cyBzZXR0aW5nIGR1cmluZyBpbml0aWFsIHJlbmRlcmluZ1xuICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VQcmV2aWV3VGFiV3JpdGUnLCBmdW5jdGlvbiAoaXNNYXJrZG93blRhYk1vdW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2dnbGVBY3RpdmUodHJ1ZSwgaXNNYXJrZG93blRhYk1vdW50ZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlUHJldmlld1RhYlByZXZpZXcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50b2dnbGVBY3RpdmUoZmFsc2UpOyB9KTtcbiAgICAgICAgX3RoaXMuaW5pdEV2ZW50KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLnRvZ2dsZUFjdGl2ZSA9IGZ1bmN0aW9uIChhY3RpdmUsIGlzTWFya2Rvd25UYWJNb3VudGVkKSB7XG4gICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWwsICdhY3RpdmUnLCBhY3RpdmUpO1xuICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoIWlzTWFya2Rvd25UYWJNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVDbGlwYm9hcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgdGhpcy5jbGlwYm9hcmQuY2xhc3NOYW1lID0gY2xzKCdwc2V1ZG8tY2xpcGJvYXJkJyk7XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkLmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgY2xpcGJvYXJkRGF0YSA9IGV2LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGE7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBjbGlwYm9hcmREYXRhICYmIGNsaXBib2FyZERhdGEuaXRlbXM7XG4gICAgICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpblJ0Zkl0ZW0gPSB0b0FycmF5XzEoaXRlbXMpLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ua2luZCA9PT0gJ3N0cmluZycgJiYgaXRlbS50eXBlID09PSAndGV4dC9ydGYnOyB9KTtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBjb250YWlucyBydGYsIGl0J3MgbW9zdCBsaWtlbHkgY29weSBwYXN0ZSBmcm9tIG9mZmljZSAtPiBubyBpbWFnZVxuICAgICAgICAgICAgICAgIGlmICghY29udGFpblJ0Zkl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlQmxvYiA9IHBhc3RlSW1hZ2VPbmx5KGl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlQmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRJbWFnZUJsb2JIb29rKF90aGlzLmV2ZW50RW1pdHRlciwgaW1hZ2VCbG9iLCBldi50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHByb2Nlc3MgdGhlIHBhc3RlZCBkYXRhIGluIGlucHV0IGV2ZW50IGZvciBJRTExXG4gICAgICAgIHRoaXMuY2xpcGJvYXJkLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IGV2LnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXYudGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsLmluc2VydEJlZm9yZSh0aGlzLmNsaXBib2FyZCwgdGhpcy52aWV3LmRvbSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvYXN0TWFyazogdGhpcy50b2FzdE1hcmssXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiB0aGlzLmV2ZW50RW1pdHRlcixcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVTcGVjcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTcGVjTWFuYWdlcihbXG4gICAgICAgICAgICBuZXcgRG9jJDEoKSxcbiAgICAgICAgICAgIG5ldyBQYXJhZ3JhcGgkMSgpLFxuICAgICAgICAgICAgbmV3IFdpZGdldCgpLFxuICAgICAgICAgICAgbmV3IFRleHQkMSgpLFxuICAgICAgICAgICAgbmV3IEhlYWRpbmckMSgpLFxuICAgICAgICAgICAgbmV3IEJsb2NrUXVvdGUkMSgpLFxuICAgICAgICAgICAgbmV3IENvZGVCbG9jayQxKCksXG4gICAgICAgICAgICBuZXcgQ3VzdG9tQmxvY2skMSgpLFxuICAgICAgICAgICAgbmV3IFRhYmxlJDEoKSxcbiAgICAgICAgICAgIG5ldyBUYWJsZUNlbGwoKSxcbiAgICAgICAgICAgIG5ldyBUaGVtYXRpY0JyZWFrJDEoKSxcbiAgICAgICAgICAgIG5ldyBMaXN0SXRlbSQxKCksXG4gICAgICAgICAgICBuZXcgU3Ryb25nJDEoKSxcbiAgICAgICAgICAgIG5ldyBTdHJpa2UkMSgpLFxuICAgICAgICAgICAgbmV3IEVtcGgkMSgpLFxuICAgICAgICAgICAgbmV3IENvZGUkMSgpLFxuICAgICAgICAgICAgbmV3IExpbmskMSgpLFxuICAgICAgICAgICAgbmV3IERlbGltaXRlcigpLFxuICAgICAgICAgICAgbmV3IFRhc2tEZWxpbWl0ZXIoKSxcbiAgICAgICAgICAgIG5ldyBNYXJrZWRUZXh0KCksXG4gICAgICAgICAgICBuZXcgTWV0YSgpLFxuICAgICAgICAgICAgbmV3IEh0bWwoKSxcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuY3JlYXRlUGx1Z2lucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkkMShbXG4gICAgICAgICAgICBzeW50YXhIaWdobGlnaHQodGhpcy5jb250ZXh0KSxcbiAgICAgICAgICAgIHByZXZpZXdIaWdobGlnaHQodGhpcy5jb250ZXh0KSxcbiAgICAgICAgICAgIHNtYXJ0VGFzayh0aGlzLmNvbnRleHQpXG4gICAgICAgIF0sIHRoaXMuY3JlYXRlUGx1Z2luUHJvcHMoKSkuY29uY2F0KHRoaXMuZGVmYXVsdFBsdWdpbnMpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yVmlldyh0aGlzLmVsLCB7XG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5jcmVhdGVTdGF0ZSgpLFxuICAgICAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbjogZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlTWFya2Rvd24odHIpO1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IF90aGlzLnZpZXcuc3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGU7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdENoYW5nZUV2ZW50KHRyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGV2Lm1ldGFLZXkgfHwgZXYuY3RybEtleSkgJiYgZXYua2V5LnRvVXBwZXJDYXNlKCkgPT09ICdWJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGlwYm9hcmQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2tleWRvd24nLCBfdGhpcy5lZGl0b3JUeXBlLCBldik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgIGNvcHk6IGZ1bmN0aW9uIChfLCBldikgeyByZXR1cm4gX3RoaXMuY2FwdHVyZUNvcHkoZXYpOyB9LFxuICAgICAgICAgICAgICAgIGN1dDogZnVuY3Rpb24gKF8sIGV2KSB7IHJldHVybiBfdGhpcy5jYXB0dXJlQ29weShldiwgRVZFTlRfVFlQRSk7IH0sXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdzY3JvbGwnLCAnZWRpdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAga2V5dXA6IGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgna2V5dXAnLCBfdGhpcy5lZGl0b3JUeXBlLCBldik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vZGVWaWV3czoge1xuICAgICAgICAgICAgICAgIHdpZGdldDogd2lkZ2V0Tm9kZVZpZXcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVDb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlY3MuY29tbWFuZHModGhpcy52aWV3KTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5jYXB0dXJlQ29weSA9IGZ1bmN0aW9uIChldiwgdHlwZSkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50cjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldENoYW5nZWQoc2VsZWN0aW9uLmNvbnRlbnQoKSk7XG4gICAgICAgIGlmIChldi5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICBldi5jbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGlwYm9hcmREYXRhLnNldERhdGEoJ1RleHQnLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gRVZFTlRfVFlQRSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YSgndWlFdmVudCcsIEVWRU5UX1RZUEUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS51cGRhdGVNYXJrZG93biA9IGZ1bmN0aW9uICh0cikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgdHIuc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcC5zbGljZSAmJiAhKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlQXJvdW5kU3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IHRyLmRvY3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBbc3RlcC5mcm9tLCBzdGVwLnRvXSwgZnJvbSA9IF9hWzBdLCB0byA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBnZXRFZGl0b3JUb01kUG9zKGRvYywgZnJvbSwgdG8pLCBzdGFydFBvcyA9IF9iWzBdLCBlbmRQb3MgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBfdGhpcy5nZXRDaGFuZ2VkKHN0ZXAuc2xpY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRQb3NbMF0gPT09IGVuZFBvc1swXSAmJiBzdGFydFBvc1sxXSA9PT0gZW5kUG9zWzFdICYmIGNoYW5nZWQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRSZXN1bHQgPSBfdGhpcy50b2FzdE1hcmsuZWRpdE1hcmtkb3duKHN0YXJ0UG9zLCBlbmRQb3MsIGNoYW5nZWQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndXBkYXRlUHJldmlldycsIGVkaXRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKCdlZGl0UmVzdWx0JywgZWRpdFJlc3VsdCkuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmdldENoYW5nZWQgPSBmdW5jdGlvbiAoc2xpY2UpIHtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSAnJztcbiAgICAgICAgdmFyIGZyb20gPSAwO1xuICAgICAgICB2YXIgdG8gPSBzbGljZS5jb250ZW50LnNpemU7XG4gICAgICAgIHNsaWNlLmNvbnRlbnQubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkICs9IG5vZGUudGV4dC5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmlzQmxvY2sgJiYgcG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gc3RhcnQ7IH1cbiAgICAgICAgdmFyIHRyID0gdGhpcy52aWV3LnN0YXRlLnRyO1xuICAgICAgICB2YXIgX2EgPSBnZXRNZFRvRWRpdG9yUG9zKHRyLmRvYywgc3RhcnQsIGVuZCksIGZyb20gPSBfYVswXSwgdG8gPSBfYVsxXTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBmcm9tLCB0bykpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLnJlcGxhY2VTZWxlY3Rpb24gPSBmdW5jdGlvbiAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgbmV3VHI7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgc2NoZW1hID0gX2Euc2NoZW1hLCBkb2MgPSBfYS5kb2M7XG4gICAgICAgIHZhciBsaW5lVGV4dHMgPSB0ZXh0LnNwbGl0KHJlTGluZUVuZGluZyQyKTtcbiAgICAgICAgdmFyIG5vZGVzID0gbGluZVRleHRzLm1hcChmdW5jdGlvbiAobGluZVRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQYXJhZ3JhcGgoc2NoZW1hLCBjcmVhdGVOb2Rlc1dpdGhXaWRnZXQobGluZVRleHQsIHNjaGVtYSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obm9kZXMpLCAxLCAxKTtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRNZFRvRWRpdG9yUG9zKGRvYywgc3RhcnQsIGVuZCksIGZyb20gPSBfYlswXSwgdG8gPSBfYlsxXTtcbiAgICAgICAgICAgIG5ld1RyID0gdHIucmVwbGFjZVJhbmdlKGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdUciA9IHRyLnJlcGxhY2VTZWxlY3Rpb24oc2xpY2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaChuZXdUci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5kZWxldGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgbmV3VHI7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgZG9jID0gX2EuZG9jO1xuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRNZFRvRWRpdG9yUG9zKGRvYywgc3RhcnQsIGVuZCksIGZyb20gPSBfYlswXSwgdG8gPSBfYlsxXTtcbiAgICAgICAgICAgIG5ld1RyID0gdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VHIgPSB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2gobmV3VHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRUZXh0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCBkb2MgPSBfYS5kb2MsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyIGZyb20gPSBzZWxlY3Rpb24uZnJvbSwgdG8gPSBzZWxlY3Rpb24udG87XG4gICAgICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBnZXRNZFRvRWRpdG9yUG9zKGRvYywgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICBmcm9tID0gcG9zWzBdO1xuICAgICAgICAgICAgdG8gPSBwb3NbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bywgJ1xcbicpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbiwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG87XG4gICAgICAgIHJldHVybiBnZXRFZGl0b3JUb01kUG9zKHRoaXMudmlldy5zdGF0ZS50ci5kb2MsIGZyb20sIHRvKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5zZXRNYXJrZG93biA9IGZ1bmN0aW9uIChtYXJrZG93biwgY3Vyc29yVG9FbmQpIHtcbiAgICAgICAgaWYgKGN1cnNvclRvRW5kID09PSB2b2lkIDApIHsgY3Vyc29yVG9FbmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciBsaW5lVGV4dHMgPSBtYXJrZG93bi5zcGxpdChyZUxpbmVFbmRpbmckMik7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgZG9jID0gX2EuZG9jLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgIHZhciBub2RlcyA9IGxpbmVUZXh0cy5tYXAoZnVuY3Rpb24gKGxpbmVUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUGFyYWdyYXBoKHNjaGVtYSwgY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KGxpbmVUZXh0LCBzY2hlbWEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5yZXBsYWNlV2l0aCgwLCBkb2MuY29udGVudC5zaXplLCBub2RlcykpO1xuICAgICAgICBpZiAoY3Vyc29yVG9FbmQpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvRW5kKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuYWRkV2lkZ2V0ID0gZnVuY3Rpb24gKG5vZGUsIHN0eWxlLCBtZFBvcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHRyID0gX2EudHIsIGRvYyA9IF9hLmRvYywgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgcG9zID0gbWRQb3MgPyBnZXRNZFRvRWRpdG9yUG9zKGRvYywgbWRQb3MsIG1kUG9zKVswXSA6IHNlbGVjdGlvbi50bztcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnNldE1ldGEoJ3dpZGdldCcsIHsgcG9zOiBwb3MsIG5vZGU6IG5vZGUsIHN0eWxlOiBzdHlsZSB9KSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUucmVwbGFjZVdpdGhXaWRnZXQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGV4dCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHRyID0gX2EudHIsIHNjaGVtYSA9IF9hLnNjaGVtYSwgZG9jID0gX2EuZG9jO1xuICAgICAgICB2YXIgcG9zID0gZ2V0TWRUb0VkaXRvclBvcyhkb2MsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB2YXIgbm9kZXMgPSBjcmVhdGVOb2Rlc1dpdGhXaWRnZXQodGV4dCwgc2NoZW1hKTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnJlcGxhY2VXaXRoKHBvc1swXSwgcG9zWzFdLCBub2RlcykpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmdldFJhbmdlSW5mb09mTm9kZSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCBkb2MgPSBfYS5kb2MsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyIG1kUG9zID0gcG9zIHx8IGdldEVkaXRvclRvTWRQb3MoZG9jLCBzZWxlY3Rpb24uZnJvbSlbMF07XG4gICAgICAgIHZhciBtZE5vZGUgPSB0aGlzLnRvYXN0TWFyay5maW5kTm9kZUF0UG9zaXRpb24obWRQb3MpO1xuICAgICAgICBpZiAobWROb2RlLnR5cGUgPT09ICd0ZXh0JyAmJiBtZE5vZGUucGFyZW50LnR5cGUgIT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICBtZE5vZGUgPSBtZE5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCAxIHN5bmMgZm9yIHByb3NlbWlycm9yIHBvc2l0aW9uXG4gICAgICAgIG1kTm9kZS5zb3VyY2Vwb3NbMV1bMV0gKz0gMTtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IG1kTm9kZS5zb3VyY2Vwb3MsIHR5cGU6IG1kTm9kZS50eXBlIH07XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuZ2V0TWFya2Rvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYXN0TWFya1xuICAgICAgICAgICAgLmdldExpbmVUZXh0cygpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsaW5lVGV4dCkgeyByZXR1cm4gdW53cmFwV2lkZ2V0U3ludGF4KGxpbmVUZXh0KTsgfSlcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5nZXRUb2FzdE1hcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYXN0TWFyaztcbiAgICB9O1xuICAgIHJldHVybiBNZEVkaXRvcjtcbn0oRWRpdG9yQmFzZSkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgR2V0IGV2ZW50IGNvbGxlY3Rpb24gZm9yIHNwZWNpZmljIEhUTUwgZWxlbWVudFxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIEVWRU5UX0tFWSA9ICdfZmVFdmVudEtleSc7XG5cbi8qKlxuICogR2V0IGV2ZW50IGNvbGxlY3Rpb24gZm9yIHNwZWNpZmljIEhUTUwgZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEhUTUwgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudCB0eXBlXG4gKiBAcmV0dXJucyB7YXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYWZlRXZlbnQkMihlbGVtZW50LCB0eXBlKSB7XG4gIHZhciBldmVudHMgPSBlbGVtZW50W0VWRU5UX0tFWV07XG4gIHZhciBoYW5kbGVycztcblxuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IGVsZW1lbnRbRVZFTlRfS0VZXSA9IHt9O1xuICB9XG5cbiAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV07XG4gIGlmICghaGFuZGxlcnMpIHtcbiAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXJzO1xufVxuXG52YXIgX3NhZmVFdmVudCA9IHNhZmVFdmVudCQyO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVW5iaW5kIERPTSBldmVudHNcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc1N0cmluZyQxID0gaXNTdHJpbmdfMTtcbnZhciBmb3JFYWNoJDEgPSBmb3JFYWNoXzE7XG5cbnZhciBzYWZlRXZlbnQkMSA9IF9zYWZlRXZlbnQ7XG5cbi8qKlxuICogVW5iaW5kIERPTSBldmVudHNcbiAqIElmIGEgaGFuZGxlciBmdW5jdGlvbiBpcyBub3QgcGFzc2VkLCByZW1vdmUgYWxsIGV2ZW50cyBvZiB0aGF0IHR5cGUuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byB1bmJpbmQgZXZlbnRzXG4gKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHlwZXMgLSBTcGFjZSBzcGxpdHRlZCBldmVudHMgbmFtZXMgb3IgZXZlbnROYW1lOmhhbmRsZXIgb2JqZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBoYW5kbGVyIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbUV2ZW50XG4gKiBAZXhhbXBsZVxuICogLy8gRm9sbG93aW5nIHRoZSBleGFtcGxlIG9mIGRvbUV2ZW50I29uXG4gKiBcbiAqIC8vIFVuYmluZCBvbmUgZXZlbnQgZnJvbSBhbiBlbGVtZW50LlxuICogb2ZmKGRpdiwgJ2NsaWNrJywgdG9nZ2xlKTtcbiAqIFxuICogLy8gVW5iaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGEgc2FtZSBoYW5kbGVyIGZyb20gbXVsdGlwbGUgZWxlbWVudHMgYXQgb25jZS5cbiAqIC8vIFVzZSBldmVudCBuYW1lcyBzcGxpdHRlZCBieSBhIHNwYWNlLlxuICogb2ZmKGVsZW1lbnQsICdtb3VzZWVudGVyIG1vdXNlbGVhdmUnLCBjaGFuZ2VDb2xvcik7XG4gKiBcbiAqIC8vIFVuYmluZCBtdWx0aXBsZSBldmVudHMgd2l0aCBkaWZmZXJlbnQgaGFuZGxlcnMgZnJvbSBhbiBlbGVtZW50IGF0IG9uY2UuXG4gKiAvLyBVc2UgYW4gb2JqZWN0IHdoaWNoIG9mIGtleSBpcyBhbiBldmVudCBuYW1lIGFuZCB2YWx1ZSBpcyBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gKiBvZmYoZGl2LCB7XG4gKiAgIGtleWRvd246IGhpZ2hsaWdodCxcbiAqICAga2V5dXA6IGRlaGlnaGxpZ2h0XG4gKiB9KTtcbiAqIFxuICogLy8gVW5iaW5kIGV2ZW50cyB3aXRob3V0IGhhbmRsZXJzLlxuICogb2ZmKGRpdiwgJ2RyYWcnKTtcbiAqL1xuZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gIGlmIChpc1N0cmluZyQxKHR5cGVzKSkge1xuICAgIGZvckVhY2gkMSh0eXBlcy5zcGxpdCgvXFxzKy9nKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgdW5iaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBmb3JFYWNoJDEodHlwZXMsIGZ1bmN0aW9uKGZ1bmMsIHR5cGUpIHtcbiAgICB1bmJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBmdW5jKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVW5iaW5kIERPTSBldmVudHNcbiAqIElmIGEgaGFuZGxlciBmdW5jdGlvbiBpcyBub3QgcGFzc2VkLCByZW1vdmUgYWxsIGV2ZW50cyBvZiB0aGF0IHR5cGUuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byB1bmJpbmQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50cyBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBoYW5kbGVyIGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1bmJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBldmVudHMgPSBzYWZlRXZlbnQkMShlbGVtZW50LCB0eXBlKTtcbiAgdmFyIGluZGV4O1xuXG4gIGlmICghaGFuZGxlcikge1xuICAgIGZvckVhY2gkMShldmVudHMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaXRlbS53cmFwcGVkSGFuZGxlcik7XG4gICAgfSk7XG4gICAgZXZlbnRzLnNwbGljZSgwLCBldmVudHMubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoJDEoZXZlbnRzLCBmdW5jdGlvbihpdGVtLCBpZHgpIHtcbiAgICAgIGlmIChoYW5kbGVyID09PSBpdGVtLmhhbmRsZXIpIHtcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCB0eXBlLCBpdGVtLndyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgaW5kZXggPSBpZHg7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gQW4gZWxlbWVudCB0byByZW1vdmUgYW4gZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBlbGVtZW50KSB7XG4gICAgZWxlbWVudC5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XG4gIH1cbn1cblxudmFyIG9mZl8xID0gb2ZmO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQmluZCBET00gZXZlbnRzXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNTdHJpbmcgPSBpc1N0cmluZ18xO1xudmFyIGZvckVhY2ggPSBmb3JFYWNoXzE7XG5cbnZhciBzYWZlRXZlbnQgPSBfc2FmZUV2ZW50O1xuXG4vKipcbiAqIEJpbmQgRE9NIGV2ZW50cy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgZXZlbnRzXG4gKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHlwZXMgLSBTcGFjZSBzcGxpdHRlZCBldmVudHMgbmFtZXMgb3IgZXZlbnROYW1lOmhhbmRsZXIgb2JqZWN0XG4gKiBAcGFyYW0geyhmdW5jdGlvbnxvYmplY3QpfSBoYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiBvciBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZFxuICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSBjb250ZXh0IC0gY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbUV2ZW50XG4gKiBAZXhhbXBsZVxuICogY29uc3QgZGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gKiBcbiAqIC8vIEJpbmQgb25lIGV2ZW50IHRvIGFuIGVsZW1lbnQuXG4gKiBvbihkaXYsICdjbGljaycsIHRvZ2dsZSk7XG4gKiBcbiAqIC8vIEJpbmQgbXVsdGlwbGUgZXZlbnRzIHdpdGggYSBzYW1lIGhhbmRsZXIgdG8gbXVsdGlwbGUgZWxlbWVudHMgYXQgb25jZS5cbiAqIC8vIFVzZSBldmVudCBuYW1lcyBzcGxpdHRlZCBieSBhIHNwYWNlLlxuICogb24oZGl2LCAnbW91c2VlbnRlciBtb3VzZWxlYXZlJywgY2hhbmdlQ29sb3IpO1xuICogXG4gKiAvLyBCaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGRpZmZlcmVudCBoYW5kbGVycyB0byBhbiBlbGVtZW50IGF0IG9uY2UuXG4gKiAvLyBVc2UgYW4gb2JqZWN0IHdoaWNoIG9mIGtleSBpcyBhbiBldmVudCBuYW1lIGFuZCB2YWx1ZSBpcyBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gKiBvbihkaXYsIHtcbiAqICAga2V5ZG93bjogaGlnaGxpZ2h0LFxuICogICBrZXl1cDogZGVoaWdobGlnaHRcbiAqIH0pO1xuICogXG4gKiAvLyBTZXQgYSBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAqIGNvbnN0IG5hbWUgPSAnZ2xvYmFsJztcbiAqIGNvbnN0IHJlcG9zaXRvcnkgPSB7bmFtZTogJ0NvZGVTbmlwcGV0J307XG4gKiBvbihkaXYsICdkcmFnJywgZnVuY3Rpb24oKSB7XG4gKiAgIGNvbnNvbGUubG9nKHRoaXMubmFtZSk7XG4gKiB9LCByZXBvc2l0b3J5KTtcbiAqIC8vIFJlc3VsdCB3aGVuIHlvdSBkcmFnIGEgZGl2OiBcIkNvZGVTbmlwcGV0XCJcbiAqL1xuZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgaWYgKGlzU3RyaW5nKHR5cGVzKSkge1xuICAgIGZvckVhY2godHlwZXMuc3BsaXQoL1xccysvZyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBjb250ZXh0KTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2godHlwZXMsIGZ1bmN0aW9uKGZ1bmMsIHR5cGUpIHtcbiAgICBiaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgZnVuYywgaGFuZGxlcik7XG4gIH0pO1xufVxuXG4vKipcbiAqIEJpbmQgRE9NIGV2ZW50c1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnRzIG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBoYW5kbGVyIGZ1bmN0aW9uIG9yIGNvbnRleHQgZm9yIGhhbmRsZXIgbWV0aG9kXG4gKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIGNvbnRleHQgLSBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIC0gZXZlbnQgb2JqZWN0XG4gICAgICovXG4gIGZ1bmN0aW9uIGV2ZW50SGFuZGxlcihlKSB7XG4gICAgaGFuZGxlci5jYWxsKGNvbnRleHQgfHwgZWxlbWVudCwgZSB8fCB3aW5kb3cuZXZlbnQpO1xuICB9XG5cbiAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBlbGVtZW50KSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGV2ZW50SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBlbGVtZW50KSB7XG4gICAgZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZXZlbnRIYW5kbGVyKTtcbiAgfVxuICBtZW1vcml6ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgZXZlbnRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBNZW1vcml6ZSBET00gZXZlbnQgaGFuZGxlciBmb3IgdW5iaW5kaW5nLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnRzIG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgdXNlciBwYXNzZWQgYXQgb24oKSB1c2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHdyYXBwZWRIYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiB0aGF0IHdyYXBwZWQgYnkgZG9tZXZlbnQgZm9yIGltcGxlbWVudGluZyBzb21lIGZlYXR1cmVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtZW1vcml6ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgd3JhcHBlZEhhbmRsZXIpIHtcbiAgdmFyIGV2ZW50cyA9IHNhZmVFdmVudChlbGVtZW50LCB0eXBlKTtcbiAgdmFyIGV4aXN0SW5FdmVudHMgPSBmYWxzZTtcblxuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICBleGlzdEluRXZlbnRzID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICBpZiAoIWV4aXN0SW5FdmVudHMpIHtcbiAgICBldmVudHMucHVzaCh7XG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgd3JhcHBlZEhhbmRsZXI6IHdyYXBwZWRIYW5kbGVyXG4gICAgfSk7XG4gIH1cbn1cblxudmFyIG9uXzEgPSBvbjtcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG52YXIgZW5jb2RlQ2FjaGUgPSB7fTtcblxuXG4vLyBDcmVhdGUgYSBsb29rdXAgYXJyYXkgd2hlcmUgYW55dGhpbmcgYnV0IGNoYXJhY3RlcnMgaW4gYGNoYXJzYCBzdHJpbmdcbi8vIGFuZCBhbHBoYW51bWVyaWMgY2hhcnMgaXMgcGVyY2VudC1lbmNvZGVkLlxuLy9cbmZ1bmN0aW9uIGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcblxuICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAvLyBhbHdheXMgYWxsb3cgdW5lbmNvZGVkIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCgnJScgKyAoJzAnICsgaS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUkMShzdHJpbmcsIGV4Y2x1ZGUsIGtlZXBFc2NhcGVkKSB7XG4gIHZhciBpLCBsLCBjb2RlLCBuZXh0Q29kZSwgY2FjaGUsXG4gICAgICByZXN1bHQgPSAnJztcblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZW5jb2RlKHN0cmluZywga2VlcEVzY2FwZWQpXG4gICAga2VlcEVzY2FwZWQgID0gZXhjbHVkZTtcbiAgICBleGNsdWRlID0gZW5jb2RlJDEuZGVmYXVsdENoYXJzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZWVwRXNjYXBlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBrZWVwRXNjYXBlZCA9IHRydWU7XG4gIH1cblxuICBjYWNoZSA9IGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGtlZXBFc2NhcGVkICYmIGNvZGUgPT09IDB4MjUgLyogJSAqLyAmJiBpICsgMiA8IGwpIHtcbiAgICAgIGlmICgvXlswLTlhLWZdezJ9JC9pLnRlc3Qoc3RyaW5nLnNsaWNlKGkgKyAxLCBpICsgMykpKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmcuc2xpY2UoaSwgaSArIDMpO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICByZXN1bHQgKz0gY2FjaGVbY29kZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERGRkYpIHtcbiAgICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REJGRiAmJiBpICsgMSA8IGwpIHtcbiAgICAgICAgbmV4dENvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgIGlmIChuZXh0Q29kZSA+PSAweERDMDAgJiYgbmV4dENvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0gKyBzdHJpbmdbaSArIDFdKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnJUVGJUJGJUJEJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmVuY29kZSQxLmRlZmF1bHRDaGFycyAgID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuZW5jb2RlJDEuY29tcG9uZW50Q2hhcnMgPSBcIi1fLiF+KicoKVwiO1xuXG5cbnZhciBlbmNvZGVfMSA9IGVuY29kZSQxO1xuXG52YXIgbGliID0ge307XG5cbnZhciBkZWNvZGUgPSB7fTtcblxudmFyIEFhY3V0ZSQxID0gXCLDgVwiO1xudmFyIGFhY3V0ZSQxID0gXCLDoVwiO1xudmFyIEFicmV2ZSA9IFwixIJcIjtcbnZhciBhYnJldmUgPSBcIsSDXCI7XG52YXIgYWMgPSBcIuKIvlwiO1xudmFyIGFjZCA9IFwi4oi/XCI7XG52YXIgYWNFID0gXCLiiL7Ms1wiO1xudmFyIEFjaXJjJDEgPSBcIsOCXCI7XG52YXIgYWNpcmMkMSA9IFwiw6JcIjtcbnZhciBhY3V0ZSQxID0gXCLCtFwiO1xudmFyIEFjeSA9IFwi0JBcIjtcbnZhciBhY3kgPSBcItCwXCI7XG52YXIgQUVsaWckMSA9IFwiw4ZcIjtcbnZhciBhZWxpZyQxID0gXCLDplwiO1xudmFyIGFmID0gXCLigaFcIjtcbnZhciBBZnIgPSBcIvCdlIRcIjtcbnZhciBhZnIgPSBcIvCdlJ5cIjtcbnZhciBBZ3JhdmUkMSA9IFwiw4BcIjtcbnZhciBhZ3JhdmUkMSA9IFwiw6BcIjtcbnZhciBhbGVmc3ltID0gXCLihLVcIjtcbnZhciBhbGVwaCA9IFwi4oS1XCI7XG52YXIgQWxwaGEgPSBcIs6RXCI7XG52YXIgYWxwaGEgPSBcIs6xXCI7XG52YXIgQW1hY3IgPSBcIsSAXCI7XG52YXIgYW1hY3IgPSBcIsSBXCI7XG52YXIgYW1hbGcgPSBcIuKov1wiO1xudmFyIGFtcCQyID0gXCImXCI7XG52YXIgQU1QJDEgPSBcIiZcIjtcbnZhciBhbmRhbmQgPSBcIuKplVwiO1xudmFyIEFuZCA9IFwi4qmTXCI7XG52YXIgYW5kID0gXCLiiKdcIjtcbnZhciBhbmRkID0gXCLiqZxcIjtcbnZhciBhbmRzbG9wZSA9IFwi4qmYXCI7XG52YXIgYW5kdiA9IFwi4qmaXCI7XG52YXIgYW5nID0gXCLiiKBcIjtcbnZhciBhbmdlID0gXCLipqRcIjtcbnZhciBhbmdsZSA9IFwi4oigXCI7XG52YXIgYW5nbXNkYWEgPSBcIuKmqFwiO1xudmFyIGFuZ21zZGFiID0gXCLipqlcIjtcbnZhciBhbmdtc2RhYyA9IFwi4qaqXCI7XG52YXIgYW5nbXNkYWQgPSBcIuKmq1wiO1xudmFyIGFuZ21zZGFlID0gXCLipqxcIjtcbnZhciBhbmdtc2RhZiA9IFwi4qatXCI7XG52YXIgYW5nbXNkYWcgPSBcIuKmrlwiO1xudmFyIGFuZ21zZGFoID0gXCLipq9cIjtcbnZhciBhbmdtc2QgPSBcIuKIoVwiO1xudmFyIGFuZ3J0ID0gXCLiiJ9cIjtcbnZhciBhbmdydHZiID0gXCLiir5cIjtcbnZhciBhbmdydHZiZCA9IFwi4qadXCI7XG52YXIgYW5nc3BoID0gXCLiiKJcIjtcbnZhciBhbmdzdCA9IFwiw4VcIjtcbnZhciBhbmd6YXJyID0gXCLijbxcIjtcbnZhciBBb2dvbiA9IFwixIRcIjtcbnZhciBhb2dvbiA9IFwixIVcIjtcbnZhciBBb3BmID0gXCLwnZS4XCI7XG52YXIgYW9wZiA9IFwi8J2VklwiO1xudmFyIGFwYWNpciA9IFwi4qmvXCI7XG52YXIgYXAgPSBcIuKJiFwiO1xudmFyIGFwRSA9IFwi4qmwXCI7XG52YXIgYXBlID0gXCLiiYpcIjtcbnZhciBhcGlkID0gXCLiiYtcIjtcbnZhciBhcG9zJDEgPSBcIidcIjtcbnZhciBBcHBseUZ1bmN0aW9uID0gXCLigaFcIjtcbnZhciBhcHByb3ggPSBcIuKJiFwiO1xudmFyIGFwcHJveGVxID0gXCLiiYpcIjtcbnZhciBBcmluZyQxID0gXCLDhVwiO1xudmFyIGFyaW5nJDEgPSBcIsOlXCI7XG52YXIgQXNjciA9IFwi8J2SnFwiO1xudmFyIGFzY3IgPSBcIvCdkrZcIjtcbnZhciBBc3NpZ24gPSBcIuKJlFwiO1xudmFyIGFzdCA9IFwiKlwiO1xudmFyIGFzeW1wID0gXCLiiYhcIjtcbnZhciBhc3ltcGVxID0gXCLiiY1cIjtcbnZhciBBdGlsZGUkMSA9IFwiw4NcIjtcbnZhciBhdGlsZGUkMSA9IFwiw6NcIjtcbnZhciBBdW1sJDEgPSBcIsOEXCI7XG52YXIgYXVtbCQxID0gXCLDpFwiO1xudmFyIGF3Y29uaW50ID0gXCLiiLNcIjtcbnZhciBhd2ludCA9IFwi4qiRXCI7XG52YXIgYmFja2NvbmcgPSBcIuKJjFwiO1xudmFyIGJhY2tlcHNpbG9uID0gXCLPtlwiO1xudmFyIGJhY2twcmltZSA9IFwi4oC1XCI7XG52YXIgYmFja3NpbSA9IFwi4oi9XCI7XG52YXIgYmFja3NpbWVxID0gXCLii41cIjtcbnZhciBCYWNrc2xhc2ggPSBcIuKIllwiO1xudmFyIEJhcnYgPSBcIuKrp1wiO1xudmFyIGJhcnZlZSA9IFwi4oq9XCI7XG52YXIgYmFyd2VkID0gXCLijIVcIjtcbnZhciBCYXJ3ZWQgPSBcIuKMhlwiO1xudmFyIGJhcndlZGdlID0gXCLijIVcIjtcbnZhciBiYnJrID0gXCLijrVcIjtcbnZhciBiYnJrdGJyayA9IFwi4o62XCI7XG52YXIgYmNvbmcgPSBcIuKJjFwiO1xudmFyIEJjeSA9IFwi0JFcIjtcbnZhciBiY3kgPSBcItCxXCI7XG52YXIgYmRxdW8gPSBcIuKAnlwiO1xudmFyIGJlY2F1cyA9IFwi4oi1XCI7XG52YXIgYmVjYXVzZSA9IFwi4oi1XCI7XG52YXIgQmVjYXVzZSA9IFwi4oi1XCI7XG52YXIgYmVtcHR5diA9IFwi4qawXCI7XG52YXIgYmVwc2kgPSBcIs+2XCI7XG52YXIgYmVybm91ID0gXCLihKxcIjtcbnZhciBCZXJub3VsbGlzID0gXCLihKxcIjtcbnZhciBCZXRhID0gXCLOklwiO1xudmFyIGJldGEgPSBcIs6yXCI7XG52YXIgYmV0aCA9IFwi4oS2XCI7XG52YXIgYmV0d2VlbiA9IFwi4omsXCI7XG52YXIgQmZyID0gXCLwnZSFXCI7XG52YXIgYmZyID0gXCLwnZSfXCI7XG52YXIgYmlnY2FwID0gXCLii4JcIjtcbnZhciBiaWdjaXJjID0gXCLil69cIjtcbnZhciBiaWdjdXAgPSBcIuKLg1wiO1xudmFyIGJpZ29kb3QgPSBcIuKogFwiO1xudmFyIGJpZ29wbHVzID0gXCLiqIFcIjtcbnZhciBiaWdvdGltZXMgPSBcIuKoglwiO1xudmFyIGJpZ3NxY3VwID0gXCLiqIZcIjtcbnZhciBiaWdzdGFyID0gXCLimIVcIjtcbnZhciBiaWd0cmlhbmdsZWRvd24gPSBcIuKWvVwiO1xudmFyIGJpZ3RyaWFuZ2xldXAgPSBcIuKWs1wiO1xudmFyIGJpZ3VwbHVzID0gXCLiqIRcIjtcbnZhciBiaWd2ZWUgPSBcIuKLgVwiO1xudmFyIGJpZ3dlZGdlID0gXCLii4BcIjtcbnZhciBia2Fyb3cgPSBcIuKkjVwiO1xudmFyIGJsYWNrbG96ZW5nZSA9IFwi4qerXCI7XG52YXIgYmxhY2tzcXVhcmUgPSBcIuKWqlwiO1xudmFyIGJsYWNrdHJpYW5nbGUgPSBcIuKWtFwiO1xudmFyIGJsYWNrdHJpYW5nbGVkb3duID0gXCLilr5cIjtcbnZhciBibGFja3RyaWFuZ2xlbGVmdCA9IFwi4peCXCI7XG52YXIgYmxhY2t0cmlhbmdsZXJpZ2h0ID0gXCLilrhcIjtcbnZhciBibGFuayA9IFwi4pCjXCI7XG52YXIgYmxrMTIgPSBcIuKWklwiO1xudmFyIGJsazE0ID0gXCLilpFcIjtcbnZhciBibGszNCA9IFwi4paTXCI7XG52YXIgYmxvY2sgPSBcIuKWiFwiO1xudmFyIGJuZSA9IFwiPeKDpVwiO1xudmFyIGJuZXF1aXYgPSBcIuKJoeKDpVwiO1xudmFyIGJOb3QgPSBcIuKrrVwiO1xudmFyIGJub3QgPSBcIuKMkFwiO1xudmFyIEJvcGYgPSBcIvCdlLlcIjtcbnZhciBib3BmID0gXCLwnZWTXCI7XG52YXIgYm90ID0gXCLiiqVcIjtcbnZhciBib3R0b20gPSBcIuKKpVwiO1xudmFyIGJvd3RpZSA9IFwi4ouIXCI7XG52YXIgYm94Ym94ID0gXCLip4lcIjtcbnZhciBib3hkbCA9IFwi4pSQXCI7XG52YXIgYm94ZEwgPSBcIuKVlVwiO1xudmFyIGJveERsID0gXCLilZZcIjtcbnZhciBib3hETCA9IFwi4pWXXCI7XG52YXIgYm94ZHIgPSBcIuKUjFwiO1xudmFyIGJveGRSID0gXCLilZJcIjtcbnZhciBib3hEciA9IFwi4pWTXCI7XG52YXIgYm94RFIgPSBcIuKVlFwiO1xudmFyIGJveGggPSBcIuKUgFwiO1xudmFyIGJveEggPSBcIuKVkFwiO1xudmFyIGJveGhkID0gXCLilKxcIjtcbnZhciBib3hIZCA9IFwi4pWkXCI7XG52YXIgYm94aEQgPSBcIuKVpVwiO1xudmFyIGJveEhEID0gXCLilaZcIjtcbnZhciBib3hodSA9IFwi4pS0XCI7XG52YXIgYm94SHUgPSBcIuKVp1wiO1xudmFyIGJveGhVID0gXCLilahcIjtcbnZhciBib3hIVSA9IFwi4pWpXCI7XG52YXIgYm94bWludXMgPSBcIuKKn1wiO1xudmFyIGJveHBsdXMgPSBcIuKKnlwiO1xudmFyIGJveHRpbWVzID0gXCLiiqBcIjtcbnZhciBib3h1bCA9IFwi4pSYXCI7XG52YXIgYm94dUwgPSBcIuKVm1wiO1xudmFyIGJveFVsID0gXCLilZxcIjtcbnZhciBib3hVTCA9IFwi4pWdXCI7XG52YXIgYm94dXIgPSBcIuKUlFwiO1xudmFyIGJveHVSID0gXCLilZhcIjtcbnZhciBib3hVciA9IFwi4pWZXCI7XG52YXIgYm94VVIgPSBcIuKVmlwiO1xudmFyIGJveHYgPSBcIuKUglwiO1xudmFyIGJveFYgPSBcIuKVkVwiO1xudmFyIGJveHZoID0gXCLilLxcIjtcbnZhciBib3h2SCA9IFwi4pWqXCI7XG52YXIgYm94VmggPSBcIuKVq1wiO1xudmFyIGJveFZIID0gXCLilaxcIjtcbnZhciBib3h2bCA9IFwi4pSkXCI7XG52YXIgYm94dkwgPSBcIuKVoVwiO1xudmFyIGJveFZsID0gXCLilaJcIjtcbnZhciBib3hWTCA9IFwi4pWjXCI7XG52YXIgYm94dnIgPSBcIuKUnFwiO1xudmFyIGJveHZSID0gXCLilZ5cIjtcbnZhciBib3hWciA9IFwi4pWfXCI7XG52YXIgYm94VlIgPSBcIuKVoFwiO1xudmFyIGJwcmltZSA9IFwi4oC1XCI7XG52YXIgYnJldmUgPSBcIsuYXCI7XG52YXIgQnJldmUgPSBcIsuYXCI7XG52YXIgYnJ2YmFyJDEgPSBcIsKmXCI7XG52YXIgYnNjciA9IFwi8J2St1wiO1xudmFyIEJzY3IgPSBcIuKErFwiO1xudmFyIGJzZW1pID0gXCLigY9cIjtcbnZhciBic2ltID0gXCLiiL1cIjtcbnZhciBic2ltZSA9IFwi4ouNXCI7XG52YXIgYnNvbGIgPSBcIuKnhVwiO1xudmFyIGJzb2wgPSBcIlxcXFxcIjtcbnZhciBic29saHN1YiA9IFwi4p+IXCI7XG52YXIgYnVsbCA9IFwi4oCiXCI7XG52YXIgYnVsbGV0ID0gXCLigKJcIjtcbnZhciBidW1wID0gXCLiiY5cIjtcbnZhciBidW1wRSA9IFwi4qquXCI7XG52YXIgYnVtcGUgPSBcIuKJj1wiO1xudmFyIEJ1bXBlcSA9IFwi4omOXCI7XG52YXIgYnVtcGVxID0gXCLiiY9cIjtcbnZhciBDYWN1dGUgPSBcIsSGXCI7XG52YXIgY2FjdXRlID0gXCLEh1wiO1xudmFyIGNhcGFuZCA9IFwi4qmEXCI7XG52YXIgY2FwYnJjdXAgPSBcIuKpiVwiO1xudmFyIGNhcGNhcCA9IFwi4qmLXCI7XG52YXIgY2FwID0gXCLiiKlcIjtcbnZhciBDYXAgPSBcIuKLklwiO1xudmFyIGNhcGN1cCA9IFwi4qmHXCI7XG52YXIgY2FwZG90ID0gXCLiqYBcIjtcbnZhciBDYXBpdGFsRGlmZmVyZW50aWFsRCA9IFwi4oWFXCI7XG52YXIgY2FwcyA9IFwi4oip77iAXCI7XG52YXIgY2FyZXQgPSBcIuKBgVwiO1xudmFyIGNhcm9uID0gXCLLh1wiO1xudmFyIENheWxleXMgPSBcIuKErVwiO1xudmFyIGNjYXBzID0gXCLiqY1cIjtcbnZhciBDY2Fyb24gPSBcIsSMXCI7XG52YXIgY2Nhcm9uID0gXCLEjVwiO1xudmFyIENjZWRpbCQxID0gXCLDh1wiO1xudmFyIGNjZWRpbCQxID0gXCLDp1wiO1xudmFyIENjaXJjID0gXCLEiFwiO1xudmFyIGNjaXJjID0gXCLEiVwiO1xudmFyIENjb25pbnQgPSBcIuKIsFwiO1xudmFyIGNjdXBzID0gXCLiqYxcIjtcbnZhciBjY3Vwc3NtID0gXCLiqZBcIjtcbnZhciBDZG90ID0gXCLEilwiO1xudmFyIGNkb3QgPSBcIsSLXCI7XG52YXIgY2VkaWwkMSA9IFwiwrhcIjtcbnZhciBDZWRpbGxhID0gXCLCuFwiO1xudmFyIGNlbXB0eXYgPSBcIuKmslwiO1xudmFyIGNlbnQkMSA9IFwiwqJcIjtcbnZhciBjZW50ZXJkb3QgPSBcIsK3XCI7XG52YXIgQ2VudGVyRG90ID0gXCLCt1wiO1xudmFyIGNmciA9IFwi8J2UoFwiO1xudmFyIENmciA9IFwi4oStXCI7XG52YXIgQ0hjeSA9IFwi0KdcIjtcbnZhciBjaGN5ID0gXCLRh1wiO1xudmFyIGNoZWNrID0gXCLinJNcIjtcbnZhciBjaGVja21hcmsgPSBcIuKck1wiO1xudmFyIENoaSA9IFwizqdcIjtcbnZhciBjaGkgPSBcIs+HXCI7XG52YXIgY2lyYyA9IFwiy4ZcIjtcbnZhciBjaXJjZXEgPSBcIuKJl1wiO1xudmFyIGNpcmNsZWFycm93bGVmdCA9IFwi4oa6XCI7XG52YXIgY2lyY2xlYXJyb3dyaWdodCA9IFwi4oa7XCI7XG52YXIgY2lyY2xlZGFzdCA9IFwi4oqbXCI7XG52YXIgY2lyY2xlZGNpcmMgPSBcIuKKmlwiO1xudmFyIGNpcmNsZWRkYXNoID0gXCLiip1cIjtcbnZhciBDaXJjbGVEb3QgPSBcIuKKmVwiO1xudmFyIGNpcmNsZWRSID0gXCLCrlwiO1xudmFyIGNpcmNsZWRTID0gXCLik4hcIjtcbnZhciBDaXJjbGVNaW51cyA9IFwi4oqWXCI7XG52YXIgQ2lyY2xlUGx1cyA9IFwi4oqVXCI7XG52YXIgQ2lyY2xlVGltZXMgPSBcIuKKl1wiO1xudmFyIGNpciA9IFwi4peLXCI7XG52YXIgY2lyRSA9IFwi4qeDXCI7XG52YXIgY2lyZSA9IFwi4omXXCI7XG52YXIgY2lyZm5pbnQgPSBcIuKokFwiO1xudmFyIGNpcm1pZCA9IFwi4quvXCI7XG52YXIgY2lyc2NpciA9IFwi4qeCXCI7XG52YXIgQ2xvY2t3aXNlQ29udG91ckludGVncmFsID0gXCLiiLJcIjtcbnZhciBDbG9zZUN1cmx5RG91YmxlUXVvdGUgPSBcIuKAnVwiO1xudmFyIENsb3NlQ3VybHlRdW90ZSA9IFwi4oCZXCI7XG52YXIgY2x1YnMgPSBcIuKZo1wiO1xudmFyIGNsdWJzdWl0ID0gXCLimaNcIjtcbnZhciBjb2xvbiA9IFwiOlwiO1xudmFyIENvbG9uID0gXCLiiLdcIjtcbnZhciBDb2xvbmUgPSBcIuKptFwiO1xudmFyIGNvbG9uZSA9IFwi4omUXCI7XG52YXIgY29sb25lcSA9IFwi4omUXCI7XG52YXIgY29tbWEgPSBcIixcIjtcbnZhciBjb21tYXQgPSBcIkBcIjtcbnZhciBjb21wID0gXCLiiIFcIjtcbnZhciBjb21wZm4gPSBcIuKImFwiO1xudmFyIGNvbXBsZW1lbnQgPSBcIuKIgVwiO1xudmFyIGNvbXBsZXhlcyA9IFwi4oSCXCI7XG52YXIgY29uZyA9IFwi4omFXCI7XG52YXIgY29uZ2RvdCA9IFwi4qmtXCI7XG52YXIgQ29uZ3J1ZW50ID0gXCLiiaFcIjtcbnZhciBjb25pbnQgPSBcIuKIrlwiO1xudmFyIENvbmludCA9IFwi4oivXCI7XG52YXIgQ29udG91ckludGVncmFsID0gXCLiiK5cIjtcbnZhciBjb3BmID0gXCLwnZWUXCI7XG52YXIgQ29wZiA9IFwi4oSCXCI7XG52YXIgY29wcm9kID0gXCLiiJBcIjtcbnZhciBDb3Byb2R1Y3QgPSBcIuKIkFwiO1xudmFyIGNvcHkkMSA9IFwiwqlcIjtcbnZhciBDT1BZJDEgPSBcIsKpXCI7XG52YXIgY29weXNyID0gXCLihJdcIjtcbnZhciBDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsID0gXCLiiLNcIjtcbnZhciBjcmFyciA9IFwi4oa1XCI7XG52YXIgY3Jvc3MgPSBcIuKcl1wiO1xudmFyIENyb3NzID0gXCLiqK9cIjtcbnZhciBDc2NyID0gXCLwnZKeXCI7XG52YXIgY3NjciA9IFwi8J2SuFwiO1xudmFyIGNzdWIgPSBcIuKrj1wiO1xudmFyIGNzdWJlID0gXCLiq5FcIjtcbnZhciBjc3VwID0gXCLiq5BcIjtcbnZhciBjc3VwZSA9IFwi4quSXCI7XG52YXIgY3Rkb3QgPSBcIuKLr1wiO1xudmFyIGN1ZGFycmwgPSBcIuKkuFwiO1xudmFyIGN1ZGFycnIgPSBcIuKktVwiO1xudmFyIGN1ZXByID0gXCLii55cIjtcbnZhciBjdWVzYyA9IFwi4oufXCI7XG52YXIgY3VsYXJyID0gXCLihrZcIjtcbnZhciBjdWxhcnJwID0gXCLipL1cIjtcbnZhciBjdXBicmNhcCA9IFwi4qmIXCI7XG52YXIgY3VwY2FwID0gXCLiqYZcIjtcbnZhciBDdXBDYXAgPSBcIuKJjVwiO1xudmFyIGN1cCA9IFwi4oiqXCI7XG52YXIgQ3VwID0gXCLii5NcIjtcbnZhciBjdXBjdXAgPSBcIuKpilwiO1xudmFyIGN1cGRvdCA9IFwi4oqNXCI7XG52YXIgY3Vwb3IgPSBcIuKphVwiO1xudmFyIGN1cHMgPSBcIuKIqu+4gFwiO1xudmFyIGN1cmFyciA9IFwi4oa3XCI7XG52YXIgY3VyYXJybSA9IFwi4qS8XCI7XG52YXIgY3VybHllcXByZWMgPSBcIuKLnlwiO1xudmFyIGN1cmx5ZXFzdWNjID0gXCLii59cIjtcbnZhciBjdXJseXZlZSA9IFwi4ouOXCI7XG52YXIgY3VybHl3ZWRnZSA9IFwi4ouPXCI7XG52YXIgY3VycmVuJDEgPSBcIsKkXCI7XG52YXIgY3VydmVhcnJvd2xlZnQgPSBcIuKGtlwiO1xudmFyIGN1cnZlYXJyb3dyaWdodCA9IFwi4oa3XCI7XG52YXIgY3V2ZWUgPSBcIuKLjlwiO1xudmFyIGN1d2VkID0gXCLii49cIjtcbnZhciBjd2NvbmludCA9IFwi4oiyXCI7XG52YXIgY3dpbnQgPSBcIuKIsVwiO1xudmFyIGN5bGN0eSA9IFwi4oytXCI7XG52YXIgZGFnZ2VyID0gXCLigKBcIjtcbnZhciBEYWdnZXIgPSBcIuKAoVwiO1xudmFyIGRhbGV0aCA9IFwi4oS4XCI7XG52YXIgZGFyciA9IFwi4oaTXCI7XG52YXIgRGFyciA9IFwi4oahXCI7XG52YXIgZEFyciA9IFwi4oeTXCI7XG52YXIgZGFzaCA9IFwi4oCQXCI7XG52YXIgRGFzaHYgPSBcIuKrpFwiO1xudmFyIGRhc2h2ID0gXCLiiqNcIjtcbnZhciBkYmthcm93ID0gXCLipI9cIjtcbnZhciBkYmxhYyA9IFwiy51cIjtcbnZhciBEY2Fyb24gPSBcIsSOXCI7XG52YXIgZGNhcm9uID0gXCLEj1wiO1xudmFyIERjeSA9IFwi0JRcIjtcbnZhciBkY3kgPSBcItC0XCI7XG52YXIgZGRhZ2dlciA9IFwi4oChXCI7XG52YXIgZGRhcnIgPSBcIuKHilwiO1xudmFyIEREID0gXCLihYVcIjtcbnZhciBkZCA9IFwi4oWGXCI7XG52YXIgRERvdHJhaGQgPSBcIuKkkVwiO1xudmFyIGRkb3RzZXEgPSBcIuKpt1wiO1xudmFyIGRlZyQxID0gXCLCsFwiO1xudmFyIERlbCA9IFwi4oiHXCI7XG52YXIgRGVsdGEgPSBcIs6UXCI7XG52YXIgZGVsdGEgPSBcIs60XCI7XG52YXIgZGVtcHR5diA9IFwi4qaxXCI7XG52YXIgZGZpc2h0ID0gXCLipb9cIjtcbnZhciBEZnIgPSBcIvCdlIdcIjtcbnZhciBkZnIgPSBcIvCdlKFcIjtcbnZhciBkSGFyID0gXCLipaVcIjtcbnZhciBkaGFybCA9IFwi4oeDXCI7XG52YXIgZGhhcnIgPSBcIuKHglwiO1xudmFyIERpYWNyaXRpY2FsQWN1dGUgPSBcIsK0XCI7XG52YXIgRGlhY3JpdGljYWxEb3QgPSBcIsuZXCI7XG52YXIgRGlhY3JpdGljYWxEb3VibGVBY3V0ZSA9IFwiy51cIjtcbnZhciBEaWFjcml0aWNhbEdyYXZlID0gXCJgXCI7XG52YXIgRGlhY3JpdGljYWxUaWxkZSA9IFwiy5xcIjtcbnZhciBkaWFtID0gXCLii4RcIjtcbnZhciBkaWFtb25kID0gXCLii4RcIjtcbnZhciBEaWFtb25kID0gXCLii4RcIjtcbnZhciBkaWFtb25kc3VpdCA9IFwi4pmmXCI7XG52YXIgZGlhbXMgPSBcIuKZplwiO1xudmFyIGRpZSA9IFwiwqhcIjtcbnZhciBEaWZmZXJlbnRpYWxEID0gXCLihYZcIjtcbnZhciBkaWdhbW1hID0gXCLPnVwiO1xudmFyIGRpc2luID0gXCLii7JcIjtcbnZhciBkaXYgPSBcIsO3XCI7XG52YXIgZGl2aWRlJDEgPSBcIsO3XCI7XG52YXIgZGl2aWRlb250aW1lcyA9IFwi4ouHXCI7XG52YXIgZGl2b254ID0gXCLii4dcIjtcbnZhciBESmN5ID0gXCLQglwiO1xudmFyIGRqY3kgPSBcItGSXCI7XG52YXIgZGxjb3JuID0gXCLijJ5cIjtcbnZhciBkbGNyb3AgPSBcIuKMjVwiO1xudmFyIGRvbGxhciA9IFwiJFwiO1xudmFyIERvcGYgPSBcIvCdlLtcIjtcbnZhciBkb3BmID0gXCLwnZWVXCI7XG52YXIgRG90ID0gXCLCqFwiO1xudmFyIGRvdCA9IFwiy5lcIjtcbnZhciBEb3REb3QgPSBcIuKDnFwiO1xudmFyIGRvdGVxID0gXCLiiZBcIjtcbnZhciBkb3RlcWRvdCA9IFwi4omRXCI7XG52YXIgRG90RXF1YWwgPSBcIuKJkFwiO1xudmFyIGRvdG1pbnVzID0gXCLiiLhcIjtcbnZhciBkb3RwbHVzID0gXCLiiJRcIjtcbnZhciBkb3RzcXVhcmUgPSBcIuKKoVwiO1xudmFyIGRvdWJsZWJhcndlZGdlID0gXCLijIZcIjtcbnZhciBEb3VibGVDb250b3VySW50ZWdyYWwgPSBcIuKIr1wiO1xudmFyIERvdWJsZURvdCA9IFwiwqhcIjtcbnZhciBEb3VibGVEb3duQXJyb3cgPSBcIuKHk1wiO1xudmFyIERvdWJsZUxlZnRBcnJvdyA9IFwi4oeQXCI7XG52YXIgRG91YmxlTGVmdFJpZ2h0QXJyb3cgPSBcIuKHlFwiO1xudmFyIERvdWJsZUxlZnRUZWUgPSBcIuKrpFwiO1xudmFyIERvdWJsZUxvbmdMZWZ0QXJyb3cgPSBcIuKfuFwiO1xudmFyIERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyA9IFwi4p+6XCI7XG52YXIgRG91YmxlTG9uZ1JpZ2h0QXJyb3cgPSBcIuKfuVwiO1xudmFyIERvdWJsZVJpZ2h0QXJyb3cgPSBcIuKHklwiO1xudmFyIERvdWJsZVJpZ2h0VGVlID0gXCLiiqhcIjtcbnZhciBEb3VibGVVcEFycm93ID0gXCLih5FcIjtcbnZhciBEb3VibGVVcERvd25BcnJvdyA9IFwi4oeVXCI7XG52YXIgRG91YmxlVmVydGljYWxCYXIgPSBcIuKIpVwiO1xudmFyIERvd25BcnJvd0JhciA9IFwi4qSTXCI7XG52YXIgZG93bmFycm93ID0gXCLihpNcIjtcbnZhciBEb3duQXJyb3cgPSBcIuKGk1wiO1xudmFyIERvd25hcnJvdyA9IFwi4oeTXCI7XG52YXIgRG93bkFycm93VXBBcnJvdyA9IFwi4oe1XCI7XG52YXIgRG93bkJyZXZlID0gXCLMkVwiO1xudmFyIGRvd25kb3duYXJyb3dzID0gXCLih4pcIjtcbnZhciBkb3duaGFycG9vbmxlZnQgPSBcIuKHg1wiO1xudmFyIGRvd25oYXJwb29ucmlnaHQgPSBcIuKHglwiO1xudmFyIERvd25MZWZ0UmlnaHRWZWN0b3IgPSBcIuKlkFwiO1xudmFyIERvd25MZWZ0VGVlVmVjdG9yID0gXCLipZ5cIjtcbnZhciBEb3duTGVmdFZlY3RvckJhciA9IFwi4qWWXCI7XG52YXIgRG93bkxlZnRWZWN0b3IgPSBcIuKGvVwiO1xudmFyIERvd25SaWdodFRlZVZlY3RvciA9IFwi4qWfXCI7XG52YXIgRG93blJpZ2h0VmVjdG9yQmFyID0gXCLipZdcIjtcbnZhciBEb3duUmlnaHRWZWN0b3IgPSBcIuKHgVwiO1xudmFyIERvd25UZWVBcnJvdyA9IFwi4oanXCI7XG52YXIgRG93blRlZSA9IFwi4oqkXCI7XG52YXIgZHJia2Fyb3cgPSBcIuKkkFwiO1xudmFyIGRyY29ybiA9IFwi4oyfXCI7XG52YXIgZHJjcm9wID0gXCLijIxcIjtcbnZhciBEc2NyID0gXCLwnZKfXCI7XG52YXIgZHNjciA9IFwi8J2SuVwiO1xudmFyIERTY3kgPSBcItCFXCI7XG52YXIgZHNjeSA9IFwi0ZVcIjtcbnZhciBkc29sID0gXCLip7ZcIjtcbnZhciBEc3Ryb2sgPSBcIsSQXCI7XG52YXIgZHN0cm9rID0gXCLEkVwiO1xudmFyIGR0ZG90ID0gXCLii7FcIjtcbnZhciBkdHJpID0gXCLilr9cIjtcbnZhciBkdHJpZiA9IFwi4pa+XCI7XG52YXIgZHVhcnIgPSBcIuKHtVwiO1xudmFyIGR1aGFyID0gXCLipa9cIjtcbnZhciBkd2FuZ2xlID0gXCLipqZcIjtcbnZhciBEWmN5ID0gXCLQj1wiO1xudmFyIGR6Y3kgPSBcItGfXCI7XG52YXIgZHppZ3JhcnIgPSBcIuKfv1wiO1xudmFyIEVhY3V0ZSQxID0gXCLDiVwiO1xudmFyIGVhY3V0ZSQxID0gXCLDqVwiO1xudmFyIGVhc3RlciA9IFwi4qmuXCI7XG52YXIgRWNhcm9uID0gXCLEmlwiO1xudmFyIGVjYXJvbiA9IFwixJtcIjtcbnZhciBFY2lyYyQxID0gXCLDilwiO1xudmFyIGVjaXJjJDEgPSBcIsOqXCI7XG52YXIgZWNpciA9IFwi4omWXCI7XG52YXIgZWNvbG9uID0gXCLiiZVcIjtcbnZhciBFY3kgPSBcItCtXCI7XG52YXIgZWN5ID0gXCLRjVwiO1xudmFyIGVERG90ID0gXCLiqbdcIjtcbnZhciBFZG90ID0gXCLEllwiO1xudmFyIGVkb3QgPSBcIsSXXCI7XG52YXIgZURvdCA9IFwi4omRXCI7XG52YXIgZWUgPSBcIuKFh1wiO1xudmFyIGVmRG90ID0gXCLiiZJcIjtcbnZhciBFZnIgPSBcIvCdlIhcIjtcbnZhciBlZnIgPSBcIvCdlKJcIjtcbnZhciBlZyA9IFwi4qqaXCI7XG52YXIgRWdyYXZlJDEgPSBcIsOIXCI7XG52YXIgZWdyYXZlJDEgPSBcIsOoXCI7XG52YXIgZWdzID0gXCLiqpZcIjtcbnZhciBlZ3Nkb3QgPSBcIuKqmFwiO1xudmFyIGVsID0gXCLiqplcIjtcbnZhciBFbGVtZW50JDEgPSBcIuKIiFwiO1xudmFyIGVsaW50ZXJzID0gXCLij6dcIjtcbnZhciBlbGwgPSBcIuKEk1wiO1xudmFyIGVscyA9IFwi4qqVXCI7XG52YXIgZWxzZG90ID0gXCLiqpdcIjtcbnZhciBFbWFjciA9IFwixJJcIjtcbnZhciBlbWFjciA9IFwixJNcIjtcbnZhciBlbXB0eSA9IFwi4oiFXCI7XG52YXIgZW1wdHlzZXQgPSBcIuKIhVwiO1xudmFyIEVtcHR5U21hbGxTcXVhcmUgPSBcIuKXu1wiO1xudmFyIGVtcHR5diA9IFwi4oiFXCI7XG52YXIgRW1wdHlWZXJ5U21hbGxTcXVhcmUgPSBcIuKWq1wiO1xudmFyIGVtc3AxMyA9IFwi4oCEXCI7XG52YXIgZW1zcDE0ID0gXCLigIVcIjtcbnZhciBlbXNwID0gXCLigINcIjtcbnZhciBFTkcgPSBcIsWKXCI7XG52YXIgZW5nID0gXCLFi1wiO1xudmFyIGVuc3AgPSBcIuKAglwiO1xudmFyIEVvZ29uID0gXCLEmFwiO1xudmFyIGVvZ29uID0gXCLEmVwiO1xudmFyIEVvcGYgPSBcIvCdlLxcIjtcbnZhciBlb3BmID0gXCLwnZWWXCI7XG52YXIgZXBhciA9IFwi4ouVXCI7XG52YXIgZXBhcnNsID0gXCLip6NcIjtcbnZhciBlcGx1cyA9IFwi4qmxXCI7XG52YXIgZXBzaSA9IFwizrVcIjtcbnZhciBFcHNpbG9uID0gXCLOlVwiO1xudmFyIGVwc2lsb24gPSBcIs61XCI7XG52YXIgZXBzaXYgPSBcIs+1XCI7XG52YXIgZXFjaXJjID0gXCLiiZZcIjtcbnZhciBlcWNvbG9uID0gXCLiiZVcIjtcbnZhciBlcXNpbSA9IFwi4omCXCI7XG52YXIgZXFzbGFudGd0ciA9IFwi4qqWXCI7XG52YXIgZXFzbGFudGxlc3MgPSBcIuKqlVwiO1xudmFyIEVxdWFsID0gXCLiqbVcIjtcbnZhciBlcXVhbHMgPSBcIj1cIjtcbnZhciBFcXVhbFRpbGRlID0gXCLiiYJcIjtcbnZhciBlcXVlc3QgPSBcIuKJn1wiO1xudmFyIEVxdWlsaWJyaXVtID0gXCLih4xcIjtcbnZhciBlcXVpdiA9IFwi4omhXCI7XG52YXIgZXF1aXZERCA9IFwi4qm4XCI7XG52YXIgZXF2cGFyc2wgPSBcIuKnpVwiO1xudmFyIGVyYXJyID0gXCLipbFcIjtcbnZhciBlckRvdCA9IFwi4omTXCI7XG52YXIgZXNjciA9IFwi4oSvXCI7XG52YXIgRXNjciA9IFwi4oSwXCI7XG52YXIgZXNkb3QgPSBcIuKJkFwiO1xudmFyIEVzaW0gPSBcIuKps1wiO1xudmFyIGVzaW0gPSBcIuKJglwiO1xudmFyIEV0YSA9IFwizpdcIjtcbnZhciBldGEgPSBcIs63XCI7XG52YXIgRVRIJDEgPSBcIsOQXCI7XG52YXIgZXRoJDEgPSBcIsOwXCI7XG52YXIgRXVtbCQxID0gXCLDi1wiO1xudmFyIGV1bWwkMSA9IFwiw6tcIjtcbnZhciBldXJvID0gXCLigqxcIjtcbnZhciBleGNsID0gXCIhXCI7XG52YXIgZXhpc3QgPSBcIuKIg1wiO1xudmFyIEV4aXN0cyA9IFwi4oiDXCI7XG52YXIgZXhwZWN0YXRpb24gPSBcIuKEsFwiO1xudmFyIGV4cG9uZW50aWFsZSA9IFwi4oWHXCI7XG52YXIgRXhwb25lbnRpYWxFID0gXCLihYdcIjtcbnZhciBmYWxsaW5nZG90c2VxID0gXCLiiZJcIjtcbnZhciBGY3kgPSBcItCkXCI7XG52YXIgZmN5ID0gXCLRhFwiO1xudmFyIGZlbWFsZSA9IFwi4pmAXCI7XG52YXIgZmZpbGlnID0gXCLvrINcIjtcbnZhciBmZmxpZyA9IFwi76yAXCI7XG52YXIgZmZsbGlnID0gXCLvrIRcIjtcbnZhciBGZnIgPSBcIvCdlIlcIjtcbnZhciBmZnIgPSBcIvCdlKNcIjtcbnZhciBmaWxpZyA9IFwi76yBXCI7XG52YXIgRmlsbGVkU21hbGxTcXVhcmUgPSBcIuKXvFwiO1xudmFyIEZpbGxlZFZlcnlTbWFsbFNxdWFyZSA9IFwi4paqXCI7XG52YXIgZmpsaWcgPSBcImZqXCI7XG52YXIgZmxhdCA9IFwi4pmtXCI7XG52YXIgZmxsaWcgPSBcIu+sglwiO1xudmFyIGZsdG5zID0gXCLilrFcIjtcbnZhciBmbm9mID0gXCLGklwiO1xudmFyIEZvcGYgPSBcIvCdlL1cIjtcbnZhciBmb3BmID0gXCLwnZWXXCI7XG52YXIgZm9yYWxsID0gXCLiiIBcIjtcbnZhciBGb3JBbGwgPSBcIuKIgFwiO1xudmFyIGZvcmsgPSBcIuKLlFwiO1xudmFyIGZvcmt2ID0gXCLiq5lcIjtcbnZhciBGb3VyaWVydHJmID0gXCLihLFcIjtcbnZhciBmcGFydGludCA9IFwi4qiNXCI7XG52YXIgZnJhYzEyJDEgPSBcIsK9XCI7XG52YXIgZnJhYzEzID0gXCLihZNcIjtcbnZhciBmcmFjMTQkMSA9IFwiwrxcIjtcbnZhciBmcmFjMTUgPSBcIuKFlVwiO1xudmFyIGZyYWMxNiA9IFwi4oWZXCI7XG52YXIgZnJhYzE4ID0gXCLihZtcIjtcbnZhciBmcmFjMjMgPSBcIuKFlFwiO1xudmFyIGZyYWMyNSA9IFwi4oWWXCI7XG52YXIgZnJhYzM0JDEgPSBcIsK+XCI7XG52YXIgZnJhYzM1ID0gXCLihZdcIjtcbnZhciBmcmFjMzggPSBcIuKFnFwiO1xudmFyIGZyYWM0NSA9IFwi4oWYXCI7XG52YXIgZnJhYzU2ID0gXCLihZpcIjtcbnZhciBmcmFjNTggPSBcIuKFnVwiO1xudmFyIGZyYWM3OCA9IFwi4oWeXCI7XG52YXIgZnJhc2wgPSBcIuKBhFwiO1xudmFyIGZyb3duID0gXCLijKJcIjtcbnZhciBmc2NyID0gXCLwnZK7XCI7XG52YXIgRnNjciA9IFwi4oSxXCI7XG52YXIgZ2FjdXRlID0gXCLHtVwiO1xudmFyIEdhbW1hID0gXCLOk1wiO1xudmFyIGdhbW1hID0gXCLOs1wiO1xudmFyIEdhbW1hZCA9IFwiz5xcIjtcbnZhciBnYW1tYWQgPSBcIs+dXCI7XG52YXIgZ2FwID0gXCLiqoZcIjtcbnZhciBHYnJldmUgPSBcIsSeXCI7XG52YXIgZ2JyZXZlID0gXCLEn1wiO1xudmFyIEdjZWRpbCA9IFwixKJcIjtcbnZhciBHY2lyYyA9IFwixJxcIjtcbnZhciBnY2lyYyA9IFwixJ1cIjtcbnZhciBHY3kgPSBcItCTXCI7XG52YXIgZ2N5ID0gXCLQs1wiO1xudmFyIEdkb3QgPSBcIsSgXCI7XG52YXIgZ2RvdCA9IFwixKFcIjtcbnZhciBnZSA9IFwi4omlXCI7XG52YXIgZ0UgPSBcIuKJp1wiO1xudmFyIGdFbCA9IFwi4qqMXCI7XG52YXIgZ2VsID0gXCLii5tcIjtcbnZhciBnZXEgPSBcIuKJpVwiO1xudmFyIGdlcXEgPSBcIuKJp1wiO1xudmFyIGdlcXNsYW50ID0gXCLiqb5cIjtcbnZhciBnZXNjYyA9IFwi4qqpXCI7XG52YXIgZ2VzID0gXCLiqb5cIjtcbnZhciBnZXNkb3QgPSBcIuKqgFwiO1xudmFyIGdlc2RvdG8gPSBcIuKqglwiO1xudmFyIGdlc2RvdG9sID0gXCLiqoRcIjtcbnZhciBnZXNsID0gXCLii5vvuIBcIjtcbnZhciBnZXNsZXMgPSBcIuKqlFwiO1xudmFyIEdmciA9IFwi8J2UilwiO1xudmFyIGdmciA9IFwi8J2UpFwiO1xudmFyIGdnID0gXCLiiatcIjtcbnZhciBHZyA9IFwi4ouZXCI7XG52YXIgZ2dnID0gXCLii5lcIjtcbnZhciBnaW1lbCA9IFwi4oS3XCI7XG52YXIgR0pjeSA9IFwi0INcIjtcbnZhciBnamN5ID0gXCLRk1wiO1xudmFyIGdsYSA9IFwi4qqlXCI7XG52YXIgZ2wgPSBcIuKJt1wiO1xudmFyIGdsRSA9IFwi4qqSXCI7XG52YXIgZ2xqID0gXCLiqqRcIjtcbnZhciBnbmFwID0gXCLiqopcIjtcbnZhciBnbmFwcHJveCA9IFwi4qqKXCI7XG52YXIgZ25lID0gXCLiqohcIjtcbnZhciBnbkUgPSBcIuKJqVwiO1xudmFyIGduZXEgPSBcIuKqiFwiO1xudmFyIGduZXFxID0gXCLiialcIjtcbnZhciBnbnNpbSA9IFwi4ounXCI7XG52YXIgR29wZiA9IFwi8J2UvlwiO1xudmFyIGdvcGYgPSBcIvCdlZhcIjtcbnZhciBncmF2ZSA9IFwiYFwiO1xudmFyIEdyZWF0ZXJFcXVhbCA9IFwi4omlXCI7XG52YXIgR3JlYXRlckVxdWFsTGVzcyA9IFwi4oubXCI7XG52YXIgR3JlYXRlckZ1bGxFcXVhbCA9IFwi4omnXCI7XG52YXIgR3JlYXRlckdyZWF0ZXIgPSBcIuKqolwiO1xudmFyIEdyZWF0ZXJMZXNzID0gXCLiibdcIjtcbnZhciBHcmVhdGVyU2xhbnRFcXVhbCA9IFwi4qm+XCI7XG52YXIgR3JlYXRlclRpbGRlID0gXCLiibNcIjtcbnZhciBHc2NyID0gXCLwnZKiXCI7XG52YXIgZ3NjciA9IFwi4oSKXCI7XG52YXIgZ3NpbSA9IFwi4omzXCI7XG52YXIgZ3NpbWUgPSBcIuKqjlwiO1xudmFyIGdzaW1sID0gXCLiqpBcIjtcbnZhciBndGNjID0gXCLiqqdcIjtcbnZhciBndGNpciA9IFwi4qm6XCI7XG52YXIgZ3QkMiA9IFwiPlwiO1xudmFyIEdUJDEgPSBcIj5cIjtcbnZhciBHdCA9IFwi4omrXCI7XG52YXIgZ3Rkb3QgPSBcIuKLl1wiO1xudmFyIGd0bFBhciA9IFwi4qaVXCI7XG52YXIgZ3RxdWVzdCA9IFwi4qm8XCI7XG52YXIgZ3RyYXBwcm94ID0gXCLiqoZcIjtcbnZhciBndHJhcnIgPSBcIuKluFwiO1xudmFyIGd0cmRvdCA9IFwi4ouXXCI7XG52YXIgZ3RyZXFsZXNzID0gXCLii5tcIjtcbnZhciBndHJlcXFsZXNzID0gXCLiqoxcIjtcbnZhciBndHJsZXNzID0gXCLiibdcIjtcbnZhciBndHJzaW0gPSBcIuKJs1wiO1xudmFyIGd2ZXJ0bmVxcSA9IFwi4omp77iAXCI7XG52YXIgZ3ZuRSA9IFwi4omp77iAXCI7XG52YXIgSGFjZWsgPSBcIsuHXCI7XG52YXIgaGFpcnNwID0gXCLigIpcIjtcbnZhciBoYWxmID0gXCLCvVwiO1xudmFyIGhhbWlsdCA9IFwi4oSLXCI7XG52YXIgSEFSRGN5ID0gXCLQqlwiO1xudmFyIGhhcmRjeSA9IFwi0YpcIjtcbnZhciBoYXJyY2lyID0gXCLipYhcIjtcbnZhciBoYXJyID0gXCLihpRcIjtcbnZhciBoQXJyID0gXCLih5RcIjtcbnZhciBoYXJydyA9IFwi4oatXCI7XG52YXIgSGF0ID0gXCJeXCI7XG52YXIgaGJhciA9IFwi4oSPXCI7XG52YXIgSGNpcmMgPSBcIsSkXCI7XG52YXIgaGNpcmMgPSBcIsSlXCI7XG52YXIgaGVhcnRzID0gXCLimaVcIjtcbnZhciBoZWFydHN1aXQgPSBcIuKZpVwiO1xudmFyIGhlbGxpcCA9IFwi4oCmXCI7XG52YXIgaGVyY29uID0gXCLiirlcIjtcbnZhciBoZnIgPSBcIvCdlKVcIjtcbnZhciBIZnIgPSBcIuKEjFwiO1xudmFyIEhpbGJlcnRTcGFjZSA9IFwi4oSLXCI7XG52YXIgaGtzZWFyb3cgPSBcIuKkpVwiO1xudmFyIGhrc3dhcm93ID0gXCLipKZcIjtcbnZhciBob2FyciA9IFwi4oe/XCI7XG52YXIgaG9tdGh0ID0gXCLiiLtcIjtcbnZhciBob29rbGVmdGFycm93ID0gXCLihqlcIjtcbnZhciBob29rcmlnaHRhcnJvdyA9IFwi4oaqXCI7XG52YXIgaG9wZiA9IFwi8J2VmVwiO1xudmFyIEhvcGYgPSBcIuKEjVwiO1xudmFyIGhvcmJhciA9IFwi4oCVXCI7XG52YXIgSG9yaXpvbnRhbExpbmUgPSBcIuKUgFwiO1xudmFyIGhzY3IgPSBcIvCdkr1cIjtcbnZhciBIc2NyID0gXCLihItcIjtcbnZhciBoc2xhc2ggPSBcIuKEj1wiO1xudmFyIEhzdHJvayA9IFwixKZcIjtcbnZhciBoc3Ryb2sgPSBcIsSnXCI7XG52YXIgSHVtcERvd25IdW1wID0gXCLiiY5cIjtcbnZhciBIdW1wRXF1YWwgPSBcIuKJj1wiO1xudmFyIGh5YnVsbCA9IFwi4oGDXCI7XG52YXIgaHlwaGVuID0gXCLigJBcIjtcbnZhciBJYWN1dGUkMSA9IFwiw41cIjtcbnZhciBpYWN1dGUkMSA9IFwiw61cIjtcbnZhciBpYyA9IFwi4oGjXCI7XG52YXIgSWNpcmMkMSA9IFwiw45cIjtcbnZhciBpY2lyYyQxID0gXCLDrlwiO1xudmFyIEljeSA9IFwi0JhcIjtcbnZhciBpY3kgPSBcItC4XCI7XG52YXIgSWRvdCA9IFwixLBcIjtcbnZhciBJRWN5ID0gXCLQlVwiO1xudmFyIGllY3kgPSBcItC1XCI7XG52YXIgaWV4Y2wkMSA9IFwiwqFcIjtcbnZhciBpZmYgPSBcIuKHlFwiO1xudmFyIGlmciA9IFwi8J2UplwiO1xudmFyIElmciA9IFwi4oSRXCI7XG52YXIgSWdyYXZlJDEgPSBcIsOMXCI7XG52YXIgaWdyYXZlJDEgPSBcIsOsXCI7XG52YXIgaWkgPSBcIuKFiFwiO1xudmFyIGlpaWludCA9IFwi4qiMXCI7XG52YXIgaWlpbnQgPSBcIuKIrVwiO1xudmFyIGlpbmZpbiA9IFwi4qecXCI7XG52YXIgaWlvdGEgPSBcIuKEqVwiO1xudmFyIElKbGlnID0gXCLEslwiO1xudmFyIGlqbGlnID0gXCLEs1wiO1xudmFyIEltYWNyID0gXCLEqlwiO1xudmFyIGltYWNyID0gXCLEq1wiO1xudmFyIGltYWdlID0gXCLihJFcIjtcbnZhciBJbWFnaW5hcnlJID0gXCLihYhcIjtcbnZhciBpbWFnbGluZSA9IFwi4oSQXCI7XG52YXIgaW1hZ3BhcnQgPSBcIuKEkVwiO1xudmFyIGltYXRoID0gXCLEsVwiO1xudmFyIEltID0gXCLihJFcIjtcbnZhciBpbW9mID0gXCLiirdcIjtcbnZhciBpbXBlZCA9IFwixrVcIjtcbnZhciBJbXBsaWVzID0gXCLih5JcIjtcbnZhciBpbmNhcmUgPSBcIuKEhVwiO1xudmFyIGluZmluID0gXCLiiJ5cIjtcbnZhciBpbmZpbnRpZSA9IFwi4qedXCI7XG52YXIgaW5vZG90ID0gXCLEsVwiO1xudmFyIGludGNhbCA9IFwi4oq6XCI7XG52YXIgaW50ID0gXCLiiKtcIjtcbnZhciBJbnQgPSBcIuKIrFwiO1xudmFyIGludGVnZXJzID0gXCLihKRcIjtcbnZhciBJbnRlZ3JhbCA9IFwi4oirXCI7XG52YXIgaW50ZXJjYWwgPSBcIuKKulwiO1xudmFyIEludGVyc2VjdGlvbiA9IFwi4ouCXCI7XG52YXIgaW50bGFyaGsgPSBcIuKol1wiO1xudmFyIGludHByb2QgPSBcIuKovFwiO1xudmFyIEludmlzaWJsZUNvbW1hID0gXCLigaNcIjtcbnZhciBJbnZpc2libGVUaW1lcyA9IFwi4oGiXCI7XG52YXIgSU9jeSA9IFwi0IFcIjtcbnZhciBpb2N5ID0gXCLRkVwiO1xudmFyIElvZ29uID0gXCLErlwiO1xudmFyIGlvZ29uID0gXCLEr1wiO1xudmFyIElvcGYgPSBcIvCdlYBcIjtcbnZhciBpb3BmID0gXCLwnZWaXCI7XG52YXIgSW90YSA9IFwizplcIjtcbnZhciBpb3RhID0gXCLOuVwiO1xudmFyIGlwcm9kID0gXCLiqLxcIjtcbnZhciBpcXVlc3QkMSA9IFwiwr9cIjtcbnZhciBpc2NyID0gXCLwnZK+XCI7XG52YXIgSXNjciA9IFwi4oSQXCI7XG52YXIgaXNpbiA9IFwi4oiIXCI7XG52YXIgaXNpbmRvdCA9IFwi4ou1XCI7XG52YXIgaXNpbkUgPSBcIuKLuVwiO1xudmFyIGlzaW5zID0gXCLii7RcIjtcbnZhciBpc2luc3YgPSBcIuKLs1wiO1xudmFyIGlzaW52ID0gXCLiiIhcIjtcbnZhciBpdCA9IFwi4oGiXCI7XG52YXIgSXRpbGRlID0gXCLEqFwiO1xudmFyIGl0aWxkZSA9IFwixKlcIjtcbnZhciBJdWtjeSA9IFwi0IZcIjtcbnZhciBpdWtjeSA9IFwi0ZZcIjtcbnZhciBJdW1sJDEgPSBcIsOPXCI7XG52YXIgaXVtbCQxID0gXCLDr1wiO1xudmFyIEpjaXJjID0gXCLEtFwiO1xudmFyIGpjaXJjID0gXCLEtVwiO1xudmFyIEpjeSA9IFwi0JlcIjtcbnZhciBqY3kgPSBcItC5XCI7XG52YXIgSmZyID0gXCLwnZSNXCI7XG52YXIgamZyID0gXCLwnZSnXCI7XG52YXIgam1hdGggPSBcIsi3XCI7XG52YXIgSm9wZiA9IFwi8J2VgVwiO1xudmFyIGpvcGYgPSBcIvCdlZtcIjtcbnZhciBKc2NyID0gXCLwnZKlXCI7XG52YXIganNjciA9IFwi8J2Sv1wiO1xudmFyIEpzZXJjeSA9IFwi0IhcIjtcbnZhciBqc2VyY3kgPSBcItGYXCI7XG52YXIgSnVrY3kgPSBcItCEXCI7XG52YXIganVrY3kgPSBcItGUXCI7XG52YXIgS2FwcGEgPSBcIs6aXCI7XG52YXIga2FwcGEgPSBcIs66XCI7XG52YXIga2FwcGF2ID0gXCLPsFwiO1xudmFyIEtjZWRpbCA9IFwixLZcIjtcbnZhciBrY2VkaWwgPSBcIsS3XCI7XG52YXIgS2N5ID0gXCLQmlwiO1xudmFyIGtjeSA9IFwi0LpcIjtcbnZhciBLZnIgPSBcIvCdlI5cIjtcbnZhciBrZnIgPSBcIvCdlKhcIjtcbnZhciBrZ3JlZW4gPSBcIsS4XCI7XG52YXIgS0hjeSA9IFwi0KVcIjtcbnZhciBraGN5ID0gXCLRhVwiO1xudmFyIEtKY3kgPSBcItCMXCI7XG52YXIga2pjeSA9IFwi0ZxcIjtcbnZhciBLb3BmID0gXCLwnZWCXCI7XG52YXIga29wZiA9IFwi8J2VnFwiO1xudmFyIEtzY3IgPSBcIvCdkqZcIjtcbnZhciBrc2NyID0gXCLwnZOAXCI7XG52YXIgbEFhcnIgPSBcIuKHmlwiO1xudmFyIExhY3V0ZSA9IFwixLlcIjtcbnZhciBsYWN1dGUgPSBcIsS6XCI7XG52YXIgbGFlbXB0eXYgPSBcIuKmtFwiO1xudmFyIGxhZ3JhbiA9IFwi4oSSXCI7XG52YXIgTGFtYmRhID0gXCLOm1wiO1xudmFyIGxhbWJkYSA9IFwizrtcIjtcbnZhciBsYW5nID0gXCLin6hcIjtcbnZhciBMYW5nID0gXCLin6pcIjtcbnZhciBsYW5nZCA9IFwi4qaRXCI7XG52YXIgbGFuZ2xlID0gXCLin6hcIjtcbnZhciBsYXAgPSBcIuKqhVwiO1xudmFyIExhcGxhY2V0cmYgPSBcIuKEklwiO1xudmFyIGxhcXVvJDEgPSBcIsKrXCI7XG52YXIgbGFycmIgPSBcIuKHpFwiO1xudmFyIGxhcnJiZnMgPSBcIuKkn1wiO1xudmFyIGxhcnIgPSBcIuKGkFwiO1xudmFyIExhcnIgPSBcIuKGnlwiO1xudmFyIGxBcnIgPSBcIuKHkFwiO1xudmFyIGxhcnJmcyA9IFwi4qSdXCI7XG52YXIgbGFycmhrID0gXCLihqlcIjtcbnZhciBsYXJybHAgPSBcIuKGq1wiO1xudmFyIGxhcnJwbCA9IFwi4qS5XCI7XG52YXIgbGFycnNpbSA9IFwi4qWzXCI7XG52YXIgbGFycnRsID0gXCLihqJcIjtcbnZhciBsYXRhaWwgPSBcIuKkmVwiO1xudmFyIGxBdGFpbCA9IFwi4qSbXCI7XG52YXIgbGF0ID0gXCLiqqtcIjtcbnZhciBsYXRlID0gXCLiqq1cIjtcbnZhciBsYXRlcyA9IFwi4qqt77iAXCI7XG52YXIgbGJhcnIgPSBcIuKkjFwiO1xudmFyIGxCYXJyID0gXCLipI5cIjtcbnZhciBsYmJyayA9IFwi4p2yXCI7XG52YXIgbGJyYWNlID0gXCJ7XCI7XG52YXIgbGJyYWNrID0gXCJbXCI7XG52YXIgbGJya2UgPSBcIuKmi1wiO1xudmFyIGxicmtzbGQgPSBcIuKmj1wiO1xudmFyIGxicmtzbHUgPSBcIuKmjVwiO1xudmFyIExjYXJvbiA9IFwixL1cIjtcbnZhciBsY2Fyb24gPSBcIsS+XCI7XG52YXIgTGNlZGlsID0gXCLEu1wiO1xudmFyIGxjZWRpbCA9IFwixLxcIjtcbnZhciBsY2VpbCA9IFwi4oyIXCI7XG52YXIgbGN1YiA9IFwie1wiO1xudmFyIExjeSA9IFwi0JtcIjtcbnZhciBsY3kgPSBcItC7XCI7XG52YXIgbGRjYSA9IFwi4qS2XCI7XG52YXIgbGRxdW8gPSBcIuKAnFwiO1xudmFyIGxkcXVvciA9IFwi4oCeXCI7XG52YXIgbGRyZGhhciA9IFwi4qWnXCI7XG52YXIgbGRydXNoYXIgPSBcIuKli1wiO1xudmFyIGxkc2ggPSBcIuKGslwiO1xudmFyIGxlID0gXCLiiaRcIjtcbnZhciBsRSA9IFwi4ommXCI7XG52YXIgTGVmdEFuZ2xlQnJhY2tldCA9IFwi4p+oXCI7XG52YXIgTGVmdEFycm93QmFyID0gXCLih6RcIjtcbnZhciBsZWZ0YXJyb3cgPSBcIuKGkFwiO1xudmFyIExlZnRBcnJvdyA9IFwi4oaQXCI7XG52YXIgTGVmdGFycm93ID0gXCLih5BcIjtcbnZhciBMZWZ0QXJyb3dSaWdodEFycm93ID0gXCLih4ZcIjtcbnZhciBsZWZ0YXJyb3d0YWlsID0gXCLihqJcIjtcbnZhciBMZWZ0Q2VpbGluZyA9IFwi4oyIXCI7XG52YXIgTGVmdERvdWJsZUJyYWNrZXQgPSBcIuKfplwiO1xudmFyIExlZnREb3duVGVlVmVjdG9yID0gXCLipaFcIjtcbnZhciBMZWZ0RG93blZlY3RvckJhciA9IFwi4qWZXCI7XG52YXIgTGVmdERvd25WZWN0b3IgPSBcIuKHg1wiO1xudmFyIExlZnRGbG9vciA9IFwi4oyKXCI7XG52YXIgbGVmdGhhcnBvb25kb3duID0gXCLihr1cIjtcbnZhciBsZWZ0aGFycG9vbnVwID0gXCLihrxcIjtcbnZhciBsZWZ0bGVmdGFycm93cyA9IFwi4oeHXCI7XG52YXIgbGVmdHJpZ2h0YXJyb3cgPSBcIuKGlFwiO1xudmFyIExlZnRSaWdodEFycm93ID0gXCLihpRcIjtcbnZhciBMZWZ0cmlnaHRhcnJvdyA9IFwi4oeUXCI7XG52YXIgbGVmdHJpZ2h0YXJyb3dzID0gXCLih4ZcIjtcbnZhciBsZWZ0cmlnaHRoYXJwb29ucyA9IFwi4oeLXCI7XG52YXIgbGVmdHJpZ2h0c3F1aWdhcnJvdyA9IFwi4oatXCI7XG52YXIgTGVmdFJpZ2h0VmVjdG9yID0gXCLipY5cIjtcbnZhciBMZWZ0VGVlQXJyb3cgPSBcIuKGpFwiO1xudmFyIExlZnRUZWUgPSBcIuKKo1wiO1xudmFyIExlZnRUZWVWZWN0b3IgPSBcIuKlmlwiO1xudmFyIGxlZnR0aHJlZXRpbWVzID0gXCLii4tcIjtcbnZhciBMZWZ0VHJpYW5nbGVCYXIgPSBcIuKnj1wiO1xudmFyIExlZnRUcmlhbmdsZSA9IFwi4oqyXCI7XG52YXIgTGVmdFRyaWFuZ2xlRXF1YWwgPSBcIuKKtFwiO1xudmFyIExlZnRVcERvd25WZWN0b3IgPSBcIuKlkVwiO1xudmFyIExlZnRVcFRlZVZlY3RvciA9IFwi4qWgXCI7XG52YXIgTGVmdFVwVmVjdG9yQmFyID0gXCLipZhcIjtcbnZhciBMZWZ0VXBWZWN0b3IgPSBcIuKGv1wiO1xudmFyIExlZnRWZWN0b3JCYXIgPSBcIuKlklwiO1xudmFyIExlZnRWZWN0b3IgPSBcIuKGvFwiO1xudmFyIGxFZyA9IFwi4qqLXCI7XG52YXIgbGVnID0gXCLii5pcIjtcbnZhciBsZXEgPSBcIuKJpFwiO1xudmFyIGxlcXEgPSBcIuKJplwiO1xudmFyIGxlcXNsYW50ID0gXCLiqb1cIjtcbnZhciBsZXNjYyA9IFwi4qqoXCI7XG52YXIgbGVzID0gXCLiqb1cIjtcbnZhciBsZXNkb3QgPSBcIuKpv1wiO1xudmFyIGxlc2RvdG8gPSBcIuKqgVwiO1xudmFyIGxlc2RvdG9yID0gXCLiqoNcIjtcbnZhciBsZXNnID0gXCLii5rvuIBcIjtcbnZhciBsZXNnZXMgPSBcIuKqk1wiO1xudmFyIGxlc3NhcHByb3ggPSBcIuKqhVwiO1xudmFyIGxlc3Nkb3QgPSBcIuKLllwiO1xudmFyIGxlc3NlcWd0ciA9IFwi4ouaXCI7XG52YXIgbGVzc2VxcWd0ciA9IFwi4qqLXCI7XG52YXIgTGVzc0VxdWFsR3JlYXRlciA9IFwi4ouaXCI7XG52YXIgTGVzc0Z1bGxFcXVhbCA9IFwi4ommXCI7XG52YXIgTGVzc0dyZWF0ZXIgPSBcIuKJtlwiO1xudmFyIGxlc3NndHIgPSBcIuKJtlwiO1xudmFyIExlc3NMZXNzID0gXCLiqqFcIjtcbnZhciBsZXNzc2ltID0gXCLiibJcIjtcbnZhciBMZXNzU2xhbnRFcXVhbCA9IFwi4qm9XCI7XG52YXIgTGVzc1RpbGRlID0gXCLiibJcIjtcbnZhciBsZmlzaHQgPSBcIuKlvFwiO1xudmFyIGxmbG9vciA9IFwi4oyKXCI7XG52YXIgTGZyID0gXCLwnZSPXCI7XG52YXIgbGZyID0gXCLwnZSpXCI7XG52YXIgbGcgPSBcIuKJtlwiO1xudmFyIGxnRSA9IFwi4qqRXCI7XG52YXIgbEhhciA9IFwi4qWiXCI7XG52YXIgbGhhcmQgPSBcIuKGvVwiO1xudmFyIGxoYXJ1ID0gXCLihrxcIjtcbnZhciBsaGFydWwgPSBcIuKlqlwiO1xudmFyIGxoYmxrID0gXCLiloRcIjtcbnZhciBMSmN5ID0gXCLQiVwiO1xudmFyIGxqY3kgPSBcItGZXCI7XG52YXIgbGxhcnIgPSBcIuKHh1wiO1xudmFyIGxsID0gXCLiiapcIjtcbnZhciBMbCA9IFwi4ouYXCI7XG52YXIgbGxjb3JuZXIgPSBcIuKMnlwiO1xudmFyIExsZWZ0YXJyb3cgPSBcIuKHmlwiO1xudmFyIGxsaGFyZCA9IFwi4qWrXCI7XG52YXIgbGx0cmkgPSBcIuKXulwiO1xudmFyIExtaWRvdCA9IFwixL9cIjtcbnZhciBsbWlkb3QgPSBcIsWAXCI7XG52YXIgbG1vdXN0YWNoZSA9IFwi4o6wXCI7XG52YXIgbG1vdXN0ID0gXCLijrBcIjtcbnZhciBsbmFwID0gXCLiqolcIjtcbnZhciBsbmFwcHJveCA9IFwi4qqJXCI7XG52YXIgbG5lID0gXCLiqodcIjtcbnZhciBsbkUgPSBcIuKJqFwiO1xudmFyIGxuZXEgPSBcIuKqh1wiO1xudmFyIGxuZXFxID0gXCLiiahcIjtcbnZhciBsbnNpbSA9IFwi4oumXCI7XG52YXIgbG9hbmcgPSBcIuKfrFwiO1xudmFyIGxvYXJyID0gXCLih71cIjtcbnZhciBsb2JyayA9IFwi4p+mXCI7XG52YXIgbG9uZ2xlZnRhcnJvdyA9IFwi4p+1XCI7XG52YXIgTG9uZ0xlZnRBcnJvdyA9IFwi4p+1XCI7XG52YXIgTG9uZ2xlZnRhcnJvdyA9IFwi4p+4XCI7XG52YXIgbG9uZ2xlZnRyaWdodGFycm93ID0gXCLin7dcIjtcbnZhciBMb25nTGVmdFJpZ2h0QXJyb3cgPSBcIuKft1wiO1xudmFyIExvbmdsZWZ0cmlnaHRhcnJvdyA9IFwi4p+6XCI7XG52YXIgbG9uZ21hcHN0byA9IFwi4p+8XCI7XG52YXIgbG9uZ3JpZ2h0YXJyb3cgPSBcIuKftlwiO1xudmFyIExvbmdSaWdodEFycm93ID0gXCLin7ZcIjtcbnZhciBMb25ncmlnaHRhcnJvdyA9IFwi4p+5XCI7XG52YXIgbG9vcGFycm93bGVmdCA9IFwi4oarXCI7XG52YXIgbG9vcGFycm93cmlnaHQgPSBcIuKGrFwiO1xudmFyIGxvcGFyID0gXCLipoVcIjtcbnZhciBMb3BmID0gXCLwnZWDXCI7XG52YXIgbG9wZiA9IFwi8J2VnVwiO1xudmFyIGxvcGx1cyA9IFwi4qitXCI7XG52YXIgbG90aW1lcyA9IFwi4qi0XCI7XG52YXIgbG93YXN0ID0gXCLiiJdcIjtcbnZhciBsb3diYXIgPSBcIl9cIjtcbnZhciBMb3dlckxlZnRBcnJvdyA9IFwi4oaZXCI7XG52YXIgTG93ZXJSaWdodEFycm93ID0gXCLihphcIjtcbnZhciBsb3ogPSBcIuKXilwiO1xudmFyIGxvemVuZ2UgPSBcIuKXilwiO1xudmFyIGxvemYgPSBcIuKnq1wiO1xudmFyIGxwYXIgPSBcIihcIjtcbnZhciBscGFybHQgPSBcIuKmk1wiO1xudmFyIGxyYXJyID0gXCLih4ZcIjtcbnZhciBscmNvcm5lciA9IFwi4oyfXCI7XG52YXIgbHJoYXIgPSBcIuKHi1wiO1xudmFyIGxyaGFyZCA9IFwi4qWtXCI7XG52YXIgbHJtID0gXCLigI5cIjtcbnZhciBscnRyaSA9IFwi4oq/XCI7XG52YXIgbHNhcXVvID0gXCLigLlcIjtcbnZhciBsc2NyID0gXCLwnZOBXCI7XG52YXIgTHNjciA9IFwi4oSSXCI7XG52YXIgbHNoID0gXCLihrBcIjtcbnZhciBMc2ggPSBcIuKGsFwiO1xudmFyIGxzaW0gPSBcIuKJslwiO1xudmFyIGxzaW1lID0gXCLiqo1cIjtcbnZhciBsc2ltZyA9IFwi4qqPXCI7XG52YXIgbHNxYiA9IFwiW1wiO1xudmFyIGxzcXVvID0gXCLigJhcIjtcbnZhciBsc3F1b3IgPSBcIuKAmlwiO1xudmFyIExzdHJvayA9IFwixYFcIjtcbnZhciBsc3Ryb2sgPSBcIsWCXCI7XG52YXIgbHRjYyA9IFwi4qqmXCI7XG52YXIgbHRjaXIgPSBcIuKpuVwiO1xudmFyIGx0JDIgPSBcIjxcIjtcbnZhciBMVCQxID0gXCI8XCI7XG52YXIgTHQgPSBcIuKJqlwiO1xudmFyIGx0ZG90ID0gXCLii5ZcIjtcbnZhciBsdGhyZWUgPSBcIuKLi1wiO1xudmFyIGx0aW1lcyA9IFwi4ouJXCI7XG52YXIgbHRsYXJyID0gXCLipbZcIjtcbnZhciBsdHF1ZXN0ID0gXCLiqbtcIjtcbnZhciBsdHJpID0gXCLil4NcIjtcbnZhciBsdHJpZSA9IFwi4oq0XCI7XG52YXIgbHRyaWYgPSBcIuKXglwiO1xudmFyIGx0clBhciA9IFwi4qaWXCI7XG52YXIgbHVyZHNoYXIgPSBcIuKlilwiO1xudmFyIGx1cnVoYXIgPSBcIuKlplwiO1xudmFyIGx2ZXJ0bmVxcSA9IFwi4omo77iAXCI7XG52YXIgbHZuRSA9IFwi4omo77iAXCI7XG52YXIgbWFjciQxID0gXCLCr1wiO1xudmFyIG1hbGUgPSBcIuKZglwiO1xudmFyIG1hbHQgPSBcIuKcoFwiO1xudmFyIG1hbHRlc2UgPSBcIuKcoFwiO1xudmFyIG1hcCA9IFwi4oamXCI7XG52YXIgbWFwc3RvID0gXCLihqZcIjtcbnZhciBtYXBzdG9kb3duID0gXCLihqdcIjtcbnZhciBtYXBzdG9sZWZ0ID0gXCLihqRcIjtcbnZhciBtYXBzdG91cCA9IFwi4oalXCI7XG52YXIgbWFya2VyID0gXCLilq5cIjtcbnZhciBtY29tbWEgPSBcIuKoqVwiO1xudmFyIE1jeSA9IFwi0JxcIjtcbnZhciBtY3kgPSBcItC8XCI7XG52YXIgbWRhc2ggPSBcIuKAlFwiO1xudmFyIG1ERG90ID0gXCLiiLpcIjtcbnZhciBtZWFzdXJlZGFuZ2xlID0gXCLiiKFcIjtcbnZhciBNZWRpdW1TcGFjZSA9IFwi4oGfXCI7XG52YXIgTWVsbGludHJmID0gXCLihLNcIjtcbnZhciBNZnIgPSBcIvCdlJBcIjtcbnZhciBtZnIgPSBcIvCdlKpcIjtcbnZhciBtaG8gPSBcIuKEp1wiO1xudmFyIG1pY3JvJDEgPSBcIsK1XCI7XG52YXIgbWlkYXN0ID0gXCIqXCI7XG52YXIgbWlkY2lyID0gXCLiq7BcIjtcbnZhciBtaWQgPSBcIuKIo1wiO1xudmFyIG1pZGRvdCQxID0gXCLCt1wiO1xudmFyIG1pbnVzYiA9IFwi4oqfXCI7XG52YXIgbWludXMgPSBcIuKIklwiO1xudmFyIG1pbnVzZCA9IFwi4oi4XCI7XG52YXIgbWludXNkdSA9IFwi4qiqXCI7XG52YXIgTWludXNQbHVzID0gXCLiiJNcIjtcbnZhciBtbGNwID0gXCLiq5tcIjtcbnZhciBtbGRyID0gXCLigKZcIjtcbnZhciBtbnBsdXMgPSBcIuKIk1wiO1xudmFyIG1vZGVscyA9IFwi4oqnXCI7XG52YXIgTW9wZiA9IFwi8J2VhFwiO1xudmFyIG1vcGYgPSBcIvCdlZ5cIjtcbnZhciBtcCA9IFwi4oiTXCI7XG52YXIgbXNjciA9IFwi8J2TglwiO1xudmFyIE1zY3IgPSBcIuKEs1wiO1xudmFyIG1zdHBvcyA9IFwi4oi+XCI7XG52YXIgTXUgPSBcIs6cXCI7XG52YXIgbXUgPSBcIs68XCI7XG52YXIgbXVsdGltYXAgPSBcIuKKuFwiO1xudmFyIG11bWFwID0gXCLiirhcIjtcbnZhciBuYWJsYSA9IFwi4oiHXCI7XG52YXIgTmFjdXRlID0gXCLFg1wiO1xudmFyIG5hY3V0ZSA9IFwixYRcIjtcbnZhciBuYW5nID0gXCLiiKDig5JcIjtcbnZhciBuYXAgPSBcIuKJiVwiO1xudmFyIG5hcEUgPSBcIuKpsMy4XCI7XG52YXIgbmFwaWQgPSBcIuKJi8y4XCI7XG52YXIgbmFwb3MgPSBcIsWJXCI7XG52YXIgbmFwcHJveCA9IFwi4omJXCI7XG52YXIgbmF0dXJhbCA9IFwi4pmuXCI7XG52YXIgbmF0dXJhbHMgPSBcIuKElVwiO1xudmFyIG5hdHVyID0gXCLima5cIjtcbnZhciBuYnNwJDEgPSBcIsKgXCI7XG52YXIgbmJ1bXAgPSBcIuKJjsy4XCI7XG52YXIgbmJ1bXBlID0gXCLiiY/MuFwiO1xudmFyIG5jYXAgPSBcIuKpg1wiO1xudmFyIE5jYXJvbiA9IFwixYdcIjtcbnZhciBuY2Fyb24gPSBcIsWIXCI7XG52YXIgTmNlZGlsID0gXCLFhVwiO1xudmFyIG5jZWRpbCA9IFwixYZcIjtcbnZhciBuY29uZyA9IFwi4omHXCI7XG52YXIgbmNvbmdkb3QgPSBcIuKprcy4XCI7XG52YXIgbmN1cCA9IFwi4qmCXCI7XG52YXIgTmN5ID0gXCLQnVwiO1xudmFyIG5jeSA9IFwi0L1cIjtcbnZhciBuZGFzaCA9IFwi4oCTXCI7XG52YXIgbmVhcmhrID0gXCLipKRcIjtcbnZhciBuZWFyciA9IFwi4oaXXCI7XG52YXIgbmVBcnIgPSBcIuKHl1wiO1xudmFyIG5lYXJyb3cgPSBcIuKGl1wiO1xudmFyIG5lID0gXCLiiaBcIjtcbnZhciBuZWRvdCA9IFwi4omQzLhcIjtcbnZhciBOZWdhdGl2ZU1lZGl1bVNwYWNlID0gXCLigItcIjtcbnZhciBOZWdhdGl2ZVRoaWNrU3BhY2UgPSBcIuKAi1wiO1xudmFyIE5lZ2F0aXZlVGhpblNwYWNlID0gXCLigItcIjtcbnZhciBOZWdhdGl2ZVZlcnlUaGluU3BhY2UgPSBcIuKAi1wiO1xudmFyIG5lcXVpdiA9IFwi4omiXCI7XG52YXIgbmVzZWFyID0gXCLipKhcIjtcbnZhciBuZXNpbSA9IFwi4omCzLhcIjtcbnZhciBOZXN0ZWRHcmVhdGVyR3JlYXRlciA9IFwi4omrXCI7XG52YXIgTmVzdGVkTGVzc0xlc3MgPSBcIuKJqlwiO1xudmFyIE5ld0xpbmUgPSBcIlxcblwiO1xudmFyIG5leGlzdCA9IFwi4oiEXCI7XG52YXIgbmV4aXN0cyA9IFwi4oiEXCI7XG52YXIgTmZyID0gXCLwnZSRXCI7XG52YXIgbmZyID0gXCLwnZSrXCI7XG52YXIgbmdFID0gXCLiiafMuFwiO1xudmFyIG5nZSA9IFwi4omxXCI7XG52YXIgbmdlcSA9IFwi4omxXCI7XG52YXIgbmdlcXEgPSBcIuKJp8y4XCI7XG52YXIgbmdlcXNsYW50ID0gXCLiqb7MuFwiO1xudmFyIG5nZXMgPSBcIuKpvsy4XCI7XG52YXIgbkdnID0gXCLii5nMuFwiO1xudmFyIG5nc2ltID0gXCLiibVcIjtcbnZhciBuR3QgPSBcIuKJq+KDklwiO1xudmFyIG5ndCA9IFwi4omvXCI7XG52YXIgbmd0ciA9IFwi4omvXCI7XG52YXIgbkd0diA9IFwi4omrzLhcIjtcbnZhciBuaGFyciA9IFwi4oauXCI7XG52YXIgbmhBcnIgPSBcIuKHjlwiO1xudmFyIG5ocGFyID0gXCLiq7JcIjtcbnZhciBuaSA9IFwi4oiLXCI7XG52YXIgbmlzID0gXCLii7xcIjtcbnZhciBuaXNkID0gXCLii7pcIjtcbnZhciBuaXYgPSBcIuKIi1wiO1xudmFyIE5KY3kgPSBcItCKXCI7XG52YXIgbmpjeSA9IFwi0ZpcIjtcbnZhciBubGFyciA9IFwi4oaaXCI7XG52YXIgbmxBcnIgPSBcIuKHjVwiO1xudmFyIG5sZHIgPSBcIuKApVwiO1xudmFyIG5sRSA9IFwi4ommzLhcIjtcbnZhciBubGUgPSBcIuKJsFwiO1xudmFyIG5sZWZ0YXJyb3cgPSBcIuKGmlwiO1xudmFyIG5MZWZ0YXJyb3cgPSBcIuKHjVwiO1xudmFyIG5sZWZ0cmlnaHRhcnJvdyA9IFwi4oauXCI7XG52YXIgbkxlZnRyaWdodGFycm93ID0gXCLih45cIjtcbnZhciBubGVxID0gXCLiibBcIjtcbnZhciBubGVxcSA9IFwi4ommzLhcIjtcbnZhciBubGVxc2xhbnQgPSBcIuKpvcy4XCI7XG52YXIgbmxlcyA9IFwi4qm9zLhcIjtcbnZhciBubGVzcyA9IFwi4omuXCI7XG52YXIgbkxsID0gXCLii5jMuFwiO1xudmFyIG5sc2ltID0gXCLiibRcIjtcbnZhciBuTHQgPSBcIuKJquKDklwiO1xudmFyIG5sdCA9IFwi4omuXCI7XG52YXIgbmx0cmkgPSBcIuKLqlwiO1xudmFyIG5sdHJpZSA9IFwi4ousXCI7XG52YXIgbkx0diA9IFwi4omqzLhcIjtcbnZhciBubWlkID0gXCLiiKRcIjtcbnZhciBOb0JyZWFrID0gXCLigaBcIjtcbnZhciBOb25CcmVha2luZ1NwYWNlID0gXCLCoFwiO1xudmFyIG5vcGYgPSBcIvCdlZ9cIjtcbnZhciBOb3BmID0gXCLihJVcIjtcbnZhciBOb3QgPSBcIuKrrFwiO1xudmFyIG5vdCQxID0gXCLCrFwiO1xudmFyIE5vdENvbmdydWVudCA9IFwi4omiXCI7XG52YXIgTm90Q3VwQ2FwID0gXCLiia1cIjtcbnZhciBOb3REb3VibGVWZXJ0aWNhbEJhciA9IFwi4oimXCI7XG52YXIgTm90RWxlbWVudCA9IFwi4oiJXCI7XG52YXIgTm90RXF1YWwgPSBcIuKJoFwiO1xudmFyIE5vdEVxdWFsVGlsZGUgPSBcIuKJgsy4XCI7XG52YXIgTm90RXhpc3RzID0gXCLiiIRcIjtcbnZhciBOb3RHcmVhdGVyID0gXCLiia9cIjtcbnZhciBOb3RHcmVhdGVyRXF1YWwgPSBcIuKJsVwiO1xudmFyIE5vdEdyZWF0ZXJGdWxsRXF1YWwgPSBcIuKJp8y4XCI7XG52YXIgTm90R3JlYXRlckdyZWF0ZXIgPSBcIuKJq8y4XCI7XG52YXIgTm90R3JlYXRlckxlc3MgPSBcIuKJuVwiO1xudmFyIE5vdEdyZWF0ZXJTbGFudEVxdWFsID0gXCLiqb7MuFwiO1xudmFyIE5vdEdyZWF0ZXJUaWxkZSA9IFwi4om1XCI7XG52YXIgTm90SHVtcERvd25IdW1wID0gXCLiiY7MuFwiO1xudmFyIE5vdEh1bXBFcXVhbCA9IFwi4omPzLhcIjtcbnZhciBub3RpbiA9IFwi4oiJXCI7XG52YXIgbm90aW5kb3QgPSBcIuKLtcy4XCI7XG52YXIgbm90aW5FID0gXCLii7nMuFwiO1xudmFyIG5vdGludmEgPSBcIuKIiVwiO1xudmFyIG5vdGludmIgPSBcIuKLt1wiO1xudmFyIG5vdGludmMgPSBcIuKLtlwiO1xudmFyIE5vdExlZnRUcmlhbmdsZUJhciA9IFwi4qePzLhcIjtcbnZhciBOb3RMZWZ0VHJpYW5nbGUgPSBcIuKLqlwiO1xudmFyIE5vdExlZnRUcmlhbmdsZUVxdWFsID0gXCLii6xcIjtcbnZhciBOb3RMZXNzID0gXCLiia5cIjtcbnZhciBOb3RMZXNzRXF1YWwgPSBcIuKJsFwiO1xudmFyIE5vdExlc3NHcmVhdGVyID0gXCLiibhcIjtcbnZhciBOb3RMZXNzTGVzcyA9IFwi4omqzLhcIjtcbnZhciBOb3RMZXNzU2xhbnRFcXVhbCA9IFwi4qm9zLhcIjtcbnZhciBOb3RMZXNzVGlsZGUgPSBcIuKJtFwiO1xudmFyIE5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyID0gXCLiqqLMuFwiO1xudmFyIE5vdE5lc3RlZExlc3NMZXNzID0gXCLiqqHMuFwiO1xudmFyIG5vdG5pID0gXCLiiIxcIjtcbnZhciBub3RuaXZhID0gXCLiiIxcIjtcbnZhciBub3RuaXZiID0gXCLii75cIjtcbnZhciBub3RuaXZjID0gXCLii71cIjtcbnZhciBOb3RQcmVjZWRlcyA9IFwi4oqAXCI7XG52YXIgTm90UHJlY2VkZXNFcXVhbCA9IFwi4qqvzLhcIjtcbnZhciBOb3RQcmVjZWRlc1NsYW50RXF1YWwgPSBcIuKLoFwiO1xudmFyIE5vdFJldmVyc2VFbGVtZW50ID0gXCLiiIxcIjtcbnZhciBOb3RSaWdodFRyaWFuZ2xlQmFyID0gXCLip5DMuFwiO1xudmFyIE5vdFJpZ2h0VHJpYW5nbGUgPSBcIuKLq1wiO1xudmFyIE5vdFJpZ2h0VHJpYW5nbGVFcXVhbCA9IFwi4outXCI7XG52YXIgTm90U3F1YXJlU3Vic2V0ID0gXCLiio/MuFwiO1xudmFyIE5vdFNxdWFyZVN1YnNldEVxdWFsID0gXCLii6JcIjtcbnZhciBOb3RTcXVhcmVTdXBlcnNldCA9IFwi4oqQzLhcIjtcbnZhciBOb3RTcXVhcmVTdXBlcnNldEVxdWFsID0gXCLii6NcIjtcbnZhciBOb3RTdWJzZXQgPSBcIuKKguKDklwiO1xudmFyIE5vdFN1YnNldEVxdWFsID0gXCLiiohcIjtcbnZhciBOb3RTdWNjZWVkcyA9IFwi4oqBXCI7XG52YXIgTm90U3VjY2VlZHNFcXVhbCA9IFwi4qqwzLhcIjtcbnZhciBOb3RTdWNjZWVkc1NsYW50RXF1YWwgPSBcIuKLoVwiO1xudmFyIE5vdFN1Y2NlZWRzVGlsZGUgPSBcIuKJv8y4XCI7XG52YXIgTm90U3VwZXJzZXQgPSBcIuKKg+KDklwiO1xudmFyIE5vdFN1cGVyc2V0RXF1YWwgPSBcIuKKiVwiO1xudmFyIE5vdFRpbGRlID0gXCLiiYFcIjtcbnZhciBOb3RUaWxkZUVxdWFsID0gXCLiiYRcIjtcbnZhciBOb3RUaWxkZUZ1bGxFcXVhbCA9IFwi4omHXCI7XG52YXIgTm90VGlsZGVUaWxkZSA9IFwi4omJXCI7XG52YXIgTm90VmVydGljYWxCYXIgPSBcIuKIpFwiO1xudmFyIG5wYXJhbGxlbCA9IFwi4oimXCI7XG52YXIgbnBhciA9IFwi4oimXCI7XG52YXIgbnBhcnNsID0gXCLiq73ig6VcIjtcbnZhciBucGFydCA9IFwi4oiCzLhcIjtcbnZhciBucG9saW50ID0gXCLiqJRcIjtcbnZhciBucHIgPSBcIuKKgFwiO1xudmFyIG5wcmN1ZSA9IFwi4ougXCI7XG52YXIgbnByZWMgPSBcIuKKgFwiO1xudmFyIG5wcmVjZXEgPSBcIuKqr8y4XCI7XG52YXIgbnByZSA9IFwi4qqvzLhcIjtcbnZhciBucmFycmMgPSBcIuKks8y4XCI7XG52YXIgbnJhcnIgPSBcIuKGm1wiO1xudmFyIG5yQXJyID0gXCLih49cIjtcbnZhciBucmFycncgPSBcIuKGncy4XCI7XG52YXIgbnJpZ2h0YXJyb3cgPSBcIuKGm1wiO1xudmFyIG5SaWdodGFycm93ID0gXCLih49cIjtcbnZhciBucnRyaSA9IFwi4ourXCI7XG52YXIgbnJ0cmllID0gXCLii61cIjtcbnZhciBuc2MgPSBcIuKKgVwiO1xudmFyIG5zY2N1ZSA9IFwi4ouhXCI7XG52YXIgbnNjZSA9IFwi4qqwzLhcIjtcbnZhciBOc2NyID0gXCLwnZKpXCI7XG52YXIgbnNjciA9IFwi8J2Tg1wiO1xudmFyIG5zaG9ydG1pZCA9IFwi4oikXCI7XG52YXIgbnNob3J0cGFyYWxsZWwgPSBcIuKIplwiO1xudmFyIG5zaW0gPSBcIuKJgVwiO1xudmFyIG5zaW1lID0gXCLiiYRcIjtcbnZhciBuc2ltZXEgPSBcIuKJhFwiO1xudmFyIG5zbWlkID0gXCLiiKRcIjtcbnZhciBuc3BhciA9IFwi4oimXCI7XG52YXIgbnNxc3ViZSA9IFwi4ouiXCI7XG52YXIgbnNxc3VwZSA9IFwi4oujXCI7XG52YXIgbnN1YiA9IFwi4oqEXCI7XG52YXIgbnN1YkUgPSBcIuKrhcy4XCI7XG52YXIgbnN1YmUgPSBcIuKKiFwiO1xudmFyIG5zdWJzZXQgPSBcIuKKguKDklwiO1xudmFyIG5zdWJzZXRlcSA9IFwi4oqIXCI7XG52YXIgbnN1YnNldGVxcSA9IFwi4quFzLhcIjtcbnZhciBuc3VjYyA9IFwi4oqBXCI7XG52YXIgbnN1Y2NlcSA9IFwi4qqwzLhcIjtcbnZhciBuc3VwID0gXCLiioVcIjtcbnZhciBuc3VwRSA9IFwi4quGzLhcIjtcbnZhciBuc3VwZSA9IFwi4oqJXCI7XG52YXIgbnN1cHNldCA9IFwi4oqD4oOSXCI7XG52YXIgbnN1cHNldGVxID0gXCLiiolcIjtcbnZhciBuc3Vwc2V0ZXFxID0gXCLiq4bMuFwiO1xudmFyIG50Z2wgPSBcIuKJuVwiO1xudmFyIE50aWxkZSQxID0gXCLDkVwiO1xudmFyIG50aWxkZSQxID0gXCLDsVwiO1xudmFyIG50bGcgPSBcIuKJuFwiO1xudmFyIG50cmlhbmdsZWxlZnQgPSBcIuKLqlwiO1xudmFyIG50cmlhbmdsZWxlZnRlcSA9IFwi4ousXCI7XG52YXIgbnRyaWFuZ2xlcmlnaHQgPSBcIuKLq1wiO1xudmFyIG50cmlhbmdsZXJpZ2h0ZXEgPSBcIuKLrVwiO1xudmFyIE51ID0gXCLOnVwiO1xudmFyIG51ID0gXCLOvVwiO1xudmFyIG51bSA9IFwiI1wiO1xudmFyIG51bWVybyA9IFwi4oSWXCI7XG52YXIgbnVtc3AgPSBcIuKAh1wiO1xudmFyIG52YXAgPSBcIuKJjeKDklwiO1xudmFyIG52ZGFzaCA9IFwi4oqsXCI7XG52YXIgbnZEYXNoID0gXCLiiq1cIjtcbnZhciBuVmRhc2ggPSBcIuKKrlwiO1xudmFyIG5WRGFzaCA9IFwi4oqvXCI7XG52YXIgbnZnZSA9IFwi4oml4oOSXCI7XG52YXIgbnZndCA9IFwiPuKDklwiO1xudmFyIG52SGFyciA9IFwi4qSEXCI7XG52YXIgbnZpbmZpbiA9IFwi4qeeXCI7XG52YXIgbnZsQXJyID0gXCLipIJcIjtcbnZhciBudmxlID0gXCLiiaTig5JcIjtcbnZhciBudmx0ID0gXCI84oOSXCI7XG52YXIgbnZsdHJpZSA9IFwi4oq04oOSXCI7XG52YXIgbnZyQXJyID0gXCLipINcIjtcbnZhciBudnJ0cmllID0gXCLiirXig5JcIjtcbnZhciBudnNpbSA9IFwi4oi84oOSXCI7XG52YXIgbndhcmhrID0gXCLipKNcIjtcbnZhciBud2FyciA9IFwi4oaWXCI7XG52YXIgbndBcnIgPSBcIuKHllwiO1xudmFyIG53YXJyb3cgPSBcIuKGllwiO1xudmFyIG53bmVhciA9IFwi4qSnXCI7XG52YXIgT2FjdXRlJDEgPSBcIsOTXCI7XG52YXIgb2FjdXRlJDEgPSBcIsOzXCI7XG52YXIgb2FzdCA9IFwi4oqbXCI7XG52YXIgT2NpcmMkMSA9IFwiw5RcIjtcbnZhciBvY2lyYyQxID0gXCLDtFwiO1xudmFyIG9jaXIgPSBcIuKKmlwiO1xudmFyIE9jeSA9IFwi0J5cIjtcbnZhciBvY3kgPSBcItC+XCI7XG52YXIgb2Rhc2ggPSBcIuKKnVwiO1xudmFyIE9kYmxhYyA9IFwixZBcIjtcbnZhciBvZGJsYWMgPSBcIsWRXCI7XG52YXIgb2RpdiA9IFwi4qi4XCI7XG52YXIgb2RvdCA9IFwi4oqZXCI7XG52YXIgb2Rzb2xkID0gXCLiprxcIjtcbnZhciBPRWxpZyA9IFwixZJcIjtcbnZhciBvZWxpZyA9IFwixZNcIjtcbnZhciBvZmNpciA9IFwi4qa/XCI7XG52YXIgT2ZyID0gXCLwnZSSXCI7XG52YXIgb2ZyID0gXCLwnZSsXCI7XG52YXIgb2dvbiA9IFwiy5tcIjtcbnZhciBPZ3JhdmUkMSA9IFwiw5JcIjtcbnZhciBvZ3JhdmUkMSA9IFwiw7JcIjtcbnZhciBvZ3QgPSBcIuKngVwiO1xudmFyIG9oYmFyID0gXCLiprVcIjtcbnZhciBvaG0gPSBcIs6pXCI7XG52YXIgb2ludCA9IFwi4oiuXCI7XG52YXIgb2xhcnIgPSBcIuKGulwiO1xudmFyIG9sY2lyID0gXCLipr5cIjtcbnZhciBvbGNyb3NzID0gXCLiprtcIjtcbnZhciBvbGluZSA9IFwi4oC+XCI7XG52YXIgb2x0ID0gXCLip4BcIjtcbnZhciBPbWFjciA9IFwixYxcIjtcbnZhciBvbWFjciA9IFwixY1cIjtcbnZhciBPbWVnYSA9IFwizqlcIjtcbnZhciBvbWVnYSA9IFwiz4lcIjtcbnZhciBPbWljcm9uID0gXCLOn1wiO1xudmFyIG9taWNyb24gPSBcIs6/XCI7XG52YXIgb21pZCA9IFwi4qa2XCI7XG52YXIgb21pbnVzID0gXCLiipZcIjtcbnZhciBPb3BmID0gXCLwnZWGXCI7XG52YXIgb29wZiA9IFwi8J2VoFwiO1xudmFyIG9wYXIgPSBcIuKmt1wiO1xudmFyIE9wZW5DdXJseURvdWJsZVF1b3RlID0gXCLigJxcIjtcbnZhciBPcGVuQ3VybHlRdW90ZSA9IFwi4oCYXCI7XG52YXIgb3BlcnAgPSBcIuKmuVwiO1xudmFyIG9wbHVzID0gXCLiipVcIjtcbnZhciBvcmFyciA9IFwi4oa7XCI7XG52YXIgT3IgPSBcIuKplFwiO1xudmFyIG9yID0gXCLiiKhcIjtcbnZhciBvcmQgPSBcIuKpnVwiO1xudmFyIG9yZGVyID0gXCLihLRcIjtcbnZhciBvcmRlcm9mID0gXCLihLRcIjtcbnZhciBvcmRmJDEgPSBcIsKqXCI7XG52YXIgb3JkbSQxID0gXCLCulwiO1xudmFyIG9yaWdvZiA9IFwi4oq2XCI7XG52YXIgb3JvciA9IFwi4qmWXCI7XG52YXIgb3JzbG9wZSA9IFwi4qmXXCI7XG52YXIgb3J2ID0gXCLiqZtcIjtcbnZhciBvUyA9IFwi4pOIXCI7XG52YXIgT3NjciA9IFwi8J2SqlwiO1xudmFyIG9zY3IgPSBcIuKEtFwiO1xudmFyIE9zbGFzaCQxID0gXCLDmFwiO1xudmFyIG9zbGFzaCQxID0gXCLDuFwiO1xudmFyIG9zb2wgPSBcIuKKmFwiO1xudmFyIE90aWxkZSQxID0gXCLDlVwiO1xudmFyIG90aWxkZSQxID0gXCLDtVwiO1xudmFyIG90aW1lc2FzID0gXCLiqLZcIjtcbnZhciBPdGltZXMgPSBcIuKot1wiO1xudmFyIG90aW1lcyA9IFwi4oqXXCI7XG52YXIgT3VtbCQxID0gXCLDllwiO1xudmFyIG91bWwkMSA9IFwiw7ZcIjtcbnZhciBvdmJhciA9IFwi4oy9XCI7XG52YXIgT3ZlckJhciA9IFwi4oC+XCI7XG52YXIgT3ZlckJyYWNlID0gXCLij55cIjtcbnZhciBPdmVyQnJhY2tldCA9IFwi4o60XCI7XG52YXIgT3ZlclBhcmVudGhlc2lzID0gXCLij5xcIjtcbnZhciBwYXJhJDEgPSBcIsK2XCI7XG52YXIgcGFyYWxsZWwgPSBcIuKIpVwiO1xudmFyIHBhciA9IFwi4oilXCI7XG52YXIgcGFyc2ltID0gXCLiq7NcIjtcbnZhciBwYXJzbCA9IFwi4qu9XCI7XG52YXIgcGFydCA9IFwi4oiCXCI7XG52YXIgUGFydGlhbEQgPSBcIuKIglwiO1xudmFyIFBjeSA9IFwi0J9cIjtcbnZhciBwY3kgPSBcItC/XCI7XG52YXIgcGVyY250ID0gXCIlXCI7XG52YXIgcGVyaW9kID0gXCIuXCI7XG52YXIgcGVybWlsID0gXCLigLBcIjtcbnZhciBwZXJwID0gXCLiiqVcIjtcbnZhciBwZXJ0ZW5rID0gXCLigLFcIjtcbnZhciBQZnIgPSBcIvCdlJNcIjtcbnZhciBwZnIgPSBcIvCdlK1cIjtcbnZhciBQaGkgPSBcIs6mXCI7XG52YXIgcGhpID0gXCLPhlwiO1xudmFyIHBoaXYgPSBcIs+VXCI7XG52YXIgcGhtbWF0ID0gXCLihLNcIjtcbnZhciBwaG9uZSA9IFwi4piOXCI7XG52YXIgUGkgPSBcIs6gXCI7XG52YXIgcGkgPSBcIs+AXCI7XG52YXIgcGl0Y2hmb3JrID0gXCLii5RcIjtcbnZhciBwaXYgPSBcIs+WXCI7XG52YXIgcGxhbmNrID0gXCLihI9cIjtcbnZhciBwbGFuY2toID0gXCLihI5cIjtcbnZhciBwbGFua3YgPSBcIuKEj1wiO1xudmFyIHBsdXNhY2lyID0gXCLiqKNcIjtcbnZhciBwbHVzYiA9IFwi4oqeXCI7XG52YXIgcGx1c2NpciA9IFwi4qiiXCI7XG52YXIgcGx1cyA9IFwiK1wiO1xudmFyIHBsdXNkbyA9IFwi4oiUXCI7XG52YXIgcGx1c2R1ID0gXCLiqKVcIjtcbnZhciBwbHVzZSA9IFwi4qmyXCI7XG52YXIgUGx1c01pbnVzID0gXCLCsVwiO1xudmFyIHBsdXNtbiQxID0gXCLCsVwiO1xudmFyIHBsdXNzaW0gPSBcIuKoplwiO1xudmFyIHBsdXN0d28gPSBcIuKop1wiO1xudmFyIHBtID0gXCLCsVwiO1xudmFyIFBvaW5jYXJlcGxhbmUgPSBcIuKEjFwiO1xudmFyIHBvaW50aW50ID0gXCLiqJVcIjtcbnZhciBwb3BmID0gXCLwnZWhXCI7XG52YXIgUG9wZiA9IFwi4oSZXCI7XG52YXIgcG91bmQkMSA9IFwiwqNcIjtcbnZhciBwcmFwID0gXCLiqrdcIjtcbnZhciBQciA9IFwi4qq7XCI7XG52YXIgcHIgPSBcIuKJulwiO1xudmFyIHByY3VlID0gXCLiibxcIjtcbnZhciBwcmVjYXBwcm94ID0gXCLiqrdcIjtcbnZhciBwcmVjID0gXCLiibpcIjtcbnZhciBwcmVjY3VybHllcSA9IFwi4om8XCI7XG52YXIgUHJlY2VkZXMgPSBcIuKJulwiO1xudmFyIFByZWNlZGVzRXF1YWwgPSBcIuKqr1wiO1xudmFyIFByZWNlZGVzU2xhbnRFcXVhbCA9IFwi4om8XCI7XG52YXIgUHJlY2VkZXNUaWxkZSA9IFwi4om+XCI7XG52YXIgcHJlY2VxID0gXCLiqq9cIjtcbnZhciBwcmVjbmFwcHJveCA9IFwi4qq5XCI7XG52YXIgcHJlY25lcXEgPSBcIuKqtVwiO1xudmFyIHByZWNuc2ltID0gXCLii6hcIjtcbnZhciBwcmUgPSBcIuKqr1wiO1xudmFyIHByRSA9IFwi4qqzXCI7XG52YXIgcHJlY3NpbSA9IFwi4om+XCI7XG52YXIgcHJpbWUgPSBcIuKAslwiO1xudmFyIFByaW1lID0gXCLigLNcIjtcbnZhciBwcmltZXMgPSBcIuKEmVwiO1xudmFyIHBybmFwID0gXCLiqrlcIjtcbnZhciBwcm5FID0gXCLiqrVcIjtcbnZhciBwcm5zaW0gPSBcIuKLqFwiO1xudmFyIHByb2QgPSBcIuKIj1wiO1xudmFyIFByb2R1Y3QgPSBcIuKIj1wiO1xudmFyIHByb2ZhbGFyID0gXCLijK5cIjtcbnZhciBwcm9mbGluZSA9IFwi4oySXCI7XG52YXIgcHJvZnN1cmYgPSBcIuKMk1wiO1xudmFyIHByb3AgPSBcIuKInVwiO1xudmFyIFByb3BvcnRpb25hbCA9IFwi4oidXCI7XG52YXIgUHJvcG9ydGlvbiA9IFwi4oi3XCI7XG52YXIgcHJvcHRvID0gXCLiiJ1cIjtcbnZhciBwcnNpbSA9IFwi4om+XCI7XG52YXIgcHJ1cmVsID0gXCLiirBcIjtcbnZhciBQc2NyID0gXCLwnZKrXCI7XG52YXIgcHNjciA9IFwi8J2ThVwiO1xudmFyIFBzaSA9IFwizqhcIjtcbnZhciBwc2kgPSBcIs+IXCI7XG52YXIgcHVuY3NwID0gXCLigIhcIjtcbnZhciBRZnIgPSBcIvCdlJRcIjtcbnZhciBxZnIgPSBcIvCdlK5cIjtcbnZhciBxaW50ID0gXCLiqIxcIjtcbnZhciBxb3BmID0gXCLwnZWiXCI7XG52YXIgUW9wZiA9IFwi4oSaXCI7XG52YXIgcXByaW1lID0gXCLigZdcIjtcbnZhciBRc2NyID0gXCLwnZKsXCI7XG52YXIgcXNjciA9IFwi8J2ThlwiO1xudmFyIHF1YXRlcm5pb25zID0gXCLihI1cIjtcbnZhciBxdWF0aW50ID0gXCLiqJZcIjtcbnZhciBxdWVzdCA9IFwiP1wiO1xudmFyIHF1ZXN0ZXEgPSBcIuKJn1wiO1xudmFyIHF1b3QkMiA9IFwiXFxcIlwiO1xudmFyIFFVT1QkMSA9IFwiXFxcIlwiO1xudmFyIHJBYXJyID0gXCLih5tcIjtcbnZhciByYWNlID0gXCLiiL3MsVwiO1xudmFyIFJhY3V0ZSA9IFwixZRcIjtcbnZhciByYWN1dGUgPSBcIsWVXCI7XG52YXIgcmFkaWMgPSBcIuKImlwiO1xudmFyIHJhZW1wdHl2ID0gXCLiprNcIjtcbnZhciByYW5nID0gXCLin6lcIjtcbnZhciBSYW5nID0gXCLin6tcIjtcbnZhciByYW5nZCA9IFwi4qaSXCI7XG52YXIgcmFuZ2UgPSBcIuKmpVwiO1xudmFyIHJhbmdsZSA9IFwi4p+pXCI7XG52YXIgcmFxdW8kMSA9IFwiwrtcIjtcbnZhciByYXJyYXAgPSBcIuKltVwiO1xudmFyIHJhcnJiID0gXCLih6VcIjtcbnZhciByYXJyYmZzID0gXCLipKBcIjtcbnZhciByYXJyYyA9IFwi4qSzXCI7XG52YXIgcmFyciA9IFwi4oaSXCI7XG52YXIgUmFyciA9IFwi4oagXCI7XG52YXIgckFyciA9IFwi4oeSXCI7XG52YXIgcmFycmZzID0gXCLipJ5cIjtcbnZhciByYXJyaGsgPSBcIuKGqlwiO1xudmFyIHJhcnJscCA9IFwi4oasXCI7XG52YXIgcmFycnBsID0gXCLipYVcIjtcbnZhciByYXJyc2ltID0gXCLipbRcIjtcbnZhciBSYXJydGwgPSBcIuKkllwiO1xudmFyIHJhcnJ0bCA9IFwi4oajXCI7XG52YXIgcmFycncgPSBcIuKGnVwiO1xudmFyIHJhdGFpbCA9IFwi4qSaXCI7XG52YXIgckF0YWlsID0gXCLipJxcIjtcbnZhciByYXRpbyA9IFwi4oi2XCI7XG52YXIgcmF0aW9uYWxzID0gXCLihJpcIjtcbnZhciByYmFyciA9IFwi4qSNXCI7XG52YXIgckJhcnIgPSBcIuKkj1wiO1xudmFyIFJCYXJyID0gXCLipJBcIjtcbnZhciByYmJyayA9IFwi4p2zXCI7XG52YXIgcmJyYWNlID0gXCJ9XCI7XG52YXIgcmJyYWNrID0gXCJdXCI7XG52YXIgcmJya2UgPSBcIuKmjFwiO1xudmFyIHJicmtzbGQgPSBcIuKmjlwiO1xudmFyIHJicmtzbHUgPSBcIuKmkFwiO1xudmFyIFJjYXJvbiA9IFwixZhcIjtcbnZhciByY2Fyb24gPSBcIsWZXCI7XG52YXIgUmNlZGlsID0gXCLFllwiO1xudmFyIHJjZWRpbCA9IFwixZdcIjtcbnZhciByY2VpbCA9IFwi4oyJXCI7XG52YXIgcmN1YiA9IFwifVwiO1xudmFyIFJjeSA9IFwi0KBcIjtcbnZhciByY3kgPSBcItGAXCI7XG52YXIgcmRjYSA9IFwi4qS3XCI7XG52YXIgcmRsZGhhciA9IFwi4qWpXCI7XG52YXIgcmRxdW8gPSBcIuKAnVwiO1xudmFyIHJkcXVvciA9IFwi4oCdXCI7XG52YXIgcmRzaCA9IFwi4oazXCI7XG52YXIgcmVhbCA9IFwi4oScXCI7XG52YXIgcmVhbGluZSA9IFwi4oSbXCI7XG52YXIgcmVhbHBhcnQgPSBcIuKEnFwiO1xudmFyIHJlYWxzID0gXCLihJ1cIjtcbnZhciBSZSA9IFwi4oScXCI7XG52YXIgcmVjdCA9IFwi4patXCI7XG52YXIgcmVnJDEgPSBcIsKuXCI7XG52YXIgUkVHJDEgPSBcIsKuXCI7XG52YXIgUmV2ZXJzZUVsZW1lbnQgPSBcIuKIi1wiO1xudmFyIFJldmVyc2VFcXVpbGlicml1bSA9IFwi4oeLXCI7XG52YXIgUmV2ZXJzZVVwRXF1aWxpYnJpdW0gPSBcIuKlr1wiO1xudmFyIHJmaXNodCA9IFwi4qW9XCI7XG52YXIgcmZsb29yID0gXCLijItcIjtcbnZhciByZnIgPSBcIvCdlK9cIjtcbnZhciBSZnIgPSBcIuKEnFwiO1xudmFyIHJIYXIgPSBcIuKlpFwiO1xudmFyIHJoYXJkID0gXCLih4FcIjtcbnZhciByaGFydSA9IFwi4oeAXCI7XG52YXIgcmhhcnVsID0gXCLipaxcIjtcbnZhciBSaG8gPSBcIs6hXCI7XG52YXIgcmhvID0gXCLPgVwiO1xudmFyIHJob3YgPSBcIs+xXCI7XG52YXIgUmlnaHRBbmdsZUJyYWNrZXQgPSBcIuKfqVwiO1xudmFyIFJpZ2h0QXJyb3dCYXIgPSBcIuKHpVwiO1xudmFyIHJpZ2h0YXJyb3cgPSBcIuKGklwiO1xudmFyIFJpZ2h0QXJyb3cgPSBcIuKGklwiO1xudmFyIFJpZ2h0YXJyb3cgPSBcIuKHklwiO1xudmFyIFJpZ2h0QXJyb3dMZWZ0QXJyb3cgPSBcIuKHhFwiO1xudmFyIHJpZ2h0YXJyb3d0YWlsID0gXCLihqNcIjtcbnZhciBSaWdodENlaWxpbmcgPSBcIuKMiVwiO1xudmFyIFJpZ2h0RG91YmxlQnJhY2tldCA9IFwi4p+nXCI7XG52YXIgUmlnaHREb3duVGVlVmVjdG9yID0gXCLipZ1cIjtcbnZhciBSaWdodERvd25WZWN0b3JCYXIgPSBcIuKllVwiO1xudmFyIFJpZ2h0RG93blZlY3RvciA9IFwi4oeCXCI7XG52YXIgUmlnaHRGbG9vciA9IFwi4oyLXCI7XG52YXIgcmlnaHRoYXJwb29uZG93biA9IFwi4oeBXCI7XG52YXIgcmlnaHRoYXJwb29udXAgPSBcIuKHgFwiO1xudmFyIHJpZ2h0bGVmdGFycm93cyA9IFwi4oeEXCI7XG52YXIgcmlnaHRsZWZ0aGFycG9vbnMgPSBcIuKHjFwiO1xudmFyIHJpZ2h0cmlnaHRhcnJvd3MgPSBcIuKHiVwiO1xudmFyIHJpZ2h0c3F1aWdhcnJvdyA9IFwi4oadXCI7XG52YXIgUmlnaHRUZWVBcnJvdyA9IFwi4oamXCI7XG52YXIgUmlnaHRUZWUgPSBcIuKKolwiO1xudmFyIFJpZ2h0VGVlVmVjdG9yID0gXCLipZtcIjtcbnZhciByaWdodHRocmVldGltZXMgPSBcIuKLjFwiO1xudmFyIFJpZ2h0VHJpYW5nbGVCYXIgPSBcIuKnkFwiO1xudmFyIFJpZ2h0VHJpYW5nbGUgPSBcIuKKs1wiO1xudmFyIFJpZ2h0VHJpYW5nbGVFcXVhbCA9IFwi4oq1XCI7XG52YXIgUmlnaHRVcERvd25WZWN0b3IgPSBcIuKlj1wiO1xudmFyIFJpZ2h0VXBUZWVWZWN0b3IgPSBcIuKlnFwiO1xudmFyIFJpZ2h0VXBWZWN0b3JCYXIgPSBcIuKllFwiO1xudmFyIFJpZ2h0VXBWZWN0b3IgPSBcIuKGvlwiO1xudmFyIFJpZ2h0VmVjdG9yQmFyID0gXCLipZNcIjtcbnZhciBSaWdodFZlY3RvciA9IFwi4oeAXCI7XG52YXIgcmluZyA9IFwiy5pcIjtcbnZhciByaXNpbmdkb3RzZXEgPSBcIuKJk1wiO1xudmFyIHJsYXJyID0gXCLih4RcIjtcbnZhciBybGhhciA9IFwi4oeMXCI7XG52YXIgcmxtID0gXCLigI9cIjtcbnZhciBybW91c3RhY2hlID0gXCLijrFcIjtcbnZhciBybW91c3QgPSBcIuKOsVwiO1xudmFyIHJubWlkID0gXCLiq65cIjtcbnZhciByb2FuZyA9IFwi4p+tXCI7XG52YXIgcm9hcnIgPSBcIuKHvlwiO1xudmFyIHJvYnJrID0gXCLin6dcIjtcbnZhciByb3BhciA9IFwi4qaGXCI7XG52YXIgcm9wZiA9IFwi8J2Vo1wiO1xudmFyIFJvcGYgPSBcIuKEnVwiO1xudmFyIHJvcGx1cyA9IFwi4qiuXCI7XG52YXIgcm90aW1lcyA9IFwi4qi1XCI7XG52YXIgUm91bmRJbXBsaWVzID0gXCLipbBcIjtcbnZhciBycGFyID0gXCIpXCI7XG52YXIgcnBhcmd0ID0gXCLippRcIjtcbnZhciBycHBvbGludCA9IFwi4qiSXCI7XG52YXIgcnJhcnIgPSBcIuKHiVwiO1xudmFyIFJyaWdodGFycm93ID0gXCLih5tcIjtcbnZhciByc2FxdW8gPSBcIuKAulwiO1xudmFyIHJzY3IgPSBcIvCdk4dcIjtcbnZhciBSc2NyID0gXCLihJtcIjtcbnZhciByc2ggPSBcIuKGsVwiO1xudmFyIFJzaCA9IFwi4oaxXCI7XG52YXIgcnNxYiA9IFwiXVwiO1xudmFyIHJzcXVvID0gXCLigJlcIjtcbnZhciByc3F1b3IgPSBcIuKAmVwiO1xudmFyIHJ0aHJlZSA9IFwi4ouMXCI7XG52YXIgcnRpbWVzID0gXCLii4pcIjtcbnZhciBydHJpID0gXCLilrlcIjtcbnZhciBydHJpZSA9IFwi4oq1XCI7XG52YXIgcnRyaWYgPSBcIuKWuFwiO1xudmFyIHJ0cmlsdHJpID0gXCLip45cIjtcbnZhciBSdWxlRGVsYXllZCA9IFwi4qe0XCI7XG52YXIgcnVsdWhhciA9IFwi4qWoXCI7XG52YXIgcnggPSBcIuKEnlwiO1xudmFyIFNhY3V0ZSA9IFwixZpcIjtcbnZhciBzYWN1dGUgPSBcIsWbXCI7XG52YXIgc2JxdW8gPSBcIuKAmlwiO1xudmFyIHNjYXAgPSBcIuKquFwiO1xudmFyIFNjYXJvbiA9IFwixaBcIjtcbnZhciBzY2Fyb24gPSBcIsWhXCI7XG52YXIgU2MgPSBcIuKqvFwiO1xudmFyIHNjID0gXCLiibtcIjtcbnZhciBzY2N1ZSA9IFwi4om9XCI7XG52YXIgc2NlID0gXCLiqrBcIjtcbnZhciBzY0UgPSBcIuKqtFwiO1xudmFyIFNjZWRpbCA9IFwixZ5cIjtcbnZhciBzY2VkaWwgPSBcIsWfXCI7XG52YXIgU2NpcmMgPSBcIsWcXCI7XG52YXIgc2NpcmMgPSBcIsWdXCI7XG52YXIgc2NuYXAgPSBcIuKqulwiO1xudmFyIHNjbkUgPSBcIuKqtlwiO1xudmFyIHNjbnNpbSA9IFwi4oupXCI7XG52YXIgc2Nwb2xpbnQgPSBcIuKok1wiO1xudmFyIHNjc2ltID0gXCLiib9cIjtcbnZhciBTY3kgPSBcItChXCI7XG52YXIgc2N5ID0gXCLRgVwiO1xudmFyIHNkb3RiID0gXCLiiqFcIjtcbnZhciBzZG90ID0gXCLii4VcIjtcbnZhciBzZG90ZSA9IFwi4qmmXCI7XG52YXIgc2VhcmhrID0gXCLipKVcIjtcbnZhciBzZWFyciA9IFwi4oaYXCI7XG52YXIgc2VBcnIgPSBcIuKHmFwiO1xudmFyIHNlYXJyb3cgPSBcIuKGmFwiO1xudmFyIHNlY3QkMSA9IFwiwqdcIjtcbnZhciBzZW1pID0gXCI7XCI7XG52YXIgc2Vzd2FyID0gXCLipKlcIjtcbnZhciBzZXRtaW51cyA9IFwi4oiWXCI7XG52YXIgc2V0bW4gPSBcIuKIllwiO1xudmFyIHNleHQgPSBcIuKctlwiO1xudmFyIFNmciA9IFwi8J2UllwiO1xudmFyIHNmciA9IFwi8J2UsFwiO1xudmFyIHNmcm93biA9IFwi4oyiXCI7XG52YXIgc2hhcnAgPSBcIuKZr1wiO1xudmFyIFNIQ0hjeSA9IFwi0KlcIjtcbnZhciBzaGNoY3kgPSBcItGJXCI7XG52YXIgU0hjeSA9IFwi0KhcIjtcbnZhciBzaGN5ID0gXCLRiFwiO1xudmFyIFNob3J0RG93bkFycm93ID0gXCLihpNcIjtcbnZhciBTaG9ydExlZnRBcnJvdyA9IFwi4oaQXCI7XG52YXIgc2hvcnRtaWQgPSBcIuKIo1wiO1xudmFyIHNob3J0cGFyYWxsZWwgPSBcIuKIpVwiO1xudmFyIFNob3J0UmlnaHRBcnJvdyA9IFwi4oaSXCI7XG52YXIgU2hvcnRVcEFycm93ID0gXCLihpFcIjtcbnZhciBzaHkkMSA9IFwiwq1cIjtcbnZhciBTaWdtYSA9IFwizqNcIjtcbnZhciBzaWdtYSA9IFwiz4NcIjtcbnZhciBzaWdtYWYgPSBcIs+CXCI7XG52YXIgc2lnbWF2ID0gXCLPglwiO1xudmFyIHNpbSA9IFwi4oi8XCI7XG52YXIgc2ltZG90ID0gXCLiqapcIjtcbnZhciBzaW1lID0gXCLiiYNcIjtcbnZhciBzaW1lcSA9IFwi4omDXCI7XG52YXIgc2ltZyA9IFwi4qqeXCI7XG52YXIgc2ltZ0UgPSBcIuKqoFwiO1xudmFyIHNpbWwgPSBcIuKqnVwiO1xudmFyIHNpbWxFID0gXCLiqp9cIjtcbnZhciBzaW1uZSA9IFwi4omGXCI7XG52YXIgc2ltcGx1cyA9IFwi4qikXCI7XG52YXIgc2ltcmFyciA9IFwi4qWyXCI7XG52YXIgc2xhcnIgPSBcIuKGkFwiO1xudmFyIFNtYWxsQ2lyY2xlID0gXCLiiJhcIjtcbnZhciBzbWFsbHNldG1pbnVzID0gXCLiiJZcIjtcbnZhciBzbWFzaHAgPSBcIuKos1wiO1xudmFyIHNtZXBhcnNsID0gXCLip6RcIjtcbnZhciBzbWlkID0gXCLiiKNcIjtcbnZhciBzbWlsZSA9IFwi4oyjXCI7XG52YXIgc210ID0gXCLiqqpcIjtcbnZhciBzbXRlID0gXCLiqqxcIjtcbnZhciBzbXRlcyA9IFwi4qqs77iAXCI7XG52YXIgU09GVGN5ID0gXCLQrFwiO1xudmFyIHNvZnRjeSA9IFwi0YxcIjtcbnZhciBzb2xiYXIgPSBcIuKMv1wiO1xudmFyIHNvbGIgPSBcIuKnhFwiO1xudmFyIHNvbCA9IFwiL1wiO1xudmFyIFNvcGYgPSBcIvCdlYpcIjtcbnZhciBzb3BmID0gXCLwnZWkXCI7XG52YXIgc3BhZGVzID0gXCLimaBcIjtcbnZhciBzcGFkZXN1aXQgPSBcIuKZoFwiO1xudmFyIHNwYXIgPSBcIuKIpVwiO1xudmFyIHNxY2FwID0gXCLiipNcIjtcbnZhciBzcWNhcHMgPSBcIuKKk++4gFwiO1xudmFyIHNxY3VwID0gXCLiipRcIjtcbnZhciBzcWN1cHMgPSBcIuKKlO+4gFwiO1xudmFyIFNxcnQgPSBcIuKImlwiO1xudmFyIHNxc3ViID0gXCLiio9cIjtcbnZhciBzcXN1YmUgPSBcIuKKkVwiO1xudmFyIHNxc3Vic2V0ID0gXCLiio9cIjtcbnZhciBzcXN1YnNldGVxID0gXCLiipFcIjtcbnZhciBzcXN1cCA9IFwi4oqQXCI7XG52YXIgc3FzdXBlID0gXCLiipJcIjtcbnZhciBzcXN1cHNldCA9IFwi4oqQXCI7XG52YXIgc3FzdXBzZXRlcSA9IFwi4oqSXCI7XG52YXIgc3F1YXJlID0gXCLilqFcIjtcbnZhciBTcXVhcmUgPSBcIuKWoVwiO1xudmFyIFNxdWFyZUludGVyc2VjdGlvbiA9IFwi4oqTXCI7XG52YXIgU3F1YXJlU3Vic2V0ID0gXCLiio9cIjtcbnZhciBTcXVhcmVTdWJzZXRFcXVhbCA9IFwi4oqRXCI7XG52YXIgU3F1YXJlU3VwZXJzZXQgPSBcIuKKkFwiO1xudmFyIFNxdWFyZVN1cGVyc2V0RXF1YWwgPSBcIuKKklwiO1xudmFyIFNxdWFyZVVuaW9uID0gXCLiipRcIjtcbnZhciBzcXVhcmYgPSBcIuKWqlwiO1xudmFyIHNxdSA9IFwi4pahXCI7XG52YXIgc3F1ZiA9IFwi4paqXCI7XG52YXIgc3JhcnIgPSBcIuKGklwiO1xudmFyIFNzY3IgPSBcIvCdkq5cIjtcbnZhciBzc2NyID0gXCLwnZOIXCI7XG52YXIgc3NldG1uID0gXCLiiJZcIjtcbnZhciBzc21pbGUgPSBcIuKMo1wiO1xudmFyIHNzdGFyZiA9IFwi4ouGXCI7XG52YXIgU3RhciA9IFwi4ouGXCI7XG52YXIgc3RhciA9IFwi4piGXCI7XG52YXIgc3RhcmYgPSBcIuKYhVwiO1xudmFyIHN0cmFpZ2h0ZXBzaWxvbiA9IFwiz7VcIjtcbnZhciBzdHJhaWdodHBoaSA9IFwiz5VcIjtcbnZhciBzdHJucyA9IFwiwq9cIjtcbnZhciBzdWIgPSBcIuKKglwiO1xudmFyIFN1YiA9IFwi4ouQXCI7XG52YXIgc3ViZG90ID0gXCLiqr1cIjtcbnZhciBzdWJFID0gXCLiq4VcIjtcbnZhciBzdWJlID0gXCLiioZcIjtcbnZhciBzdWJlZG90ID0gXCLiq4NcIjtcbnZhciBzdWJtdWx0ID0gXCLiq4FcIjtcbnZhciBzdWJuRSA9IFwi4quLXCI7XG52YXIgc3VibmUgPSBcIuKKilwiO1xudmFyIHN1YnBsdXMgPSBcIuKqv1wiO1xudmFyIHN1YnJhcnIgPSBcIuKluVwiO1xudmFyIHN1YnNldCA9IFwi4oqCXCI7XG52YXIgU3Vic2V0ID0gXCLii5BcIjtcbnZhciBzdWJzZXRlcSA9IFwi4oqGXCI7XG52YXIgc3Vic2V0ZXFxID0gXCLiq4VcIjtcbnZhciBTdWJzZXRFcXVhbCA9IFwi4oqGXCI7XG52YXIgc3Vic2V0bmVxID0gXCLiiopcIjtcbnZhciBzdWJzZXRuZXFxID0gXCLiq4tcIjtcbnZhciBzdWJzaW0gPSBcIuKrh1wiO1xudmFyIHN1YnN1YiA9IFwi4quVXCI7XG52YXIgc3Vic3VwID0gXCLiq5NcIjtcbnZhciBzdWNjYXBwcm94ID0gXCLiqrhcIjtcbnZhciBzdWNjID0gXCLiibtcIjtcbnZhciBzdWNjY3VybHllcSA9IFwi4om9XCI7XG52YXIgU3VjY2VlZHMgPSBcIuKJu1wiO1xudmFyIFN1Y2NlZWRzRXF1YWwgPSBcIuKqsFwiO1xudmFyIFN1Y2NlZWRzU2xhbnRFcXVhbCA9IFwi4om9XCI7XG52YXIgU3VjY2VlZHNUaWxkZSA9IFwi4om/XCI7XG52YXIgc3VjY2VxID0gXCLiqrBcIjtcbnZhciBzdWNjbmFwcHJveCA9IFwi4qq6XCI7XG52YXIgc3VjY25lcXEgPSBcIuKqtlwiO1xudmFyIHN1Y2Nuc2ltID0gXCLii6lcIjtcbnZhciBzdWNjc2ltID0gXCLiib9cIjtcbnZhciBTdWNoVGhhdCA9IFwi4oiLXCI7XG52YXIgc3VtID0gXCLiiJFcIjtcbnZhciBTdW0gPSBcIuKIkVwiO1xudmFyIHN1bmcgPSBcIuKZqlwiO1xudmFyIHN1cDEkMSA9IFwiwrlcIjtcbnZhciBzdXAyJDEgPSBcIsKyXCI7XG52YXIgc3VwMyQxID0gXCLCs1wiO1xudmFyIHN1cCA9IFwi4oqDXCI7XG52YXIgU3VwID0gXCLii5FcIjtcbnZhciBzdXBkb3QgPSBcIuKqvlwiO1xudmFyIHN1cGRzdWIgPSBcIuKrmFwiO1xudmFyIHN1cEUgPSBcIuKrhlwiO1xudmFyIHN1cGUgPSBcIuKKh1wiO1xudmFyIHN1cGVkb3QgPSBcIuKrhFwiO1xudmFyIFN1cGVyc2V0ID0gXCLiioNcIjtcbnZhciBTdXBlcnNldEVxdWFsID0gXCLiiodcIjtcbnZhciBzdXBoc29sID0gXCLin4lcIjtcbnZhciBzdXBoc3ViID0gXCLiq5dcIjtcbnZhciBzdXBsYXJyID0gXCLipbtcIjtcbnZhciBzdXBtdWx0ID0gXCLiq4JcIjtcbnZhciBzdXBuRSA9IFwi4quMXCI7XG52YXIgc3VwbmUgPSBcIuKKi1wiO1xudmFyIHN1cHBsdXMgPSBcIuKrgFwiO1xudmFyIHN1cHNldCA9IFwi4oqDXCI7XG52YXIgU3Vwc2V0ID0gXCLii5FcIjtcbnZhciBzdXBzZXRlcSA9IFwi4oqHXCI7XG52YXIgc3Vwc2V0ZXFxID0gXCLiq4ZcIjtcbnZhciBzdXBzZXRuZXEgPSBcIuKKi1wiO1xudmFyIHN1cHNldG5lcXEgPSBcIuKrjFwiO1xudmFyIHN1cHNpbSA9IFwi4quIXCI7XG52YXIgc3Vwc3ViID0gXCLiq5RcIjtcbnZhciBzdXBzdXAgPSBcIuKrllwiO1xudmFyIHN3YXJoayA9IFwi4qSmXCI7XG52YXIgc3dhcnIgPSBcIuKGmVwiO1xudmFyIHN3QXJyID0gXCLih5lcIjtcbnZhciBzd2Fycm93ID0gXCLihplcIjtcbnZhciBzd253YXIgPSBcIuKkqlwiO1xudmFyIHN6bGlnJDEgPSBcIsOfXCI7XG52YXIgVGFiID0gXCJcXHRcIjtcbnZhciB0YXJnZXQgPSBcIuKMllwiO1xudmFyIFRhdSA9IFwizqRcIjtcbnZhciB0YXUgPSBcIs+EXCI7XG52YXIgdGJyayA9IFwi4o60XCI7XG52YXIgVGNhcm9uID0gXCLFpFwiO1xudmFyIHRjYXJvbiA9IFwixaVcIjtcbnZhciBUY2VkaWwgPSBcIsWiXCI7XG52YXIgdGNlZGlsID0gXCLFo1wiO1xudmFyIFRjeSA9IFwi0KJcIjtcbnZhciB0Y3kgPSBcItGCXCI7XG52YXIgdGRvdCA9IFwi4oObXCI7XG52YXIgdGVscmVjID0gXCLijJVcIjtcbnZhciBUZnIgPSBcIvCdlJdcIjtcbnZhciB0ZnIgPSBcIvCdlLFcIjtcbnZhciB0aGVyZTQgPSBcIuKItFwiO1xudmFyIHRoZXJlZm9yZSA9IFwi4oi0XCI7XG52YXIgVGhlcmVmb3JlID0gXCLiiLRcIjtcbnZhciBUaGV0YSA9IFwizphcIjtcbnZhciB0aGV0YSA9IFwizrhcIjtcbnZhciB0aGV0YXN5bSA9IFwiz5FcIjtcbnZhciB0aGV0YXYgPSBcIs+RXCI7XG52YXIgdGhpY2thcHByb3ggPSBcIuKJiFwiO1xudmFyIHRoaWNrc2ltID0gXCLiiLxcIjtcbnZhciBUaGlja1NwYWNlID0gXCLigZ/igIpcIjtcbnZhciBUaGluU3BhY2UgPSBcIuKAiVwiO1xudmFyIHRoaW5zcCA9IFwi4oCJXCI7XG52YXIgdGhrYXAgPSBcIuKJiFwiO1xudmFyIHRoa3NpbSA9IFwi4oi8XCI7XG52YXIgVEhPUk4kMSA9IFwiw55cIjtcbnZhciB0aG9ybiQxID0gXCLDvlwiO1xudmFyIHRpbGRlID0gXCLLnFwiO1xudmFyIFRpbGRlID0gXCLiiLxcIjtcbnZhciBUaWxkZUVxdWFsID0gXCLiiYNcIjtcbnZhciBUaWxkZUZ1bGxFcXVhbCA9IFwi4omFXCI7XG52YXIgVGlsZGVUaWxkZSA9IFwi4omIXCI7XG52YXIgdGltZXNiYXIgPSBcIuKosVwiO1xudmFyIHRpbWVzYiA9IFwi4oqgXCI7XG52YXIgdGltZXMkMSA9IFwiw5dcIjtcbnZhciB0aW1lc2QgPSBcIuKosFwiO1xudmFyIHRpbnQgPSBcIuKIrVwiO1xudmFyIHRvZWEgPSBcIuKkqFwiO1xudmFyIHRvcGJvdCA9IFwi4oy2XCI7XG52YXIgdG9wY2lyID0gXCLiq7FcIjtcbnZhciB0b3AgPSBcIuKKpFwiO1xudmFyIFRvcGYgPSBcIvCdlYtcIjtcbnZhciB0b3BmID0gXCLwnZWlXCI7XG52YXIgdG9wZm9yayA9IFwi4quaXCI7XG52YXIgdG9zYSA9IFwi4qSpXCI7XG52YXIgdHByaW1lID0gXCLigLRcIjtcbnZhciB0cmFkZSA9IFwi4oSiXCI7XG52YXIgVFJBREUgPSBcIuKEolwiO1xudmFyIHRyaWFuZ2xlID0gXCLilrVcIjtcbnZhciB0cmlhbmdsZWRvd24gPSBcIuKWv1wiO1xudmFyIHRyaWFuZ2xlbGVmdCA9IFwi4peDXCI7XG52YXIgdHJpYW5nbGVsZWZ0ZXEgPSBcIuKKtFwiO1xudmFyIHRyaWFuZ2xlcSA9IFwi4omcXCI7XG52YXIgdHJpYW5nbGVyaWdodCA9IFwi4pa5XCI7XG52YXIgdHJpYW5nbGVyaWdodGVxID0gXCLiirVcIjtcbnZhciB0cmlkb3QgPSBcIuKXrFwiO1xudmFyIHRyaWUgPSBcIuKJnFwiO1xudmFyIHRyaW1pbnVzID0gXCLiqLpcIjtcbnZhciBUcmlwbGVEb3QgPSBcIuKDm1wiO1xudmFyIHRyaXBsdXMgPSBcIuKouVwiO1xudmFyIHRyaXNiID0gXCLip41cIjtcbnZhciB0cml0aW1lID0gXCLiqLtcIjtcbnZhciB0cnBleml1bSA9IFwi4o+iXCI7XG52YXIgVHNjciA9IFwi8J2Sr1wiO1xudmFyIHRzY3IgPSBcIvCdk4lcIjtcbnZhciBUU2N5ID0gXCLQplwiO1xudmFyIHRzY3kgPSBcItGGXCI7XG52YXIgVFNIY3kgPSBcItCLXCI7XG52YXIgdHNoY3kgPSBcItGbXCI7XG52YXIgVHN0cm9rID0gXCLFplwiO1xudmFyIHRzdHJvayA9IFwixadcIjtcbnZhciB0d2l4dCA9IFwi4omsXCI7XG52YXIgdHdvaGVhZGxlZnRhcnJvdyA9IFwi4oaeXCI7XG52YXIgdHdvaGVhZHJpZ2h0YXJyb3cgPSBcIuKGoFwiO1xudmFyIFVhY3V0ZSQxID0gXCLDmlwiO1xudmFyIHVhY3V0ZSQxID0gXCLDulwiO1xudmFyIHVhcnIgPSBcIuKGkVwiO1xudmFyIFVhcnIgPSBcIuKGn1wiO1xudmFyIHVBcnIgPSBcIuKHkVwiO1xudmFyIFVhcnJvY2lyID0gXCLipYlcIjtcbnZhciBVYnJjeSA9IFwi0I5cIjtcbnZhciB1YnJjeSA9IFwi0Z5cIjtcbnZhciBVYnJldmUgPSBcIsWsXCI7XG52YXIgdWJyZXZlID0gXCLFrVwiO1xudmFyIFVjaXJjJDEgPSBcIsObXCI7XG52YXIgdWNpcmMkMSA9IFwiw7tcIjtcbnZhciBVY3kgPSBcItCjXCI7XG52YXIgdWN5ID0gXCLRg1wiO1xudmFyIHVkYXJyID0gXCLih4VcIjtcbnZhciBVZGJsYWMgPSBcIsWwXCI7XG52YXIgdWRibGFjID0gXCLFsVwiO1xudmFyIHVkaGFyID0gXCLipa5cIjtcbnZhciB1ZmlzaHQgPSBcIuKlvlwiO1xudmFyIFVmciA9IFwi8J2UmFwiO1xudmFyIHVmciA9IFwi8J2UslwiO1xudmFyIFVncmF2ZSQxID0gXCLDmVwiO1xudmFyIHVncmF2ZSQxID0gXCLDuVwiO1xudmFyIHVIYXIgPSBcIuKlo1wiO1xudmFyIHVoYXJsID0gXCLihr9cIjtcbnZhciB1aGFyciA9IFwi4oa+XCI7XG52YXIgdWhibGsgPSBcIuKWgFwiO1xudmFyIHVsY29ybiA9IFwi4oycXCI7XG52YXIgdWxjb3JuZXIgPSBcIuKMnFwiO1xudmFyIHVsY3JvcCA9IFwi4oyPXCI7XG52YXIgdWx0cmkgPSBcIuKXuFwiO1xudmFyIFVtYWNyID0gXCLFqlwiO1xudmFyIHVtYWNyID0gXCLFq1wiO1xudmFyIHVtbCQxID0gXCLCqFwiO1xudmFyIFVuZGVyQmFyID0gXCJfXCI7XG52YXIgVW5kZXJCcmFjZSA9IFwi4o+fXCI7XG52YXIgVW5kZXJCcmFja2V0ID0gXCLijrVcIjtcbnZhciBVbmRlclBhcmVudGhlc2lzID0gXCLij51cIjtcbnZhciBVbmlvbiA9IFwi4ouDXCI7XG52YXIgVW5pb25QbHVzID0gXCLiio5cIjtcbnZhciBVb2dvbiA9IFwixbJcIjtcbnZhciB1b2dvbiA9IFwixbNcIjtcbnZhciBVb3BmID0gXCLwnZWMXCI7XG52YXIgdW9wZiA9IFwi8J2VplwiO1xudmFyIFVwQXJyb3dCYXIgPSBcIuKkklwiO1xudmFyIHVwYXJyb3cgPSBcIuKGkVwiO1xudmFyIFVwQXJyb3cgPSBcIuKGkVwiO1xudmFyIFVwYXJyb3cgPSBcIuKHkVwiO1xudmFyIFVwQXJyb3dEb3duQXJyb3cgPSBcIuKHhVwiO1xudmFyIHVwZG93bmFycm93ID0gXCLihpVcIjtcbnZhciBVcERvd25BcnJvdyA9IFwi4oaVXCI7XG52YXIgVXBkb3duYXJyb3cgPSBcIuKHlVwiO1xudmFyIFVwRXF1aWxpYnJpdW0gPSBcIuKlrlwiO1xudmFyIHVwaGFycG9vbmxlZnQgPSBcIuKGv1wiO1xudmFyIHVwaGFycG9vbnJpZ2h0ID0gXCLihr5cIjtcbnZhciB1cGx1cyA9IFwi4oqOXCI7XG52YXIgVXBwZXJMZWZ0QXJyb3cgPSBcIuKGllwiO1xudmFyIFVwcGVyUmlnaHRBcnJvdyA9IFwi4oaXXCI7XG52YXIgdXBzaSA9IFwiz4VcIjtcbnZhciBVcHNpID0gXCLPklwiO1xudmFyIHVwc2loID0gXCLPklwiO1xudmFyIFVwc2lsb24gPSBcIs6lXCI7XG52YXIgdXBzaWxvbiA9IFwiz4VcIjtcbnZhciBVcFRlZUFycm93ID0gXCLihqVcIjtcbnZhciBVcFRlZSA9IFwi4oqlXCI7XG52YXIgdXB1cGFycm93cyA9IFwi4oeIXCI7XG52YXIgdXJjb3JuID0gXCLijJ1cIjtcbnZhciB1cmNvcm5lciA9IFwi4oydXCI7XG52YXIgdXJjcm9wID0gXCLijI5cIjtcbnZhciBVcmluZyA9IFwixa5cIjtcbnZhciB1cmluZyA9IFwixa9cIjtcbnZhciB1cnRyaSA9IFwi4pe5XCI7XG52YXIgVXNjciA9IFwi8J2SsFwiO1xudmFyIHVzY3IgPSBcIvCdk4pcIjtcbnZhciB1dGRvdCA9IFwi4ouwXCI7XG52YXIgVXRpbGRlID0gXCLFqFwiO1xudmFyIHV0aWxkZSA9IFwixalcIjtcbnZhciB1dHJpID0gXCLilrVcIjtcbnZhciB1dHJpZiA9IFwi4pa0XCI7XG52YXIgdXVhcnIgPSBcIuKHiFwiO1xudmFyIFV1bWwkMSA9IFwiw5xcIjtcbnZhciB1dW1sJDEgPSBcIsO8XCI7XG52YXIgdXdhbmdsZSA9IFwi4qanXCI7XG52YXIgdmFuZ3J0ID0gXCLippxcIjtcbnZhciB2YXJlcHNpbG9uID0gXCLPtVwiO1xudmFyIHZhcmthcHBhID0gXCLPsFwiO1xudmFyIHZhcm5vdGhpbmcgPSBcIuKIhVwiO1xudmFyIHZhcnBoaSA9IFwiz5VcIjtcbnZhciB2YXJwaSA9IFwiz5ZcIjtcbnZhciB2YXJwcm9wdG8gPSBcIuKInVwiO1xudmFyIHZhcnIgPSBcIuKGlVwiO1xudmFyIHZBcnIgPSBcIuKHlVwiO1xudmFyIHZhcnJobyA9IFwiz7FcIjtcbnZhciB2YXJzaWdtYSA9IFwiz4JcIjtcbnZhciB2YXJzdWJzZXRuZXEgPSBcIuKKiu+4gFwiO1xudmFyIHZhcnN1YnNldG5lcXEgPSBcIuKri++4gFwiO1xudmFyIHZhcnN1cHNldG5lcSA9IFwi4oqL77iAXCI7XG52YXIgdmFyc3Vwc2V0bmVxcSA9IFwi4quM77iAXCI7XG52YXIgdmFydGhldGEgPSBcIs+RXCI7XG52YXIgdmFydHJpYW5nbGVsZWZ0ID0gXCLiirJcIjtcbnZhciB2YXJ0cmlhbmdsZXJpZ2h0ID0gXCLiirNcIjtcbnZhciB2QmFyID0gXCLiq6hcIjtcbnZhciBWYmFyID0gXCLiq6tcIjtcbnZhciB2QmFydiA9IFwi4qupXCI7XG52YXIgVmN5ID0gXCLQklwiO1xudmFyIHZjeSA9IFwi0LJcIjtcbnZhciB2ZGFzaCA9IFwi4oqiXCI7XG52YXIgdkRhc2ggPSBcIuKKqFwiO1xudmFyIFZkYXNoID0gXCLiiqlcIjtcbnZhciBWRGFzaCA9IFwi4oqrXCI7XG52YXIgVmRhc2hsID0gXCLiq6ZcIjtcbnZhciB2ZWViYXIgPSBcIuKKu1wiO1xudmFyIHZlZSA9IFwi4oioXCI7XG52YXIgVmVlID0gXCLii4FcIjtcbnZhciB2ZWVlcSA9IFwi4omaXCI7XG52YXIgdmVsbGlwID0gXCLii65cIjtcbnZhciB2ZXJiYXIgPSBcInxcIjtcbnZhciBWZXJiYXIgPSBcIuKAllwiO1xudmFyIHZlcnQgPSBcInxcIjtcbnZhciBWZXJ0ID0gXCLigJZcIjtcbnZhciBWZXJ0aWNhbEJhciA9IFwi4oijXCI7XG52YXIgVmVydGljYWxMaW5lID0gXCJ8XCI7XG52YXIgVmVydGljYWxTZXBhcmF0b3IgPSBcIuKdmFwiO1xudmFyIFZlcnRpY2FsVGlsZGUgPSBcIuKJgFwiO1xudmFyIFZlcnlUaGluU3BhY2UgPSBcIuKAilwiO1xudmFyIFZmciA9IFwi8J2UmVwiO1xudmFyIHZmciA9IFwi8J2Us1wiO1xudmFyIHZsdHJpID0gXCLiirJcIjtcbnZhciB2bnN1YiA9IFwi4oqC4oOSXCI7XG52YXIgdm5zdXAgPSBcIuKKg+KDklwiO1xudmFyIFZvcGYgPSBcIvCdlY1cIjtcbnZhciB2b3BmID0gXCLwnZWnXCI7XG52YXIgdnByb3AgPSBcIuKInVwiO1xudmFyIHZydHJpID0gXCLiirNcIjtcbnZhciBWc2NyID0gXCLwnZKxXCI7XG52YXIgdnNjciA9IFwi8J2Ti1wiO1xudmFyIHZzdWJuRSA9IFwi4quL77iAXCI7XG52YXIgdnN1Ym5lID0gXCLiiorvuIBcIjtcbnZhciB2c3VwbkUgPSBcIuKrjO+4gFwiO1xudmFyIHZzdXBuZSA9IFwi4oqL77iAXCI7XG52YXIgVnZkYXNoID0gXCLiiqpcIjtcbnZhciB2emlnemFnID0gXCLipppcIjtcbnZhciBXY2lyYyA9IFwixbRcIjtcbnZhciB3Y2lyYyA9IFwixbVcIjtcbnZhciB3ZWRiYXIgPSBcIuKpn1wiO1xudmFyIHdlZGdlID0gXCLiiKdcIjtcbnZhciBXZWRnZSA9IFwi4ouAXCI7XG52YXIgd2VkZ2VxID0gXCLiiZlcIjtcbnZhciB3ZWllcnAgPSBcIuKEmFwiO1xudmFyIFdmciA9IFwi8J2UmlwiO1xudmFyIHdmciA9IFwi8J2UtFwiO1xudmFyIFdvcGYgPSBcIvCdlY5cIjtcbnZhciB3b3BmID0gXCLwnZWoXCI7XG52YXIgd3AgPSBcIuKEmFwiO1xudmFyIHdyID0gXCLiiYBcIjtcbnZhciB3cmVhdGggPSBcIuKJgFwiO1xudmFyIFdzY3IgPSBcIvCdkrJcIjtcbnZhciB3c2NyID0gXCLwnZOMXCI7XG52YXIgeGNhcCA9IFwi4ouCXCI7XG52YXIgeGNpcmMgPSBcIuKXr1wiO1xudmFyIHhjdXAgPSBcIuKLg1wiO1xudmFyIHhkdHJpID0gXCLilr1cIjtcbnZhciBYZnIgPSBcIvCdlJtcIjtcbnZhciB4ZnIgPSBcIvCdlLVcIjtcbnZhciB4aGFyciA9IFwi4p+3XCI7XG52YXIgeGhBcnIgPSBcIuKfulwiO1xudmFyIFhpID0gXCLOnlwiO1xudmFyIHhpID0gXCLOvlwiO1xudmFyIHhsYXJyID0gXCLin7VcIjtcbnZhciB4bEFyciA9IFwi4p+4XCI7XG52YXIgeG1hcCA9IFwi4p+8XCI7XG52YXIgeG5pcyA9IFwi4ou7XCI7XG52YXIgeG9kb3QgPSBcIuKogFwiO1xudmFyIFhvcGYgPSBcIvCdlY9cIjtcbnZhciB4b3BmID0gXCLwnZWpXCI7XG52YXIgeG9wbHVzID0gXCLiqIFcIjtcbnZhciB4b3RpbWUgPSBcIuKoglwiO1xudmFyIHhyYXJyID0gXCLin7ZcIjtcbnZhciB4ckFyciA9IFwi4p+5XCI7XG52YXIgWHNjciA9IFwi8J2Ss1wiO1xudmFyIHhzY3IgPSBcIvCdk41cIjtcbnZhciB4c3FjdXAgPSBcIuKohlwiO1xudmFyIHh1cGx1cyA9IFwi4qiEXCI7XG52YXIgeHV0cmkgPSBcIuKWs1wiO1xudmFyIHh2ZWUgPSBcIuKLgVwiO1xudmFyIHh3ZWRnZSA9IFwi4ouAXCI7XG52YXIgWWFjdXRlJDEgPSBcIsOdXCI7XG52YXIgeWFjdXRlJDEgPSBcIsO9XCI7XG52YXIgWUFjeSA9IFwi0K9cIjtcbnZhciB5YWN5ID0gXCLRj1wiO1xudmFyIFljaXJjID0gXCLFtlwiO1xudmFyIHljaXJjID0gXCLFt1wiO1xudmFyIFljeSA9IFwi0KtcIjtcbnZhciB5Y3kgPSBcItGLXCI7XG52YXIgeWVuJDEgPSBcIsKlXCI7XG52YXIgWWZyID0gXCLwnZScXCI7XG52YXIgeWZyID0gXCLwnZS2XCI7XG52YXIgWUljeSA9IFwi0IdcIjtcbnZhciB5aWN5ID0gXCLRl1wiO1xudmFyIFlvcGYgPSBcIvCdlZBcIjtcbnZhciB5b3BmID0gXCLwnZWqXCI7XG52YXIgWXNjciA9IFwi8J2StFwiO1xudmFyIHlzY3IgPSBcIvCdk45cIjtcbnZhciBZVWN5ID0gXCLQrlwiO1xudmFyIHl1Y3kgPSBcItGOXCI7XG52YXIgeXVtbCQxID0gXCLDv1wiO1xudmFyIFl1bWwgPSBcIsW4XCI7XG52YXIgWmFjdXRlID0gXCLFuVwiO1xudmFyIHphY3V0ZSA9IFwixbpcIjtcbnZhciBaY2Fyb24gPSBcIsW9XCI7XG52YXIgemNhcm9uID0gXCLFvlwiO1xudmFyIFpjeSA9IFwi0JdcIjtcbnZhciB6Y3kgPSBcItC3XCI7XG52YXIgWmRvdCA9IFwixbtcIjtcbnZhciB6ZG90ID0gXCLFvFwiO1xudmFyIHplZXRyZiA9IFwi4oSoXCI7XG52YXIgWmVyb1dpZHRoU3BhY2UgPSBcIuKAi1wiO1xudmFyIFpldGEgPSBcIs6WXCI7XG52YXIgemV0YSA9IFwizrZcIjtcbnZhciB6ZnIgPSBcIvCdlLdcIjtcbnZhciBaZnIgPSBcIuKEqFwiO1xudmFyIFpIY3kgPSBcItCWXCI7XG52YXIgemhjeSA9IFwi0LZcIjtcbnZhciB6aWdyYXJyID0gXCLih51cIjtcbnZhciB6b3BmID0gXCLwnZWrXCI7XG52YXIgWm9wZiA9IFwi4oSkXCI7XG52YXIgWnNjciA9IFwi8J2StVwiO1xudmFyIHpzY3IgPSBcIvCdk49cIjtcbnZhciB6d2ogPSBcIuKAjVwiO1xudmFyIHp3bmogPSBcIuKAjFwiO1xudmFyIHJlcXVpcmUkJDEkMSA9IHtcblx0QWFjdXRlOiBBYWN1dGUkMSxcblx0YWFjdXRlOiBhYWN1dGUkMSxcblx0QWJyZXZlOiBBYnJldmUsXG5cdGFicmV2ZTogYWJyZXZlLFxuXHRhYzogYWMsXG5cdGFjZDogYWNkLFxuXHRhY0U6IGFjRSxcblx0QWNpcmM6IEFjaXJjJDEsXG5cdGFjaXJjOiBhY2lyYyQxLFxuXHRhY3V0ZTogYWN1dGUkMSxcblx0QWN5OiBBY3ksXG5cdGFjeTogYWN5LFxuXHRBRWxpZzogQUVsaWckMSxcblx0YWVsaWc6IGFlbGlnJDEsXG5cdGFmOiBhZixcblx0QWZyOiBBZnIsXG5cdGFmcjogYWZyLFxuXHRBZ3JhdmU6IEFncmF2ZSQxLFxuXHRhZ3JhdmU6IGFncmF2ZSQxLFxuXHRhbGVmc3ltOiBhbGVmc3ltLFxuXHRhbGVwaDogYWxlcGgsXG5cdEFscGhhOiBBbHBoYSxcblx0YWxwaGE6IGFscGhhLFxuXHRBbWFjcjogQW1hY3IsXG5cdGFtYWNyOiBhbWFjcixcblx0YW1hbGc6IGFtYWxnLFxuXHRhbXA6IGFtcCQyLFxuXHRBTVA6IEFNUCQxLFxuXHRhbmRhbmQ6IGFuZGFuZCxcblx0QW5kOiBBbmQsXG5cdGFuZDogYW5kLFxuXHRhbmRkOiBhbmRkLFxuXHRhbmRzbG9wZTogYW5kc2xvcGUsXG5cdGFuZHY6IGFuZHYsXG5cdGFuZzogYW5nLFxuXHRhbmdlOiBhbmdlLFxuXHRhbmdsZTogYW5nbGUsXG5cdGFuZ21zZGFhOiBhbmdtc2RhYSxcblx0YW5nbXNkYWI6IGFuZ21zZGFiLFxuXHRhbmdtc2RhYzogYW5nbXNkYWMsXG5cdGFuZ21zZGFkOiBhbmdtc2RhZCxcblx0YW5nbXNkYWU6IGFuZ21zZGFlLFxuXHRhbmdtc2RhZjogYW5nbXNkYWYsXG5cdGFuZ21zZGFnOiBhbmdtc2RhZyxcblx0YW5nbXNkYWg6IGFuZ21zZGFoLFxuXHRhbmdtc2Q6IGFuZ21zZCxcblx0YW5ncnQ6IGFuZ3J0LFxuXHRhbmdydHZiOiBhbmdydHZiLFxuXHRhbmdydHZiZDogYW5ncnR2YmQsXG5cdGFuZ3NwaDogYW5nc3BoLFxuXHRhbmdzdDogYW5nc3QsXG5cdGFuZ3phcnI6IGFuZ3phcnIsXG5cdEFvZ29uOiBBb2dvbixcblx0YW9nb246IGFvZ29uLFxuXHRBb3BmOiBBb3BmLFxuXHRhb3BmOiBhb3BmLFxuXHRhcGFjaXI6IGFwYWNpcixcblx0YXA6IGFwLFxuXHRhcEU6IGFwRSxcblx0YXBlOiBhcGUsXG5cdGFwaWQ6IGFwaWQsXG5cdGFwb3M6IGFwb3MkMSxcblx0QXBwbHlGdW5jdGlvbjogQXBwbHlGdW5jdGlvbixcblx0YXBwcm94OiBhcHByb3gsXG5cdGFwcHJveGVxOiBhcHByb3hlcSxcblx0QXJpbmc6IEFyaW5nJDEsXG5cdGFyaW5nOiBhcmluZyQxLFxuXHRBc2NyOiBBc2NyLFxuXHRhc2NyOiBhc2NyLFxuXHRBc3NpZ246IEFzc2lnbixcblx0YXN0OiBhc3QsXG5cdGFzeW1wOiBhc3ltcCxcblx0YXN5bXBlcTogYXN5bXBlcSxcblx0QXRpbGRlOiBBdGlsZGUkMSxcblx0YXRpbGRlOiBhdGlsZGUkMSxcblx0QXVtbDogQXVtbCQxLFxuXHRhdW1sOiBhdW1sJDEsXG5cdGF3Y29uaW50OiBhd2NvbmludCxcblx0YXdpbnQ6IGF3aW50LFxuXHRiYWNrY29uZzogYmFja2NvbmcsXG5cdGJhY2tlcHNpbG9uOiBiYWNrZXBzaWxvbixcblx0YmFja3ByaW1lOiBiYWNrcHJpbWUsXG5cdGJhY2tzaW06IGJhY2tzaW0sXG5cdGJhY2tzaW1lcTogYmFja3NpbWVxLFxuXHRCYWNrc2xhc2g6IEJhY2tzbGFzaCxcblx0QmFydjogQmFydixcblx0YmFydmVlOiBiYXJ2ZWUsXG5cdGJhcndlZDogYmFyd2VkLFxuXHRCYXJ3ZWQ6IEJhcndlZCxcblx0YmFyd2VkZ2U6IGJhcndlZGdlLFxuXHRiYnJrOiBiYnJrLFxuXHRiYnJrdGJyazogYmJya3RicmssXG5cdGJjb25nOiBiY29uZyxcblx0QmN5OiBCY3ksXG5cdGJjeTogYmN5LFxuXHRiZHF1bzogYmRxdW8sXG5cdGJlY2F1czogYmVjYXVzLFxuXHRiZWNhdXNlOiBiZWNhdXNlLFxuXHRCZWNhdXNlOiBCZWNhdXNlLFxuXHRiZW1wdHl2OiBiZW1wdHl2LFxuXHRiZXBzaTogYmVwc2ksXG5cdGJlcm5vdTogYmVybm91LFxuXHRCZXJub3VsbGlzOiBCZXJub3VsbGlzLFxuXHRCZXRhOiBCZXRhLFxuXHRiZXRhOiBiZXRhLFxuXHRiZXRoOiBiZXRoLFxuXHRiZXR3ZWVuOiBiZXR3ZWVuLFxuXHRCZnI6IEJmcixcblx0YmZyOiBiZnIsXG5cdGJpZ2NhcDogYmlnY2FwLFxuXHRiaWdjaXJjOiBiaWdjaXJjLFxuXHRiaWdjdXA6IGJpZ2N1cCxcblx0Ymlnb2RvdDogYmlnb2RvdCxcblx0Ymlnb3BsdXM6IGJpZ29wbHVzLFxuXHRiaWdvdGltZXM6IGJpZ290aW1lcyxcblx0Ymlnc3FjdXA6IGJpZ3NxY3VwLFxuXHRiaWdzdGFyOiBiaWdzdGFyLFxuXHRiaWd0cmlhbmdsZWRvd246IGJpZ3RyaWFuZ2xlZG93bixcblx0YmlndHJpYW5nbGV1cDogYmlndHJpYW5nbGV1cCxcblx0YmlndXBsdXM6IGJpZ3VwbHVzLFxuXHRiaWd2ZWU6IGJpZ3ZlZSxcblx0Ymlnd2VkZ2U6IGJpZ3dlZGdlLFxuXHRia2Fyb3c6IGJrYXJvdyxcblx0YmxhY2tsb3plbmdlOiBibGFja2xvemVuZ2UsXG5cdGJsYWNrc3F1YXJlOiBibGFja3NxdWFyZSxcblx0YmxhY2t0cmlhbmdsZTogYmxhY2t0cmlhbmdsZSxcblx0YmxhY2t0cmlhbmdsZWRvd246IGJsYWNrdHJpYW5nbGVkb3duLFxuXHRibGFja3RyaWFuZ2xlbGVmdDogYmxhY2t0cmlhbmdsZWxlZnQsXG5cdGJsYWNrdHJpYW5nbGVyaWdodDogYmxhY2t0cmlhbmdsZXJpZ2h0LFxuXHRibGFuazogYmxhbmssXG5cdGJsazEyOiBibGsxMixcblx0YmxrMTQ6IGJsazE0LFxuXHRibGszNDogYmxrMzQsXG5cdGJsb2NrOiBibG9jayxcblx0Ym5lOiBibmUsXG5cdGJuZXF1aXY6IGJuZXF1aXYsXG5cdGJOb3Q6IGJOb3QsXG5cdGJub3Q6IGJub3QsXG5cdEJvcGY6IEJvcGYsXG5cdGJvcGY6IGJvcGYsXG5cdGJvdDogYm90LFxuXHRib3R0b206IGJvdHRvbSxcblx0Ym93dGllOiBib3d0aWUsXG5cdGJveGJveDogYm94Ym94LFxuXHRib3hkbDogYm94ZGwsXG5cdGJveGRMOiBib3hkTCxcblx0Ym94RGw6IGJveERsLFxuXHRib3hETDogYm94REwsXG5cdGJveGRyOiBib3hkcixcblx0Ym94ZFI6IGJveGRSLFxuXHRib3hEcjogYm94RHIsXG5cdGJveERSOiBib3hEUixcblx0Ym94aDogYm94aCxcblx0Ym94SDogYm94SCxcblx0Ym94aGQ6IGJveGhkLFxuXHRib3hIZDogYm94SGQsXG5cdGJveGhEOiBib3hoRCxcblx0Ym94SEQ6IGJveEhELFxuXHRib3hodTogYm94aHUsXG5cdGJveEh1OiBib3hIdSxcblx0Ym94aFU6IGJveGhVLFxuXHRib3hIVTogYm94SFUsXG5cdGJveG1pbnVzOiBib3htaW51cyxcblx0Ym94cGx1czogYm94cGx1cyxcblx0Ym94dGltZXM6IGJveHRpbWVzLFxuXHRib3h1bDogYm94dWwsXG5cdGJveHVMOiBib3h1TCxcblx0Ym94VWw6IGJveFVsLFxuXHRib3hVTDogYm94VUwsXG5cdGJveHVyOiBib3h1cixcblx0Ym94dVI6IGJveHVSLFxuXHRib3hVcjogYm94VXIsXG5cdGJveFVSOiBib3hVUixcblx0Ym94djogYm94dixcblx0Ym94VjogYm94Vixcblx0Ym94dmg6IGJveHZoLFxuXHRib3h2SDogYm94dkgsXG5cdGJveFZoOiBib3hWaCxcblx0Ym94Vkg6IGJveFZILFxuXHRib3h2bDogYm94dmwsXG5cdGJveHZMOiBib3h2TCxcblx0Ym94Vmw6IGJveFZsLFxuXHRib3hWTDogYm94VkwsXG5cdGJveHZyOiBib3h2cixcblx0Ym94dlI6IGJveHZSLFxuXHRib3hWcjogYm94VnIsXG5cdGJveFZSOiBib3hWUixcblx0YnByaW1lOiBicHJpbWUsXG5cdGJyZXZlOiBicmV2ZSxcblx0QnJldmU6IEJyZXZlLFxuXHRicnZiYXI6IGJydmJhciQxLFxuXHRic2NyOiBic2NyLFxuXHRCc2NyOiBCc2NyLFxuXHRic2VtaTogYnNlbWksXG5cdGJzaW06IGJzaW0sXG5cdGJzaW1lOiBic2ltZSxcblx0YnNvbGI6IGJzb2xiLFxuXHRic29sOiBic29sLFxuXHRic29saHN1YjogYnNvbGhzdWIsXG5cdGJ1bGw6IGJ1bGwsXG5cdGJ1bGxldDogYnVsbGV0LFxuXHRidW1wOiBidW1wLFxuXHRidW1wRTogYnVtcEUsXG5cdGJ1bXBlOiBidW1wZSxcblx0QnVtcGVxOiBCdW1wZXEsXG5cdGJ1bXBlcTogYnVtcGVxLFxuXHRDYWN1dGU6IENhY3V0ZSxcblx0Y2FjdXRlOiBjYWN1dGUsXG5cdGNhcGFuZDogY2FwYW5kLFxuXHRjYXBicmN1cDogY2FwYnJjdXAsXG5cdGNhcGNhcDogY2FwY2FwLFxuXHRjYXA6IGNhcCxcblx0Q2FwOiBDYXAsXG5cdGNhcGN1cDogY2FwY3VwLFxuXHRjYXBkb3Q6IGNhcGRvdCxcblx0Q2FwaXRhbERpZmZlcmVudGlhbEQ6IENhcGl0YWxEaWZmZXJlbnRpYWxELFxuXHRjYXBzOiBjYXBzLFxuXHRjYXJldDogY2FyZXQsXG5cdGNhcm9uOiBjYXJvbixcblx0Q2F5bGV5czogQ2F5bGV5cyxcblx0Y2NhcHM6IGNjYXBzLFxuXHRDY2Fyb246IENjYXJvbixcblx0Y2Nhcm9uOiBjY2Fyb24sXG5cdENjZWRpbDogQ2NlZGlsJDEsXG5cdGNjZWRpbDogY2NlZGlsJDEsXG5cdENjaXJjOiBDY2lyYyxcblx0Y2NpcmM6IGNjaXJjLFxuXHRDY29uaW50OiBDY29uaW50LFxuXHRjY3VwczogY2N1cHMsXG5cdGNjdXBzc206IGNjdXBzc20sXG5cdENkb3Q6IENkb3QsXG5cdGNkb3Q6IGNkb3QsXG5cdGNlZGlsOiBjZWRpbCQxLFxuXHRDZWRpbGxhOiBDZWRpbGxhLFxuXHRjZW1wdHl2OiBjZW1wdHl2LFxuXHRjZW50OiBjZW50JDEsXG5cdGNlbnRlcmRvdDogY2VudGVyZG90LFxuXHRDZW50ZXJEb3Q6IENlbnRlckRvdCxcblx0Y2ZyOiBjZnIsXG5cdENmcjogQ2ZyLFxuXHRDSGN5OiBDSGN5LFxuXHRjaGN5OiBjaGN5LFxuXHRjaGVjazogY2hlY2ssXG5cdGNoZWNrbWFyazogY2hlY2ttYXJrLFxuXHRDaGk6IENoaSxcblx0Y2hpOiBjaGksXG5cdGNpcmM6IGNpcmMsXG5cdGNpcmNlcTogY2lyY2VxLFxuXHRjaXJjbGVhcnJvd2xlZnQ6IGNpcmNsZWFycm93bGVmdCxcblx0Y2lyY2xlYXJyb3dyaWdodDogY2lyY2xlYXJyb3dyaWdodCxcblx0Y2lyY2xlZGFzdDogY2lyY2xlZGFzdCxcblx0Y2lyY2xlZGNpcmM6IGNpcmNsZWRjaXJjLFxuXHRjaXJjbGVkZGFzaDogY2lyY2xlZGRhc2gsXG5cdENpcmNsZURvdDogQ2lyY2xlRG90LFxuXHRjaXJjbGVkUjogY2lyY2xlZFIsXG5cdGNpcmNsZWRTOiBjaXJjbGVkUyxcblx0Q2lyY2xlTWludXM6IENpcmNsZU1pbnVzLFxuXHRDaXJjbGVQbHVzOiBDaXJjbGVQbHVzLFxuXHRDaXJjbGVUaW1lczogQ2lyY2xlVGltZXMsXG5cdGNpcjogY2lyLFxuXHRjaXJFOiBjaXJFLFxuXHRjaXJlOiBjaXJlLFxuXHRjaXJmbmludDogY2lyZm5pbnQsXG5cdGNpcm1pZDogY2lybWlkLFxuXHRjaXJzY2lyOiBjaXJzY2lyLFxuXHRDbG9ja3dpc2VDb250b3VySW50ZWdyYWw6IENsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCxcblx0Q2xvc2VDdXJseURvdWJsZVF1b3RlOiBDbG9zZUN1cmx5RG91YmxlUXVvdGUsXG5cdENsb3NlQ3VybHlRdW90ZTogQ2xvc2VDdXJseVF1b3RlLFxuXHRjbHViczogY2x1YnMsXG5cdGNsdWJzdWl0OiBjbHVic3VpdCxcblx0Y29sb246IGNvbG9uLFxuXHRDb2xvbjogQ29sb24sXG5cdENvbG9uZTogQ29sb25lLFxuXHRjb2xvbmU6IGNvbG9uZSxcblx0Y29sb25lcTogY29sb25lcSxcblx0Y29tbWE6IGNvbW1hLFxuXHRjb21tYXQ6IGNvbW1hdCxcblx0Y29tcDogY29tcCxcblx0Y29tcGZuOiBjb21wZm4sXG5cdGNvbXBsZW1lbnQ6IGNvbXBsZW1lbnQsXG5cdGNvbXBsZXhlczogY29tcGxleGVzLFxuXHRjb25nOiBjb25nLFxuXHRjb25nZG90OiBjb25nZG90LFxuXHRDb25ncnVlbnQ6IENvbmdydWVudCxcblx0Y29uaW50OiBjb25pbnQsXG5cdENvbmludDogQ29uaW50LFxuXHRDb250b3VySW50ZWdyYWw6IENvbnRvdXJJbnRlZ3JhbCxcblx0Y29wZjogY29wZixcblx0Q29wZjogQ29wZixcblx0Y29wcm9kOiBjb3Byb2QsXG5cdENvcHJvZHVjdDogQ29wcm9kdWN0LFxuXHRjb3B5OiBjb3B5JDEsXG5cdENPUFk6IENPUFkkMSxcblx0Y29weXNyOiBjb3B5c3IsXG5cdENvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWw6IENvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwsXG5cdGNyYXJyOiBjcmFycixcblx0Y3Jvc3M6IGNyb3NzLFxuXHRDcm9zczogQ3Jvc3MsXG5cdENzY3I6IENzY3IsXG5cdGNzY3I6IGNzY3IsXG5cdGNzdWI6IGNzdWIsXG5cdGNzdWJlOiBjc3ViZSxcblx0Y3N1cDogY3N1cCxcblx0Y3N1cGU6IGNzdXBlLFxuXHRjdGRvdDogY3Rkb3QsXG5cdGN1ZGFycmw6IGN1ZGFycmwsXG5cdGN1ZGFycnI6IGN1ZGFycnIsXG5cdGN1ZXByOiBjdWVwcixcblx0Y3Vlc2M6IGN1ZXNjLFxuXHRjdWxhcnI6IGN1bGFycixcblx0Y3VsYXJycDogY3VsYXJycCxcblx0Y3VwYnJjYXA6IGN1cGJyY2FwLFxuXHRjdXBjYXA6IGN1cGNhcCxcblx0Q3VwQ2FwOiBDdXBDYXAsXG5cdGN1cDogY3VwLFxuXHRDdXA6IEN1cCxcblx0Y3VwY3VwOiBjdXBjdXAsXG5cdGN1cGRvdDogY3VwZG90LFxuXHRjdXBvcjogY3Vwb3IsXG5cdGN1cHM6IGN1cHMsXG5cdGN1cmFycjogY3VyYXJyLFxuXHRjdXJhcnJtOiBjdXJhcnJtLFxuXHRjdXJseWVxcHJlYzogY3VybHllcXByZWMsXG5cdGN1cmx5ZXFzdWNjOiBjdXJseWVxc3VjYyxcblx0Y3VybHl2ZWU6IGN1cmx5dmVlLFxuXHRjdXJseXdlZGdlOiBjdXJseXdlZGdlLFxuXHRjdXJyZW46IGN1cnJlbiQxLFxuXHRjdXJ2ZWFycm93bGVmdDogY3VydmVhcnJvd2xlZnQsXG5cdGN1cnZlYXJyb3dyaWdodDogY3VydmVhcnJvd3JpZ2h0LFxuXHRjdXZlZTogY3V2ZWUsXG5cdGN1d2VkOiBjdXdlZCxcblx0Y3djb25pbnQ6IGN3Y29uaW50LFxuXHRjd2ludDogY3dpbnQsXG5cdGN5bGN0eTogY3lsY3R5LFxuXHRkYWdnZXI6IGRhZ2dlcixcblx0RGFnZ2VyOiBEYWdnZXIsXG5cdGRhbGV0aDogZGFsZXRoLFxuXHRkYXJyOiBkYXJyLFxuXHREYXJyOiBEYXJyLFxuXHRkQXJyOiBkQXJyLFxuXHRkYXNoOiBkYXNoLFxuXHREYXNodjogRGFzaHYsXG5cdGRhc2h2OiBkYXNodixcblx0ZGJrYXJvdzogZGJrYXJvdyxcblx0ZGJsYWM6IGRibGFjLFxuXHREY2Fyb246IERjYXJvbixcblx0ZGNhcm9uOiBkY2Fyb24sXG5cdERjeTogRGN5LFxuXHRkY3k6IGRjeSxcblx0ZGRhZ2dlcjogZGRhZ2dlcixcblx0ZGRhcnI6IGRkYXJyLFxuXHRERDogREQsXG5cdGRkOiBkZCxcblx0RERvdHJhaGQ6IEREb3RyYWhkLFxuXHRkZG90c2VxOiBkZG90c2VxLFxuXHRkZWc6IGRlZyQxLFxuXHREZWw6IERlbCxcblx0RGVsdGE6IERlbHRhLFxuXHRkZWx0YTogZGVsdGEsXG5cdGRlbXB0eXY6IGRlbXB0eXYsXG5cdGRmaXNodDogZGZpc2h0LFxuXHREZnI6IERmcixcblx0ZGZyOiBkZnIsXG5cdGRIYXI6IGRIYXIsXG5cdGRoYXJsOiBkaGFybCxcblx0ZGhhcnI6IGRoYXJyLFxuXHREaWFjcml0aWNhbEFjdXRlOiBEaWFjcml0aWNhbEFjdXRlLFxuXHREaWFjcml0aWNhbERvdDogRGlhY3JpdGljYWxEb3QsXG5cdERpYWNyaXRpY2FsRG91YmxlQWN1dGU6IERpYWNyaXRpY2FsRG91YmxlQWN1dGUsXG5cdERpYWNyaXRpY2FsR3JhdmU6IERpYWNyaXRpY2FsR3JhdmUsXG5cdERpYWNyaXRpY2FsVGlsZGU6IERpYWNyaXRpY2FsVGlsZGUsXG5cdGRpYW06IGRpYW0sXG5cdGRpYW1vbmQ6IGRpYW1vbmQsXG5cdERpYW1vbmQ6IERpYW1vbmQsXG5cdGRpYW1vbmRzdWl0OiBkaWFtb25kc3VpdCxcblx0ZGlhbXM6IGRpYW1zLFxuXHRkaWU6IGRpZSxcblx0RGlmZmVyZW50aWFsRDogRGlmZmVyZW50aWFsRCxcblx0ZGlnYW1tYTogZGlnYW1tYSxcblx0ZGlzaW46IGRpc2luLFxuXHRkaXY6IGRpdixcblx0ZGl2aWRlOiBkaXZpZGUkMSxcblx0ZGl2aWRlb250aW1lczogZGl2aWRlb250aW1lcyxcblx0ZGl2b254OiBkaXZvbngsXG5cdERKY3k6IERKY3ksXG5cdGRqY3k6IGRqY3ksXG5cdGRsY29ybjogZGxjb3JuLFxuXHRkbGNyb3A6IGRsY3JvcCxcblx0ZG9sbGFyOiBkb2xsYXIsXG5cdERvcGY6IERvcGYsXG5cdGRvcGY6IGRvcGYsXG5cdERvdDogRG90LFxuXHRkb3Q6IGRvdCxcblx0RG90RG90OiBEb3REb3QsXG5cdGRvdGVxOiBkb3RlcSxcblx0ZG90ZXFkb3Q6IGRvdGVxZG90LFxuXHREb3RFcXVhbDogRG90RXF1YWwsXG5cdGRvdG1pbnVzOiBkb3RtaW51cyxcblx0ZG90cGx1czogZG90cGx1cyxcblx0ZG90c3F1YXJlOiBkb3RzcXVhcmUsXG5cdGRvdWJsZWJhcndlZGdlOiBkb3VibGViYXJ3ZWRnZSxcblx0RG91YmxlQ29udG91ckludGVncmFsOiBEb3VibGVDb250b3VySW50ZWdyYWwsXG5cdERvdWJsZURvdDogRG91YmxlRG90LFxuXHREb3VibGVEb3duQXJyb3c6IERvdWJsZURvd25BcnJvdyxcblx0RG91YmxlTGVmdEFycm93OiBEb3VibGVMZWZ0QXJyb3csXG5cdERvdWJsZUxlZnRSaWdodEFycm93OiBEb3VibGVMZWZ0UmlnaHRBcnJvdyxcblx0RG91YmxlTGVmdFRlZTogRG91YmxlTGVmdFRlZSxcblx0RG91YmxlTG9uZ0xlZnRBcnJvdzogRG91YmxlTG9uZ0xlZnRBcnJvdyxcblx0RG91YmxlTG9uZ0xlZnRSaWdodEFycm93OiBEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3csXG5cdERvdWJsZUxvbmdSaWdodEFycm93OiBEb3VibGVMb25nUmlnaHRBcnJvdyxcblx0RG91YmxlUmlnaHRBcnJvdzogRG91YmxlUmlnaHRBcnJvdyxcblx0RG91YmxlUmlnaHRUZWU6IERvdWJsZVJpZ2h0VGVlLFxuXHREb3VibGVVcEFycm93OiBEb3VibGVVcEFycm93LFxuXHREb3VibGVVcERvd25BcnJvdzogRG91YmxlVXBEb3duQXJyb3csXG5cdERvdWJsZVZlcnRpY2FsQmFyOiBEb3VibGVWZXJ0aWNhbEJhcixcblx0RG93bkFycm93QmFyOiBEb3duQXJyb3dCYXIsXG5cdGRvd25hcnJvdzogZG93bmFycm93LFxuXHREb3duQXJyb3c6IERvd25BcnJvdyxcblx0RG93bmFycm93OiBEb3duYXJyb3csXG5cdERvd25BcnJvd1VwQXJyb3c6IERvd25BcnJvd1VwQXJyb3csXG5cdERvd25CcmV2ZTogRG93bkJyZXZlLFxuXHRkb3duZG93bmFycm93czogZG93bmRvd25hcnJvd3MsXG5cdGRvd25oYXJwb29ubGVmdDogZG93bmhhcnBvb25sZWZ0LFxuXHRkb3duaGFycG9vbnJpZ2h0OiBkb3duaGFycG9vbnJpZ2h0LFxuXHREb3duTGVmdFJpZ2h0VmVjdG9yOiBEb3duTGVmdFJpZ2h0VmVjdG9yLFxuXHREb3duTGVmdFRlZVZlY3RvcjogRG93bkxlZnRUZWVWZWN0b3IsXG5cdERvd25MZWZ0VmVjdG9yQmFyOiBEb3duTGVmdFZlY3RvckJhcixcblx0RG93bkxlZnRWZWN0b3I6IERvd25MZWZ0VmVjdG9yLFxuXHREb3duUmlnaHRUZWVWZWN0b3I6IERvd25SaWdodFRlZVZlY3Rvcixcblx0RG93blJpZ2h0VmVjdG9yQmFyOiBEb3duUmlnaHRWZWN0b3JCYXIsXG5cdERvd25SaWdodFZlY3RvcjogRG93blJpZ2h0VmVjdG9yLFxuXHREb3duVGVlQXJyb3c6IERvd25UZWVBcnJvdyxcblx0RG93blRlZTogRG93blRlZSxcblx0ZHJia2Fyb3c6IGRyYmthcm93LFxuXHRkcmNvcm46IGRyY29ybixcblx0ZHJjcm9wOiBkcmNyb3AsXG5cdERzY3I6IERzY3IsXG5cdGRzY3I6IGRzY3IsXG5cdERTY3k6IERTY3ksXG5cdGRzY3k6IGRzY3ksXG5cdGRzb2w6IGRzb2wsXG5cdERzdHJvazogRHN0cm9rLFxuXHRkc3Ryb2s6IGRzdHJvayxcblx0ZHRkb3Q6IGR0ZG90LFxuXHRkdHJpOiBkdHJpLFxuXHRkdHJpZjogZHRyaWYsXG5cdGR1YXJyOiBkdWFycixcblx0ZHVoYXI6IGR1aGFyLFxuXHRkd2FuZ2xlOiBkd2FuZ2xlLFxuXHREWmN5OiBEWmN5LFxuXHRkemN5OiBkemN5LFxuXHRkemlncmFycjogZHppZ3JhcnIsXG5cdEVhY3V0ZTogRWFjdXRlJDEsXG5cdGVhY3V0ZTogZWFjdXRlJDEsXG5cdGVhc3RlcjogZWFzdGVyLFxuXHRFY2Fyb246IEVjYXJvbixcblx0ZWNhcm9uOiBlY2Fyb24sXG5cdEVjaXJjOiBFY2lyYyQxLFxuXHRlY2lyYzogZWNpcmMkMSxcblx0ZWNpcjogZWNpcixcblx0ZWNvbG9uOiBlY29sb24sXG5cdEVjeTogRWN5LFxuXHRlY3k6IGVjeSxcblx0ZUREb3Q6IGVERG90LFxuXHRFZG90OiBFZG90LFxuXHRlZG90OiBlZG90LFxuXHRlRG90OiBlRG90LFxuXHRlZTogZWUsXG5cdGVmRG90OiBlZkRvdCxcblx0RWZyOiBFZnIsXG5cdGVmcjogZWZyLFxuXHRlZzogZWcsXG5cdEVncmF2ZTogRWdyYXZlJDEsXG5cdGVncmF2ZTogZWdyYXZlJDEsXG5cdGVnczogZWdzLFxuXHRlZ3Nkb3Q6IGVnc2RvdCxcblx0ZWw6IGVsLFxuXHRFbGVtZW50OiBFbGVtZW50JDEsXG5cdGVsaW50ZXJzOiBlbGludGVycyxcblx0ZWxsOiBlbGwsXG5cdGVsczogZWxzLFxuXHRlbHNkb3Q6IGVsc2RvdCxcblx0RW1hY3I6IEVtYWNyLFxuXHRlbWFjcjogZW1hY3IsXG5cdGVtcHR5OiBlbXB0eSxcblx0ZW1wdHlzZXQ6IGVtcHR5c2V0LFxuXHRFbXB0eVNtYWxsU3F1YXJlOiBFbXB0eVNtYWxsU3F1YXJlLFxuXHRlbXB0eXY6IGVtcHR5dixcblx0RW1wdHlWZXJ5U21hbGxTcXVhcmU6IEVtcHR5VmVyeVNtYWxsU3F1YXJlLFxuXHRlbXNwMTM6IGVtc3AxMyxcblx0ZW1zcDE0OiBlbXNwMTQsXG5cdGVtc3A6IGVtc3AsXG5cdEVORzogRU5HLFxuXHRlbmc6IGVuZyxcblx0ZW5zcDogZW5zcCxcblx0RW9nb246IEVvZ29uLFxuXHRlb2dvbjogZW9nb24sXG5cdEVvcGY6IEVvcGYsXG5cdGVvcGY6IGVvcGYsXG5cdGVwYXI6IGVwYXIsXG5cdGVwYXJzbDogZXBhcnNsLFxuXHRlcGx1czogZXBsdXMsXG5cdGVwc2k6IGVwc2ksXG5cdEVwc2lsb246IEVwc2lsb24sXG5cdGVwc2lsb246IGVwc2lsb24sXG5cdGVwc2l2OiBlcHNpdixcblx0ZXFjaXJjOiBlcWNpcmMsXG5cdGVxY29sb246IGVxY29sb24sXG5cdGVxc2ltOiBlcXNpbSxcblx0ZXFzbGFudGd0cjogZXFzbGFudGd0cixcblx0ZXFzbGFudGxlc3M6IGVxc2xhbnRsZXNzLFxuXHRFcXVhbDogRXF1YWwsXG5cdGVxdWFsczogZXF1YWxzLFxuXHRFcXVhbFRpbGRlOiBFcXVhbFRpbGRlLFxuXHRlcXVlc3Q6IGVxdWVzdCxcblx0RXF1aWxpYnJpdW06IEVxdWlsaWJyaXVtLFxuXHRlcXVpdjogZXF1aXYsXG5cdGVxdWl2REQ6IGVxdWl2REQsXG5cdGVxdnBhcnNsOiBlcXZwYXJzbCxcblx0ZXJhcnI6IGVyYXJyLFxuXHRlckRvdDogZXJEb3QsXG5cdGVzY3I6IGVzY3IsXG5cdEVzY3I6IEVzY3IsXG5cdGVzZG90OiBlc2RvdCxcblx0RXNpbTogRXNpbSxcblx0ZXNpbTogZXNpbSxcblx0RXRhOiBFdGEsXG5cdGV0YTogZXRhLFxuXHRFVEg6IEVUSCQxLFxuXHRldGg6IGV0aCQxLFxuXHRFdW1sOiBFdW1sJDEsXG5cdGV1bWw6IGV1bWwkMSxcblx0ZXVybzogZXVybyxcblx0ZXhjbDogZXhjbCxcblx0ZXhpc3Q6IGV4aXN0LFxuXHRFeGlzdHM6IEV4aXN0cyxcblx0ZXhwZWN0YXRpb246IGV4cGVjdGF0aW9uLFxuXHRleHBvbmVudGlhbGU6IGV4cG9uZW50aWFsZSxcblx0RXhwb25lbnRpYWxFOiBFeHBvbmVudGlhbEUsXG5cdGZhbGxpbmdkb3RzZXE6IGZhbGxpbmdkb3RzZXEsXG5cdEZjeTogRmN5LFxuXHRmY3k6IGZjeSxcblx0ZmVtYWxlOiBmZW1hbGUsXG5cdGZmaWxpZzogZmZpbGlnLFxuXHRmZmxpZzogZmZsaWcsXG5cdGZmbGxpZzogZmZsbGlnLFxuXHRGZnI6IEZmcixcblx0ZmZyOiBmZnIsXG5cdGZpbGlnOiBmaWxpZyxcblx0RmlsbGVkU21hbGxTcXVhcmU6IEZpbGxlZFNtYWxsU3F1YXJlLFxuXHRGaWxsZWRWZXJ5U21hbGxTcXVhcmU6IEZpbGxlZFZlcnlTbWFsbFNxdWFyZSxcblx0ZmpsaWc6IGZqbGlnLFxuXHRmbGF0OiBmbGF0LFxuXHRmbGxpZzogZmxsaWcsXG5cdGZsdG5zOiBmbHRucyxcblx0Zm5vZjogZm5vZixcblx0Rm9wZjogRm9wZixcblx0Zm9wZjogZm9wZixcblx0Zm9yYWxsOiBmb3JhbGwsXG5cdEZvckFsbDogRm9yQWxsLFxuXHRmb3JrOiBmb3JrLFxuXHRmb3JrdjogZm9ya3YsXG5cdEZvdXJpZXJ0cmY6IEZvdXJpZXJ0cmYsXG5cdGZwYXJ0aW50OiBmcGFydGludCxcblx0ZnJhYzEyOiBmcmFjMTIkMSxcblx0ZnJhYzEzOiBmcmFjMTMsXG5cdGZyYWMxNDogZnJhYzE0JDEsXG5cdGZyYWMxNTogZnJhYzE1LFxuXHRmcmFjMTY6IGZyYWMxNixcblx0ZnJhYzE4OiBmcmFjMTgsXG5cdGZyYWMyMzogZnJhYzIzLFxuXHRmcmFjMjU6IGZyYWMyNSxcblx0ZnJhYzM0OiBmcmFjMzQkMSxcblx0ZnJhYzM1OiBmcmFjMzUsXG5cdGZyYWMzODogZnJhYzM4LFxuXHRmcmFjNDU6IGZyYWM0NSxcblx0ZnJhYzU2OiBmcmFjNTYsXG5cdGZyYWM1ODogZnJhYzU4LFxuXHRmcmFjNzg6IGZyYWM3OCxcblx0ZnJhc2w6IGZyYXNsLFxuXHRmcm93bjogZnJvd24sXG5cdGZzY3I6IGZzY3IsXG5cdEZzY3I6IEZzY3IsXG5cdGdhY3V0ZTogZ2FjdXRlLFxuXHRHYW1tYTogR2FtbWEsXG5cdGdhbW1hOiBnYW1tYSxcblx0R2FtbWFkOiBHYW1tYWQsXG5cdGdhbW1hZDogZ2FtbWFkLFxuXHRnYXA6IGdhcCxcblx0R2JyZXZlOiBHYnJldmUsXG5cdGdicmV2ZTogZ2JyZXZlLFxuXHRHY2VkaWw6IEdjZWRpbCxcblx0R2NpcmM6IEdjaXJjLFxuXHRnY2lyYzogZ2NpcmMsXG5cdEdjeTogR2N5LFxuXHRnY3k6IGdjeSxcblx0R2RvdDogR2RvdCxcblx0Z2RvdDogZ2RvdCxcblx0Z2U6IGdlLFxuXHRnRTogZ0UsXG5cdGdFbDogZ0VsLFxuXHRnZWw6IGdlbCxcblx0Z2VxOiBnZXEsXG5cdGdlcXE6IGdlcXEsXG5cdGdlcXNsYW50OiBnZXFzbGFudCxcblx0Z2VzY2M6IGdlc2NjLFxuXHRnZXM6IGdlcyxcblx0Z2VzZG90OiBnZXNkb3QsXG5cdGdlc2RvdG86IGdlc2RvdG8sXG5cdGdlc2RvdG9sOiBnZXNkb3RvbCxcblx0Z2VzbDogZ2VzbCxcblx0Z2VzbGVzOiBnZXNsZXMsXG5cdEdmcjogR2ZyLFxuXHRnZnI6IGdmcixcblx0Z2c6IGdnLFxuXHRHZzogR2csXG5cdGdnZzogZ2dnLFxuXHRnaW1lbDogZ2ltZWwsXG5cdEdKY3k6IEdKY3ksXG5cdGdqY3k6IGdqY3ksXG5cdGdsYTogZ2xhLFxuXHRnbDogZ2wsXG5cdGdsRTogZ2xFLFxuXHRnbGo6IGdsaixcblx0Z25hcDogZ25hcCxcblx0Z25hcHByb3g6IGduYXBwcm94LFxuXHRnbmU6IGduZSxcblx0Z25FOiBnbkUsXG5cdGduZXE6IGduZXEsXG5cdGduZXFxOiBnbmVxcSxcblx0Z25zaW06IGduc2ltLFxuXHRHb3BmOiBHb3BmLFxuXHRnb3BmOiBnb3BmLFxuXHRncmF2ZTogZ3JhdmUsXG5cdEdyZWF0ZXJFcXVhbDogR3JlYXRlckVxdWFsLFxuXHRHcmVhdGVyRXF1YWxMZXNzOiBHcmVhdGVyRXF1YWxMZXNzLFxuXHRHcmVhdGVyRnVsbEVxdWFsOiBHcmVhdGVyRnVsbEVxdWFsLFxuXHRHcmVhdGVyR3JlYXRlcjogR3JlYXRlckdyZWF0ZXIsXG5cdEdyZWF0ZXJMZXNzOiBHcmVhdGVyTGVzcyxcblx0R3JlYXRlclNsYW50RXF1YWw6IEdyZWF0ZXJTbGFudEVxdWFsLFxuXHRHcmVhdGVyVGlsZGU6IEdyZWF0ZXJUaWxkZSxcblx0R3NjcjogR3Njcixcblx0Z3NjcjogZ3Njcixcblx0Z3NpbTogZ3NpbSxcblx0Z3NpbWU6IGdzaW1lLFxuXHRnc2ltbDogZ3NpbWwsXG5cdGd0Y2M6IGd0Y2MsXG5cdGd0Y2lyOiBndGNpcixcblx0Z3Q6IGd0JDIsXG5cdEdUOiBHVCQxLFxuXHRHdDogR3QsXG5cdGd0ZG90OiBndGRvdCxcblx0Z3RsUGFyOiBndGxQYXIsXG5cdGd0cXVlc3Q6IGd0cXVlc3QsXG5cdGd0cmFwcHJveDogZ3RyYXBwcm94LFxuXHRndHJhcnI6IGd0cmFycixcblx0Z3RyZG90OiBndHJkb3QsXG5cdGd0cmVxbGVzczogZ3RyZXFsZXNzLFxuXHRndHJlcXFsZXNzOiBndHJlcXFsZXNzLFxuXHRndHJsZXNzOiBndHJsZXNzLFxuXHRndHJzaW06IGd0cnNpbSxcblx0Z3ZlcnRuZXFxOiBndmVydG5lcXEsXG5cdGd2bkU6IGd2bkUsXG5cdEhhY2VrOiBIYWNlayxcblx0aGFpcnNwOiBoYWlyc3AsXG5cdGhhbGY6IGhhbGYsXG5cdGhhbWlsdDogaGFtaWx0LFxuXHRIQVJEY3k6IEhBUkRjeSxcblx0aGFyZGN5OiBoYXJkY3ksXG5cdGhhcnJjaXI6IGhhcnJjaXIsXG5cdGhhcnI6IGhhcnIsXG5cdGhBcnI6IGhBcnIsXG5cdGhhcnJ3OiBoYXJydyxcblx0SGF0OiBIYXQsXG5cdGhiYXI6IGhiYXIsXG5cdEhjaXJjOiBIY2lyYyxcblx0aGNpcmM6IGhjaXJjLFxuXHRoZWFydHM6IGhlYXJ0cyxcblx0aGVhcnRzdWl0OiBoZWFydHN1aXQsXG5cdGhlbGxpcDogaGVsbGlwLFxuXHRoZXJjb246IGhlcmNvbixcblx0aGZyOiBoZnIsXG5cdEhmcjogSGZyLFxuXHRIaWxiZXJ0U3BhY2U6IEhpbGJlcnRTcGFjZSxcblx0aGtzZWFyb3c6IGhrc2Vhcm93LFxuXHRoa3N3YXJvdzogaGtzd2Fyb3csXG5cdGhvYXJyOiBob2Fycixcblx0aG9tdGh0OiBob210aHQsXG5cdGhvb2tsZWZ0YXJyb3c6IGhvb2tsZWZ0YXJyb3csXG5cdGhvb2tyaWdodGFycm93OiBob29rcmlnaHRhcnJvdyxcblx0aG9wZjogaG9wZixcblx0SG9wZjogSG9wZixcblx0aG9yYmFyOiBob3JiYXIsXG5cdEhvcml6b250YWxMaW5lOiBIb3Jpem9udGFsTGluZSxcblx0aHNjcjogaHNjcixcblx0SHNjcjogSHNjcixcblx0aHNsYXNoOiBoc2xhc2gsXG5cdEhzdHJvazogSHN0cm9rLFxuXHRoc3Ryb2s6IGhzdHJvayxcblx0SHVtcERvd25IdW1wOiBIdW1wRG93bkh1bXAsXG5cdEh1bXBFcXVhbDogSHVtcEVxdWFsLFxuXHRoeWJ1bGw6IGh5YnVsbCxcblx0aHlwaGVuOiBoeXBoZW4sXG5cdElhY3V0ZTogSWFjdXRlJDEsXG5cdGlhY3V0ZTogaWFjdXRlJDEsXG5cdGljOiBpYyxcblx0SWNpcmM6IEljaXJjJDEsXG5cdGljaXJjOiBpY2lyYyQxLFxuXHRJY3k6IEljeSxcblx0aWN5OiBpY3ksXG5cdElkb3Q6IElkb3QsXG5cdElFY3k6IElFY3ksXG5cdGllY3k6IGllY3ksXG5cdGlleGNsOiBpZXhjbCQxLFxuXHRpZmY6IGlmZixcblx0aWZyOiBpZnIsXG5cdElmcjogSWZyLFxuXHRJZ3JhdmU6IElncmF2ZSQxLFxuXHRpZ3JhdmU6IGlncmF2ZSQxLFxuXHRpaTogaWksXG5cdGlpaWludDogaWlpaW50LFxuXHRpaWludDogaWlpbnQsXG5cdGlpbmZpbjogaWluZmluLFxuXHRpaW90YTogaWlvdGEsXG5cdElKbGlnOiBJSmxpZyxcblx0aWpsaWc6IGlqbGlnLFxuXHRJbWFjcjogSW1hY3IsXG5cdGltYWNyOiBpbWFjcixcblx0aW1hZ2U6IGltYWdlLFxuXHRJbWFnaW5hcnlJOiBJbWFnaW5hcnlJLFxuXHRpbWFnbGluZTogaW1hZ2xpbmUsXG5cdGltYWdwYXJ0OiBpbWFncGFydCxcblx0aW1hdGg6IGltYXRoLFxuXHRJbTogSW0sXG5cdGltb2Y6IGltb2YsXG5cdGltcGVkOiBpbXBlZCxcblx0SW1wbGllczogSW1wbGllcyxcblx0aW5jYXJlOiBpbmNhcmUsXG5cdFwiaW5cIjogXCLiiIhcIixcblx0aW5maW46IGluZmluLFxuXHRpbmZpbnRpZTogaW5maW50aWUsXG5cdGlub2RvdDogaW5vZG90LFxuXHRpbnRjYWw6IGludGNhbCxcblx0aW50OiBpbnQsXG5cdEludDogSW50LFxuXHRpbnRlZ2VyczogaW50ZWdlcnMsXG5cdEludGVncmFsOiBJbnRlZ3JhbCxcblx0aW50ZXJjYWw6IGludGVyY2FsLFxuXHRJbnRlcnNlY3Rpb246IEludGVyc2VjdGlvbixcblx0aW50bGFyaGs6IGludGxhcmhrLFxuXHRpbnRwcm9kOiBpbnRwcm9kLFxuXHRJbnZpc2libGVDb21tYTogSW52aXNpYmxlQ29tbWEsXG5cdEludmlzaWJsZVRpbWVzOiBJbnZpc2libGVUaW1lcyxcblx0SU9jeTogSU9jeSxcblx0aW9jeTogaW9jeSxcblx0SW9nb246IElvZ29uLFxuXHRpb2dvbjogaW9nb24sXG5cdElvcGY6IElvcGYsXG5cdGlvcGY6IGlvcGYsXG5cdElvdGE6IElvdGEsXG5cdGlvdGE6IGlvdGEsXG5cdGlwcm9kOiBpcHJvZCxcblx0aXF1ZXN0OiBpcXVlc3QkMSxcblx0aXNjcjogaXNjcixcblx0SXNjcjogSXNjcixcblx0aXNpbjogaXNpbixcblx0aXNpbmRvdDogaXNpbmRvdCxcblx0aXNpbkU6IGlzaW5FLFxuXHRpc2luczogaXNpbnMsXG5cdGlzaW5zdjogaXNpbnN2LFxuXHRpc2ludjogaXNpbnYsXG5cdGl0OiBpdCxcblx0SXRpbGRlOiBJdGlsZGUsXG5cdGl0aWxkZTogaXRpbGRlLFxuXHRJdWtjeTogSXVrY3ksXG5cdGl1a2N5OiBpdWtjeSxcblx0SXVtbDogSXVtbCQxLFxuXHRpdW1sOiBpdW1sJDEsXG5cdEpjaXJjOiBKY2lyYyxcblx0amNpcmM6IGpjaXJjLFxuXHRKY3k6IEpjeSxcblx0amN5OiBqY3ksXG5cdEpmcjogSmZyLFxuXHRqZnI6IGpmcixcblx0am1hdGg6IGptYXRoLFxuXHRKb3BmOiBKb3BmLFxuXHRqb3BmOiBqb3BmLFxuXHRKc2NyOiBKc2NyLFxuXHRqc2NyOiBqc2NyLFxuXHRKc2VyY3k6IEpzZXJjeSxcblx0anNlcmN5OiBqc2VyY3ksXG5cdEp1a2N5OiBKdWtjeSxcblx0anVrY3k6IGp1a2N5LFxuXHRLYXBwYTogS2FwcGEsXG5cdGthcHBhOiBrYXBwYSxcblx0a2FwcGF2OiBrYXBwYXYsXG5cdEtjZWRpbDogS2NlZGlsLFxuXHRrY2VkaWw6IGtjZWRpbCxcblx0S2N5OiBLY3ksXG5cdGtjeToga2N5LFxuXHRLZnI6IEtmcixcblx0a2ZyOiBrZnIsXG5cdGtncmVlbjoga2dyZWVuLFxuXHRLSGN5OiBLSGN5LFxuXHRraGN5OiBraGN5LFxuXHRLSmN5OiBLSmN5LFxuXHRramN5OiBramN5LFxuXHRLb3BmOiBLb3BmLFxuXHRrb3BmOiBrb3BmLFxuXHRLc2NyOiBLc2NyLFxuXHRrc2NyOiBrc2NyLFxuXHRsQWFycjogbEFhcnIsXG5cdExhY3V0ZTogTGFjdXRlLFxuXHRsYWN1dGU6IGxhY3V0ZSxcblx0bGFlbXB0eXY6IGxhZW1wdHl2LFxuXHRsYWdyYW46IGxhZ3Jhbixcblx0TGFtYmRhOiBMYW1iZGEsXG5cdGxhbWJkYTogbGFtYmRhLFxuXHRsYW5nOiBsYW5nLFxuXHRMYW5nOiBMYW5nLFxuXHRsYW5nZDogbGFuZ2QsXG5cdGxhbmdsZTogbGFuZ2xlLFxuXHRsYXA6IGxhcCxcblx0TGFwbGFjZXRyZjogTGFwbGFjZXRyZixcblx0bGFxdW86IGxhcXVvJDEsXG5cdGxhcnJiOiBsYXJyYixcblx0bGFycmJmczogbGFycmJmcyxcblx0bGFycjogbGFycixcblx0TGFycjogTGFycixcblx0bEFycjogbEFycixcblx0bGFycmZzOiBsYXJyZnMsXG5cdGxhcnJoazogbGFycmhrLFxuXHRsYXJybHA6IGxhcnJscCxcblx0bGFycnBsOiBsYXJycGwsXG5cdGxhcnJzaW06IGxhcnJzaW0sXG5cdGxhcnJ0bDogbGFycnRsLFxuXHRsYXRhaWw6IGxhdGFpbCxcblx0bEF0YWlsOiBsQXRhaWwsXG5cdGxhdDogbGF0LFxuXHRsYXRlOiBsYXRlLFxuXHRsYXRlczogbGF0ZXMsXG5cdGxiYXJyOiBsYmFycixcblx0bEJhcnI6IGxCYXJyLFxuXHRsYmJyazogbGJicmssXG5cdGxicmFjZTogbGJyYWNlLFxuXHRsYnJhY2s6IGxicmFjayxcblx0bGJya2U6IGxicmtlLFxuXHRsYnJrc2xkOiBsYnJrc2xkLFxuXHRsYnJrc2x1OiBsYnJrc2x1LFxuXHRMY2Fyb246IExjYXJvbixcblx0bGNhcm9uOiBsY2Fyb24sXG5cdExjZWRpbDogTGNlZGlsLFxuXHRsY2VkaWw6IGxjZWRpbCxcblx0bGNlaWw6IGxjZWlsLFxuXHRsY3ViOiBsY3ViLFxuXHRMY3k6IExjeSxcblx0bGN5OiBsY3ksXG5cdGxkY2E6IGxkY2EsXG5cdGxkcXVvOiBsZHF1byxcblx0bGRxdW9yOiBsZHF1b3IsXG5cdGxkcmRoYXI6IGxkcmRoYXIsXG5cdGxkcnVzaGFyOiBsZHJ1c2hhcixcblx0bGRzaDogbGRzaCxcblx0bGU6IGxlLFxuXHRsRTogbEUsXG5cdExlZnRBbmdsZUJyYWNrZXQ6IExlZnRBbmdsZUJyYWNrZXQsXG5cdExlZnRBcnJvd0JhcjogTGVmdEFycm93QmFyLFxuXHRsZWZ0YXJyb3c6IGxlZnRhcnJvdyxcblx0TGVmdEFycm93OiBMZWZ0QXJyb3csXG5cdExlZnRhcnJvdzogTGVmdGFycm93LFxuXHRMZWZ0QXJyb3dSaWdodEFycm93OiBMZWZ0QXJyb3dSaWdodEFycm93LFxuXHRsZWZ0YXJyb3d0YWlsOiBsZWZ0YXJyb3d0YWlsLFxuXHRMZWZ0Q2VpbGluZzogTGVmdENlaWxpbmcsXG5cdExlZnREb3VibGVCcmFja2V0OiBMZWZ0RG91YmxlQnJhY2tldCxcblx0TGVmdERvd25UZWVWZWN0b3I6IExlZnREb3duVGVlVmVjdG9yLFxuXHRMZWZ0RG93blZlY3RvckJhcjogTGVmdERvd25WZWN0b3JCYXIsXG5cdExlZnREb3duVmVjdG9yOiBMZWZ0RG93blZlY3Rvcixcblx0TGVmdEZsb29yOiBMZWZ0Rmxvb3IsXG5cdGxlZnRoYXJwb29uZG93bjogbGVmdGhhcnBvb25kb3duLFxuXHRsZWZ0aGFycG9vbnVwOiBsZWZ0aGFycG9vbnVwLFxuXHRsZWZ0bGVmdGFycm93czogbGVmdGxlZnRhcnJvd3MsXG5cdGxlZnRyaWdodGFycm93OiBsZWZ0cmlnaHRhcnJvdyxcblx0TGVmdFJpZ2h0QXJyb3c6IExlZnRSaWdodEFycm93LFxuXHRMZWZ0cmlnaHRhcnJvdzogTGVmdHJpZ2h0YXJyb3csXG5cdGxlZnRyaWdodGFycm93czogbGVmdHJpZ2h0YXJyb3dzLFxuXHRsZWZ0cmlnaHRoYXJwb29uczogbGVmdHJpZ2h0aGFycG9vbnMsXG5cdGxlZnRyaWdodHNxdWlnYXJyb3c6IGxlZnRyaWdodHNxdWlnYXJyb3csXG5cdExlZnRSaWdodFZlY3RvcjogTGVmdFJpZ2h0VmVjdG9yLFxuXHRMZWZ0VGVlQXJyb3c6IExlZnRUZWVBcnJvdyxcblx0TGVmdFRlZTogTGVmdFRlZSxcblx0TGVmdFRlZVZlY3RvcjogTGVmdFRlZVZlY3Rvcixcblx0bGVmdHRocmVldGltZXM6IGxlZnR0aHJlZXRpbWVzLFxuXHRMZWZ0VHJpYW5nbGVCYXI6IExlZnRUcmlhbmdsZUJhcixcblx0TGVmdFRyaWFuZ2xlOiBMZWZ0VHJpYW5nbGUsXG5cdExlZnRUcmlhbmdsZUVxdWFsOiBMZWZ0VHJpYW5nbGVFcXVhbCxcblx0TGVmdFVwRG93blZlY3RvcjogTGVmdFVwRG93blZlY3Rvcixcblx0TGVmdFVwVGVlVmVjdG9yOiBMZWZ0VXBUZWVWZWN0b3IsXG5cdExlZnRVcFZlY3RvckJhcjogTGVmdFVwVmVjdG9yQmFyLFxuXHRMZWZ0VXBWZWN0b3I6IExlZnRVcFZlY3Rvcixcblx0TGVmdFZlY3RvckJhcjogTGVmdFZlY3RvckJhcixcblx0TGVmdFZlY3RvcjogTGVmdFZlY3Rvcixcblx0bEVnOiBsRWcsXG5cdGxlZzogbGVnLFxuXHRsZXE6IGxlcSxcblx0bGVxcTogbGVxcSxcblx0bGVxc2xhbnQ6IGxlcXNsYW50LFxuXHRsZXNjYzogbGVzY2MsXG5cdGxlczogbGVzLFxuXHRsZXNkb3Q6IGxlc2RvdCxcblx0bGVzZG90bzogbGVzZG90byxcblx0bGVzZG90b3I6IGxlc2RvdG9yLFxuXHRsZXNnOiBsZXNnLFxuXHRsZXNnZXM6IGxlc2dlcyxcblx0bGVzc2FwcHJveDogbGVzc2FwcHJveCxcblx0bGVzc2RvdDogbGVzc2RvdCxcblx0bGVzc2VxZ3RyOiBsZXNzZXFndHIsXG5cdGxlc3NlcXFndHI6IGxlc3NlcXFndHIsXG5cdExlc3NFcXVhbEdyZWF0ZXI6IExlc3NFcXVhbEdyZWF0ZXIsXG5cdExlc3NGdWxsRXF1YWw6IExlc3NGdWxsRXF1YWwsXG5cdExlc3NHcmVhdGVyOiBMZXNzR3JlYXRlcixcblx0bGVzc2d0cjogbGVzc2d0cixcblx0TGVzc0xlc3M6IExlc3NMZXNzLFxuXHRsZXNzc2ltOiBsZXNzc2ltLFxuXHRMZXNzU2xhbnRFcXVhbDogTGVzc1NsYW50RXF1YWwsXG5cdExlc3NUaWxkZTogTGVzc1RpbGRlLFxuXHRsZmlzaHQ6IGxmaXNodCxcblx0bGZsb29yOiBsZmxvb3IsXG5cdExmcjogTGZyLFxuXHRsZnI6IGxmcixcblx0bGc6IGxnLFxuXHRsZ0U6IGxnRSxcblx0bEhhcjogbEhhcixcblx0bGhhcmQ6IGxoYXJkLFxuXHRsaGFydTogbGhhcnUsXG5cdGxoYXJ1bDogbGhhcnVsLFxuXHRsaGJsazogbGhibGssXG5cdExKY3k6IExKY3ksXG5cdGxqY3k6IGxqY3ksXG5cdGxsYXJyOiBsbGFycixcblx0bGw6IGxsLFxuXHRMbDogTGwsXG5cdGxsY29ybmVyOiBsbGNvcm5lcixcblx0TGxlZnRhcnJvdzogTGxlZnRhcnJvdyxcblx0bGxoYXJkOiBsbGhhcmQsXG5cdGxsdHJpOiBsbHRyaSxcblx0TG1pZG90OiBMbWlkb3QsXG5cdGxtaWRvdDogbG1pZG90LFxuXHRsbW91c3RhY2hlOiBsbW91c3RhY2hlLFxuXHRsbW91c3Q6IGxtb3VzdCxcblx0bG5hcDogbG5hcCxcblx0bG5hcHByb3g6IGxuYXBwcm94LFxuXHRsbmU6IGxuZSxcblx0bG5FOiBsbkUsXG5cdGxuZXE6IGxuZXEsXG5cdGxuZXFxOiBsbmVxcSxcblx0bG5zaW06IGxuc2ltLFxuXHRsb2FuZzogbG9hbmcsXG5cdGxvYXJyOiBsb2Fycixcblx0bG9icms6IGxvYnJrLFxuXHRsb25nbGVmdGFycm93OiBsb25nbGVmdGFycm93LFxuXHRMb25nTGVmdEFycm93OiBMb25nTGVmdEFycm93LFxuXHRMb25nbGVmdGFycm93OiBMb25nbGVmdGFycm93LFxuXHRsb25nbGVmdHJpZ2h0YXJyb3c6IGxvbmdsZWZ0cmlnaHRhcnJvdyxcblx0TG9uZ0xlZnRSaWdodEFycm93OiBMb25nTGVmdFJpZ2h0QXJyb3csXG5cdExvbmdsZWZ0cmlnaHRhcnJvdzogTG9uZ2xlZnRyaWdodGFycm93LFxuXHRsb25nbWFwc3RvOiBsb25nbWFwc3RvLFxuXHRsb25ncmlnaHRhcnJvdzogbG9uZ3JpZ2h0YXJyb3csXG5cdExvbmdSaWdodEFycm93OiBMb25nUmlnaHRBcnJvdyxcblx0TG9uZ3JpZ2h0YXJyb3c6IExvbmdyaWdodGFycm93LFxuXHRsb29wYXJyb3dsZWZ0OiBsb29wYXJyb3dsZWZ0LFxuXHRsb29wYXJyb3dyaWdodDogbG9vcGFycm93cmlnaHQsXG5cdGxvcGFyOiBsb3Bhcixcblx0TG9wZjogTG9wZixcblx0bG9wZjogbG9wZixcblx0bG9wbHVzOiBsb3BsdXMsXG5cdGxvdGltZXM6IGxvdGltZXMsXG5cdGxvd2FzdDogbG93YXN0LFxuXHRsb3diYXI6IGxvd2Jhcixcblx0TG93ZXJMZWZ0QXJyb3c6IExvd2VyTGVmdEFycm93LFxuXHRMb3dlclJpZ2h0QXJyb3c6IExvd2VyUmlnaHRBcnJvdyxcblx0bG96OiBsb3osXG5cdGxvemVuZ2U6IGxvemVuZ2UsXG5cdGxvemY6IGxvemYsXG5cdGxwYXI6IGxwYXIsXG5cdGxwYXJsdDogbHBhcmx0LFxuXHRscmFycjogbHJhcnIsXG5cdGxyY29ybmVyOiBscmNvcm5lcixcblx0bHJoYXI6IGxyaGFyLFxuXHRscmhhcmQ6IGxyaGFyZCxcblx0bHJtOiBscm0sXG5cdGxydHJpOiBscnRyaSxcblx0bHNhcXVvOiBsc2FxdW8sXG5cdGxzY3I6IGxzY3IsXG5cdExzY3I6IExzY3IsXG5cdGxzaDogbHNoLFxuXHRMc2g6IExzaCxcblx0bHNpbTogbHNpbSxcblx0bHNpbWU6IGxzaW1lLFxuXHRsc2ltZzogbHNpbWcsXG5cdGxzcWI6IGxzcWIsXG5cdGxzcXVvOiBsc3F1byxcblx0bHNxdW9yOiBsc3F1b3IsXG5cdExzdHJvazogTHN0cm9rLFxuXHRsc3Ryb2s6IGxzdHJvayxcblx0bHRjYzogbHRjYyxcblx0bHRjaXI6IGx0Y2lyLFxuXHRsdDogbHQkMixcblx0TFQ6IExUJDEsXG5cdEx0OiBMdCxcblx0bHRkb3Q6IGx0ZG90LFxuXHRsdGhyZWU6IGx0aHJlZSxcblx0bHRpbWVzOiBsdGltZXMsXG5cdGx0bGFycjogbHRsYXJyLFxuXHRsdHF1ZXN0OiBsdHF1ZXN0LFxuXHRsdHJpOiBsdHJpLFxuXHRsdHJpZTogbHRyaWUsXG5cdGx0cmlmOiBsdHJpZixcblx0bHRyUGFyOiBsdHJQYXIsXG5cdGx1cmRzaGFyOiBsdXJkc2hhcixcblx0bHVydWhhcjogbHVydWhhcixcblx0bHZlcnRuZXFxOiBsdmVydG5lcXEsXG5cdGx2bkU6IGx2bkUsXG5cdG1hY3I6IG1hY3IkMSxcblx0bWFsZTogbWFsZSxcblx0bWFsdDogbWFsdCxcblx0bWFsdGVzZTogbWFsdGVzZSxcblx0XCJNYXBcIjogXCLipIVcIixcblx0bWFwOiBtYXAsXG5cdG1hcHN0bzogbWFwc3RvLFxuXHRtYXBzdG9kb3duOiBtYXBzdG9kb3duLFxuXHRtYXBzdG9sZWZ0OiBtYXBzdG9sZWZ0LFxuXHRtYXBzdG91cDogbWFwc3RvdXAsXG5cdG1hcmtlcjogbWFya2VyLFxuXHRtY29tbWE6IG1jb21tYSxcblx0TWN5OiBNY3ksXG5cdG1jeTogbWN5LFxuXHRtZGFzaDogbWRhc2gsXG5cdG1ERG90OiBtRERvdCxcblx0bWVhc3VyZWRhbmdsZTogbWVhc3VyZWRhbmdsZSxcblx0TWVkaXVtU3BhY2U6IE1lZGl1bVNwYWNlLFxuXHRNZWxsaW50cmY6IE1lbGxpbnRyZixcblx0TWZyOiBNZnIsXG5cdG1mcjogbWZyLFxuXHRtaG86IG1obyxcblx0bWljcm86IG1pY3JvJDEsXG5cdG1pZGFzdDogbWlkYXN0LFxuXHRtaWRjaXI6IG1pZGNpcixcblx0bWlkOiBtaWQsXG5cdG1pZGRvdDogbWlkZG90JDEsXG5cdG1pbnVzYjogbWludXNiLFxuXHRtaW51czogbWludXMsXG5cdG1pbnVzZDogbWludXNkLFxuXHRtaW51c2R1OiBtaW51c2R1LFxuXHRNaW51c1BsdXM6IE1pbnVzUGx1cyxcblx0bWxjcDogbWxjcCxcblx0bWxkcjogbWxkcixcblx0bW5wbHVzOiBtbnBsdXMsXG5cdG1vZGVsczogbW9kZWxzLFxuXHRNb3BmOiBNb3BmLFxuXHRtb3BmOiBtb3BmLFxuXHRtcDogbXAsXG5cdG1zY3I6IG1zY3IsXG5cdE1zY3I6IE1zY3IsXG5cdG1zdHBvczogbXN0cG9zLFxuXHRNdTogTXUsXG5cdG11OiBtdSxcblx0bXVsdGltYXA6IG11bHRpbWFwLFxuXHRtdW1hcDogbXVtYXAsXG5cdG5hYmxhOiBuYWJsYSxcblx0TmFjdXRlOiBOYWN1dGUsXG5cdG5hY3V0ZTogbmFjdXRlLFxuXHRuYW5nOiBuYW5nLFxuXHRuYXA6IG5hcCxcblx0bmFwRTogbmFwRSxcblx0bmFwaWQ6IG5hcGlkLFxuXHRuYXBvczogbmFwb3MsXG5cdG5hcHByb3g6IG5hcHByb3gsXG5cdG5hdHVyYWw6IG5hdHVyYWwsXG5cdG5hdHVyYWxzOiBuYXR1cmFscyxcblx0bmF0dXI6IG5hdHVyLFxuXHRuYnNwOiBuYnNwJDEsXG5cdG5idW1wOiBuYnVtcCxcblx0bmJ1bXBlOiBuYnVtcGUsXG5cdG5jYXA6IG5jYXAsXG5cdE5jYXJvbjogTmNhcm9uLFxuXHRuY2Fyb246IG5jYXJvbixcblx0TmNlZGlsOiBOY2VkaWwsXG5cdG5jZWRpbDogbmNlZGlsLFxuXHRuY29uZzogbmNvbmcsXG5cdG5jb25nZG90OiBuY29uZ2RvdCxcblx0bmN1cDogbmN1cCxcblx0TmN5OiBOY3ksXG5cdG5jeTogbmN5LFxuXHRuZGFzaDogbmRhc2gsXG5cdG5lYXJoazogbmVhcmhrLFxuXHRuZWFycjogbmVhcnIsXG5cdG5lQXJyOiBuZUFycixcblx0bmVhcnJvdzogbmVhcnJvdyxcblx0bmU6IG5lLFxuXHRuZWRvdDogbmVkb3QsXG5cdE5lZ2F0aXZlTWVkaXVtU3BhY2U6IE5lZ2F0aXZlTWVkaXVtU3BhY2UsXG5cdE5lZ2F0aXZlVGhpY2tTcGFjZTogTmVnYXRpdmVUaGlja1NwYWNlLFxuXHROZWdhdGl2ZVRoaW5TcGFjZTogTmVnYXRpdmVUaGluU3BhY2UsXG5cdE5lZ2F0aXZlVmVyeVRoaW5TcGFjZTogTmVnYXRpdmVWZXJ5VGhpblNwYWNlLFxuXHRuZXF1aXY6IG5lcXVpdixcblx0bmVzZWFyOiBuZXNlYXIsXG5cdG5lc2ltOiBuZXNpbSxcblx0TmVzdGVkR3JlYXRlckdyZWF0ZXI6IE5lc3RlZEdyZWF0ZXJHcmVhdGVyLFxuXHROZXN0ZWRMZXNzTGVzczogTmVzdGVkTGVzc0xlc3MsXG5cdE5ld0xpbmU6IE5ld0xpbmUsXG5cdG5leGlzdDogbmV4aXN0LFxuXHRuZXhpc3RzOiBuZXhpc3RzLFxuXHROZnI6IE5mcixcblx0bmZyOiBuZnIsXG5cdG5nRTogbmdFLFxuXHRuZ2U6IG5nZSxcblx0bmdlcTogbmdlcSxcblx0bmdlcXE6IG5nZXFxLFxuXHRuZ2Vxc2xhbnQ6IG5nZXFzbGFudCxcblx0bmdlczogbmdlcyxcblx0bkdnOiBuR2csXG5cdG5nc2ltOiBuZ3NpbSxcblx0bkd0OiBuR3QsXG5cdG5ndDogbmd0LFxuXHRuZ3RyOiBuZ3RyLFxuXHRuR3R2OiBuR3R2LFxuXHRuaGFycjogbmhhcnIsXG5cdG5oQXJyOiBuaEFycixcblx0bmhwYXI6IG5ocGFyLFxuXHRuaTogbmksXG5cdG5pczogbmlzLFxuXHRuaXNkOiBuaXNkLFxuXHRuaXY6IG5pdixcblx0TkpjeTogTkpjeSxcblx0bmpjeTogbmpjeSxcblx0bmxhcnI6IG5sYXJyLFxuXHRubEFycjogbmxBcnIsXG5cdG5sZHI6IG5sZHIsXG5cdG5sRTogbmxFLFxuXHRubGU6IG5sZSxcblx0bmxlZnRhcnJvdzogbmxlZnRhcnJvdyxcblx0bkxlZnRhcnJvdzogbkxlZnRhcnJvdyxcblx0bmxlZnRyaWdodGFycm93OiBubGVmdHJpZ2h0YXJyb3csXG5cdG5MZWZ0cmlnaHRhcnJvdzogbkxlZnRyaWdodGFycm93LFxuXHRubGVxOiBubGVxLFxuXHRubGVxcTogbmxlcXEsXG5cdG5sZXFzbGFudDogbmxlcXNsYW50LFxuXHRubGVzOiBubGVzLFxuXHRubGVzczogbmxlc3MsXG5cdG5MbDogbkxsLFxuXHRubHNpbTogbmxzaW0sXG5cdG5MdDogbkx0LFxuXHRubHQ6IG5sdCxcblx0bmx0cmk6IG5sdHJpLFxuXHRubHRyaWU6IG5sdHJpZSxcblx0bkx0djogbkx0dixcblx0bm1pZDogbm1pZCxcblx0Tm9CcmVhazogTm9CcmVhayxcblx0Tm9uQnJlYWtpbmdTcGFjZTogTm9uQnJlYWtpbmdTcGFjZSxcblx0bm9wZjogbm9wZixcblx0Tm9wZjogTm9wZixcblx0Tm90OiBOb3QsXG5cdG5vdDogbm90JDEsXG5cdE5vdENvbmdydWVudDogTm90Q29uZ3J1ZW50LFxuXHROb3RDdXBDYXA6IE5vdEN1cENhcCxcblx0Tm90RG91YmxlVmVydGljYWxCYXI6IE5vdERvdWJsZVZlcnRpY2FsQmFyLFxuXHROb3RFbGVtZW50OiBOb3RFbGVtZW50LFxuXHROb3RFcXVhbDogTm90RXF1YWwsXG5cdE5vdEVxdWFsVGlsZGU6IE5vdEVxdWFsVGlsZGUsXG5cdE5vdEV4aXN0czogTm90RXhpc3RzLFxuXHROb3RHcmVhdGVyOiBOb3RHcmVhdGVyLFxuXHROb3RHcmVhdGVyRXF1YWw6IE5vdEdyZWF0ZXJFcXVhbCxcblx0Tm90R3JlYXRlckZ1bGxFcXVhbDogTm90R3JlYXRlckZ1bGxFcXVhbCxcblx0Tm90R3JlYXRlckdyZWF0ZXI6IE5vdEdyZWF0ZXJHcmVhdGVyLFxuXHROb3RHcmVhdGVyTGVzczogTm90R3JlYXRlckxlc3MsXG5cdE5vdEdyZWF0ZXJTbGFudEVxdWFsOiBOb3RHcmVhdGVyU2xhbnRFcXVhbCxcblx0Tm90R3JlYXRlclRpbGRlOiBOb3RHcmVhdGVyVGlsZGUsXG5cdE5vdEh1bXBEb3duSHVtcDogTm90SHVtcERvd25IdW1wLFxuXHROb3RIdW1wRXF1YWw6IE5vdEh1bXBFcXVhbCxcblx0bm90aW46IG5vdGluLFxuXHRub3RpbmRvdDogbm90aW5kb3QsXG5cdG5vdGluRTogbm90aW5FLFxuXHRub3RpbnZhOiBub3RpbnZhLFxuXHRub3RpbnZiOiBub3RpbnZiLFxuXHRub3RpbnZjOiBub3RpbnZjLFxuXHROb3RMZWZ0VHJpYW5nbGVCYXI6IE5vdExlZnRUcmlhbmdsZUJhcixcblx0Tm90TGVmdFRyaWFuZ2xlOiBOb3RMZWZ0VHJpYW5nbGUsXG5cdE5vdExlZnRUcmlhbmdsZUVxdWFsOiBOb3RMZWZ0VHJpYW5nbGVFcXVhbCxcblx0Tm90TGVzczogTm90TGVzcyxcblx0Tm90TGVzc0VxdWFsOiBOb3RMZXNzRXF1YWwsXG5cdE5vdExlc3NHcmVhdGVyOiBOb3RMZXNzR3JlYXRlcixcblx0Tm90TGVzc0xlc3M6IE5vdExlc3NMZXNzLFxuXHROb3RMZXNzU2xhbnRFcXVhbDogTm90TGVzc1NsYW50RXF1YWwsXG5cdE5vdExlc3NUaWxkZTogTm90TGVzc1RpbGRlLFxuXHROb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcjogTm90TmVzdGVkR3JlYXRlckdyZWF0ZXIsXG5cdE5vdE5lc3RlZExlc3NMZXNzOiBOb3ROZXN0ZWRMZXNzTGVzcyxcblx0bm90bmk6IG5vdG5pLFxuXHRub3RuaXZhOiBub3RuaXZhLFxuXHRub3RuaXZiOiBub3RuaXZiLFxuXHRub3RuaXZjOiBub3RuaXZjLFxuXHROb3RQcmVjZWRlczogTm90UHJlY2VkZXMsXG5cdE5vdFByZWNlZGVzRXF1YWw6IE5vdFByZWNlZGVzRXF1YWwsXG5cdE5vdFByZWNlZGVzU2xhbnRFcXVhbDogTm90UHJlY2VkZXNTbGFudEVxdWFsLFxuXHROb3RSZXZlcnNlRWxlbWVudDogTm90UmV2ZXJzZUVsZW1lbnQsXG5cdE5vdFJpZ2h0VHJpYW5nbGVCYXI6IE5vdFJpZ2h0VHJpYW5nbGVCYXIsXG5cdE5vdFJpZ2h0VHJpYW5nbGU6IE5vdFJpZ2h0VHJpYW5nbGUsXG5cdE5vdFJpZ2h0VHJpYW5nbGVFcXVhbDogTm90UmlnaHRUcmlhbmdsZUVxdWFsLFxuXHROb3RTcXVhcmVTdWJzZXQ6IE5vdFNxdWFyZVN1YnNldCxcblx0Tm90U3F1YXJlU3Vic2V0RXF1YWw6IE5vdFNxdWFyZVN1YnNldEVxdWFsLFxuXHROb3RTcXVhcmVTdXBlcnNldDogTm90U3F1YXJlU3VwZXJzZXQsXG5cdE5vdFNxdWFyZVN1cGVyc2V0RXF1YWw6IE5vdFNxdWFyZVN1cGVyc2V0RXF1YWwsXG5cdE5vdFN1YnNldDogTm90U3Vic2V0LFxuXHROb3RTdWJzZXRFcXVhbDogTm90U3Vic2V0RXF1YWwsXG5cdE5vdFN1Y2NlZWRzOiBOb3RTdWNjZWVkcyxcblx0Tm90U3VjY2VlZHNFcXVhbDogTm90U3VjY2VlZHNFcXVhbCxcblx0Tm90U3VjY2VlZHNTbGFudEVxdWFsOiBOb3RTdWNjZWVkc1NsYW50RXF1YWwsXG5cdE5vdFN1Y2NlZWRzVGlsZGU6IE5vdFN1Y2NlZWRzVGlsZGUsXG5cdE5vdFN1cGVyc2V0OiBOb3RTdXBlcnNldCxcblx0Tm90U3VwZXJzZXRFcXVhbDogTm90U3VwZXJzZXRFcXVhbCxcblx0Tm90VGlsZGU6IE5vdFRpbGRlLFxuXHROb3RUaWxkZUVxdWFsOiBOb3RUaWxkZUVxdWFsLFxuXHROb3RUaWxkZUZ1bGxFcXVhbDogTm90VGlsZGVGdWxsRXF1YWwsXG5cdE5vdFRpbGRlVGlsZGU6IE5vdFRpbGRlVGlsZGUsXG5cdE5vdFZlcnRpY2FsQmFyOiBOb3RWZXJ0aWNhbEJhcixcblx0bnBhcmFsbGVsOiBucGFyYWxsZWwsXG5cdG5wYXI6IG5wYXIsXG5cdG5wYXJzbDogbnBhcnNsLFxuXHRucGFydDogbnBhcnQsXG5cdG5wb2xpbnQ6IG5wb2xpbnQsXG5cdG5wcjogbnByLFxuXHRucHJjdWU6IG5wcmN1ZSxcblx0bnByZWM6IG5wcmVjLFxuXHRucHJlY2VxOiBucHJlY2VxLFxuXHRucHJlOiBucHJlLFxuXHRucmFycmM6IG5yYXJyYyxcblx0bnJhcnI6IG5yYXJyLFxuXHRuckFycjogbnJBcnIsXG5cdG5yYXJydzogbnJhcnJ3LFxuXHRucmlnaHRhcnJvdzogbnJpZ2h0YXJyb3csXG5cdG5SaWdodGFycm93OiBuUmlnaHRhcnJvdyxcblx0bnJ0cmk6IG5ydHJpLFxuXHRucnRyaWU6IG5ydHJpZSxcblx0bnNjOiBuc2MsXG5cdG5zY2N1ZTogbnNjY3VlLFxuXHRuc2NlOiBuc2NlLFxuXHROc2NyOiBOc2NyLFxuXHRuc2NyOiBuc2NyLFxuXHRuc2hvcnRtaWQ6IG5zaG9ydG1pZCxcblx0bnNob3J0cGFyYWxsZWw6IG5zaG9ydHBhcmFsbGVsLFxuXHRuc2ltOiBuc2ltLFxuXHRuc2ltZTogbnNpbWUsXG5cdG5zaW1lcTogbnNpbWVxLFxuXHRuc21pZDogbnNtaWQsXG5cdG5zcGFyOiBuc3Bhcixcblx0bnNxc3ViZTogbnNxc3ViZSxcblx0bnNxc3VwZTogbnNxc3VwZSxcblx0bnN1YjogbnN1Yixcblx0bnN1YkU6IG5zdWJFLFxuXHRuc3ViZTogbnN1YmUsXG5cdG5zdWJzZXQ6IG5zdWJzZXQsXG5cdG5zdWJzZXRlcTogbnN1YnNldGVxLFxuXHRuc3Vic2V0ZXFxOiBuc3Vic2V0ZXFxLFxuXHRuc3VjYzogbnN1Y2MsXG5cdG5zdWNjZXE6IG5zdWNjZXEsXG5cdG5zdXA6IG5zdXAsXG5cdG5zdXBFOiBuc3VwRSxcblx0bnN1cGU6IG5zdXBlLFxuXHRuc3Vwc2V0OiBuc3Vwc2V0LFxuXHRuc3Vwc2V0ZXE6IG5zdXBzZXRlcSxcblx0bnN1cHNldGVxcTogbnN1cHNldGVxcSxcblx0bnRnbDogbnRnbCxcblx0TnRpbGRlOiBOdGlsZGUkMSxcblx0bnRpbGRlOiBudGlsZGUkMSxcblx0bnRsZzogbnRsZyxcblx0bnRyaWFuZ2xlbGVmdDogbnRyaWFuZ2xlbGVmdCxcblx0bnRyaWFuZ2xlbGVmdGVxOiBudHJpYW5nbGVsZWZ0ZXEsXG5cdG50cmlhbmdsZXJpZ2h0OiBudHJpYW5nbGVyaWdodCxcblx0bnRyaWFuZ2xlcmlnaHRlcTogbnRyaWFuZ2xlcmlnaHRlcSxcblx0TnU6IE51LFxuXHRudTogbnUsXG5cdG51bTogbnVtLFxuXHRudW1lcm86IG51bWVybyxcblx0bnVtc3A6IG51bXNwLFxuXHRudmFwOiBudmFwLFxuXHRudmRhc2g6IG52ZGFzaCxcblx0bnZEYXNoOiBudkRhc2gsXG5cdG5WZGFzaDogblZkYXNoLFxuXHRuVkRhc2g6IG5WRGFzaCxcblx0bnZnZTogbnZnZSxcblx0bnZndDogbnZndCxcblx0bnZIYXJyOiBudkhhcnIsXG5cdG52aW5maW46IG52aW5maW4sXG5cdG52bEFycjogbnZsQXJyLFxuXHRudmxlOiBudmxlLFxuXHRudmx0OiBudmx0LFxuXHRudmx0cmllOiBudmx0cmllLFxuXHRudnJBcnI6IG52ckFycixcblx0bnZydHJpZTogbnZydHJpZSxcblx0bnZzaW06IG52c2ltLFxuXHRud2FyaGs6IG53YXJoayxcblx0bndhcnI6IG53YXJyLFxuXHRud0FycjogbndBcnIsXG5cdG53YXJyb3c6IG53YXJyb3csXG5cdG53bmVhcjogbnduZWFyLFxuXHRPYWN1dGU6IE9hY3V0ZSQxLFxuXHRvYWN1dGU6IG9hY3V0ZSQxLFxuXHRvYXN0OiBvYXN0LFxuXHRPY2lyYzogT2NpcmMkMSxcblx0b2NpcmM6IG9jaXJjJDEsXG5cdG9jaXI6IG9jaXIsXG5cdE9jeTogT2N5LFxuXHRvY3k6IG9jeSxcblx0b2Rhc2g6IG9kYXNoLFxuXHRPZGJsYWM6IE9kYmxhYyxcblx0b2RibGFjOiBvZGJsYWMsXG5cdG9kaXY6IG9kaXYsXG5cdG9kb3Q6IG9kb3QsXG5cdG9kc29sZDogb2Rzb2xkLFxuXHRPRWxpZzogT0VsaWcsXG5cdG9lbGlnOiBvZWxpZyxcblx0b2ZjaXI6IG9mY2lyLFxuXHRPZnI6IE9mcixcblx0b2ZyOiBvZnIsXG5cdG9nb246IG9nb24sXG5cdE9ncmF2ZTogT2dyYXZlJDEsXG5cdG9ncmF2ZTogb2dyYXZlJDEsXG5cdG9ndDogb2d0LFxuXHRvaGJhcjogb2hiYXIsXG5cdG9obTogb2htLFxuXHRvaW50OiBvaW50LFxuXHRvbGFycjogb2xhcnIsXG5cdG9sY2lyOiBvbGNpcixcblx0b2xjcm9zczogb2xjcm9zcyxcblx0b2xpbmU6IG9saW5lLFxuXHRvbHQ6IG9sdCxcblx0T21hY3I6IE9tYWNyLFxuXHRvbWFjcjogb21hY3IsXG5cdE9tZWdhOiBPbWVnYSxcblx0b21lZ2E6IG9tZWdhLFxuXHRPbWljcm9uOiBPbWljcm9uLFxuXHRvbWljcm9uOiBvbWljcm9uLFxuXHRvbWlkOiBvbWlkLFxuXHRvbWludXM6IG9taW51cyxcblx0T29wZjogT29wZixcblx0b29wZjogb29wZixcblx0b3Bhcjogb3Bhcixcblx0T3BlbkN1cmx5RG91YmxlUXVvdGU6IE9wZW5DdXJseURvdWJsZVF1b3RlLFxuXHRPcGVuQ3VybHlRdW90ZTogT3BlbkN1cmx5UXVvdGUsXG5cdG9wZXJwOiBvcGVycCxcblx0b3BsdXM6IG9wbHVzLFxuXHRvcmFycjogb3JhcnIsXG5cdE9yOiBPcixcblx0b3I6IG9yLFxuXHRvcmQ6IG9yZCxcblx0b3JkZXI6IG9yZGVyLFxuXHRvcmRlcm9mOiBvcmRlcm9mLFxuXHRvcmRmOiBvcmRmJDEsXG5cdG9yZG06IG9yZG0kMSxcblx0b3JpZ29mOiBvcmlnb2YsXG5cdG9yb3I6IG9yb3IsXG5cdG9yc2xvcGU6IG9yc2xvcGUsXG5cdG9ydjogb3J2LFxuXHRvUzogb1MsXG5cdE9zY3I6IE9zY3IsXG5cdG9zY3I6IG9zY3IsXG5cdE9zbGFzaDogT3NsYXNoJDEsXG5cdG9zbGFzaDogb3NsYXNoJDEsXG5cdG9zb2w6IG9zb2wsXG5cdE90aWxkZTogT3RpbGRlJDEsXG5cdG90aWxkZTogb3RpbGRlJDEsXG5cdG90aW1lc2FzOiBvdGltZXNhcyxcblx0T3RpbWVzOiBPdGltZXMsXG5cdG90aW1lczogb3RpbWVzLFxuXHRPdW1sOiBPdW1sJDEsXG5cdG91bWw6IG91bWwkMSxcblx0b3ZiYXI6IG92YmFyLFxuXHRPdmVyQmFyOiBPdmVyQmFyLFxuXHRPdmVyQnJhY2U6IE92ZXJCcmFjZSxcblx0T3ZlckJyYWNrZXQ6IE92ZXJCcmFja2V0LFxuXHRPdmVyUGFyZW50aGVzaXM6IE92ZXJQYXJlbnRoZXNpcyxcblx0cGFyYTogcGFyYSQxLFxuXHRwYXJhbGxlbDogcGFyYWxsZWwsXG5cdHBhcjogcGFyLFxuXHRwYXJzaW06IHBhcnNpbSxcblx0cGFyc2w6IHBhcnNsLFxuXHRwYXJ0OiBwYXJ0LFxuXHRQYXJ0aWFsRDogUGFydGlhbEQsXG5cdFBjeTogUGN5LFxuXHRwY3k6IHBjeSxcblx0cGVyY250OiBwZXJjbnQsXG5cdHBlcmlvZDogcGVyaW9kLFxuXHRwZXJtaWw6IHBlcm1pbCxcblx0cGVycDogcGVycCxcblx0cGVydGVuazogcGVydGVuayxcblx0UGZyOiBQZnIsXG5cdHBmcjogcGZyLFxuXHRQaGk6IFBoaSxcblx0cGhpOiBwaGksXG5cdHBoaXY6IHBoaXYsXG5cdHBobW1hdDogcGhtbWF0LFxuXHRwaG9uZTogcGhvbmUsXG5cdFBpOiBQaSxcblx0cGk6IHBpLFxuXHRwaXRjaGZvcms6IHBpdGNoZm9yayxcblx0cGl2OiBwaXYsXG5cdHBsYW5jazogcGxhbmNrLFxuXHRwbGFuY2toOiBwbGFuY2toLFxuXHRwbGFua3Y6IHBsYW5rdixcblx0cGx1c2FjaXI6IHBsdXNhY2lyLFxuXHRwbHVzYjogcGx1c2IsXG5cdHBsdXNjaXI6IHBsdXNjaXIsXG5cdHBsdXM6IHBsdXMsXG5cdHBsdXNkbzogcGx1c2RvLFxuXHRwbHVzZHU6IHBsdXNkdSxcblx0cGx1c2U6IHBsdXNlLFxuXHRQbHVzTWludXM6IFBsdXNNaW51cyxcblx0cGx1c21uOiBwbHVzbW4kMSxcblx0cGx1c3NpbTogcGx1c3NpbSxcblx0cGx1c3R3bzogcGx1c3R3byxcblx0cG06IHBtLFxuXHRQb2luY2FyZXBsYW5lOiBQb2luY2FyZXBsYW5lLFxuXHRwb2ludGludDogcG9pbnRpbnQsXG5cdHBvcGY6IHBvcGYsXG5cdFBvcGY6IFBvcGYsXG5cdHBvdW5kOiBwb3VuZCQxLFxuXHRwcmFwOiBwcmFwLFxuXHRQcjogUHIsXG5cdHByOiBwcixcblx0cHJjdWU6IHByY3VlLFxuXHRwcmVjYXBwcm94OiBwcmVjYXBwcm94LFxuXHRwcmVjOiBwcmVjLFxuXHRwcmVjY3VybHllcTogcHJlY2N1cmx5ZXEsXG5cdFByZWNlZGVzOiBQcmVjZWRlcyxcblx0UHJlY2VkZXNFcXVhbDogUHJlY2VkZXNFcXVhbCxcblx0UHJlY2VkZXNTbGFudEVxdWFsOiBQcmVjZWRlc1NsYW50RXF1YWwsXG5cdFByZWNlZGVzVGlsZGU6IFByZWNlZGVzVGlsZGUsXG5cdHByZWNlcTogcHJlY2VxLFxuXHRwcmVjbmFwcHJveDogcHJlY25hcHByb3gsXG5cdHByZWNuZXFxOiBwcmVjbmVxcSxcblx0cHJlY25zaW06IHByZWNuc2ltLFxuXHRwcmU6IHByZSxcblx0cHJFOiBwckUsXG5cdHByZWNzaW06IHByZWNzaW0sXG5cdHByaW1lOiBwcmltZSxcblx0UHJpbWU6IFByaW1lLFxuXHRwcmltZXM6IHByaW1lcyxcblx0cHJuYXA6IHBybmFwLFxuXHRwcm5FOiBwcm5FLFxuXHRwcm5zaW06IHBybnNpbSxcblx0cHJvZDogcHJvZCxcblx0UHJvZHVjdDogUHJvZHVjdCxcblx0cHJvZmFsYXI6IHByb2ZhbGFyLFxuXHRwcm9mbGluZTogcHJvZmxpbmUsXG5cdHByb2ZzdXJmOiBwcm9mc3VyZixcblx0cHJvcDogcHJvcCxcblx0UHJvcG9ydGlvbmFsOiBQcm9wb3J0aW9uYWwsXG5cdFByb3BvcnRpb246IFByb3BvcnRpb24sXG5cdHByb3B0bzogcHJvcHRvLFxuXHRwcnNpbTogcHJzaW0sXG5cdHBydXJlbDogcHJ1cmVsLFxuXHRQc2NyOiBQc2NyLFxuXHRwc2NyOiBwc2NyLFxuXHRQc2k6IFBzaSxcblx0cHNpOiBwc2ksXG5cdHB1bmNzcDogcHVuY3NwLFxuXHRRZnI6IFFmcixcblx0cWZyOiBxZnIsXG5cdHFpbnQ6IHFpbnQsXG5cdHFvcGY6IHFvcGYsXG5cdFFvcGY6IFFvcGYsXG5cdHFwcmltZTogcXByaW1lLFxuXHRRc2NyOiBRc2NyLFxuXHRxc2NyOiBxc2NyLFxuXHRxdWF0ZXJuaW9uczogcXVhdGVybmlvbnMsXG5cdHF1YXRpbnQ6IHF1YXRpbnQsXG5cdHF1ZXN0OiBxdWVzdCxcblx0cXVlc3RlcTogcXVlc3RlcSxcblx0cXVvdDogcXVvdCQyLFxuXHRRVU9UOiBRVU9UJDEsXG5cdHJBYXJyOiByQWFycixcblx0cmFjZTogcmFjZSxcblx0UmFjdXRlOiBSYWN1dGUsXG5cdHJhY3V0ZTogcmFjdXRlLFxuXHRyYWRpYzogcmFkaWMsXG5cdHJhZW1wdHl2OiByYWVtcHR5dixcblx0cmFuZzogcmFuZyxcblx0UmFuZzogUmFuZyxcblx0cmFuZ2Q6IHJhbmdkLFxuXHRyYW5nZTogcmFuZ2UsXG5cdHJhbmdsZTogcmFuZ2xlLFxuXHRyYXF1bzogcmFxdW8kMSxcblx0cmFycmFwOiByYXJyYXAsXG5cdHJhcnJiOiByYXJyYixcblx0cmFycmJmczogcmFycmJmcyxcblx0cmFycmM6IHJhcnJjLFxuXHRyYXJyOiByYXJyLFxuXHRSYXJyOiBSYXJyLFxuXHRyQXJyOiByQXJyLFxuXHRyYXJyZnM6IHJhcnJmcyxcblx0cmFycmhrOiByYXJyaGssXG5cdHJhcnJscDogcmFycmxwLFxuXHRyYXJycGw6IHJhcnJwbCxcblx0cmFycnNpbTogcmFycnNpbSxcblx0UmFycnRsOiBSYXJydGwsXG5cdHJhcnJ0bDogcmFycnRsLFxuXHRyYXJydzogcmFycncsXG5cdHJhdGFpbDogcmF0YWlsLFxuXHRyQXRhaWw6IHJBdGFpbCxcblx0cmF0aW86IHJhdGlvLFxuXHRyYXRpb25hbHM6IHJhdGlvbmFscyxcblx0cmJhcnI6IHJiYXJyLFxuXHRyQmFycjogckJhcnIsXG5cdFJCYXJyOiBSQmFycixcblx0cmJicms6IHJiYnJrLFxuXHRyYnJhY2U6IHJicmFjZSxcblx0cmJyYWNrOiByYnJhY2ssXG5cdHJicmtlOiByYnJrZSxcblx0cmJya3NsZDogcmJya3NsZCxcblx0cmJya3NsdTogcmJya3NsdSxcblx0UmNhcm9uOiBSY2Fyb24sXG5cdHJjYXJvbjogcmNhcm9uLFxuXHRSY2VkaWw6IFJjZWRpbCxcblx0cmNlZGlsOiByY2VkaWwsXG5cdHJjZWlsOiByY2VpbCxcblx0cmN1YjogcmN1Yixcblx0UmN5OiBSY3ksXG5cdHJjeTogcmN5LFxuXHRyZGNhOiByZGNhLFxuXHRyZGxkaGFyOiByZGxkaGFyLFxuXHRyZHF1bzogcmRxdW8sXG5cdHJkcXVvcjogcmRxdW9yLFxuXHRyZHNoOiByZHNoLFxuXHRyZWFsOiByZWFsLFxuXHRyZWFsaW5lOiByZWFsaW5lLFxuXHRyZWFscGFydDogcmVhbHBhcnQsXG5cdHJlYWxzOiByZWFscyxcblx0UmU6IFJlLFxuXHRyZWN0OiByZWN0LFxuXHRyZWc6IHJlZyQxLFxuXHRSRUc6IFJFRyQxLFxuXHRSZXZlcnNlRWxlbWVudDogUmV2ZXJzZUVsZW1lbnQsXG5cdFJldmVyc2VFcXVpbGlicml1bTogUmV2ZXJzZUVxdWlsaWJyaXVtLFxuXHRSZXZlcnNlVXBFcXVpbGlicml1bTogUmV2ZXJzZVVwRXF1aWxpYnJpdW0sXG5cdHJmaXNodDogcmZpc2h0LFxuXHRyZmxvb3I6IHJmbG9vcixcblx0cmZyOiByZnIsXG5cdFJmcjogUmZyLFxuXHRySGFyOiBySGFyLFxuXHRyaGFyZDogcmhhcmQsXG5cdHJoYXJ1OiByaGFydSxcblx0cmhhcnVsOiByaGFydWwsXG5cdFJobzogUmhvLFxuXHRyaG86IHJobyxcblx0cmhvdjogcmhvdixcblx0UmlnaHRBbmdsZUJyYWNrZXQ6IFJpZ2h0QW5nbGVCcmFja2V0LFxuXHRSaWdodEFycm93QmFyOiBSaWdodEFycm93QmFyLFxuXHRyaWdodGFycm93OiByaWdodGFycm93LFxuXHRSaWdodEFycm93OiBSaWdodEFycm93LFxuXHRSaWdodGFycm93OiBSaWdodGFycm93LFxuXHRSaWdodEFycm93TGVmdEFycm93OiBSaWdodEFycm93TGVmdEFycm93LFxuXHRyaWdodGFycm93dGFpbDogcmlnaHRhcnJvd3RhaWwsXG5cdFJpZ2h0Q2VpbGluZzogUmlnaHRDZWlsaW5nLFxuXHRSaWdodERvdWJsZUJyYWNrZXQ6IFJpZ2h0RG91YmxlQnJhY2tldCxcblx0UmlnaHREb3duVGVlVmVjdG9yOiBSaWdodERvd25UZWVWZWN0b3IsXG5cdFJpZ2h0RG93blZlY3RvckJhcjogUmlnaHREb3duVmVjdG9yQmFyLFxuXHRSaWdodERvd25WZWN0b3I6IFJpZ2h0RG93blZlY3Rvcixcblx0UmlnaHRGbG9vcjogUmlnaHRGbG9vcixcblx0cmlnaHRoYXJwb29uZG93bjogcmlnaHRoYXJwb29uZG93bixcblx0cmlnaHRoYXJwb29udXA6IHJpZ2h0aGFycG9vbnVwLFxuXHRyaWdodGxlZnRhcnJvd3M6IHJpZ2h0bGVmdGFycm93cyxcblx0cmlnaHRsZWZ0aGFycG9vbnM6IHJpZ2h0bGVmdGhhcnBvb25zLFxuXHRyaWdodHJpZ2h0YXJyb3dzOiByaWdodHJpZ2h0YXJyb3dzLFxuXHRyaWdodHNxdWlnYXJyb3c6IHJpZ2h0c3F1aWdhcnJvdyxcblx0UmlnaHRUZWVBcnJvdzogUmlnaHRUZWVBcnJvdyxcblx0UmlnaHRUZWU6IFJpZ2h0VGVlLFxuXHRSaWdodFRlZVZlY3RvcjogUmlnaHRUZWVWZWN0b3IsXG5cdHJpZ2h0dGhyZWV0aW1lczogcmlnaHR0aHJlZXRpbWVzLFxuXHRSaWdodFRyaWFuZ2xlQmFyOiBSaWdodFRyaWFuZ2xlQmFyLFxuXHRSaWdodFRyaWFuZ2xlOiBSaWdodFRyaWFuZ2xlLFxuXHRSaWdodFRyaWFuZ2xlRXF1YWw6IFJpZ2h0VHJpYW5nbGVFcXVhbCxcblx0UmlnaHRVcERvd25WZWN0b3I6IFJpZ2h0VXBEb3duVmVjdG9yLFxuXHRSaWdodFVwVGVlVmVjdG9yOiBSaWdodFVwVGVlVmVjdG9yLFxuXHRSaWdodFVwVmVjdG9yQmFyOiBSaWdodFVwVmVjdG9yQmFyLFxuXHRSaWdodFVwVmVjdG9yOiBSaWdodFVwVmVjdG9yLFxuXHRSaWdodFZlY3RvckJhcjogUmlnaHRWZWN0b3JCYXIsXG5cdFJpZ2h0VmVjdG9yOiBSaWdodFZlY3Rvcixcblx0cmluZzogcmluZyxcblx0cmlzaW5nZG90c2VxOiByaXNpbmdkb3RzZXEsXG5cdHJsYXJyOiBybGFycixcblx0cmxoYXI6IHJsaGFyLFxuXHRybG06IHJsbSxcblx0cm1vdXN0YWNoZTogcm1vdXN0YWNoZSxcblx0cm1vdXN0OiBybW91c3QsXG5cdHJubWlkOiBybm1pZCxcblx0cm9hbmc6IHJvYW5nLFxuXHRyb2Fycjogcm9hcnIsXG5cdHJvYnJrOiByb2Jyayxcblx0cm9wYXI6IHJvcGFyLFxuXHRyb3BmOiByb3BmLFxuXHRSb3BmOiBSb3BmLFxuXHRyb3BsdXM6IHJvcGx1cyxcblx0cm90aW1lczogcm90aW1lcyxcblx0Um91bmRJbXBsaWVzOiBSb3VuZEltcGxpZXMsXG5cdHJwYXI6IHJwYXIsXG5cdHJwYXJndDogcnBhcmd0LFxuXHRycHBvbGludDogcnBwb2xpbnQsXG5cdHJyYXJyOiBycmFycixcblx0UnJpZ2h0YXJyb3c6IFJyaWdodGFycm93LFxuXHRyc2FxdW86IHJzYXF1byxcblx0cnNjcjogcnNjcixcblx0UnNjcjogUnNjcixcblx0cnNoOiByc2gsXG5cdFJzaDogUnNoLFxuXHRyc3FiOiByc3FiLFxuXHRyc3F1bzogcnNxdW8sXG5cdHJzcXVvcjogcnNxdW9yLFxuXHRydGhyZWU6IHJ0aHJlZSxcblx0cnRpbWVzOiBydGltZXMsXG5cdHJ0cmk6IHJ0cmksXG5cdHJ0cmllOiBydHJpZSxcblx0cnRyaWY6IHJ0cmlmLFxuXHRydHJpbHRyaTogcnRyaWx0cmksXG5cdFJ1bGVEZWxheWVkOiBSdWxlRGVsYXllZCxcblx0cnVsdWhhcjogcnVsdWhhcixcblx0cng6IHJ4LFxuXHRTYWN1dGU6IFNhY3V0ZSxcblx0c2FjdXRlOiBzYWN1dGUsXG5cdHNicXVvOiBzYnF1byxcblx0c2NhcDogc2NhcCxcblx0U2Nhcm9uOiBTY2Fyb24sXG5cdHNjYXJvbjogc2Nhcm9uLFxuXHRTYzogU2MsXG5cdHNjOiBzYyxcblx0c2NjdWU6IHNjY3VlLFxuXHRzY2U6IHNjZSxcblx0c2NFOiBzY0UsXG5cdFNjZWRpbDogU2NlZGlsLFxuXHRzY2VkaWw6IHNjZWRpbCxcblx0U2NpcmM6IFNjaXJjLFxuXHRzY2lyYzogc2NpcmMsXG5cdHNjbmFwOiBzY25hcCxcblx0c2NuRTogc2NuRSxcblx0c2Nuc2ltOiBzY25zaW0sXG5cdHNjcG9saW50OiBzY3BvbGludCxcblx0c2NzaW06IHNjc2ltLFxuXHRTY3k6IFNjeSxcblx0c2N5OiBzY3ksXG5cdHNkb3RiOiBzZG90Yixcblx0c2RvdDogc2RvdCxcblx0c2RvdGU6IHNkb3RlLFxuXHRzZWFyaGs6IHNlYXJoayxcblx0c2VhcnI6IHNlYXJyLFxuXHRzZUFycjogc2VBcnIsXG5cdHNlYXJyb3c6IHNlYXJyb3csXG5cdHNlY3Q6IHNlY3QkMSxcblx0c2VtaTogc2VtaSxcblx0c2Vzd2FyOiBzZXN3YXIsXG5cdHNldG1pbnVzOiBzZXRtaW51cyxcblx0c2V0bW46IHNldG1uLFxuXHRzZXh0OiBzZXh0LFxuXHRTZnI6IFNmcixcblx0c2ZyOiBzZnIsXG5cdHNmcm93bjogc2Zyb3duLFxuXHRzaGFycDogc2hhcnAsXG5cdFNIQ0hjeTogU0hDSGN5LFxuXHRzaGNoY3k6IHNoY2hjeSxcblx0U0hjeTogU0hjeSxcblx0c2hjeTogc2hjeSxcblx0U2hvcnREb3duQXJyb3c6IFNob3J0RG93bkFycm93LFxuXHRTaG9ydExlZnRBcnJvdzogU2hvcnRMZWZ0QXJyb3csXG5cdHNob3J0bWlkOiBzaG9ydG1pZCxcblx0c2hvcnRwYXJhbGxlbDogc2hvcnRwYXJhbGxlbCxcblx0U2hvcnRSaWdodEFycm93OiBTaG9ydFJpZ2h0QXJyb3csXG5cdFNob3J0VXBBcnJvdzogU2hvcnRVcEFycm93LFxuXHRzaHk6IHNoeSQxLFxuXHRTaWdtYTogU2lnbWEsXG5cdHNpZ21hOiBzaWdtYSxcblx0c2lnbWFmOiBzaWdtYWYsXG5cdHNpZ21hdjogc2lnbWF2LFxuXHRzaW06IHNpbSxcblx0c2ltZG90OiBzaW1kb3QsXG5cdHNpbWU6IHNpbWUsXG5cdHNpbWVxOiBzaW1lcSxcblx0c2ltZzogc2ltZyxcblx0c2ltZ0U6IHNpbWdFLFxuXHRzaW1sOiBzaW1sLFxuXHRzaW1sRTogc2ltbEUsXG5cdHNpbW5lOiBzaW1uZSxcblx0c2ltcGx1czogc2ltcGx1cyxcblx0c2ltcmFycjogc2ltcmFycixcblx0c2xhcnI6IHNsYXJyLFxuXHRTbWFsbENpcmNsZTogU21hbGxDaXJjbGUsXG5cdHNtYWxsc2V0bWludXM6IHNtYWxsc2V0bWludXMsXG5cdHNtYXNocDogc21hc2hwLFxuXHRzbWVwYXJzbDogc21lcGFyc2wsXG5cdHNtaWQ6IHNtaWQsXG5cdHNtaWxlOiBzbWlsZSxcblx0c210OiBzbXQsXG5cdHNtdGU6IHNtdGUsXG5cdHNtdGVzOiBzbXRlcyxcblx0U09GVGN5OiBTT0ZUY3ksXG5cdHNvZnRjeTogc29mdGN5LFxuXHRzb2xiYXI6IHNvbGJhcixcblx0c29sYjogc29sYixcblx0c29sOiBzb2wsXG5cdFNvcGY6IFNvcGYsXG5cdHNvcGY6IHNvcGYsXG5cdHNwYWRlczogc3BhZGVzLFxuXHRzcGFkZXN1aXQ6IHNwYWRlc3VpdCxcblx0c3Bhcjogc3Bhcixcblx0c3FjYXA6IHNxY2FwLFxuXHRzcWNhcHM6IHNxY2Fwcyxcblx0c3FjdXA6IHNxY3VwLFxuXHRzcWN1cHM6IHNxY3Vwcyxcblx0U3FydDogU3FydCxcblx0c3FzdWI6IHNxc3ViLFxuXHRzcXN1YmU6IHNxc3ViZSxcblx0c3FzdWJzZXQ6IHNxc3Vic2V0LFxuXHRzcXN1YnNldGVxOiBzcXN1YnNldGVxLFxuXHRzcXN1cDogc3FzdXAsXG5cdHNxc3VwZTogc3FzdXBlLFxuXHRzcXN1cHNldDogc3FzdXBzZXQsXG5cdHNxc3Vwc2V0ZXE6IHNxc3Vwc2V0ZXEsXG5cdHNxdWFyZTogc3F1YXJlLFxuXHRTcXVhcmU6IFNxdWFyZSxcblx0U3F1YXJlSW50ZXJzZWN0aW9uOiBTcXVhcmVJbnRlcnNlY3Rpb24sXG5cdFNxdWFyZVN1YnNldDogU3F1YXJlU3Vic2V0LFxuXHRTcXVhcmVTdWJzZXRFcXVhbDogU3F1YXJlU3Vic2V0RXF1YWwsXG5cdFNxdWFyZVN1cGVyc2V0OiBTcXVhcmVTdXBlcnNldCxcblx0U3F1YXJlU3VwZXJzZXRFcXVhbDogU3F1YXJlU3VwZXJzZXRFcXVhbCxcblx0U3F1YXJlVW5pb246IFNxdWFyZVVuaW9uLFxuXHRzcXVhcmY6IHNxdWFyZixcblx0c3F1OiBzcXUsXG5cdHNxdWY6IHNxdWYsXG5cdHNyYXJyOiBzcmFycixcblx0U3NjcjogU3Njcixcblx0c3Njcjogc3Njcixcblx0c3NldG1uOiBzc2V0bW4sXG5cdHNzbWlsZTogc3NtaWxlLFxuXHRzc3RhcmY6IHNzdGFyZixcblx0U3RhcjogU3Rhcixcblx0c3Rhcjogc3Rhcixcblx0c3RhcmY6IHN0YXJmLFxuXHRzdHJhaWdodGVwc2lsb246IHN0cmFpZ2h0ZXBzaWxvbixcblx0c3RyYWlnaHRwaGk6IHN0cmFpZ2h0cGhpLFxuXHRzdHJuczogc3RybnMsXG5cdHN1Yjogc3ViLFxuXHRTdWI6IFN1Yixcblx0c3ViZG90OiBzdWJkb3QsXG5cdHN1YkU6IHN1YkUsXG5cdHN1YmU6IHN1YmUsXG5cdHN1YmVkb3Q6IHN1YmVkb3QsXG5cdHN1Ym11bHQ6IHN1Ym11bHQsXG5cdHN1Ym5FOiBzdWJuRSxcblx0c3VibmU6IHN1Ym5lLFxuXHRzdWJwbHVzOiBzdWJwbHVzLFxuXHRzdWJyYXJyOiBzdWJyYXJyLFxuXHRzdWJzZXQ6IHN1YnNldCxcblx0U3Vic2V0OiBTdWJzZXQsXG5cdHN1YnNldGVxOiBzdWJzZXRlcSxcblx0c3Vic2V0ZXFxOiBzdWJzZXRlcXEsXG5cdFN1YnNldEVxdWFsOiBTdWJzZXRFcXVhbCxcblx0c3Vic2V0bmVxOiBzdWJzZXRuZXEsXG5cdHN1YnNldG5lcXE6IHN1YnNldG5lcXEsXG5cdHN1YnNpbTogc3Vic2ltLFxuXHRzdWJzdWI6IHN1YnN1Yixcblx0c3Vic3VwOiBzdWJzdXAsXG5cdHN1Y2NhcHByb3g6IHN1Y2NhcHByb3gsXG5cdHN1Y2M6IHN1Y2MsXG5cdHN1Y2NjdXJseWVxOiBzdWNjY3VybHllcSxcblx0U3VjY2VlZHM6IFN1Y2NlZWRzLFxuXHRTdWNjZWVkc0VxdWFsOiBTdWNjZWVkc0VxdWFsLFxuXHRTdWNjZWVkc1NsYW50RXF1YWw6IFN1Y2NlZWRzU2xhbnRFcXVhbCxcblx0U3VjY2VlZHNUaWxkZTogU3VjY2VlZHNUaWxkZSxcblx0c3VjY2VxOiBzdWNjZXEsXG5cdHN1Y2NuYXBwcm94OiBzdWNjbmFwcHJveCxcblx0c3VjY25lcXE6IHN1Y2NuZXFxLFxuXHRzdWNjbnNpbTogc3VjY25zaW0sXG5cdHN1Y2NzaW06IHN1Y2NzaW0sXG5cdFN1Y2hUaGF0OiBTdWNoVGhhdCxcblx0c3VtOiBzdW0sXG5cdFN1bTogU3VtLFxuXHRzdW5nOiBzdW5nLFxuXHRzdXAxOiBzdXAxJDEsXG5cdHN1cDI6IHN1cDIkMSxcblx0c3VwMzogc3VwMyQxLFxuXHRzdXA6IHN1cCxcblx0U3VwOiBTdXAsXG5cdHN1cGRvdDogc3VwZG90LFxuXHRzdXBkc3ViOiBzdXBkc3ViLFxuXHRzdXBFOiBzdXBFLFxuXHRzdXBlOiBzdXBlLFxuXHRzdXBlZG90OiBzdXBlZG90LFxuXHRTdXBlcnNldDogU3VwZXJzZXQsXG5cdFN1cGVyc2V0RXF1YWw6IFN1cGVyc2V0RXF1YWwsXG5cdHN1cGhzb2w6IHN1cGhzb2wsXG5cdHN1cGhzdWI6IHN1cGhzdWIsXG5cdHN1cGxhcnI6IHN1cGxhcnIsXG5cdHN1cG11bHQ6IHN1cG11bHQsXG5cdHN1cG5FOiBzdXBuRSxcblx0c3VwbmU6IHN1cG5lLFxuXHRzdXBwbHVzOiBzdXBwbHVzLFxuXHRzdXBzZXQ6IHN1cHNldCxcblx0U3Vwc2V0OiBTdXBzZXQsXG5cdHN1cHNldGVxOiBzdXBzZXRlcSxcblx0c3Vwc2V0ZXFxOiBzdXBzZXRlcXEsXG5cdHN1cHNldG5lcTogc3Vwc2V0bmVxLFxuXHRzdXBzZXRuZXFxOiBzdXBzZXRuZXFxLFxuXHRzdXBzaW06IHN1cHNpbSxcblx0c3Vwc3ViOiBzdXBzdWIsXG5cdHN1cHN1cDogc3Vwc3VwLFxuXHRzd2FyaGs6IHN3YXJoayxcblx0c3dhcnI6IHN3YXJyLFxuXHRzd0Fycjogc3dBcnIsXG5cdHN3YXJyb3c6IHN3YXJyb3csXG5cdHN3bndhcjogc3dud2FyLFxuXHRzemxpZzogc3psaWckMSxcblx0VGFiOiBUYWIsXG5cdHRhcmdldDogdGFyZ2V0LFxuXHRUYXU6IFRhdSxcblx0dGF1OiB0YXUsXG5cdHRicms6IHRicmssXG5cdFRjYXJvbjogVGNhcm9uLFxuXHR0Y2Fyb246IHRjYXJvbixcblx0VGNlZGlsOiBUY2VkaWwsXG5cdHRjZWRpbDogdGNlZGlsLFxuXHRUY3k6IFRjeSxcblx0dGN5OiB0Y3ksXG5cdHRkb3Q6IHRkb3QsXG5cdHRlbHJlYzogdGVscmVjLFxuXHRUZnI6IFRmcixcblx0dGZyOiB0ZnIsXG5cdHRoZXJlNDogdGhlcmU0LFxuXHR0aGVyZWZvcmU6IHRoZXJlZm9yZSxcblx0VGhlcmVmb3JlOiBUaGVyZWZvcmUsXG5cdFRoZXRhOiBUaGV0YSxcblx0dGhldGE6IHRoZXRhLFxuXHR0aGV0YXN5bTogdGhldGFzeW0sXG5cdHRoZXRhdjogdGhldGF2LFxuXHR0aGlja2FwcHJveDogdGhpY2thcHByb3gsXG5cdHRoaWNrc2ltOiB0aGlja3NpbSxcblx0VGhpY2tTcGFjZTogVGhpY2tTcGFjZSxcblx0VGhpblNwYWNlOiBUaGluU3BhY2UsXG5cdHRoaW5zcDogdGhpbnNwLFxuXHR0aGthcDogdGhrYXAsXG5cdHRoa3NpbTogdGhrc2ltLFxuXHRUSE9STjogVEhPUk4kMSxcblx0dGhvcm46IHRob3JuJDEsXG5cdHRpbGRlOiB0aWxkZSxcblx0VGlsZGU6IFRpbGRlLFxuXHRUaWxkZUVxdWFsOiBUaWxkZUVxdWFsLFxuXHRUaWxkZUZ1bGxFcXVhbDogVGlsZGVGdWxsRXF1YWwsXG5cdFRpbGRlVGlsZGU6IFRpbGRlVGlsZGUsXG5cdHRpbWVzYmFyOiB0aW1lc2Jhcixcblx0dGltZXNiOiB0aW1lc2IsXG5cdHRpbWVzOiB0aW1lcyQxLFxuXHR0aW1lc2Q6IHRpbWVzZCxcblx0dGludDogdGludCxcblx0dG9lYTogdG9lYSxcblx0dG9wYm90OiB0b3Bib3QsXG5cdHRvcGNpcjogdG9wY2lyLFxuXHR0b3A6IHRvcCxcblx0VG9wZjogVG9wZixcblx0dG9wZjogdG9wZixcblx0dG9wZm9yazogdG9wZm9yayxcblx0dG9zYTogdG9zYSxcblx0dHByaW1lOiB0cHJpbWUsXG5cdHRyYWRlOiB0cmFkZSxcblx0VFJBREU6IFRSQURFLFxuXHR0cmlhbmdsZTogdHJpYW5nbGUsXG5cdHRyaWFuZ2xlZG93bjogdHJpYW5nbGVkb3duLFxuXHR0cmlhbmdsZWxlZnQ6IHRyaWFuZ2xlbGVmdCxcblx0dHJpYW5nbGVsZWZ0ZXE6IHRyaWFuZ2xlbGVmdGVxLFxuXHR0cmlhbmdsZXE6IHRyaWFuZ2xlcSxcblx0dHJpYW5nbGVyaWdodDogdHJpYW5nbGVyaWdodCxcblx0dHJpYW5nbGVyaWdodGVxOiB0cmlhbmdsZXJpZ2h0ZXEsXG5cdHRyaWRvdDogdHJpZG90LFxuXHR0cmllOiB0cmllLFxuXHR0cmltaW51czogdHJpbWludXMsXG5cdFRyaXBsZURvdDogVHJpcGxlRG90LFxuXHR0cmlwbHVzOiB0cmlwbHVzLFxuXHR0cmlzYjogdHJpc2IsXG5cdHRyaXRpbWU6IHRyaXRpbWUsXG5cdHRycGV6aXVtOiB0cnBleml1bSxcblx0VHNjcjogVHNjcixcblx0dHNjcjogdHNjcixcblx0VFNjeTogVFNjeSxcblx0dHNjeTogdHNjeSxcblx0VFNIY3k6IFRTSGN5LFxuXHR0c2hjeTogdHNoY3ksXG5cdFRzdHJvazogVHN0cm9rLFxuXHR0c3Ryb2s6IHRzdHJvayxcblx0dHdpeHQ6IHR3aXh0LFxuXHR0d29oZWFkbGVmdGFycm93OiB0d29oZWFkbGVmdGFycm93LFxuXHR0d29oZWFkcmlnaHRhcnJvdzogdHdvaGVhZHJpZ2h0YXJyb3csXG5cdFVhY3V0ZTogVWFjdXRlJDEsXG5cdHVhY3V0ZTogdWFjdXRlJDEsXG5cdHVhcnI6IHVhcnIsXG5cdFVhcnI6IFVhcnIsXG5cdHVBcnI6IHVBcnIsXG5cdFVhcnJvY2lyOiBVYXJyb2Npcixcblx0VWJyY3k6IFVicmN5LFxuXHR1YnJjeTogdWJyY3ksXG5cdFVicmV2ZTogVWJyZXZlLFxuXHR1YnJldmU6IHVicmV2ZSxcblx0VWNpcmM6IFVjaXJjJDEsXG5cdHVjaXJjOiB1Y2lyYyQxLFxuXHRVY3k6IFVjeSxcblx0dWN5OiB1Y3ksXG5cdHVkYXJyOiB1ZGFycixcblx0VWRibGFjOiBVZGJsYWMsXG5cdHVkYmxhYzogdWRibGFjLFxuXHR1ZGhhcjogdWRoYXIsXG5cdHVmaXNodDogdWZpc2h0LFxuXHRVZnI6IFVmcixcblx0dWZyOiB1ZnIsXG5cdFVncmF2ZTogVWdyYXZlJDEsXG5cdHVncmF2ZTogdWdyYXZlJDEsXG5cdHVIYXI6IHVIYXIsXG5cdHVoYXJsOiB1aGFybCxcblx0dWhhcnI6IHVoYXJyLFxuXHR1aGJsazogdWhibGssXG5cdHVsY29ybjogdWxjb3JuLFxuXHR1bGNvcm5lcjogdWxjb3JuZXIsXG5cdHVsY3JvcDogdWxjcm9wLFxuXHR1bHRyaTogdWx0cmksXG5cdFVtYWNyOiBVbWFjcixcblx0dW1hY3I6IHVtYWNyLFxuXHR1bWw6IHVtbCQxLFxuXHRVbmRlckJhcjogVW5kZXJCYXIsXG5cdFVuZGVyQnJhY2U6IFVuZGVyQnJhY2UsXG5cdFVuZGVyQnJhY2tldDogVW5kZXJCcmFja2V0LFxuXHRVbmRlclBhcmVudGhlc2lzOiBVbmRlclBhcmVudGhlc2lzLFxuXHRVbmlvbjogVW5pb24sXG5cdFVuaW9uUGx1czogVW5pb25QbHVzLFxuXHRVb2dvbjogVW9nb24sXG5cdHVvZ29uOiB1b2dvbixcblx0VW9wZjogVW9wZixcblx0dW9wZjogdW9wZixcblx0VXBBcnJvd0JhcjogVXBBcnJvd0Jhcixcblx0dXBhcnJvdzogdXBhcnJvdyxcblx0VXBBcnJvdzogVXBBcnJvdyxcblx0VXBhcnJvdzogVXBhcnJvdyxcblx0VXBBcnJvd0Rvd25BcnJvdzogVXBBcnJvd0Rvd25BcnJvdyxcblx0dXBkb3duYXJyb3c6IHVwZG93bmFycm93LFxuXHRVcERvd25BcnJvdzogVXBEb3duQXJyb3csXG5cdFVwZG93bmFycm93OiBVcGRvd25hcnJvdyxcblx0VXBFcXVpbGlicml1bTogVXBFcXVpbGlicml1bSxcblx0dXBoYXJwb29ubGVmdDogdXBoYXJwb29ubGVmdCxcblx0dXBoYXJwb29ucmlnaHQ6IHVwaGFycG9vbnJpZ2h0LFxuXHR1cGx1czogdXBsdXMsXG5cdFVwcGVyTGVmdEFycm93OiBVcHBlckxlZnRBcnJvdyxcblx0VXBwZXJSaWdodEFycm93OiBVcHBlclJpZ2h0QXJyb3csXG5cdHVwc2k6IHVwc2ksXG5cdFVwc2k6IFVwc2ksXG5cdHVwc2loOiB1cHNpaCxcblx0VXBzaWxvbjogVXBzaWxvbixcblx0dXBzaWxvbjogdXBzaWxvbixcblx0VXBUZWVBcnJvdzogVXBUZWVBcnJvdyxcblx0VXBUZWU6IFVwVGVlLFxuXHR1cHVwYXJyb3dzOiB1cHVwYXJyb3dzLFxuXHR1cmNvcm46IHVyY29ybixcblx0dXJjb3JuZXI6IHVyY29ybmVyLFxuXHR1cmNyb3A6IHVyY3JvcCxcblx0VXJpbmc6IFVyaW5nLFxuXHR1cmluZzogdXJpbmcsXG5cdHVydHJpOiB1cnRyaSxcblx0VXNjcjogVXNjcixcblx0dXNjcjogdXNjcixcblx0dXRkb3Q6IHV0ZG90LFxuXHRVdGlsZGU6IFV0aWxkZSxcblx0dXRpbGRlOiB1dGlsZGUsXG5cdHV0cmk6IHV0cmksXG5cdHV0cmlmOiB1dHJpZixcblx0dXVhcnI6IHV1YXJyLFxuXHRVdW1sOiBVdW1sJDEsXG5cdHV1bWw6IHV1bWwkMSxcblx0dXdhbmdsZTogdXdhbmdsZSxcblx0dmFuZ3J0OiB2YW5ncnQsXG5cdHZhcmVwc2lsb246IHZhcmVwc2lsb24sXG5cdHZhcmthcHBhOiB2YXJrYXBwYSxcblx0dmFybm90aGluZzogdmFybm90aGluZyxcblx0dmFycGhpOiB2YXJwaGksXG5cdHZhcnBpOiB2YXJwaSxcblx0dmFycHJvcHRvOiB2YXJwcm9wdG8sXG5cdHZhcnI6IHZhcnIsXG5cdHZBcnI6IHZBcnIsXG5cdHZhcnJobzogdmFycmhvLFxuXHR2YXJzaWdtYTogdmFyc2lnbWEsXG5cdHZhcnN1YnNldG5lcTogdmFyc3Vic2V0bmVxLFxuXHR2YXJzdWJzZXRuZXFxOiB2YXJzdWJzZXRuZXFxLFxuXHR2YXJzdXBzZXRuZXE6IHZhcnN1cHNldG5lcSxcblx0dmFyc3Vwc2V0bmVxcTogdmFyc3Vwc2V0bmVxcSxcblx0dmFydGhldGE6IHZhcnRoZXRhLFxuXHR2YXJ0cmlhbmdsZWxlZnQ6IHZhcnRyaWFuZ2xlbGVmdCxcblx0dmFydHJpYW5nbGVyaWdodDogdmFydHJpYW5nbGVyaWdodCxcblx0dkJhcjogdkJhcixcblx0VmJhcjogVmJhcixcblx0dkJhcnY6IHZCYXJ2LFxuXHRWY3k6IFZjeSxcblx0dmN5OiB2Y3ksXG5cdHZkYXNoOiB2ZGFzaCxcblx0dkRhc2g6IHZEYXNoLFxuXHRWZGFzaDogVmRhc2gsXG5cdFZEYXNoOiBWRGFzaCxcblx0VmRhc2hsOiBWZGFzaGwsXG5cdHZlZWJhcjogdmVlYmFyLFxuXHR2ZWU6IHZlZSxcblx0VmVlOiBWZWUsXG5cdHZlZWVxOiB2ZWVlcSxcblx0dmVsbGlwOiB2ZWxsaXAsXG5cdHZlcmJhcjogdmVyYmFyLFxuXHRWZXJiYXI6IFZlcmJhcixcblx0dmVydDogdmVydCxcblx0VmVydDogVmVydCxcblx0VmVydGljYWxCYXI6IFZlcnRpY2FsQmFyLFxuXHRWZXJ0aWNhbExpbmU6IFZlcnRpY2FsTGluZSxcblx0VmVydGljYWxTZXBhcmF0b3I6IFZlcnRpY2FsU2VwYXJhdG9yLFxuXHRWZXJ0aWNhbFRpbGRlOiBWZXJ0aWNhbFRpbGRlLFxuXHRWZXJ5VGhpblNwYWNlOiBWZXJ5VGhpblNwYWNlLFxuXHRWZnI6IFZmcixcblx0dmZyOiB2ZnIsXG5cdHZsdHJpOiB2bHRyaSxcblx0dm5zdWI6IHZuc3ViLFxuXHR2bnN1cDogdm5zdXAsXG5cdFZvcGY6IFZvcGYsXG5cdHZvcGY6IHZvcGYsXG5cdHZwcm9wOiB2cHJvcCxcblx0dnJ0cmk6IHZydHJpLFxuXHRWc2NyOiBWc2NyLFxuXHR2c2NyOiB2c2NyLFxuXHR2c3VibkU6IHZzdWJuRSxcblx0dnN1Ym5lOiB2c3VibmUsXG5cdHZzdXBuRTogdnN1cG5FLFxuXHR2c3VwbmU6IHZzdXBuZSxcblx0VnZkYXNoOiBWdmRhc2gsXG5cdHZ6aWd6YWc6IHZ6aWd6YWcsXG5cdFdjaXJjOiBXY2lyYyxcblx0d2NpcmM6IHdjaXJjLFxuXHR3ZWRiYXI6IHdlZGJhcixcblx0d2VkZ2U6IHdlZGdlLFxuXHRXZWRnZTogV2VkZ2UsXG5cdHdlZGdlcTogd2VkZ2VxLFxuXHR3ZWllcnA6IHdlaWVycCxcblx0V2ZyOiBXZnIsXG5cdHdmcjogd2ZyLFxuXHRXb3BmOiBXb3BmLFxuXHR3b3BmOiB3b3BmLFxuXHR3cDogd3AsXG5cdHdyOiB3cixcblx0d3JlYXRoOiB3cmVhdGgsXG5cdFdzY3I6IFdzY3IsXG5cdHdzY3I6IHdzY3IsXG5cdHhjYXA6IHhjYXAsXG5cdHhjaXJjOiB4Y2lyYyxcblx0eGN1cDogeGN1cCxcblx0eGR0cmk6IHhkdHJpLFxuXHRYZnI6IFhmcixcblx0eGZyOiB4ZnIsXG5cdHhoYXJyOiB4aGFycixcblx0eGhBcnI6IHhoQXJyLFxuXHRYaTogWGksXG5cdHhpOiB4aSxcblx0eGxhcnI6IHhsYXJyLFxuXHR4bEFycjogeGxBcnIsXG5cdHhtYXA6IHhtYXAsXG5cdHhuaXM6IHhuaXMsXG5cdHhvZG90OiB4b2RvdCxcblx0WG9wZjogWG9wZixcblx0eG9wZjogeG9wZixcblx0eG9wbHVzOiB4b3BsdXMsXG5cdHhvdGltZTogeG90aW1lLFxuXHR4cmFycjogeHJhcnIsXG5cdHhyQXJyOiB4ckFycixcblx0WHNjcjogWHNjcixcblx0eHNjcjogeHNjcixcblx0eHNxY3VwOiB4c3FjdXAsXG5cdHh1cGx1czogeHVwbHVzLFxuXHR4dXRyaTogeHV0cmksXG5cdHh2ZWU6IHh2ZWUsXG5cdHh3ZWRnZTogeHdlZGdlLFxuXHRZYWN1dGU6IFlhY3V0ZSQxLFxuXHR5YWN1dGU6IHlhY3V0ZSQxLFxuXHRZQWN5OiBZQWN5LFxuXHR5YWN5OiB5YWN5LFxuXHRZY2lyYzogWWNpcmMsXG5cdHljaXJjOiB5Y2lyYyxcblx0WWN5OiBZY3ksXG5cdHljeTogeWN5LFxuXHR5ZW46IHllbiQxLFxuXHRZZnI6IFlmcixcblx0eWZyOiB5ZnIsXG5cdFlJY3k6IFlJY3ksXG5cdHlpY3k6IHlpY3ksXG5cdFlvcGY6IFlvcGYsXG5cdHlvcGY6IHlvcGYsXG5cdFlzY3I6IFlzY3IsXG5cdHlzY3I6IHlzY3IsXG5cdFlVY3k6IFlVY3ksXG5cdHl1Y3k6IHl1Y3ksXG5cdHl1bWw6IHl1bWwkMSxcblx0WXVtbDogWXVtbCxcblx0WmFjdXRlOiBaYWN1dGUsXG5cdHphY3V0ZTogemFjdXRlLFxuXHRaY2Fyb246IFpjYXJvbixcblx0emNhcm9uOiB6Y2Fyb24sXG5cdFpjeTogWmN5LFxuXHR6Y3k6IHpjeSxcblx0WmRvdDogWmRvdCxcblx0emRvdDogemRvdCxcblx0emVldHJmOiB6ZWV0cmYsXG5cdFplcm9XaWR0aFNwYWNlOiBaZXJvV2lkdGhTcGFjZSxcblx0WmV0YTogWmV0YSxcblx0emV0YTogemV0YSxcblx0emZyOiB6ZnIsXG5cdFpmcjogWmZyLFxuXHRaSGN5OiBaSGN5LFxuXHR6aGN5OiB6aGN5LFxuXHR6aWdyYXJyOiB6aWdyYXJyLFxuXHR6b3BmOiB6b3BmLFxuXHRab3BmOiBab3BmLFxuXHRac2NyOiBac2NyLFxuXHR6c2NyOiB6c2NyLFxuXHR6d2o6IHp3aixcblx0enduajogendualxufTtcblxudmFyIEFhY3V0ZSA9IFwiw4FcIjtcbnZhciBhYWN1dGUgPSBcIsOhXCI7XG52YXIgQWNpcmMgPSBcIsOCXCI7XG52YXIgYWNpcmMgPSBcIsOiXCI7XG52YXIgYWN1dGUgPSBcIsK0XCI7XG52YXIgQUVsaWcgPSBcIsOGXCI7XG52YXIgYWVsaWcgPSBcIsOmXCI7XG52YXIgQWdyYXZlID0gXCLDgFwiO1xudmFyIGFncmF2ZSA9IFwiw6BcIjtcbnZhciBhbXAkMSA9IFwiJlwiO1xudmFyIEFNUCA9IFwiJlwiO1xudmFyIEFyaW5nID0gXCLDhVwiO1xudmFyIGFyaW5nID0gXCLDpVwiO1xudmFyIEF0aWxkZSA9IFwiw4NcIjtcbnZhciBhdGlsZGUgPSBcIsOjXCI7XG52YXIgQXVtbCA9IFwiw4RcIjtcbnZhciBhdW1sID0gXCLDpFwiO1xudmFyIGJydmJhciA9IFwiwqZcIjtcbnZhciBDY2VkaWwgPSBcIsOHXCI7XG52YXIgY2NlZGlsID0gXCLDp1wiO1xudmFyIGNlZGlsID0gXCLCuFwiO1xudmFyIGNlbnQgPSBcIsKiXCI7XG52YXIgY29weSA9IFwiwqlcIjtcbnZhciBDT1BZID0gXCLCqVwiO1xudmFyIGN1cnJlbiA9IFwiwqRcIjtcbnZhciBkZWcgPSBcIsKwXCI7XG52YXIgZGl2aWRlID0gXCLDt1wiO1xudmFyIEVhY3V0ZSA9IFwiw4lcIjtcbnZhciBlYWN1dGUgPSBcIsOpXCI7XG52YXIgRWNpcmMgPSBcIsOKXCI7XG52YXIgZWNpcmMgPSBcIsOqXCI7XG52YXIgRWdyYXZlID0gXCLDiFwiO1xudmFyIGVncmF2ZSA9IFwiw6hcIjtcbnZhciBFVEggPSBcIsOQXCI7XG52YXIgZXRoID0gXCLDsFwiO1xudmFyIEV1bWwgPSBcIsOLXCI7XG52YXIgZXVtbCA9IFwiw6tcIjtcbnZhciBmcmFjMTIgPSBcIsK9XCI7XG52YXIgZnJhYzE0ID0gXCLCvFwiO1xudmFyIGZyYWMzNCA9IFwiwr5cIjtcbnZhciBndCQxID0gXCI+XCI7XG52YXIgR1QgPSBcIj5cIjtcbnZhciBJYWN1dGUgPSBcIsONXCI7XG52YXIgaWFjdXRlID0gXCLDrVwiO1xudmFyIEljaXJjID0gXCLDjlwiO1xudmFyIGljaXJjID0gXCLDrlwiO1xudmFyIGlleGNsID0gXCLCoVwiO1xudmFyIElncmF2ZSA9IFwiw4xcIjtcbnZhciBpZ3JhdmUgPSBcIsOsXCI7XG52YXIgaXF1ZXN0ID0gXCLCv1wiO1xudmFyIEl1bWwgPSBcIsOPXCI7XG52YXIgaXVtbCA9IFwiw69cIjtcbnZhciBsYXF1byA9IFwiwqtcIjtcbnZhciBsdCQxID0gXCI8XCI7XG52YXIgTFQgPSBcIjxcIjtcbnZhciBtYWNyID0gXCLCr1wiO1xudmFyIG1pY3JvID0gXCLCtVwiO1xudmFyIG1pZGRvdCA9IFwiwrdcIjtcbnZhciBuYnNwID0gXCLCoFwiO1xudmFyIG5vdCA9IFwiwqxcIjtcbnZhciBOdGlsZGUgPSBcIsORXCI7XG52YXIgbnRpbGRlID0gXCLDsVwiO1xudmFyIE9hY3V0ZSA9IFwiw5NcIjtcbnZhciBvYWN1dGUgPSBcIsOzXCI7XG52YXIgT2NpcmMgPSBcIsOUXCI7XG52YXIgb2NpcmMgPSBcIsO0XCI7XG52YXIgT2dyYXZlID0gXCLDklwiO1xudmFyIG9ncmF2ZSA9IFwiw7JcIjtcbnZhciBvcmRmID0gXCLCqlwiO1xudmFyIG9yZG0gPSBcIsK6XCI7XG52YXIgT3NsYXNoID0gXCLDmFwiO1xudmFyIG9zbGFzaCA9IFwiw7hcIjtcbnZhciBPdGlsZGUgPSBcIsOVXCI7XG52YXIgb3RpbGRlID0gXCLDtVwiO1xudmFyIE91bWwgPSBcIsOWXCI7XG52YXIgb3VtbCA9IFwiw7ZcIjtcbnZhciBwYXJhID0gXCLCtlwiO1xudmFyIHBsdXNtbiA9IFwiwrFcIjtcbnZhciBwb3VuZCA9IFwiwqNcIjtcbnZhciBxdW90JDEgPSBcIlxcXCJcIjtcbnZhciBRVU9UID0gXCJcXFwiXCI7XG52YXIgcmFxdW8gPSBcIsK7XCI7XG52YXIgcmVnID0gXCLCrlwiO1xudmFyIFJFRyA9IFwiwq5cIjtcbnZhciBzZWN0ID0gXCLCp1wiO1xudmFyIHNoeSA9IFwiwq1cIjtcbnZhciBzdXAxID0gXCLCuVwiO1xudmFyIHN1cDIgPSBcIsKyXCI7XG52YXIgc3VwMyA9IFwiwrNcIjtcbnZhciBzemxpZyA9IFwiw59cIjtcbnZhciBUSE9STiA9IFwiw55cIjtcbnZhciB0aG9ybiA9IFwiw75cIjtcbnZhciB0aW1lcyA9IFwiw5dcIjtcbnZhciBVYWN1dGUgPSBcIsOaXCI7XG52YXIgdWFjdXRlID0gXCLDulwiO1xudmFyIFVjaXJjID0gXCLDm1wiO1xudmFyIHVjaXJjID0gXCLDu1wiO1xudmFyIFVncmF2ZSA9IFwiw5lcIjtcbnZhciB1Z3JhdmUgPSBcIsO5XCI7XG52YXIgdW1sID0gXCLCqFwiO1xudmFyIFV1bWwgPSBcIsOcXCI7XG52YXIgdXVtbCA9IFwiw7xcIjtcbnZhciBZYWN1dGUgPSBcIsOdXCI7XG52YXIgeWFjdXRlID0gXCLDvVwiO1xudmFyIHllbiA9IFwiwqVcIjtcbnZhciB5dW1sID0gXCLDv1wiO1xudmFyIHJlcXVpcmUkJDEgPSB7XG5cdEFhY3V0ZTogQWFjdXRlLFxuXHRhYWN1dGU6IGFhY3V0ZSxcblx0QWNpcmM6IEFjaXJjLFxuXHRhY2lyYzogYWNpcmMsXG5cdGFjdXRlOiBhY3V0ZSxcblx0QUVsaWc6IEFFbGlnLFxuXHRhZWxpZzogYWVsaWcsXG5cdEFncmF2ZTogQWdyYXZlLFxuXHRhZ3JhdmU6IGFncmF2ZSxcblx0YW1wOiBhbXAkMSxcblx0QU1QOiBBTVAsXG5cdEFyaW5nOiBBcmluZyxcblx0YXJpbmc6IGFyaW5nLFxuXHRBdGlsZGU6IEF0aWxkZSxcblx0YXRpbGRlOiBhdGlsZGUsXG5cdEF1bWw6IEF1bWwsXG5cdGF1bWw6IGF1bWwsXG5cdGJydmJhcjogYnJ2YmFyLFxuXHRDY2VkaWw6IENjZWRpbCxcblx0Y2NlZGlsOiBjY2VkaWwsXG5cdGNlZGlsOiBjZWRpbCxcblx0Y2VudDogY2VudCxcblx0Y29weTogY29weSxcblx0Q09QWTogQ09QWSxcblx0Y3VycmVuOiBjdXJyZW4sXG5cdGRlZzogZGVnLFxuXHRkaXZpZGU6IGRpdmlkZSxcblx0RWFjdXRlOiBFYWN1dGUsXG5cdGVhY3V0ZTogZWFjdXRlLFxuXHRFY2lyYzogRWNpcmMsXG5cdGVjaXJjOiBlY2lyYyxcblx0RWdyYXZlOiBFZ3JhdmUsXG5cdGVncmF2ZTogZWdyYXZlLFxuXHRFVEg6IEVUSCxcblx0ZXRoOiBldGgsXG5cdEV1bWw6IEV1bWwsXG5cdGV1bWw6IGV1bWwsXG5cdGZyYWMxMjogZnJhYzEyLFxuXHRmcmFjMTQ6IGZyYWMxNCxcblx0ZnJhYzM0OiBmcmFjMzQsXG5cdGd0OiBndCQxLFxuXHRHVDogR1QsXG5cdElhY3V0ZTogSWFjdXRlLFxuXHRpYWN1dGU6IGlhY3V0ZSxcblx0SWNpcmM6IEljaXJjLFxuXHRpY2lyYzogaWNpcmMsXG5cdGlleGNsOiBpZXhjbCxcblx0SWdyYXZlOiBJZ3JhdmUsXG5cdGlncmF2ZTogaWdyYXZlLFxuXHRpcXVlc3Q6IGlxdWVzdCxcblx0SXVtbDogSXVtbCxcblx0aXVtbDogaXVtbCxcblx0bGFxdW86IGxhcXVvLFxuXHRsdDogbHQkMSxcblx0TFQ6IExULFxuXHRtYWNyOiBtYWNyLFxuXHRtaWNybzogbWljcm8sXG5cdG1pZGRvdDogbWlkZG90LFxuXHRuYnNwOiBuYnNwLFxuXHRub3Q6IG5vdCxcblx0TnRpbGRlOiBOdGlsZGUsXG5cdG50aWxkZTogbnRpbGRlLFxuXHRPYWN1dGU6IE9hY3V0ZSxcblx0b2FjdXRlOiBvYWN1dGUsXG5cdE9jaXJjOiBPY2lyYyxcblx0b2NpcmM6IG9jaXJjLFxuXHRPZ3JhdmU6IE9ncmF2ZSxcblx0b2dyYXZlOiBvZ3JhdmUsXG5cdG9yZGY6IG9yZGYsXG5cdG9yZG06IG9yZG0sXG5cdE9zbGFzaDogT3NsYXNoLFxuXHRvc2xhc2g6IG9zbGFzaCxcblx0T3RpbGRlOiBPdGlsZGUsXG5cdG90aWxkZTogb3RpbGRlLFxuXHRPdW1sOiBPdW1sLFxuXHRvdW1sOiBvdW1sLFxuXHRwYXJhOiBwYXJhLFxuXHRwbHVzbW46IHBsdXNtbixcblx0cG91bmQ6IHBvdW5kLFxuXHRxdW90OiBxdW90JDEsXG5cdFFVT1Q6IFFVT1QsXG5cdHJhcXVvOiByYXF1byxcblx0cmVnOiByZWcsXG5cdFJFRzogUkVHLFxuXHRzZWN0OiBzZWN0LFxuXHRzaHk6IHNoeSxcblx0c3VwMTogc3VwMSxcblx0c3VwMjogc3VwMixcblx0c3VwMzogc3VwMyxcblx0c3psaWc6IHN6bGlnLFxuXHRUSE9STjogVEhPUk4sXG5cdHRob3JuOiB0aG9ybixcblx0dGltZXM6IHRpbWVzLFxuXHRVYWN1dGU6IFVhY3V0ZSxcblx0dWFjdXRlOiB1YWN1dGUsXG5cdFVjaXJjOiBVY2lyYyxcblx0dWNpcmM6IHVjaXJjLFxuXHRVZ3JhdmU6IFVncmF2ZSxcblx0dWdyYXZlOiB1Z3JhdmUsXG5cdHVtbDogdW1sLFxuXHRVdW1sOiBVdW1sLFxuXHR1dW1sOiB1dW1sLFxuXHRZYWN1dGU6IFlhY3V0ZSxcblx0eWFjdXRlOiB5YWN1dGUsXG5cdHllbjogeWVuLFxuXHR5dW1sOiB5dW1sXG59O1xuXG52YXIgYW1wID0gXCImXCI7XG52YXIgYXBvcyA9IFwiJ1wiO1xudmFyIGd0ID0gXCI+XCI7XG52YXIgbHQgPSBcIjxcIjtcbnZhciBxdW90ID0gXCJcXFwiXCI7XG52YXIgcmVxdWlyZSQkMCQxID0ge1xuXHRhbXA6IGFtcCxcblx0YXBvczogYXBvcyxcblx0Z3Q6IGd0LFxuXHRsdDogbHQsXG5cdHF1b3Q6IHF1b3Rcbn07XG5cbnZhciBkZWNvZGVfY29kZXBvaW50ID0ge307XG5cbnZhciByZXF1aXJlJCQwID0ge1xuXHRcIjBcIjogNjU1MzMsXG5cdFwiMTI4XCI6IDgzNjQsXG5cdFwiMTMwXCI6IDgyMTgsXG5cdFwiMTMxXCI6IDQwMixcblx0XCIxMzJcIjogODIyMixcblx0XCIxMzNcIjogODIzMCxcblx0XCIxMzRcIjogODIyNCxcblx0XCIxMzVcIjogODIyNSxcblx0XCIxMzZcIjogNzEwLFxuXHRcIjEzN1wiOiA4MjQwLFxuXHRcIjEzOFwiOiAzNTIsXG5cdFwiMTM5XCI6IDgyNDksXG5cdFwiMTQwXCI6IDMzOCxcblx0XCIxNDJcIjogMzgxLFxuXHRcIjE0NVwiOiA4MjE2LFxuXHRcIjE0NlwiOiA4MjE3LFxuXHRcIjE0N1wiOiA4MjIwLFxuXHRcIjE0OFwiOiA4MjIxLFxuXHRcIjE0OVwiOiA4MjI2LFxuXHRcIjE1MFwiOiA4MjExLFxuXHRcIjE1MVwiOiA4MjEyLFxuXHRcIjE1MlwiOiA3MzIsXG5cdFwiMTUzXCI6IDg0ODIsXG5cdFwiMTU0XCI6IDM1Myxcblx0XCIxNTVcIjogODI1MCxcblx0XCIxNTZcIjogMzM5LFxuXHRcIjE1OFwiOiAzODIsXG5cdFwiMTU5XCI6IDM3NlxufTtcblxudmFyIF9faW1wb3J0RGVmYXVsdCQyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWNvZGVfY29kZXBvaW50LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZWNvZGVfanNvbl8xID0gX19pbXBvcnREZWZhdWx0JDIocmVxdWlyZSQkMCk7XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvaGUvYmxvYi9tYXN0ZXIvc3JjL2hlLmpzI0w5NC1MMTE5XG52YXIgZnJvbUNvZGVQb2ludCQyID0gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuU3RyaW5nLmZyb21Db2RlUG9pbnQgfHxcbiAgICBmdW5jdGlvbiAoY29kZVBvaW50KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhmZmZmKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+PiAxMCkgJiAweDNmZikgfCAweGQ4MDApO1xuICAgICAgICAgICAgY29kZVBvaW50ID0gMHhkYzAwIHwgKGNvZGVQb2ludCAmIDB4M2ZmKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG4gICAgaWYgKChjb2RlUG9pbnQgPj0gMHhkODAwICYmIGNvZGVQb2ludCA8PSAweGRmZmYpIHx8IGNvZGVQb2ludCA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHJldHVybiBcIlxcdUZGRkRcIjtcbiAgICB9XG4gICAgaWYgKGNvZGVQb2ludCBpbiBkZWNvZGVfanNvbl8xLmRlZmF1bHQpIHtcbiAgICAgICAgY29kZVBvaW50ID0gZGVjb2RlX2pzb25fMS5kZWZhdWx0W2NvZGVQb2ludF07XG4gICAgfVxuICAgIHJldHVybiBmcm9tQ29kZVBvaW50JDIoY29kZVBvaW50KTtcbn1cbmRlY29kZV9jb2RlcG9pbnQuZGVmYXVsdCA9IGRlY29kZUNvZGVQb2ludDtcblxudmFyIF9faW1wb3J0RGVmYXVsdCQxID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWNvZGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZGVjb2RlLmRlY29kZUhUTUwgPSBkZWNvZGUuZGVjb2RlSFRNTFN0cmljdCA9IGRlY29kZS5kZWNvZGVYTUwgPSB2b2lkIDA7XG52YXIgZW50aXRpZXNfanNvbl8xJDEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQxJDEpO1xudmFyIGxlZ2FjeV9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQxKTtcbnZhciB4bWxfanNvbl8xJDEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQwJDEpO1xudmFyIGRlY29kZV9jb2RlcG9pbnRfMSA9IF9faW1wb3J0RGVmYXVsdCQxKGRlY29kZV9jb2RlcG9pbnQpO1xudmFyIHN0cmljdEVudGl0eVJlID0gLyYoPzpbYS16QS1aMC05XSt8I1t4WF1bXFxkYS1mQS1GXSt8I1xcZCspOy9nO1xuZGVjb2RlLmRlY29kZVhNTCA9IGdldFN0cmljdERlY29kZXIoeG1sX2pzb25fMSQxLmRlZmF1bHQpO1xuZGVjb2RlLmRlY29kZUhUTUxTdHJpY3QgPSBnZXRTdHJpY3REZWNvZGVyKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpO1xuZnVuY3Rpb24gZ2V0U3RyaWN0RGVjb2RlcihtYXApIHtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKG1hcCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2Uoc3RyaWN0RW50aXR5UmUsIHJlcGxhY2UpOyB9O1xufVxudmFyIHNvcnRlciA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYSA8IGIgPyAxIDogLTEpOyB9O1xuZGVjb2RlLmRlY29kZUhUTUwgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZWdhY3kgPSBPYmplY3Qua2V5cyhsZWdhY3lfanNvbl8xLmRlZmF1bHQpLnNvcnQoc29ydGVyKTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpLnNvcnQoc29ydGVyKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZWdhY3lbal0gPT09IGtleXNbaV0pIHtcbiAgICAgICAgICAgIGtleXNbaV0gKz0gXCI7P1wiO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5c1tpXSArPSBcIjtcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiJig/OlwiICsga2V5cy5qb2luKFwifFwiKSArIFwifCNbeFhdW1xcXFxkYS1mQS1GXSs7P3wjXFxcXGQrOz8pXCIsIFwiZ1wiKTtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKHN0cikge1xuICAgICAgICBpZiAoc3RyLnN1YnN0cigtMSkgIT09IFwiO1wiKVxuICAgICAgICAgICAgc3RyICs9IFwiO1wiO1xuICAgICAgICByZXR1cm4gcmVwbGFjZShzdHIpO1xuICAgIH1cbiAgICAvLyBUT0RPIGNvbnNpZGVyIGNyZWF0aW5nIGEgbWVyZ2VkIG1hcFxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHJlLCByZXBsYWNlcik7IH07XG59KSgpO1xuZnVuY3Rpb24gZ2V0UmVwbGFjZXIobWFwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2Uoc3RyKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDEpID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIHNlY29uZENoYXIgPSBzdHIuY2hhckF0KDIpO1xuICAgICAgICAgICAgaWYgKHNlY29uZENoYXIgPT09IFwiWFwiIHx8IHNlY29uZENoYXIgPT09IFwieFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZV9jb2RlcG9pbnRfMS5kZWZhdWx0KHBhcnNlSW50KHN0ci5zdWJzdHIoMyksIDE2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlX2NvZGVwb2ludF8xLmRlZmF1bHQocGFyc2VJbnQoc3RyLnN1YnN0cigyKSwgMTApKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgcmV0dXJuIG1hcFtzdHIuc2xpY2UoMSwgLTEpXSB8fCBzdHI7XG4gICAgfTtcbn1cblxudmFyIGVuY29kZSA9IHt9O1xuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbmNvZGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZW5jb2RlLmVzY2FwZVVURjggPSBlbmNvZGUuZXNjYXBlID0gZW5jb2RlLmVuY29kZU5vbkFzY2lpSFRNTCA9IGVuY29kZS5lbmNvZGVIVE1MID0gZW5jb2RlLmVuY29kZVhNTCA9IHZvaWQgMDtcbnZhciB4bWxfanNvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUkJDAkMSk7XG52YXIgaW52ZXJzZVhNTCA9IGdldEludmVyc2VPYmooeG1sX2pzb25fMS5kZWZhdWx0KTtcbnZhciB4bWxSZXBsYWNlciA9IGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlWE1MKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzIHdlbGwgYXMgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gWE1MXG4gKiBkb2N1bWVudHMgdXNpbmcgWE1MIGVudGl0aWVzLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYVxuICogbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5lbmNvZGUuZW5jb2RlWE1MID0gZ2V0QVNDSUlFbmNvZGVyKGludmVyc2VYTUwpO1xudmFyIGVudGl0aWVzX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlJCQxJDEpO1xudmFyIGludmVyc2VIVE1MID0gZ2V0SW52ZXJzZU9iaihlbnRpdGllc19qc29uXzEuZGVmYXVsdCk7XG52YXIgaHRtbFJlcGxhY2VyID0gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2VIVE1MKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgZW50aXRpZXMgYW5kIG5vbi1BU0NJSSBjaGFyYWN0ZXJzIGluIHRoZSBpbnB1dC5cbiAqXG4gKiBUaGlzIGluY2x1ZGVzIGNoYXJhY3RlcnMgdGhhdCBhcmUgdmFsaWQgQVNDSUkgY2hhcmFjdGVycyBpbiBIVE1MIGRvY3VtZW50cy5cbiAqIEZvciBleGFtcGxlIGAjYCB3aWxsIGJlIGVuY29kZWQgYXMgYCZudW07YC4gVG8gZ2V0IGEgbW9yZSBjb21wYWN0IG91dHB1dCxcbiAqIGNvbnNpZGVyIHVzaW5nIHRoZSBgZW5jb2RlTm9uQXNjaWlIVE1MYCBmdW5jdGlvbi5cbiAqXG4gKiBJZiBhIGNoYXJhY3RlciBoYXMgbm8gZXF1aXZhbGVudCBlbnRpdHksIGFcbiAqIG51bWVyaWMgaGV4YWRlY2ltYWwgcmVmZXJlbmNlIChlZy4gYCYjeGZjO2ApIHdpbGwgYmUgdXNlZC5cbiAqL1xuZW5jb2RlLmVuY29kZUhUTUwgPSBnZXRJbnZlcnNlKGludmVyc2VIVE1MLCBodG1sUmVwbGFjZXIpO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycywgYXMgd2VsbCBhcyBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBIVE1MXG4gKiBkb2N1bWVudHMgdXNpbmcgSFRNTCBlbnRpdGllcy5cbiAqXG4gKiBJZiBhIGNoYXJhY3RlciBoYXMgbm8gZXF1aXZhbGVudCBlbnRpdHksIGFcbiAqIG51bWVyaWMgaGV4YWRlY2ltYWwgcmVmZXJlbmNlIChlZy4gYCYjeGZjO2ApIHdpbGwgYmUgdXNlZC5cbiAqL1xuZW5jb2RlLmVuY29kZU5vbkFzY2lpSFRNTCA9IGdldEFTQ0lJRW5jb2RlcihpbnZlcnNlSFRNTCk7XG5mdW5jdGlvbiBnZXRJbnZlcnNlT2JqKG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoaW52ZXJzZSwgbmFtZSkge1xuICAgICAgICBpbnZlcnNlW29ialtuYW1lXV0gPSBcIiZcIiArIG5hbWUgKyBcIjtcIjtcbiAgICAgICAgcmV0dXJuIGludmVyc2U7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0SW52ZXJzZVJlcGxhY2VyKGludmVyc2UpIHtcbiAgICB2YXIgc2luZ2xlID0gW107XG4gICAgdmFyIG11bHRpcGxlID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKGludmVyc2UpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgayA9IF9hW19pXTtcbiAgICAgICAgaWYgKGsubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmFsdWUgdG8gc2luZ2xlIGFycmF5XG4gICAgICAgICAgICBzaW5nbGUucHVzaChcIlxcXFxcIiArIGspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQWRkIHZhbHVlIHRvIG11bHRpcGxlIGFycmF5XG4gICAgICAgICAgICBtdWx0aXBsZS5wdXNoKGspO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCByYW5nZXMgdG8gc2luZ2xlIGNoYXJhY3RlcnMuXG4gICAgc2luZ2xlLnNvcnQoKTtcbiAgICBmb3IgKHZhciBzdGFydCA9IDA7IHN0YXJ0IDwgc2luZ2xlLmxlbmd0aCAtIDE7IHN0YXJ0KyspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZW5kIG9mIGEgcnVuIG9mIGNoYXJhY3RlcnNcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSAoZW5kIDwgc2luZ2xlLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgIHNpbmdsZVtlbmRdLmNoYXJDb2RlQXQoMSkgKyAxID09PSBzaW5nbGVbZW5kICsgMV0uY2hhckNvZGVBdCgxKSkge1xuICAgICAgICAgICAgZW5kICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50ID0gMSArIGVuZCAtIHN0YXJ0O1xuICAgICAgICAvLyBXZSB3YW50IHRvIHJlcGxhY2UgYXQgbGVhc3QgdGhyZWUgY2hhcmFjdGVyc1xuICAgICAgICBpZiAoY291bnQgPCAzKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHNpbmdsZS5zcGxpY2Uoc3RhcnQsIGNvdW50LCBzaW5nbGVbc3RhcnRdICsgXCItXCIgKyBzaW5nbGVbZW5kXSk7XG4gICAgfVxuICAgIG11bHRpcGxlLnVuc2hpZnQoXCJbXCIgKyBzaW5nbGUuam9pbihcIlwiKSArIFwiXVwiKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChtdWx0aXBsZS5qb2luKFwifFwiKSwgXCJnXCIpO1xufVxuLy8gL1teXFwwLVxceDdGXS9ndVxudmFyIHJlTm9uQVNDSUkgPSAvKD86W1xceDgwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pL2c7XG52YXIgZ2V0Q29kZVBvaW50ID0gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCAhPSBudWxsXG4gICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHIuY29kZVBvaW50QXQoMCk7IH1cbiAgICA6IC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gKGMuY2hhckNvZGVBdCgwKSAtIDB4ZDgwMCkgKiAweDQwMCArXG4gICAgICAgICAgICAgICAgYy5jaGFyQ29kZUF0KDEpIC1cbiAgICAgICAgICAgICAgICAweGRjMDAgK1xuICAgICAgICAgICAgICAgIDB4MTAwMDA7XG4gICAgICAgIH07XG5mdW5jdGlvbiBzaW5nbGVDaGFyUmVwbGFjZXIoYykge1xuICAgIHJldHVybiBcIiYjeFwiICsgKGMubGVuZ3RoID4gMSA/IGdldENvZGVQb2ludChjKSA6IGMuY2hhckNvZGVBdCgwKSlcbiAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAudG9VcHBlckNhc2UoKSArIFwiO1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52ZXJzZShpbnZlcnNlLCByZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICAgICAgLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBpbnZlcnNlW25hbWVdOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UocmVOb25BU0NJSSwgc2luZ2xlQ2hhclJlcGxhY2VyKTtcbiAgICB9O1xufVxudmFyIHJlRXNjYXBlQ2hhcnMgPSBuZXcgUmVnRXhwKHhtbFJlcGxhY2VyLnNvdXJjZSArIFwifFwiICsgcmVOb25BU0NJSS5zb3VyY2UsIFwiZ1wiKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzIHdlbGwgYXMgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gWE1MXG4gKiBkb2N1bWVudHMgdXNpbmcgbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkuXG4gKlxuICogSGF2ZSBhIGxvb2sgYXQgYGVzY2FwZVVURjhgIGlmIHlvdSB3YW50IGEgbW9yZSBjb25jaXNlIG91dHB1dCBhdCB0aGUgZXhwZW5zZVxuICogb2YgcmVkdWNlZCB0cmFuc3BvcnRhYmlsaXR5LlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBlc2NhcGUuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZShyZUVzY2FwZUNoYXJzLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xufVxuZW5jb2RlLmVzY2FwZSA9IGVzY2FwZTtcbi8qKlxuICogRW5jb2RlcyBhbGwgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gWE1MIGRvY3VtZW50cyB1c2luZyBudW1lcmljIGhleGFkZWNpbWFsXG4gKiByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBvdXRwdXQgd2lsbCBiZSBjaGFyYWN0ZXItc2V0IGRlcGVuZGVudC5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZXNjYXBlLlxuICovXG5mdW5jdGlvbiBlc2NhcGVVVEY4KGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKHhtbFJlcGxhY2VyLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xufVxuZW5jb2RlLmVzY2FwZVVURjggPSBlc2NhcGVVVEY4O1xuZnVuY3Rpb24gZ2V0QVNDSUlFbmNvZGVyKG9iaikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5yZXBsYWNlKHJlRXNjYXBlQ2hhcnMsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBvYmpbY10gfHwgc2luZ2xlQ2hhclJlcGxhY2VyKGMpOyB9KTtcbiAgICB9O1xufVxuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlWE1MU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MNVN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTDRTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUw1ID0gZXhwb3J0cy5kZWNvZGVIVE1MNCA9IGV4cG9ydHMuZGVjb2RlSFRNTFN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTCA9IGV4cG9ydHMuZGVjb2RlWE1MID0gZXhwb3J0cy5lbmNvZGVIVE1MNSA9IGV4cG9ydHMuZW5jb2RlSFRNTDQgPSBleHBvcnRzLmVzY2FwZVVURjggPSBleHBvcnRzLmVzY2FwZSA9IGV4cG9ydHMuZW5jb2RlTm9uQXNjaWlIVE1MID0gZXhwb3J0cy5lbmNvZGVIVE1MID0gZXhwb3J0cy5lbmNvZGVYTUwgPSBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlU3RyaWN0ID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG52YXIgZGVjb2RlXzEgPSBkZWNvZGU7XG52YXIgZW5jb2RlXzEgPSBlbmNvZGU7XG4vKipcbiAqIERlY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZGVjb2RlLlxuICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGRlY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAqIEBkZXByZWNhdGVkIFVzZSBgZGVjb2RlWE1MYCBvciBgZGVjb2RlSFRNTGAgZGlyZWN0bHkuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZSQxKGRhdGEsIGxldmVsKSB7XG4gICAgcmV0dXJuICghbGV2ZWwgfHwgbGV2ZWwgPD0gMCA/IGRlY29kZV8xLmRlY29kZVhNTCA6IGRlY29kZV8xLmRlY29kZUhUTUwpKGRhdGEpO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGUkMTtcbi8qKlxuICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLiBEb2VzIG5vdCBhbGxvdyBtaXNzaW5nIHRyYWlsaW5nIHNlbWljb2xvbnMgZm9yIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZGVjb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICogQGRlcHJlY2F0ZWQgVXNlIGBkZWNvZGVIVE1MU3RyaWN0YCBvciBgZGVjb2RlWE1MYCBkaXJlY3RseS5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlU3RyaWN0KGRhdGEsIGxldmVsKSB7XG4gICAgcmV0dXJuICghbGV2ZWwgfHwgbGV2ZWwgPD0gMCA/IGRlY29kZV8xLmRlY29kZVhNTCA6IGRlY29kZV8xLmRlY29kZUhUTUxTdHJpY3QpKGRhdGEpO1xufVxuZXhwb3J0cy5kZWNvZGVTdHJpY3QgPSBkZWNvZGVTdHJpY3Q7XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGVuY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAqIEBkZXByZWNhdGVkIFVzZSBgZW5jb2RlSFRNTGAsIGBlbmNvZGVYTUxgIG9yIGBlbmNvZGVOb25Bc2NpaUhUTUxgIGRpcmVjdGx5LlxuICovXG5mdW5jdGlvbiBlbmNvZGUkMShkYXRhLCBsZXZlbCkge1xuICAgIHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBlbmNvZGVfMS5lbmNvZGVYTUwgOiBlbmNvZGVfMS5lbmNvZGVIVE1MKShkYXRhKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlJDE7XG52YXIgZW5jb2RlXzIgPSBlbmNvZGU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVYTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZVhNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVOb25Bc2NpaUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZU5vbkFzY2lpSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZXNjYXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlVVRGOFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZXNjYXBlVVRGODsgfSB9KTtcbi8vIExlZ2FjeSBhbGlhc2VzIChkZXByZWNhdGVkKVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlSFRNTDRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVIVE1MNVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlSFRNTDsgfSB9KTtcbnZhciBkZWNvZGVfMiA9IGRlY29kZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVhNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlWE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUxTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7IH0gfSk7XG4vLyBMZWdhY3kgYWxpYXNlcyAoZGVwcmVjYXRlZClcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MNFN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTFN0cmljdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw1U3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlWE1MU3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVYTUw7IH0gfSk7XG59KGxpYikpO1xuXG52YXIgRU5USVRZID0gJyYoPzojeFthLWYwLTldezEsNn18I1swLTldezEsN318W2Etel1bYS16MC05XXsxLDMxfSk7JztcbnZhciBDX0JBQ0tTTEFTSCQxID0gOTI7XG52YXIgcmVCYWNrc2xhc2hPckFtcCA9IC9bXFxcXCZdLztcbnZhciBFU0NBUEFCTEUgPSAnWyFcIiMkJSZcXCcoKSorLC4vOjs8PT4/QFtcXFxcXFxcXFxcXFxdXl9ge3x9fi1dJztcbnZhciByZUVudGl0eU9yRXNjYXBlZENoYXIgPSBuZXcgUmVnRXhwKFwiXFxcXFxcXFxcIiArIEVTQ0FQQUJMRSArIFwifFwiICsgRU5USVRZLCAnZ2knKTtcbnZhciBYTUxTUEVDSUFMID0gJ1smPD5cIl0nO1xudmFyIHJlWG1sU3BlY2lhbCA9IG5ldyBSZWdFeHAoWE1MU1BFQ0lBTCwgJ2cnKTtcbnZhciB1bmVzY2FwZUNoYXIgPSBmdW5jdGlvbiAocykge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoMCkgPT09IENfQkFDS1NMQVNIJDEpIHtcbiAgICAgICAgcmV0dXJuIHMuY2hhckF0KDEpO1xuICAgIH1cbiAgICByZXR1cm4gbGliLmRlY29kZUhUTUwocyk7XG59O1xuLy8gUmVwbGFjZSBlbnRpdGllcyBhbmQgYmFja3NsYXNoIGVzY2FwZXMgd2l0aCBsaXRlcmFsIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB1bmVzY2FwZVN0cmluZyhzKSB7XG4gICAgaWYgKHJlQmFja3NsYXNoT3JBbXAudGVzdChzKSkge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKHJlRW50aXR5T3JFc2NhcGVkQ2hhciwgdW5lc2NhcGVDaGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBub3JtYWxpemVVUkkodXJpKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGVuY29kZV8xKHVyaSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhcihzKSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICcmYW1wOyc7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuICcmbHQ7JztcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICByZXR1cm4gJyZndDsnO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJyZxdW90Oyc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICB9XG59XG5mdW5jdGlvbiBlc2NhcGVYbWwocykge1xuICAgIGlmIChyZVhtbFNwZWNpYWwudGVzdChzKSkge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKHJlWG1sU3BlY2lhbCwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBhcnIucHVzaChzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyLmpvaW4oJycpO1xufVxuZnVuY3Rpb24gaXNFbXB0eShzdHIpIHtcbiAgICBpZiAoIXN0cikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICEvW14gXFx0XSsvLnRlc3Qoc3RyKTtcbn1cblxudmFyIE5vZGVXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZVdhbGtlcihyb290KSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHJvb3Q7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuZW50ZXJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBOb2RlV2Fsa2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50O1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSB0aGlzLmVudGVyaW5nO1xuICAgICAgICBpZiAoY3VyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGFpbmVyID0gaXNDb250YWluZXIkMShjdXIpO1xuICAgICAgICBpZiAoZW50ZXJpbmcgJiYgY29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiAoY3VyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN0YXkgb24gbm9kZSBidXQgZXhpdFxuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIgPT09IHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5uZXh0O1xuICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZW50ZXJpbmc6IGVudGVyaW5nLCBub2RlOiBjdXIgfTtcbiAgICB9O1xuICAgIE5vZGVXYWxrZXIucHJvdG90eXBlLnJlc3VtZUF0ID0gZnVuY3Rpb24gKG5vZGUsIGVudGVyaW5nKSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5vZGU7XG4gICAgICAgIHRoaXMuZW50ZXJpbmcgPSBlbnRlcmluZyA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlV2Fsa2VyO1xufSgpKTtcblxuZnVuY3Rpb24gaXNDb250YWluZXIkMShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICBjYXNlICdibG9ja1F1b3RlJzpcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOlxuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgY2FzZSAnZW1waCc6XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6XG4gICAgICAgIGNhc2UgJ3N0cmlrZSc6XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgY2FzZSAndGFibGVIZWFkJzpcbiAgICAgICAgY2FzZSAndGFibGVCb2R5JzpcbiAgICAgICAgY2FzZSAndGFibGVSb3cnOlxuICAgICAgICBjYXNlICd0YWJsZUNlbGwnOlxuICAgICAgICBjYXNlICd0YWJsZURlbGltUm93JzpcbiAgICAgICAgY2FzZSAnY3VzdG9tSW5saW5lJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbnZhciBsYXN0Tm9kZUlkID0gMTtcbnZhciBub2RlTWFwID0ge307XG5mdW5jdGlvbiBnZXROb2RlQnlJZChpZCkge1xuICAgIHJldHVybiBub2RlTWFwW2lkXTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU5vZGVCeUlkKGlkKSB7XG4gICAgZGVsZXRlIG5vZGVNYXBbaWRdO1xufVxuZnVuY3Rpb24gcmVtb3ZlQWxsTm9kZSgpIHtcbiAgICBub2RlTWFwID0ge307XG59XG52YXIgTm9kZSQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUobm9kZVR5cGUsIHNvdXJjZXBvcykge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIC8vIG9ubHkgZm9yIGNvbnRhaW5lciBub2RlXG4gICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENoaWxkID0gbnVsbDtcbiAgICAgICAgLy8gb25seSBmb3IgbGVhZiBub2RlXG4gICAgICAgIHRoaXMubGl0ZXJhbCA9IG51bGw7XG4gICAgICAgIGlmIChub2RlVHlwZSA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgICAgdGhpcy5pZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pZCA9IGxhc3ROb2RlSWQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSBub2RlVHlwZTtcbiAgICAgICAgdGhpcy5zb3VyY2Vwb3MgPSBzb3VyY2Vwb3M7XG4gICAgICAgIG5vZGVNYXBbdGhpcy5pZF0gPSB0aGlzO1xuICAgIH1cbiAgICBOb2RlLnByb3RvdHlwZS5pc0NvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29udGFpbmVyJDEodGhpcyk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXYpIHtcbiAgICAgICAgICAgIHRoaXMucHJldi5uZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5maXJzdENoaWxkID0gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5wcmV2ID0gdGhpcy5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5sYXN0Q2hpbGQgPSB0aGlzLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUucmVwbGFjZVdpdGggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgICAgdGhpcy51bmxpbmsoKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKHNpYmxpbmcpIHtcbiAgICAgICAgc2libGluZy51bmxpbmsoKTtcbiAgICAgICAgc2libGluZy5uZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoc2libGluZy5uZXh0KSB7XG4gICAgICAgICAgICBzaWJsaW5nLm5leHQucHJldiA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5wcmV2ID0gdGhpcztcbiAgICAgICAgdGhpcy5uZXh0ID0gc2libGluZztcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgaWYgKCFzaWJsaW5nLm5leHQpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudC5sYXN0Q2hpbGQgPSBzaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoc2libGluZykge1xuICAgICAgICBzaWJsaW5nLnVubGluaygpO1xuICAgICAgICBzaWJsaW5nLnByZXYgPSB0aGlzLnByZXY7XG4gICAgICAgIGlmIChzaWJsaW5nLnByZXYpIHtcbiAgICAgICAgICAgIHNpYmxpbmcucHJldi5uZXh0ID0gc2libGluZztcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLm5leHQgPSB0aGlzO1xuICAgICAgICB0aGlzLnByZXYgPSBzaWJsaW5nO1xuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXNpYmxpbmcucHJldikge1xuICAgICAgICAgICAgc2libGluZy5wYXJlbnQuZmlyc3RDaGlsZCA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnVubGluaygpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkLm5leHQgPSBjaGlsZDtcbiAgICAgICAgICAgIGNoaWxkLnByZXYgPSB0aGlzLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnByZXBlbmRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC51bmxpbmsoKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkLnByZXYgPSBjaGlsZDtcbiAgICAgICAgICAgIGNoaWxkLm5leHQgPSB0aGlzLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUud2Fsa2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVXYWxrZXIodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZTtcbn0oKSk7XG52YXIgQmxvY2tOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tOb2RlKG5vZGVUeXBlLCBzb3VyY2Vwb3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbm9kZVR5cGUsIHNvdXJjZXBvcykgfHwgdGhpcztcbiAgICAgICAgLy8gdGVtcG9yYWwgZGF0YSAoZm9yIHBhcnNpbmcpXG4gICAgICAgIF90aGlzLm9wZW4gPSB0cnVlO1xuICAgICAgICBfdGhpcy5saW5lT2Zmc2V0cyA9IG51bGw7XG4gICAgICAgIF90aGlzLnN0cmluZ0NvbnRlbnQgPSBudWxsO1xuICAgICAgICBfdGhpcy5sYXN0TGluZUJsYW5rID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmxhc3RMaW5lQ2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy50eXBlID0gbm9kZVR5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJsb2NrTm9kZTtcbn0oTm9kZSQxKSk7XG52YXIgTGlzdE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpc3ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3ROb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGlzdERhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaXN0Tm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgSGVhZGluZ05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlYWRpbmdOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRpbmdOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGV2ZWwgPSAwO1xuICAgICAgICBfdGhpcy5oZWFkaW5nVHlwZSA9ICdhdHgnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIZWFkaW5nTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgQ29kZUJsb2NrTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29kZUJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2RlQmxvY2tOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaXNGZW5jZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuZmVuY2VDaGFyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuZmVuY2VMZW5ndGggPSAwO1xuICAgICAgICBfdGhpcy5mZW5jZU9mZnNldCA9IC0xO1xuICAgICAgICBfdGhpcy5pbmZvID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaW5mb1BhZGRpbmcgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb2RlQmxvY2tOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBUYWJsZU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZU5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb2x1bW5zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgVGFibGVDZWxsTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVDZWxsTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUNlbGxOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhcnRJZHggPSAwO1xuICAgICAgICBfdGhpcy5lbmRJZHggPSAwO1xuICAgICAgICBfdGhpcy5wYWRkaW5nTGVmdCA9IDA7XG4gICAgICAgIF90aGlzLnBhZGRpbmdSaWdodCA9IDA7XG4gICAgICAgIF90aGlzLmlnbm9yZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFibGVDZWxsTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgUmVmRGVmTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmRGVmTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZEZWZOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGl0bGUgPSAnJztcbiAgICAgICAgX3RoaXMuZGVzdCA9ICcnO1xuICAgICAgICBfdGhpcy5sYWJlbCA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZWZEZWZOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBDdXN0b21CbG9ja05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEN1c3RvbUJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21CbG9ja05vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zeW50YXhMZW5ndGggPSAwO1xuICAgICAgICBfdGhpcy5vZmZzZXQgPSAtMTtcbiAgICAgICAgX3RoaXMuaW5mbyA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDdXN0b21CbG9ja05vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIEh0bWxCbG9ja05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEh0bWxCbG9ja05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHRtbEJsb2NrTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmh0bWxCbG9ja1R5cGUgPSAtMTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSHRtbEJsb2NrTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgTGlua05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmtOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmtOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBfdGhpcy50aXRsZSA9IG51bGw7XG4gICAgICAgIF90aGlzLmV4dGVuZGVkQXV0b2xpbmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlua05vZGU7XG59KE5vZGUkMSkpO1xudmFyIENvZGVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2RlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2RlTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRpY2tDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvZGVOb2RlO1xufShOb2RlJDEpKTtcbnZhciBDdXN0b21JbmxpbmVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDdXN0b21JbmxpbmVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUlubGluZU5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbmZvID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEN1c3RvbUlubGluZU5vZGU7XG59KE5vZGUkMSkpO1xuZnVuY3Rpb24gY3JlYXRlTm9kZSQxKHR5cGUsIHNvdXJjZXBvcykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVhZGluZ05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0Tm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5rTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjb2RlQmxvY2snOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2RlQmxvY2tOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2h0bWxCbG9jayc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEh0bWxCbG9ja05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZU5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAndGFibGVDZWxsJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFibGVDZWxsTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrUXVvdGUnOlxuICAgICAgICBjYXNlICd0aGVtYXRpY0JyZWFrJzpcbiAgICAgICAgY2FzZSAndGFibGVSb3cnOlxuICAgICAgICBjYXNlICd0YWJsZUJvZHknOlxuICAgICAgICBjYXNlICd0YWJsZUhlYWQnOlxuICAgICAgICBjYXNlICdmcm9udE1hdHRlcic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29kZU5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAncmVmRGVmJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmRGVmTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjdXN0b21CbG9jayc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUJsb2NrTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjdXN0b21JbmxpbmUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21JbmxpbmVOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGUkMSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQ29kZUJsb2NrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnY29kZUJsb2NrJztcbn1cbmZ1bmN0aW9uIGlzSHRtbEJsb2NrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnaHRtbEJsb2NrJztcbn1cbmZ1bmN0aW9uIGlzSGVhZGluZyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2hlYWRpbmcnO1xufVxuZnVuY3Rpb24gaXNMaXN0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnbGlzdCc7XG59XG5mdW5jdGlvbiBpc1RhYmxlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAndGFibGUnO1xufVxuZnVuY3Rpb24gaXNSZWZEZWYobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdyZWZEZWYnO1xufVxuZnVuY3Rpb24gaXNDdXN0b21CbG9jayhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2N1c3RvbUJsb2NrJztcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tSW5saW5lKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnY3VzdG9tSW5saW5lJztcbn1cbmZ1bmN0aW9uIHRleHQkMShzLCBzb3VyY2Vwb3MpIHtcbiAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUkMSgndGV4dCcsIHNvdXJjZXBvcyk7XG4gICAgbm9kZS5saXRlcmFsID0gcztcbiAgICByZXR1cm4gbm9kZTtcbn1cblxudmFyIFRBR05BTUUgPSAnW0EtWmEtel1bQS1aYS16MC05LV0qJztcbnZhciBBVFRSSUJVVEVOQU1FID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcbnZhciBVTlFVT1RFRFZBTFVFID0gJ1teXCJcXCc9PD5gXFxcXHgwMC1cXFxceDIwXSsnO1xudmFyIFNJTkdMRVFVT1RFRFZBTFVFID0gXCInW14nXSonXCI7XG52YXIgRE9VQkxFUVVPVEVEVkFMVUUgPSAnXCJbXlwiXSpcIic7XG52YXIgQVRUUklCVVRFVkFMVUUgPSBcIig/OlwiICsgVU5RVU9URURWQUxVRSArIFwifFwiICsgU0lOR0xFUVVPVEVEVkFMVUUgKyBcInxcIiArIERPVUJMRVFVT1RFRFZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFVkFMVUVTUEVDID0gXCJcIiArICcoPzpcXFxccyo9XFxcXHMqJyArIEFUVFJJQlVURVZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFID0gXCJcIiArICcoPzpcXFxccysnICsgQVRUUklCVVRFTkFNRSArIEFUVFJJQlVURVZBTFVFU1BFQyArIFwiPylcIjtcbnZhciBPUEVOVEFHID0gXCI8XCIgKyBUQUdOQU1FICsgQVRUUklCVVRFICsgXCIqXFxcXHMqLz8+XCI7XG52YXIgQ0xPU0VUQUcgPSBcIjwvXCIgKyBUQUdOQU1FICsgXCJcXFxccypbPl1cIjtcbnZhciBIVE1MQ09NTUVOVCA9ICc8IS0tLS0+fDwhLS0oPzotP1tePi1dKSg/Oi0/W14tXSkqLS0+JztcbnZhciBQUk9DRVNTSU5HSU5TVFJVQ1RJT04gPSAnWzxdWz9dLio/Wz9dWz5dJztcbnZhciBERUNMQVJBVElPTiA9ICc8IVtBLVpdK1xcXFxzK1tePl0qPic7XG52YXIgQ0RBVEEgPSAnPCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JztcbnZhciBIVE1MVEFHID0gXCIoPzpcIiArIE9QRU5UQUcgKyBcInxcIiArIENMT1NFVEFHICsgXCJ8XCIgKyBIVE1MQ09NTUVOVCArIFwifFwiICsgUFJPQ0VTU0lOR0lOU1RSVUNUSU9OICsgXCJ8XCIgKyBERUNMQVJBVElPTiArIFwifFwiICsgQ0RBVEEgKyBcIilcIjtcbnZhciByZUh0bWxUYWcgPSBuZXcgUmVnRXhwKFwiXlwiICsgSFRNTFRBRywgJ2knKTtcblxuLy8gZGVyaXZlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5mcm9tQ29kZVBvaW50XG4vKiEgaHR0cDovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4yLjEgYnkgQG1hdGhpYXMgKi9cbnZhciBmcm9tQ29kZVBvaW50O1xuaWYgKFN0cmluZy5mcm9tQ29kZVBvaW50KSB7XG4gICAgZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZmZmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGVfMSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgdmFyIGZsb29yXzEgPSBNYXRoLmZsb29yO1xuICAgIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE1BWF9TSVpFID0gMHg0MDAwO1xuICAgICAgICB2YXIgY29kZVVuaXRzID0gW107XG4gICAgICAgIHZhciBoaWdoU3Vycm9nYXRlO1xuICAgICAgICB2YXIgbG93U3Vycm9nYXRlO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJnc1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPCAwIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCA+IDB4MTBmZmZmIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgIGZsb29yXzEoY29kZVBvaW50KSAhPT0gY29kZVBvaW50IC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweGZmZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgICAgICAvLyBCTVAgY29kZSBwb2ludFxuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgMHhkODAwO1xuICAgICAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweGRjMDA7XG4gICAgICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCArIDEgPT09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlXzEuYXBwbHkodm9pZCAwLCBjb2RlVW5pdHMpO1xuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbnZhciBmcm9tQ29kZVBvaW50JDEgPSBmcm9tQ29kZVBvaW50O1xuXG52YXIgRE9NQUlOID0gJyg/Olt3LV0rLikqW0EtWmEtejAtOS1dKy5bQS1aYS16MC05LV0rJztcbnZhciBQQVRIID0gJ1tePFxcXFxzXSpbXjw/IS4sOipfP35cXFxcc10nO1xudmFyIEVNQUlMID0gJ1tcXFxcdy4rLV0rQCg/OltcXFxcdy1dK1xcXFwuKStbXFxcXHctXSsnO1xuZnVuY3Rpb24gdHJpbVVubWF0Y2hlZFRyYWlsaW5nUGFyZW5zKHNvdXJjZSkge1xuICAgIHZhciB0cmFpbGluZ1BhcmVuID0gL1xcKSskLy5leGVjKHNvdXJjZSk7XG4gICAgaWYgKHRyYWlsaW5nUGFyZW4pIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzb3VyY2VfMSA9IHNvdXJjZTsgX2kgPCBzb3VyY2VfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHNvdXJjZV8xW19pXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgICAgIHZhciB0cmltQ291bnQgPSBNYXRoLm1pbigtY291bnQsIHRyYWlsaW5nUGFyZW5bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic3RyaW5nKDAsIHNvdXJjZS5sZW5ndGggLSB0cmltQ291bnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiB0cmltVHJhaWxpbmdFbnRpdHkoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKC8mW0EtWmEtejAtOV0rOyQvLCAnJyk7XG59XG5mdW5jdGlvbiBwYXJzZUVtYWlsTGluayhzb3VyY2UpIHtcbiAgICB2YXIgcmVFbWFpbExpbmsgPSBuZXcgUmVnRXhwKEVNQUlMLCAnZycpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbTtcbiAgICB3aGlsZSAoKG0gPSByZUVtYWlsTGluay5leGVjKHNvdXJjZSkpKSB7XG4gICAgICAgIHZhciB0ZXh0XzEgPSBtWzBdO1xuICAgICAgICBpZiAoIS9bXy1dKyQvLnRlc3QodGV4dF8xKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIHRleHQ6IHRleHRfMSxcbiAgICAgICAgICAgICAgICByYW5nZTogW20uaW5kZXgsIG0uaW5kZXggKyB0ZXh0XzEubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgdXJsOiBcIm1haWx0bzpcIiArIHRleHRfMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZVVybExpbmsoc291cmNlKSB7XG4gICAgdmFyIHJlV3d3QXV0b2xpbmsgPSBuZXcgUmVnRXhwKFwiKHd3d3xodHRwcz86Ly8pLlwiICsgRE9NQUlOICsgUEFUSCwgJ2cnKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIG07XG4gICAgd2hpbGUgKChtID0gcmVXd3dBdXRvbGluay5leGVjKHNvdXJjZSkpKSB7XG4gICAgICAgIHZhciB0ZXh0XzIgPSB0cmltVHJhaWxpbmdFbnRpdHkodHJpbVVubWF0Y2hlZFRyYWlsaW5nUGFyZW5zKG1bMF0pKTtcbiAgICAgICAgdmFyIHNjaGVtZSA9IG1bMV0gPT09ICd3d3cnID8gJ2h0dHA6Ly8nIDogJyc7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IHRleHRfMixcbiAgICAgICAgICAgIHJhbmdlOiBbbS5pbmRleCwgbS5pbmRleCArIHRleHRfMi5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHVybDogXCJcIiArIHNjaGVtZSArIHRleHRfMixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBiYXNlQXV0b2xpbmtQYXJzZXIoc291cmNlKSB7XG4gICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcGFyc2VVcmxMaW5rKHNvdXJjZSkpLCBwYXJzZUVtYWlsTGluayhzb3VyY2UpKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnJhbmdlWzBdIC0gYi5yYW5nZVswXTsgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RXh0QXV0b0xpbmtzKHdhbGtlciwgYXV0b2xpbmtQYXJzZXIpIHtcbiAgICBpZiAodHlwZW9mIGF1dG9saW5rUGFyc2VyID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgYXV0b2xpbmtQYXJzZXIgPSBiYXNlQXV0b2xpbmtQYXJzZXI7XG4gICAgfVxuICAgIHZhciBldmVudDtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmcsIG5vZGUgPSBldmVudC5ub2RlO1xuICAgICAgICBpZiAoZW50ZXJpbmcgJiYgbm9kZS50eXBlID09PSAndGV4dCcgJiYgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgICAgIHZhciBsaW5rSW5mb3MgPSBhdXRvbGlua1BhcnNlcihsaXRlcmFsKTtcbiAgICAgICAgICAgIGlmICghbGlua0luZm9zIHx8ICFsaW5rSW5mb3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0SWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBfYSA9IG5vZGUuc291cmNlcG9zWzBdLCBsaW5lTnVtXzEgPSBfYVswXSwgY2hQb3NfMSA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIHNvdXJjZXBvcyA9IGZ1bmN0aW9uIChzdGFydElkeCwgZW5kSWR4KSB7IHJldHVybiBbXG4gICAgICAgICAgICAgICAgW2xpbmVOdW1fMSwgY2hQb3NfMSArIHN0YXJ0SWR4XSxcbiAgICAgICAgICAgICAgICBbbGluZU51bV8xLCBjaFBvc18xICsgZW5kSWR4XSxcbiAgICAgICAgICAgIF07IH07XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbGlua0luZm9zXzEgPSBsaW5rSW5mb3M7IF9pIDwgbGlua0luZm9zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gbGlua0luZm9zXzFbX2ldLCByYW5nZSA9IF9iLnJhbmdlLCB1cmwgPSBfYi51cmwsIGxpbmtUZXh0ID0gX2IudGV4dDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VbMF0gPiBsYXN0SWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGVzLnB1c2godGV4dCQxKGxpdGVyYWwuc3Vic3RyaW5nKGxhc3RJZHgsIHJhbmdlWzBdKSwgc291cmNlcG9zKGxhc3RJZHgsIHJhbmdlWzBdIC0gMSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtOb2RlID0gY3JlYXRlTm9kZSQxKCdsaW5rJywgc291cmNlcG9zLmFwcGx5KHZvaWQgMCwgcmFuZ2UpKTtcbiAgICAgICAgICAgICAgICBsaW5rTm9kZS5hcHBlbmRDaGlsZCh0ZXh0JDEobGlua1RleHQsIHNvdXJjZXBvcy5hcHBseSh2b2lkIDAsIHJhbmdlKSkpO1xuICAgICAgICAgICAgICAgIGxpbmtOb2RlLmRlc3RpbmF0aW9uID0gdXJsO1xuICAgICAgICAgICAgICAgIGxpbmtOb2RlLmV4dGVuZGVkQXV0b2xpbmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5ld05vZGVzLnB1c2gobGlua05vZGUpO1xuICAgICAgICAgICAgICAgIGxhc3RJZHggPSByYW5nZVsxXSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdElkeCA8IGxpdGVyYWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZXMucHVzaCh0ZXh0JDEobGl0ZXJhbC5zdWJzdHJpbmcobGFzdElkeCksIHNvdXJjZXBvcyhsYXN0SWR4LCBsaXRlcmFsLmxlbmd0aCAtIDEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IDAsIG5ld05vZGVzXzEgPSBuZXdOb2RlczsgX2MgPCBuZXdOb2Rlc18xLmxlbmd0aDsgX2MrKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gbmV3Tm9kZXNfMVtfY107XG4gICAgICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnVubGluaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgX2xvb3BfMSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cbi8vIG5vcm1hbGl6ZSBhIHJlZmVyZW5jZSBpbiByZWZlcmVuY2UgbGluayAocmVtb3ZlIFtdcywgdHJpbSxcbi8vIGNvbGxhcHNlIGludGVybmFsIHNwYWNlLCB1bmljb2RlIGNhc2UgZm9sZC5cbi8vIFNlZSBjb21tb25tYXJrL2NvbW1vbm1hcmsuanMjMTY4LlxuZnVuY3Rpb24gbm9ybWFsaXplUmVmZXJlbmNlKHN0cikge1xuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnNsaWNlKDEsIHN0ci5sZW5ndGggLSAxKVxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKC9bIFxcdFxcclxcbl0rLywgJyAnKVxuICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGl0ZXJhdGVPYmplY3Qob2JqLCBpdGVyYXRlZSkge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGl0ZXJhdGVlKGtleSwgb2JqW2tleV0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gb21pdChvYmopIHtcbiAgICB2YXIgcHJvcE5hbWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcHJvcE5hbWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0TWFwID0gX19hc3NpZ24oe30sIG9iaik7XG4gICAgcHJvcE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgcmVzdWx0TWFwW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdE1hcDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XG4gICAgcmV0dXJuICFPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNsZWFyT2JqKG9iaikge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICB9KTtcbn1cblxudmFyIENfTkVXTElORSA9IDEwO1xudmFyIENfQVNURVJJU0sgPSA0MjtcbnZhciBDX1VOREVSU0NPUkUgPSA5NTtcbnZhciBDX0JBQ0tUSUNLID0gOTY7XG52YXIgQ19PUEVOX0JSQUNLRVQkMSA9IDkxO1xudmFyIENfQ0xPU0VfQlJBQ0tFVCA9IDkzO1xudmFyIENfVElMREUgPSAxMjY7XG52YXIgQ19MRVNTVEhBTiQxID0gNjA7XG52YXIgQ19CQU5HID0gMzM7XG52YXIgQ19CQUNLU0xBU0ggPSA5MjtcbnZhciBDX0FNUEVSU0FORCA9IDM4O1xudmFyIENfT1BFTl9QQVJFTiA9IDQwO1xudmFyIENfQ0xPU0VfUEFSRU4gPSA0MTtcbnZhciBDX0NPTE9OID0gNTg7XG52YXIgQ19TSU5HTEVRVU9URSA9IDM5O1xudmFyIENfRE9VQkxFUVVPVEUgPSAzNDtcbnZhciBDX0RPTExBUiA9IDM2O1xuLy8gU29tZSByZWdleHBzIHVzZWQgaW4gaW5saW5lIHBhcnNlcjpcbnZhciBFU0NBUEVEX0NIQVIgPSBcIlxcXFxcXFxcXCIgKyBFU0NBUEFCTEU7XG52YXIgcmVQdW5jdHVhdGlvbiA9IG5ldyBSZWdFeHAoL1shXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5cXHhBMVxceEE3XFx4QUJcXHhCNlxceEI3XFx4QkJcXHhCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTQyXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERjlGXFx1REZEMF18XFx1RDgwMVxcdURENkZ8XFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzlcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1RENDNlxcdUREQzEtXFx1REREN1xcdURFNDEtXFx1REU0M1xcdURGM0MtXFx1REYzRV18XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF18XFx1RDgyRlxcdURDOUZ8XFx1RDgzNltcXHVERTg3LVxcdURFOEJdLyk7XG52YXIgcmVMaW5rVGl0bGUgPSBuZXcgUmVnRXhwKFwiXig/OlxcXCIoXCIgKyBFU0NBUEVEX0NIQVIgKyBcInxbXlxcXCJcXFxceDAwXSkqXFxcIlwiICtcbiAgICBcInxcIiArXG4gICAgKFwiJyhcIiArIEVTQ0FQRURfQ0hBUiArIFwifFteJ1xcXFx4MDBdKSonXCIpICtcbiAgICBcInxcIiArXG4gICAgKFwiXFxcXCgoXCIgKyBFU0NBUEVEX0NIQVIgKyBcInxbXigpXFxcXHgwMF0pKlxcXFwpKVwiKSk7XG52YXIgcmVMaW5rRGVzdGluYXRpb25CcmFjZXMgPSAvXig/OjwoPzpbXjw+XFxuXFxcXFxceDAwXXxcXFxcLikqPikvO1xudmFyIHJlRXNjYXBhYmxlID0gbmV3IFJlZ0V4cChcIl5cIiArIEVTQ0FQQUJMRSk7XG52YXIgcmVFbnRpdHlIZXJlID0gbmV3IFJlZ0V4cChcIl5cIiArIEVOVElUWSwgJ2knKTtcbnZhciByZVRpY2tzID0gL2ArLztcbnZhciByZVRpY2tzSGVyZSA9IC9eYCsvO1xudmFyIHJlRWxsaXBzZXMgPSAvXFwuXFwuXFwuL2c7XG52YXIgcmVEYXNoID0gLy0tKy9nO1xudmFyIHJlRW1haWxBdXRvbGluayA9IC9ePChbYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqKT4vO1xudmFyIHJlQXV0b2xpbmsgPSAvXjxbQS1aYS16XVtBLVphLXowLTkuKy1dezEsMzF9OltePD5cXHgwMC1cXHgyMF0qPi9pO1xudmFyIHJlU3BubCA9IC9eICooPzpcXG4gKik/LztcbnZhciByZVdoaXRlc3BhY2VDaGFyID0gL15bIFxcdFxcblxceDBiXFx4MGNcXHgwZF0vO1xudmFyIHJlVW5pY29kZVdoaXRlc3BhY2VDaGFyID0gL15cXHMvO1xudmFyIHJlRmluYWxTcGFjZSA9IC8gKiQvO1xudmFyIHJlSW5pdGlhbFNwYWNlID0gL14gKi87XG52YXIgcmVTcGFjZUF0RW5kT2ZMaW5lID0gL14gKig/OlxcbnwkKS87XG52YXIgcmVMaW5rTGFiZWwgPSAvXlxcWyg/OlteXFxcXFxcW1xcXV18XFxcXC4pezAsMTAwMH1cXF0vO1xuLy8gTWF0Y2hlcyBhIHN0cmluZyBvZiBub24tc3BlY2lhbCBjaGFyYWN0ZXJzLlxudmFyIHJlTWFpbiA9IC9eW15cXG5gXFxbXFxdXFxcXCE8JipfJ1wifiRdKy9tO1xudmFyIElubGluZVBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmxpbmVQYXJzZXIob3B0aW9ucykge1xuICAgICAgICAvLyBBbiBJbmxpbmVQYXJzZXIga2VlcHMgdHJhY2sgb2YgYSBzdWJqZWN0IChhIHN0cmluZyB0byBiZSBwYXJzZWQpXG4gICAgICAgIC8vIGFuZCBhIHBvc2l0aW9uIGluIHRoYXQgc3ViamVjdC5cbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gJyc7XG4gICAgICAgIHRoaXMuZGVsaW1pdGVycyA9IG51bGw7IC8vIHVzZWQgYnkgaGFuZGxlRGVsaW0gbWV0aG9kXG4gICAgICAgIHRoaXMuYnJhY2tldHMgPSBudWxsO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0TnVtID0gMDtcbiAgICAgICAgdGhpcy5saW5lSWR4ID0gMDtcbiAgICAgICAgdGhpcy5saW5lT2Zmc2V0cyA9IFswXTtcbiAgICAgICAgdGhpcy5saW5lUG9zT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5yZWZNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuc291cmNlcG9zID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIGxpbmVQb3NPZmZzZXQgPSB0aGlzLmxpbmVQb3NPZmZzZXQgKyB0aGlzLmxpbmVPZmZzZXRzW3RoaXMubGluZUlkeF07XG4gICAgICAgIHZhciBsaW5lTnVtID0gdGhpcy5saW5lU3RhcnROdW0gKyB0aGlzLmxpbmVJZHg7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IFtsaW5lTnVtLCBzdGFydCArIGxpbmVQb3NPZmZzZXRdO1xuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBbc3RhcnRwb3MsIFtsaW5lTnVtLCBlbmQgKyBsaW5lUG9zT2Zmc2V0XV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0cG9zO1xuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5uZXh0TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saW5lSWR4ICs9IDE7XG4gICAgICAgIHRoaXMubGluZVBvc09mZnNldCA9IC10aGlzLnBvcztcbiAgICB9O1xuICAgIC8vIElmIHJlIG1hdGNoZXMgYXQgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgc3ViamVjdCwgYWR2YW5jZVxuICAgIC8vIHBvc2l0aW9uIGluIHN1YmplY3QgYW5kIHJldHVybiB0aGUgbWF0Y2g7IG90aGVyd2lzZSByZXR1cm4gbnVsbC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHJlKSB7XG4gICAgICAgIHZhciBtID0gcmUuZXhlYyh0aGlzLnN1YmplY3Quc2xpY2UodGhpcy5wb3MpKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG0uaW5kZXggKyBtWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgfTtcbiAgICAvLyBSZXR1cm5zIHRoZSBjb2RlIGZvciB0aGUgY2hhcmFjdGVyIGF0IHRoZSBjdXJyZW50IHN1YmplY3QgcG9zaXRpb24sIG9yIC0xXG4gICAgLy8gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3ViamVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YmplY3QuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgLy8gUGFyc2UgemVybyBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBhdCBtb3N0IG9uZSBuZXdsaW5lXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5zcG5sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1hdGNoKHJlU3BubCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gQWxsIG9mIHRoZSBwYXJzZXJzIGJlbG93IHRyeSB0byBtYXRjaCBzb21ldGhpbmcgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAvLyBpbiB0aGUgc3ViamVjdC4gIElmIHRoZXkgc3VjY2VlZCBpbiBtYXRjaGluZyBhbnl0aGluZywgdGhleVxuICAgIC8vIHJldHVybiB0aGUgaW5saW5lIG1hdGNoZWQsIGFkdmFuY2luZyB0aGUgc3ViamVjdC5cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGJhY2t0aWNrcywgYWRkaW5nIGVpdGhlciBhIGJhY2t0aWNrIGNvZGUgc3BhbiBvciBhXG4gICAgLy8gbGl0ZXJhbCBzZXF1ZW5jZSBvZiBiYWNrdGlja3MuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJhY2t0aWNrcyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHZhciB0aWNrcyA9IHRoaXMubWF0Y2gocmVUaWNrc0hlcmUpO1xuICAgICAgICBpZiAodGlja3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZ0ZXJPcGVuVGlja3MgPSB0aGlzLnBvcztcbiAgICAgICAgdmFyIG1hdGNoZWQ7XG4gICAgICAgIHdoaWxlICgobWF0Y2hlZCA9IHRoaXMubWF0Y2gocmVUaWNrcykpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCA9PT0gdGlja3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSB0aGlzLnN1YmplY3Quc2xpY2UoYWZ0ZXJPcGVuVGlja3MsIHRoaXMucG9zIC0gdGlja3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlcG9zID0gdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSBjb250ZW50cy5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RMaW5lID0gbGFzdChsaW5lcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUlkeCArPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVQb3NPZmZzZXQgPSAtKHRoaXMucG9zIC0gbGFzdExpbmUubGVuZ3RoIC0gdGlja3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlcG9zWzFdID0gdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IGxpbmVzLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlJDEoJ2NvZGUnLCBzb3VyY2Vwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLm1hdGNoKC9bXiBdLykgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHNbMF0gPT0gJyAnICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzW2NvbnRlbnRzLmxlbmd0aCAtIDFdID09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxpdGVyYWwgPSBjb250ZW50cy5zbGljZSgxLCBjb250ZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGl0ZXJhbCA9IGNvbnRlbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnRpY2tDb3VudCA9IHRpY2tzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgd2UgZGlkbid0IG1hdGNoIGEgY2xvc2luZyBiYWNrdGljayBzZXF1ZW5jZS5cbiAgICAgICAgdGhpcy5wb3MgPSBhZnRlck9wZW5UaWNrcztcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKHRpY2tzLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MgLSAxKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIGEgYmFja3NsYXNoLWVzY2FwZWQgc3BlY2lhbCBjaGFyYWN0ZXIsIGFkZGluZyBlaXRoZXIgdGhlIGVzY2FwZWRcbiAgICAvLyBjaGFyYWN0ZXIsIGEgaGFyZCBsaW5lIGJyZWFrIChpZiB0aGUgYmFja3NsYXNoIGlzIGZvbGxvd2VkIGJ5IGEgbmV3bGluZSksXG4gICAgLy8gb3IgYSBsaXRlcmFsIGJhY2tzbGFzaCB0byB0aGUgYmxvY2sncyBjaGlsZHJlbi4gIEFzc3VtZXMgY3VycmVudCBjaGFyYWN0ZXJcbiAgICAvLyBpcyBhIGJhY2tzbGFzaC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlQmFja3NsYXNoID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBzdWJqID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19ORVdMSU5FKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUkMSgnbGluZWJyZWFrJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MgLSAxLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVFc2NhcGFibGUudGVzdChzdWJqLmNoYXJBdCh0aGlzLnBvcykpKSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEoc3Viai5jaGFyQXQodGhpcy5wb3MpLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKSk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKCdcXFxcJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHN0YXJ0cG9zKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhbiBhdXRvbGluayAoVVJMIG9yIGVtYWlsIGluIHBvaW50eSBicmFja2V0cykuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUF1dG9saW5rID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBtO1xuICAgICAgICB2YXIgZGVzdDtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZUVtYWlsQXV0b2xpbmspKSkge1xuICAgICAgICAgICAgZGVzdCA9IG0uc2xpY2UoMSwgbS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlJDEoJ2xpbmsnLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgIG5vZGUuZGVzdGluYXRpb24gPSBub3JtYWxpemVVUkkoXCJtYWlsdG86XCIgKyBkZXN0KTtcbiAgICAgICAgICAgIG5vZGUudGl0bGUgPSAnJztcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dCQxKGRlc3QsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zICsgMSwgdGhpcy5wb3MgLSAxKSkpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG0gPSB0aGlzLm1hdGNoKHJlQXV0b2xpbmspKSkge1xuICAgICAgICAgICAgZGVzdCA9IG0uc2xpY2UoMSwgbS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlJDEoJ2xpbmsnLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgIG5vZGUuZGVzdGluYXRpb24gPSBub3JtYWxpemVVUkkoZGVzdCk7XG4gICAgICAgICAgICBub2RlLnRpdGxlID0gJyc7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRleHQkMShkZXN0LCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcyArIDEsIHRoaXMucG9zIC0gMSkpKTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhIHJhdyBIVE1MIHRhZy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlSHRtbFRhZyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHZhciBtID0gdGhpcy5tYXRjaChyZUh0bWxUYWcpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gY3JlYXRlTm9kZSQxKCdodG1sSW5saW5lJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSk7XG4gICAgICAgIG5vZGUubGl0ZXJhbCA9IG07XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIFNjYW4gYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHdpdGggY29kZSBjYywgYW5kIHJldHVybiBpbmZvcm1hdGlvbiBhYm91dFxuICAgIC8vIHRoZSBudW1iZXIgb2YgZGVsaW1pdGVycyBhbmQgd2hldGhlciB0aGV5IGFyZSBwb3NpdGlvbmVkIHN1Y2ggdGhhdFxuICAgIC8vIHRoZXkgY2FuIG9wZW4gYW5kL29yIGNsb3NlIGVtcGhhc2lzIG9yIHN0cm9uZyBlbXBoYXNpcy4gIEEgdXRpbGl0eVxuICAgIC8vIGZ1bmN0aW9uIGZvciBzdHJvbmcvZW1waCBwYXJzaW5nLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuc2NhbkRlbGltcyA9IGZ1bmN0aW9uIChjYykge1xuICAgICAgICB2YXIgbnVtZGVsaW1zID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChjYyA9PT0gQ19TSU5HTEVRVU9URSB8fCBjYyA9PT0gQ19ET1VCTEVRVU9URSkge1xuICAgICAgICAgICAgbnVtZGVsaW1zKys7XG4gICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMucGVlaygpID09PSBjYykge1xuICAgICAgICAgICAgICAgIG51bWRlbGltcysrO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bWRlbGltcyA9PT0gMCB8fCAobnVtZGVsaW1zIDwgMiAmJiAoY2MgPT09IENfVElMREUgfHwgY2MgPT09IENfRE9MTEFSKSkpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhckJlZm9yZSA9IHN0YXJ0cG9zID09PSAwID8gJ1xcbicgOiB0aGlzLnN1YmplY3QuY2hhckF0KHN0YXJ0cG9zIC0gMSk7XG4gICAgICAgIHZhciBjY0FmdGVyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHZhciBjaGFyQWZ0ZXI7XG4gICAgICAgIGlmIChjY0FmdGVyID09PSAtMSkge1xuICAgICAgICAgICAgY2hhckFmdGVyID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFyQWZ0ZXIgPSBmcm9tQ29kZVBvaW50JDEoY2NBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFmdGVySXNXaGl0ZXNwYWNlID0gcmVVbmljb2RlV2hpdGVzcGFjZUNoYXIudGVzdChjaGFyQWZ0ZXIpO1xuICAgICAgICB2YXIgYWZ0ZXJJc1B1bmN0dWF0aW9uID0gcmVQdW5jdHVhdGlvbi50ZXN0KGNoYXJBZnRlcik7XG4gICAgICAgIHZhciBiZWZvcmVJc1doaXRlc3BhY2UgPSByZVVuaWNvZGVXaGl0ZXNwYWNlQ2hhci50ZXN0KGNoYXJCZWZvcmUpO1xuICAgICAgICB2YXIgYmVmb3JlSXNQdW5jdHVhdGlvbiA9IHJlUHVuY3R1YXRpb24udGVzdChjaGFyQmVmb3JlKTtcbiAgICAgICAgdmFyIGxlZnRGbGFua2luZyA9ICFhZnRlcklzV2hpdGVzcGFjZSAmJiAoIWFmdGVySXNQdW5jdHVhdGlvbiB8fCBiZWZvcmVJc1doaXRlc3BhY2UgfHwgYmVmb3JlSXNQdW5jdHVhdGlvbik7XG4gICAgICAgIHZhciByaWdodEZsYW5raW5nID0gIWJlZm9yZUlzV2hpdGVzcGFjZSAmJiAoIWJlZm9yZUlzUHVuY3R1YXRpb24gfHwgYWZ0ZXJJc1doaXRlc3BhY2UgfHwgYWZ0ZXJJc1B1bmN0dWF0aW9uKTtcbiAgICAgICAgdmFyIGNhbk9wZW47XG4gICAgICAgIHZhciBjYW5DbG9zZTtcbiAgICAgICAgaWYgKGNjID09PSBDX1VOREVSU0NPUkUpIHtcbiAgICAgICAgICAgIGNhbk9wZW4gPSBsZWZ0RmxhbmtpbmcgJiYgKCFyaWdodEZsYW5raW5nIHx8IGJlZm9yZUlzUHVuY3R1YXRpb24pO1xuICAgICAgICAgICAgY2FuQ2xvc2UgPSByaWdodEZsYW5raW5nICYmICghbGVmdEZsYW5raW5nIHx8IGFmdGVySXNQdW5jdHVhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2MgPT09IENfU0lOR0xFUVVPVEUgfHwgY2MgPT09IENfRE9VQkxFUVVPVEUpIHtcbiAgICAgICAgICAgIGNhbk9wZW4gPSBsZWZ0RmxhbmtpbmcgJiYgIXJpZ2h0Rmxhbmtpbmc7XG4gICAgICAgICAgICBjYW5DbG9zZSA9IHJpZ2h0Rmxhbmtpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2MgPT09IENfRE9MTEFSKSB7XG4gICAgICAgICAgICBjYW5PcGVuID0gIWFmdGVySXNXaGl0ZXNwYWNlO1xuICAgICAgICAgICAgY2FuQ2xvc2UgPSAhYmVmb3JlSXNXaGl0ZXNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FuT3BlbiA9IGxlZnRGbGFua2luZztcbiAgICAgICAgICAgIGNhbkNsb3NlID0gcmlnaHRGbGFua2luZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICByZXR1cm4geyBudW1kZWxpbXM6IG51bWRlbGltcywgY2FuT3BlbjogY2FuT3BlbiwgY2FuQ2xvc2U6IGNhbkNsb3NlIH07XG4gICAgfTtcbiAgICAvLyBIYW5kbGUgYSBkZWxpbWl0ZXIgbWFya2VyIGZvciBlbXBoYXNpcyBvciBhIHF1b3RlLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuaGFuZGxlRGVsaW0gPSBmdW5jdGlvbiAoY2MsIGJsb2NrKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLnNjYW5EZWxpbXMoY2MpO1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1kZWxpbXMgPSByZXMubnVtZGVsaW1zO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHZhciBjb250ZW50cztcbiAgICAgICAgdGhpcy5wb3MgKz0gbnVtZGVsaW1zO1xuICAgICAgICBpZiAoY2MgPT09IENfU0lOR0xFUVVPVEUpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gJ1xcdTIwMTknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNjID09PSBDX0RPVUJMRVFVT1RFKSB7XG4gICAgICAgICAgICBjb250ZW50cyA9ICdcXHUyMDFDJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gdGhpcy5zdWJqZWN0LnNsaWNlKHN0YXJ0cG9zIC0gMSwgdGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gdGV4dCQxKGNvbnRlbnRzLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIC8vIEFkZCBlbnRyeSB0byBzdGFjayBmb3IgdGhpcyBvcGVuZXJcbiAgICAgICAgaWYgKChyZXMuY2FuT3BlbiB8fCByZXMuY2FuQ2xvc2UpICYmXG4gICAgICAgICAgICAodGhpcy5vcHRpb25zLnNtYXJ0IHx8IChjYyAhPT0gQ19TSU5HTEVRVU9URSAmJiBjYyAhPT0gQ19ET1VCTEVRVU9URSkpKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGltaXRlcnMgPSB7XG4gICAgICAgICAgICAgICAgY2M6IGNjLFxuICAgICAgICAgICAgICAgIG51bWRlbGltczogbnVtZGVsaW1zLFxuICAgICAgICAgICAgICAgIG9yaWdkZWxpbXM6IG51bWRlbGltcyxcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiB0aGlzLmRlbGltaXRlcnMsXG4gICAgICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICBjYW5PcGVuOiByZXMuY2FuT3BlbixcbiAgICAgICAgICAgICAgICBjYW5DbG9zZTogcmVzLmNhbkNsb3NlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGltaXRlcnMucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlcnMucHJldmlvdXMubmV4dCA9IHRoaXMuZGVsaW1pdGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucmVtb3ZlRGVsaW1pdGVyID0gZnVuY3Rpb24gKGRlbGltKSB7XG4gICAgICAgIGlmIChkZWxpbS5wcmV2aW91cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsaW0ucHJldmlvdXMubmV4dCA9IGRlbGltLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGltLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHRvcCBvZiBzdGFja1xuICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gZGVsaW0ucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxpbS5uZXh0LnByZXZpb3VzID0gZGVsaW0ucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucmVtb3ZlRGVsaW1pdGVyc0JldHdlZW4gPSBmdW5jdGlvbiAoYm90dG9tLCB0b3ApIHtcbiAgICAgICAgaWYgKGJvdHRvbS5uZXh0ICE9PSB0b3ApIHtcbiAgICAgICAgICAgIGJvdHRvbS5uZXh0ID0gdG9wO1xuICAgICAgICAgICAgdG9wLnByZXZpb3VzID0gYm90dG9tO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCBkZWxpbWl0ZXJzIC0gZW1waGFzaXMsIHN0cm9uZyBlbXBoYXNpcywgc3RyaWtldGhyb3VnaChnZm0pXG4gICAgICogSWYgdGhlIHNtYXJ0IHB1bmN0dWF0aW9uIG9wdGlvbnMgaXMgdHJ1ZSxcbiAgICAgKiBjb252ZXJ0IHNpbmdsZS9kb3VibGUgcXVvdGVzIHRvIGNvcnJlc3BvbmRpbmcgdW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgICAqKi9cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnByb2Nlc3NFbXBoYXNpcyA9IGZ1bmN0aW9uIChzdGFja0JvdHRvbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBvcGVuZXI7XG4gICAgICAgIHZhciBjbG9zZXI7XG4gICAgICAgIHZhciBvbGRDbG9zZXI7XG4gICAgICAgIHZhciBvcGVuZXJJbmwsIGNsb3NlcklubDtcbiAgICAgICAgdmFyIG9wZW5lckZvdW5kO1xuICAgICAgICB2YXIgb2RkTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdmFyIG9wZW5lcnNCb3R0b20gPSAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW0NfVU5ERVJTQ09SRV0gPSBbc3RhY2tCb3R0b20sIHN0YWNrQm90dG9tLCBzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX0FTVEVSSVNLXSA9IFtzdGFja0JvdHRvbSwgc3RhY2tCb3R0b20sIHN0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfU0lOR0xFUVVPVEVdID0gW3N0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfRE9VQkxFUVVPVEVdID0gW3N0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfVElMREVdID0gW3N0YWNrQm90dG9tXSxcbiAgICAgICAgICAgIF9hW0NfRE9MTEFSXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYSk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3QgY2xvc2VyIGFib3ZlIHN0YWNrQm90dG9tOlxuICAgICAgICBjbG9zZXIgPSB0aGlzLmRlbGltaXRlcnM7XG4gICAgICAgIHdoaWxlIChjbG9zZXIgIT09IG51bGwgJiYgY2xvc2VyLnByZXZpb3VzICE9PSBzdGFja0JvdHRvbSkge1xuICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vdmUgZm9yd2FyZCwgbG9va2luZyBmb3IgY2xvc2VycywgYW5kIGhhbmRsaW5nIGVhY2hcbiAgICAgICAgd2hpbGUgKGNsb3NlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNsb3NlcmNjID0gY2xvc2VyLmNjO1xuICAgICAgICAgICAgdmFyIGNsb3NlckVtcGggPSBjbG9zZXJjYyA9PT0gQ19VTkRFUlNDT1JFIHx8IGNsb3NlcmNjID09PSBDX0FTVEVSSVNLO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXIuY2FuQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXIgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZvdW5kIGVtcGhhc2lzIGNsb3Nlci4gbm93IGxvb2sgYmFjayBmb3IgZmlyc3QgbWF0Y2hpbmcgb3BlbmVyOlxuICAgICAgICAgICAgICAgIG9wZW5lciA9IGNsb3Nlci5wcmV2aW91cztcbiAgICAgICAgICAgICAgICBvcGVuZXJGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChvcGVuZXIgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyICE9PSBzdGFja0JvdHRvbSAmJlxuICAgICAgICAgICAgICAgICAgICBvcGVuZXIgIT09IG9wZW5lcnNCb3R0b21bY2xvc2VyY2NdW2Nsb3NlckVtcGggPyBjbG9zZXIub3JpZ2RlbGltcyAlIDMgOiAwXSkge1xuICAgICAgICAgICAgICAgICAgICBvZGRNYXRjaCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJFbXBoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsb3Nlci5jYW5PcGVuIHx8IG9wZW5lci5jYW5DbG9zZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXIub3JpZ2RlbGltcyAlIDMgIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3BlbmVyLm9yaWdkZWxpbXMgKyBjbG9zZXIub3JpZ2RlbGltcykgJSAzID09PSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyLmNjID09PSBjbG9zZXIuY2MgJiYgb3BlbmVyLmNhbk9wZW4gJiYgIW9kZE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcGVuZXIgPSBvcGVuZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9sZENsb3NlciA9IGNsb3NlcjtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VyRW1waCB8fCBjbG9zZXJjYyA9PT0gQ19USUxERSB8fCBjbG9zZXJjYyA9PT0gQ19ET0xMQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcGVuZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3BlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAobnVsbCBvcGVuZXIgY2hlY2sgZm9yIHR5cGUgbmFycm93aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGFjdHVhbCBudW1iZXIgb2YgZGVsaW1pdGVycyB1c2VkIGZyb20gY2xvc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXNlRGVsaW1zID0gY2xvc2VyLm51bWRlbGltcyA+PSAyICYmIG9wZW5lci5udW1kZWxpbXMgPj0gMiA/IDIgOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVtcHR5RGVsaW1zID0gY2xvc2VyRW1waCA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sID0gb3BlbmVyLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJJbmwgPSBjbG9zZXIubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGNvbnRlbnRzIGZvciBuZXcgZW1waCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBjbG9zZXJFbXBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB1c2VEZWxpbXMgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnZW1waCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnc3Ryb25nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3N0cmlrZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VyY2MgPT09IENfRE9MTEFSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVR5cGUgPSAnY3VzdG9tSW5saW5lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gY3JlYXRlTm9kZSQxKG5vZGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuZXJFbmRQb3MgPSBvcGVuZXJJbmwuc291cmNlcG9zWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlclN0YXJ0UG9zID0gY2xvc2VySW5sLnNvdXJjZXBvc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuc291cmNlcG9zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcGVuZXJFbmRQb3NbMF0sIG9wZW5lckVuZFBvc1sxXSAtIHVzZURlbGltcyArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjbG9zZXJTdGFydFBvc1swXSwgY2xvc2VyU3RhcnRQb3NbMV0gKyB1c2VEZWxpbXMgLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJJbmwuc291cmNlcG9zWzFdWzFdIC09IHVzZURlbGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlcklubC5zb3VyY2Vwb3NbMF1bMV0gKz0gdXNlRGVsaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sLmxpdGVyYWwgPSBvcGVuZXJJbmwubGl0ZXJhbC5zbGljZSh1c2VEZWxpbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VySW5sLmxpdGVyYWwgPSBjbG9zZXJJbmwubGl0ZXJhbC5zbGljZSh1c2VEZWxpbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyLm51bWRlbGltcyAtPSB1c2VEZWxpbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXIubnVtZGVsaW1zIC09IHVzZURlbGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB1c2VkIGRlbGltaXRlcnMgZnJvbSBzdGFjayBlbHRzIGFuZCBpbmxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gb3BlbmVySW5sLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0bXAgJiYgdG1wICE9PSBjbG9zZXJJbmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdG1wLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnVubGluaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuYXBwZW5kQ2hpbGQodG1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnVpbGQgY3VzdG9tIGlubGluZSBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VyY2MgPT09IENfRE9MTEFSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHROb2RlID0gbmV3Tm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXRlcmFsID0gdGV4dE5vZGUubGl0ZXJhbCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IGxpdGVyYWwuc3BsaXQoL1xccy8pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuaW5mbyA9IGluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpdGVyYWwubGVuZ3RoIDw9IGluZm8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHROb2RlLnVubGluaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUuc291cmNlcG9zWzBdWzFdICs9IGluZm8ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5saXRlcmFsID0gbGl0ZXJhbC5yZXBsYWNlKGluZm8gKyBcIiBcIiwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubC5pbnNlcnRBZnRlcihuZXdOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBlbHRzIGJldHdlZW4gb3BlbmVyIGFuZCBjbG9zZXIgaW4gZGVsaW1pdGVycyBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXJzQmV0d2VlbihvcGVuZXIsIGNsb3Nlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBvcGVuZXIgaGFzIDAgZGVsaW1zLCByZW1vdmUgaXQgYW5kIHRoZSBpbmxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9wZW5lciBoYXMgMSBkZWxpbXMgYW5kIGNoYXJhY3RlciBpcyB0aWxkZSwgcmVtb3ZlIGRlbGltaXRlciBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyLm51bWRlbGltcyA8PSBlbXB0eURlbGltcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXIubnVtZGVsaW1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubC51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXIob3BlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNsb3NlciBoYXMgMCBkZWxpbXMsIHJlbW92ZSBpdCBhbmQgdGhlIGlubGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2xvc2VyIGhhcyAxIGRlbGltcyBhbmQgY2hhcmFjdGVyIGlzIHRpbGRlLCByZW1vdmUgZGVsaW1pdGVyIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXIubnVtZGVsaW1zIDw9IGVtcHR5RGVsaW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlci5udW1kZWxpbXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VySW5sLnVubGluaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcHN0YWNrID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXIoY2xvc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXIgPSB0ZW1wc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VyY2MgPT09IENfU0lOR0xFUVVPVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyLm5vZGUubGl0ZXJhbCA9ICdcXHUyMDE5JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIubm9kZS5saXRlcmFsID0gJ1xcdTIwMTgnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbG9zZXJjYyA9PT0gQ19ET1VCTEVRVU9URSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXIubm9kZS5saXRlcmFsID0gJ1xcdTIwMUQnO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lci5ub2RlLmxpdGVyYWwgPSAnXFx1MjAxQyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghb3BlbmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGxvd2VyIGJvdW5kIGZvciBmdXR1cmUgc2VhcmNoZXMgZm9yIG9wZW5lcnM6XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lcnNCb3R0b21bY2xvc2VyY2NdW2Nsb3NlckVtcGggPyBvbGRDbG9zZXIub3JpZ2RlbGltcyAlIDMgOiAwXSA9IG9sZENsb3Nlci5wcmV2aW91cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGRDbG9zZXIuY2FuT3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHJlbW92ZSBhIGNsb3NlciB0aGF0IGNhbid0IGJlIGFuIG9wZW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uY2Ugd2UndmUgc2VlbiB0aGVyZSdzIG5vIG1hdGNoaW5nIG9wZW5lcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyKG9sZENsb3Nlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBkZWxpbWl0ZXJzXG4gICAgICAgIHdoaWxlICh0aGlzLmRlbGltaXRlcnMgIT09IG51bGwgJiYgdGhpcy5kZWxpbWl0ZXJzICE9PSBzdGFja0JvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXIodGhpcy5kZWxpbWl0ZXJzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBsaW5rIHRpdGxlIChzYW5zIHF1b3RlcyksIHJldHVybmluZyB0aGUgc3RyaW5nXG4gICAgLy8gb3IgbnVsbCBpZiBubyBtYXRjaC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlTGlua1RpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLm1hdGNoKHJlTGlua1RpdGxlKTtcbiAgICAgICAgaWYgKHRpdGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaG9wIG9mZiBxdW90ZXMgZnJvbSB0aXRsZSBhbmQgdW5lc2NhcGU6XG4gICAgICAgIHJldHVybiB1bmVzY2FwZVN0cmluZyh0aXRsZS5zdWJzdHIoMSwgdGl0bGUubGVuZ3RoIC0gMikpO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBsaW5rIGRlc3RpbmF0aW9uLCByZXR1cm5pbmcgdGhlIHN0cmluZyBvciBudWxsIGlmIG5vIG1hdGNoLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VMaW5rRGVzdGluYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLm1hdGNoKHJlTGlua0Rlc3RpbmF0aW9uQnJhY2VzKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX0xFU1NUSEFOJDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEBUT0RPIGhhbmRyb2xsZWQgcGFyc2VyOyByZXMgc2hvdWxkIGJlIG51bGwgb3IgdGhlIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHNhdmVwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHZhciBvcGVucGFyZW5zID0gMDtcbiAgICAgICAgICAgIHZhciBjID0gdm9pZCAwO1xuICAgICAgICAgICAgd2hpbGUgKChjID0gdGhpcy5wZWVrKCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChjID09PSBDX0JBQ0tTTEFTSCAmJiByZUVzY2FwYWJsZS50ZXN0KHRoaXMuc3ViamVjdC5jaGFyQXQodGhpcy5wb3MgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVlaygpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBDX09QRU5fUEFSRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgb3BlbnBhcmVucyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSBDX0NMT1NFX1BBUkVOKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVucGFyZW5zIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbnBhcmVucyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlV2hpdGVzcGFjZUNoYXIuZXhlYyhmcm9tQ29kZVBvaW50JDEoYykpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHNhdmVwb3MgJiYgYyAhPT0gQ19DTE9TRV9QQVJFTikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wZW5wYXJlbnMgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHRoaXMuc3ViamVjdC5zdWJzdHIoc2F2ZXBvcywgdGhpcy5wb3MgLSBzYXZlcG9zKTtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVVUkkodW5lc2NhcGVTdHJpbmcocmVzKSk7XG4gICAgICAgIH0gLy8gY2hvcCBvZmYgc3Vycm91bmRpbmcgPC4uPjpcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVVSSSh1bmVzY2FwZVN0cmluZyhyZXMuc3Vic3RyKDEsIHJlcy5sZW5ndGggLSAyKSkpO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhIGxpbmsgbGFiZWwsIHJldHVybmluZyBudW1iZXIgb2YgY2hhcmFjdGVycyBwYXJzZWQuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpbmtMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLm1hdGNoKHJlTGlua0xhYmVsKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwgfHwgbS5sZW5ndGggPiAxMDAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5sZW5ndGg7XG4gICAgfTtcbiAgICAvLyBBZGQgb3BlbiBicmFja2V0IHRvIGRlbGltaXRlciBzdGFjayBhbmQgYWRkIGEgdGV4dCBub2RlIHRvIGJsb2NrJ3MgY2hpbGRyZW4uXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9wZW5CcmFja2V0ID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICB2YXIgbm9kZSA9IHRleHQkMSgnWycsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zLCB0aGlzLnBvcykpO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgLy8gQWRkIGVudHJ5IHRvIHN0YWNrIGZvciB0aGlzIG9wZW5lclxuICAgICAgICB0aGlzLmFkZEJyYWNrZXQobm9kZSwgc3RhcnRwb3MsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBJRiBuZXh0IGNoYXJhY3RlciBpcyBbLCBhbmQgISBkZWxpbWl0ZXIgdG8gZGVsaW1pdGVyIHN0YWNrIGFuZFxuICAgIC8vIGFkZCBhIHRleHQgbm9kZSB0byBibG9jaydzIGNoaWxkcmVuLiAgT3RoZXJ3aXNlIGp1c3QgYWRkIGEgdGV4dCBub2RlLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VCYW5nID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfT1BFTl9CUkFDS0VUJDEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRleHQkMSgnIVsnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyAtIDEsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIC8vIEFkZCBlbnRyeSB0byBzdGFjayBmb3IgdGhpcyBvcGVuZXJcbiAgICAgICAgICAgIHRoaXMuYWRkQnJhY2tldChub2RlLCBzdGFydHBvcyArIDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0ZXh0JDEoJyEnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gVHJ5IHRvIG1hdGNoIGNsb3NlIGJyYWNrZXQgYWdhaW5zdCBhbiBvcGVuaW5nIGluIHRoZSBkZWxpbWl0ZXJcbiAgICAvLyBzdGFjay4gIEFkZCBlaXRoZXIgYSBsaW5rIG9yIGltYWdlLCBvciBhIHBsYWluIFsgY2hhcmFjdGVyLFxuICAgIC8vIHRvIGJsb2NrJ3MgY2hpbGRyZW4uICBJZiB0aGVyZSBpcyBhIG1hdGNoaW5nIGRlbGltaXRlcixcbiAgICAvLyByZW1vdmUgaXQgZnJvbSB0aGUgZGVsaW1pdGVyIHN0YWNrLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VDbG9zZUJyYWNrZXQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIGRlc3QgPSBudWxsO1xuICAgICAgICB2YXIgdGl0bGUgPSBudWxsO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gZ2V0IGxhc3QgWyBvciAhW1xuICAgICAgICB2YXIgb3BlbmVyID0gdGhpcy5icmFja2V0cztcbiAgICAgICAgaWYgKG9wZW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm8gbWF0Y2hlZCBvcGVuZXIsIGp1c3QgcmV0dXJuIGEgbGl0ZXJhbFxuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKCddJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHN0YXJ0cG9zKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcGVuZXIuYWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBubyBtYXRjaGVkIG9wZW5lciwganVzdCByZXR1cm4gYSBsaXRlcmFsXG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEoJ10nLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgc3RhcnRwb3MpKSk7XG4gICAgICAgICAgICAvLyB0YWtlIG9wZW5lciBvZmYgYnJhY2tldHMgc3RhY2tcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIG9wZW4gaXMgYSBwb3RlbnRpYWwgb3BlbmVyXG4gICAgICAgIHZhciBpc0ltYWdlID0gb3BlbmVyLmltYWdlO1xuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGxpbmsvaW1hZ2VcbiAgICAgICAgdmFyIHNhdmVwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gSW5saW5lIGxpbms/XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19PUEVOX1BBUkVOKSB7XG4gICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BubCgpICYmXG4gICAgICAgICAgICAgICAgKGRlc3QgPSB0aGlzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKCkpICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zcG5sKCkgJiZcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlcmUncyBhIHNwYWNlIGJlZm9yZSB0aGUgdGl0bGU6XG4gICAgICAgICAgICAgICAgKChyZVdoaXRlc3BhY2VDaGFyLnRlc3QodGhpcy5zdWJqZWN0LmNoYXJBdCh0aGlzLnBvcyAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICAgICAodGl0bGUgPSB0aGlzLnBhcnNlTGlua1RpdGxlKCkpKSB8fFxuICAgICAgICAgICAgICAgICAgICB0cnVlKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3BubCgpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrKCkgPT09IENfQ0xPU0VfUEFSRU4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBzYXZlcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWZMYWJlbCA9ICcnO1xuICAgICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgICAgIC8vIE5leHQsIHNlZSBpZiB0aGVyZSdzIGEgbGluayBsYWJlbFxuICAgICAgICAgICAgdmFyIGJlZm9yZWxhYmVsID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMucGFyc2VMaW5rTGFiZWwoKTtcbiAgICAgICAgICAgIGlmIChuID4gMikge1xuICAgICAgICAgICAgICAgIHJlZkxhYmVsID0gdGhpcy5zdWJqZWN0LnNsaWNlKGJlZm9yZWxhYmVsLCBiZWZvcmVsYWJlbCArIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW9wZW5lci5icmFja2V0QWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBFbXB0eSBvciBtaXNzaW5nIHNlY29uZCBsYWJlbCBtZWFucyB0byB1c2UgdGhlIGZpcnN0IGxhYmVsIGFzIHRoZSByZWZlcmVuY2UuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlZmVyZW5jZSBtdXN0IG5vdCBjb250YWluIGEgYnJhY2tldC4gSWYgd2Uga25vdyB0aGVyZSdzIGEgYnJhY2tldCwgd2UgZG9uJ3QgZXZlbiBib3RoZXIgY2hlY2tpbmcgaXQuXG4gICAgICAgICAgICAgICAgcmVmTGFiZWwgPSB0aGlzLnN1YmplY3Quc2xpY2Uob3BlbmVyLmluZGV4LCBzdGFydHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rLCByZXdpbmQgYmVmb3JlIHNwYWNlcyB3ZSBza2lwcGVkLlxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gc2F2ZXBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWZMYWJlbCkge1xuICAgICAgICAgICAgICAgIHJlZkxhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHJlZkxhYmVsKTtcbiAgICAgICAgICAgICAgICAvLyBsb29rdXAgcmF3bGFiZWwgaW4gcmVmTWFwXG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSB0aGlzLnJlZk1hcFtyZWZMYWJlbF07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdCA9IGxpbmsuZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gbGluay50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUkMShpc0ltYWdlID8gJ2ltYWdlJyA6ICdsaW5rJyk7XG4gICAgICAgICAgICBub2RlLmRlc3RpbmF0aW9uID0gZGVzdDtcbiAgICAgICAgICAgIG5vZGUudGl0bGUgPSB0aXRsZSB8fCAnJztcbiAgICAgICAgICAgIG5vZGUuc291cmNlcG9zID0gW29wZW5lci5zdGFydHBvcywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MpXTtcbiAgICAgICAgICAgIHZhciB0bXAgPSBvcGVuZXIubm9kZS5uZXh0O1xuICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAodG1wKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHRtcC5uZXh0O1xuICAgICAgICAgICAgICAgIHRtcC51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAgICAgICAgICAgdG1wID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRW1waGFzaXMob3BlbmVyLnByZXZpb3VzRGVsaW1pdGVyKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpO1xuICAgICAgICAgICAgb3BlbmVyLm5vZGUudW5saW5rKCk7XG4gICAgICAgICAgICAvLyBXZSByZW1vdmUgdGhpcyBicmFja2V0IGFuZCBwcm9jZXNzRW1waGFzaXMgd2lsbCByZW1vdmUgbGF0ZXIgZGVsaW1pdGVycy5cbiAgICAgICAgICAgIC8vIE5vdywgZm9yIGEgbGluaywgd2UgYWxzbyBkZWFjdGl2YXRlIGVhcmxpZXIgbGluayBvcGVuZXJzLlxuICAgICAgICAgICAgLy8gKG5vIGxpbmtzIGluIGxpbmtzKVxuICAgICAgICAgICAgaWYgKCFpc0ltYWdlKSB7XG4gICAgICAgICAgICAgICAgb3BlbmVyID0gdGhpcy5icmFja2V0cztcbiAgICAgICAgICAgICAgICB3aGlsZSAob3BlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3BlbmVyLmltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIuYWN0aXZlID0gZmFsc2U7IC8vIGRlYWN0aXZhdGUgdGhpcyBvcGVuZXJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcGVuZXIgPSBvcGVuZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwW2Jsb2NrLmlkXSA9IHsgbm9kZTogYmxvY2ssIHJlZkxhYmVsOiByZWZMYWJlbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gbm8gbWF0Y2hcbiAgICAgICAgdGhpcy5yZW1vdmVCcmFja2V0KCk7IC8vIHJlbW92ZSB0aGlzIG9wZW5lciBmcm9tIHN0YWNrXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQkMSgnXScsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXBbYmxvY2suaWRdID0geyBub2RlOiBibG9jaywgcmVmTGFiZWw6IHJlZkxhYmVsIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLmFkZEJyYWNrZXQgPSBmdW5jdGlvbiAobm9kZSwgaW5kZXgsIGltYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLmJyYWNrZXRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJyYWNrZXRzLmJyYWNrZXRBZnRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5icmFja2V0cyA9IHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICBzdGFydHBvczogdGhpcy5zb3VyY2Vwb3MoaW5kZXggKyAoaW1hZ2UgPyAwIDogMSkpLFxuICAgICAgICAgICAgcHJldmlvdXM6IHRoaXMuYnJhY2tldHMsXG4gICAgICAgICAgICBwcmV2aW91c0RlbGltaXRlcjogdGhpcy5kZWxpbWl0ZXJzLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5yZW1vdmVCcmFja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5icmFja2V0cykge1xuICAgICAgICAgICAgdGhpcy5icmFja2V0cyA9IHRoaXMuYnJhY2tldHMucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYW4gZW50aXR5LlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRpdHkgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZUVudGl0eUhlcmUpKSkge1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKGxpYi5kZWNvZGVIVE1MKG0pLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBQYXJzZSBhIHJ1biBvZiBvcmRpbmFyeSBjaGFyYWN0ZXJzLCBvciBhIHNpbmdsZSBjaGFyYWN0ZXIgd2l0aFxuICAgIC8vIGEgc3BlY2lhbCBtZWFuaW5nIGluIG1hcmtkb3duLCBhcyBhIHBsYWluIHN0cmluZy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBtO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIGlmICgobSA9IHRoaXMubWF0Y2gocmVNYWluKSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGl0ID0gbS5yZXBsYWNlKHJlRWxsaXBzZXMsICdcXHUyMDI2JykucmVwbGFjZShyZURhc2gsIGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5Db3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJzLmxlbmd0aCAlIDMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzaWJsZSBieSAzLCB1c2UgYWxsIGVtIGRhc2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1Db3VudCA9IGNoYXJzLmxlbmd0aCAvIDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhcnMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNpYmxlIGJ5IDIsIHVzZSBhbGwgZW4gZGFzaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBlbkNvdW50ID0gY2hhcnMubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFycy5sZW5ndGggJSAzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiAyIGV4dHJhIGRhc2hlcywgdXNlIGVuIGRhc2ggZm9yIGxhc3QgMjsgZW0gZGFzaGVzIGZvciByZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBlbkNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtQ291bnQgPSAoY2hhcnMubGVuZ3RoIC0gMikgLyAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGVuIGRhc2hlcyBmb3IgbGFzdCA0IGh5cGhlbnM7IGVtIGRhc2hlcyBmb3IgcmVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5Db3VudCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbUNvdW50ID0gKGNoYXJzLmxlbmd0aCAtIDQpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwZWF0KCdcXHUyMDE0JywgZW1Db3VudCkgKyByZXBlYXQoJ1xcdTIwMTMnLCBlbkNvdW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEobGl0LCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRleHQkMShtLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIGEgbmV3bGluZS4gIElmIGl0IHdhcyBwcmVjZWRlZCBieSB0d28gc3BhY2VzLCByZXR1cm4gYSBoYXJkXG4gICAgLy8gbGluZSBicmVhazsgb3RoZXJ3aXNlIGEgc29mdCBsaW5lIGJyZWFrLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VOZXdsaW5lID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDE7IC8vIGFzc3VtZSB3ZSdyZSBhdCBhIFxcblxuICAgICAgICAvLyBjaGVjayBwcmV2aW91cyBub2RlIGZvciB0cmFpbGluZyBzcGFjZXNcbiAgICAgICAgdmFyIGxhc3RjID0gYmxvY2subGFzdENoaWxkO1xuICAgICAgICBpZiAobGFzdGMgJiYgbGFzdGMudHlwZSA9PT0gJ3RleHQnICYmIGxhc3RjLmxpdGVyYWxbbGFzdGMubGl0ZXJhbC5sZW5ndGggLSAxXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICB2YXIgaGFyZGJyZWFrID0gbGFzdGMubGl0ZXJhbFtsYXN0Yy5saXRlcmFsLmxlbmd0aCAtIDJdID09PSAnICc7XG4gICAgICAgICAgICB2YXIgbGl0TGVuID0gbGFzdGMubGl0ZXJhbC5sZW5ndGg7XG4gICAgICAgICAgICBsYXN0Yy5saXRlcmFsID0gbGFzdGMubGl0ZXJhbC5yZXBsYWNlKHJlRmluYWxTcGFjZSwgJycpO1xuICAgICAgICAgICAgdmFyIGZpbmFsU3BhY2VMZW4gPSBsaXRMZW4gLSBsYXN0Yy5saXRlcmFsLmxlbmd0aDtcbiAgICAgICAgICAgIGxhc3RjLnNvdXJjZXBvc1sxXVsxXSAtPSBmaW5hbFNwYWNlTGVuO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoY3JlYXRlTm9kZSQxKGhhcmRicmVhayA/ICdsaW5lYnJlYWsnIDogJ3NvZnRicmVhaycsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zIC0gZmluYWxTcGFjZUxlbiwgdGhpcy5wb3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChjcmVhdGVOb2RlJDEoJ3NvZnRicmVhaycsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zLCB0aGlzLnBvcykpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgIHRoaXMubWF0Y2gocmVJbml0aWFsU3BhY2UpOyAvLyBnb2JibGUgbGVhZGluZyBzcGFjZXMgaW4gbmV4dCBsaW5lXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBhIGxpbmsgcmVmZXJlbmNlLCBtb2RpZnlpbmcgcmVmbWFwLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VSZWZlcmVuY2UgPSBmdW5jdGlvbiAoYmxvY2ssIHJlZk1hcCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmplY3QgPSBibG9jay5zdHJpbmdDb250ZW50O1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHZhciB0aXRsZSA9IG51bGw7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICAvLyBsYWJlbDpcbiAgICAgICAgdmFyIG1hdGNoQ2hhcnMgPSB0aGlzLnBhcnNlTGlua0xhYmVsKCk7XG4gICAgICAgIGlmIChtYXRjaENoYXJzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmF3bGFiZWwgPSB0aGlzLnN1YmplY3Quc3Vic3RyKDAsIG1hdGNoQ2hhcnMpO1xuICAgICAgICAvLyBjb2xvbjpcbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX0NPTE9OKSB7XG4gICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vICBsaW5rIHVybFxuICAgICAgICB0aGlzLnNwbmwoKTtcbiAgICAgICAgdmFyIGRlc3QgPSB0aGlzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKCk7XG4gICAgICAgIGlmIChkZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZm9yZXRpdGxlID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMuc3BubCgpO1xuICAgICAgICBpZiAodGhpcy5wb3MgIT09IGJlZm9yZXRpdGxlKSB7XG4gICAgICAgICAgICB0aXRsZSA9IHRoaXMucGFyc2VMaW5rVGl0bGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGl0bGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRpdGxlID0gJyc7XG4gICAgICAgICAgICAvLyByZXdpbmQgYmVmb3JlIHNwYWNlc1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBiZWZvcmV0aXRsZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UncmUgYXQgbGluZSBlbmQ6XG4gICAgICAgIHZhciBhdExpbmVFbmQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5tYXRjaChyZVNwYWNlQXRFbmRPZkxpbmUpID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGl0bGUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgYXRMaW5lRW5kID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcG90ZW50aWFsIHRpdGxlIHdlIGZvdW5kIGlzIG5vdCBhdCB0aGUgbGluZSBlbmQsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGl0IGNvdWxkIHN0aWxsIGJlIGEgbGVnYWwgbGluayByZWZlcmVuY2UgaWYgd2VcbiAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIHRoZSB0aXRsZVxuICAgICAgICAgICAgICAgIHRpdGxlID0gJyc7XG4gICAgICAgICAgICAgICAgLy8gcmV3aW5kIGJlZm9yZSBzcGFjZXNcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGJlZm9yZXRpdGxlO1xuICAgICAgICAgICAgICAgIC8vIGFuZCBpbnN0ZWFkIGNoZWNrIGlmIHRoZSBsaW5rIFVSTCBpcyBhdCB0aGUgbGluZSBlbmRcbiAgICAgICAgICAgICAgICBhdExpbmVFbmQgPSB0aGlzLm1hdGNoKHJlU3BhY2VBdEVuZE9mTGluZSkgIT09IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhdExpbmVFbmQpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9ybWFsTGFiZWwgPSBub3JtYWxpemVSZWZlcmVuY2UocmF3bGFiZWwpO1xuICAgICAgICBpZiAobm9ybWFsTGFiZWwgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBsYWJlbCBtdXN0IGNvbnRhaW4gbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2Vwb3MgPSB0aGlzLmdldFJlZmVyZW5jZURlZlNvdXJjZXBvcyhibG9jayk7XG4gICAgICAgIGJsb2NrLnNvdXJjZXBvc1swXVswXSA9IHNvdXJjZXBvc1sxXVswXSArIDE7XG4gICAgICAgIHZhciBub2RlID0gY3JlYXRlTm9kZSQxKCdyZWZEZWYnLCBzb3VyY2Vwb3MpO1xuICAgICAgICBub2RlLnRpdGxlID0gdGl0bGU7XG4gICAgICAgIG5vZGUuZGVzdCA9IGRlc3Q7XG4gICAgICAgIG5vZGUubGFiZWwgPSBub3JtYWxMYWJlbDtcbiAgICAgICAgYmxvY2suaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICBpZiAoIXJlZk1hcFtub3JtYWxMYWJlbF0pIHtcbiAgICAgICAgICAgIHJlZk1hcFtub3JtYWxMYWJlbF0gPSBjcmVhdGVSZWZEZWZTdGF0ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLSBzdGFydHBvcztcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUubWVyZ2VUZXh0Tm9kZXMgPSBmdW5jdGlvbiAod2Fsa2VyKSB7XG4gICAgICAgIHZhciBldmVudDtcbiAgICAgICAgdmFyIHRleHROb2RlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgIHZhciBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nLCBub2RlID0gZXZlbnQubm9kZTtcbiAgICAgICAgICAgIGlmIChlbnRlcmluZyAmJiBub2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRleHROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRleHROb2RlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3ROb2RlID0gdGV4dE5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9kZS5zb3VyY2Vwb3MgJiYgbGFzdE5vZGUuc291cmNlcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5zb3VyY2Vwb3NbMV0gPSBsYXN0Tm9kZS5zb3VyY2Vwb3NbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5uZXh0ID0gbGFzdE5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb2RlLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlLm5leHQucHJldiA9IGZpcnN0Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0ZXh0Tm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlLmxpdGVyYWwgKz0gdGV4dE5vZGVzW2ldLmxpdGVyYWw7XG4gICAgICAgICAgICAgICAgICAgIHRleHROb2Rlc1tpXS51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dE5vZGVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuZ2V0UmVmZXJlbmNlRGVmU291cmNlcG9zID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGJsb2NrLnN0cmluZ0NvbnRlbnQuc3BsaXQoL1xcbnxcXHJcXG4vKTtcbiAgICAgICAgdmFyIHBhc3NlZFVybExpbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHF1b3RhdGlvbkNvdW50ID0gMDtcbiAgICAgICAgdmFyIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiAwLCBjaDogMCB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgaWYgKHJlV2hpdGVzcGFjZUNoYXIudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9cXDovLnRlc3QobGluZSkgJiYgcXVvdGF0aW9uQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFzc2VkVXJsTGluZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSBsaW5lLmluZGV4T2YoJzonKSA9PT0gbGluZS5sZW5ndGggLSAxID8gaSArIDEgOiBpO1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiBsaW5lT2Zmc2V0LCBjaDogbGluZXNbbGluZU9mZnNldF0ubGVuZ3RoIH07XG4gICAgICAgICAgICAgICAgcGFzc2VkVXJsTGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzaG91bGQgY29uc2lkZXIgZXh0ZW5kYWJsZSB0aXRsZVxuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBsaW5lLm1hdGNoKC8nfFwiL2cpO1xuICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBxdW90YXRpb25Db3VudCArPSBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdW90YXRpb25Db3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiBpLCBjaDogbGluZS5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW2Jsb2NrLnNvdXJjZXBvc1swXVswXSwgYmxvY2suc291cmNlcG9zWzBdWzFdXSxcbiAgICAgICAgICAgIFtibG9jay5zb3VyY2Vwb3NbMF1bMF0gKyBsYXN0TGluZU9mZnNldC5saW5lLCBsYXN0TGluZU9mZnNldC5jaF0sXG4gICAgICAgIF07XG4gICAgfTtcbiAgICAvLyBQYXJzZSB0aGUgbmV4dCBpbmxpbmUgZWxlbWVudCBpbiBzdWJqZWN0LCBhZHZhbmNpbmcgc3ViamVjdCBwb3NpdGlvbi5cbiAgICAvLyBPbiBzdWNjZXNzLCBhZGQgdGhlIHJlc3VsdCB0byBibG9jaydzIGNoaWxkcmVuIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAvLyBPbiBmYWlsdXJlLCByZXR1cm4gZmFsc2UuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciByZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGMgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIENfTkVXTElORTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlTmV3bGluZShibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQkFDS1NMQVNIOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VCYWNrc2xhc2goYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0JBQ0tUSUNLOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VCYWNrdGlja3MoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0FTVEVSSVNLOlxuICAgICAgICAgICAgY2FzZSBDX1VOREVSU0NPUkU6XG4gICAgICAgICAgICBjYXNlIENfVElMREU6XG4gICAgICAgICAgICBjYXNlIENfRE9MTEFSOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMuaGFuZGxlRGVsaW0oYywgYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX1NJTkdMRVFVT1RFOlxuICAgICAgICAgICAgY2FzZSBDX0RPVUJMRVFVT1RFOlxuICAgICAgICAgICAgICAgIHJlcyA9ICEhKChfYSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNtYXJ0KSAmJiB0aGlzLmhhbmRsZURlbGltKGMsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19PUEVOX0JSQUNLRVQkMTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlT3BlbkJyYWNrZXQoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0JBTkc6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUJhbmcoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0NMT1NFX0JSQUNLRVQ6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUNsb3NlQnJhY2tldChibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfTEVTU1RIQU4kMTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlQXV0b2xpbmsoYmxvY2spIHx8IHRoaXMucGFyc2VIdG1sVGFnKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19BTVBFUlNBTkQ6XG4gICAgICAgICAgICAgICAgaWYgKCFibG9jay5kaXNhYmxlZEVudGl0eVBhcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VFbnRpdHkoYmxvY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZVN0cmluZyhibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEoZnJvbUNvZGVQb2ludCQxKGMpLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcywgdGhpcy5wb3MgKyAxKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gUGFyc2Ugc3RyaW5nIGNvbnRlbnQgaW4gYmxvY2sgaW50byBpbmxpbmUgY2hpbGRyZW4sXG4gICAgLy8gdXNpbmcgcmVmbWFwIHRvIHJlc29sdmUgcmVmZXJlbmNlcy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQudHJpbSgpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVsaW1pdGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJhY2tldHMgPSBudWxsO1xuICAgICAgICB0aGlzLmxpbmVPZmZzZXRzID0gYmxvY2subGluZU9mZnNldHMgfHwgWzBdO1xuICAgICAgICB0aGlzLmxpbmVJZHggPSAwO1xuICAgICAgICB0aGlzLmxpbmVQb3NPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmxpbmVTdGFydE51bSA9IGJsb2NrLnNvdXJjZXBvc1swXVswXTtcbiAgICAgICAgaWYgKGlzSGVhZGluZyhibG9jaykpIHtcbiAgICAgICAgICAgIHRoaXMubGluZU9mZnNldHNbMF0gKz0gYmxvY2subGV2ZWwgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnBhcnNlSW5saW5lKGJsb2NrKSkgeyB9XG4gICAgICAgIGJsb2NrLnN0cmluZ0NvbnRlbnQgPSBudWxsOyAvLyBhbGxvdyByYXcgc3RyaW5nIHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIHRoaXMucHJvY2Vzc0VtcGhhc2lzKG51bGwpO1xuICAgICAgICB0aGlzLm1lcmdlVGV4dE5vZGVzKGJsb2NrLndhbGtlcigpKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBleHRlbmRlZEF1dG9saW5rcyA9IF9hLmV4dGVuZGVkQXV0b2xpbmtzLCBjdXN0b21QYXJzZXIgPSBfYS5jdXN0b21QYXJzZXI7XG4gICAgICAgIGlmIChleHRlbmRlZEF1dG9saW5rcykge1xuICAgICAgICAgICAgY29udmVydEV4dEF1dG9MaW5rcyhibG9jay53YWxrZXIoKSwgZXh0ZW5kZWRBdXRvbGlua3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXN0b21QYXJzZXIgJiYgYmxvY2suZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzE7XG4gICAgICAgICAgICB2YXIgd2Fsa2VyID0gYmxvY2suZmlyc3RDaGlsZC53YWxrZXIoKTtcbiAgICAgICAgICAgIHdoaWxlICgoZXZlbnRfMSA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBldmVudF8xLm5vZGUsIGVudGVyaW5nID0gZXZlbnRfMS5lbnRlcmluZztcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tUGFyc2VyW25vZGUudHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tUGFyc2VyW25vZGUudHlwZV0obm9kZSwgeyBlbnRlcmluZzogZW50ZXJpbmcsIG9wdGlvbnM6IHRoaXMub3B0aW9ucyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbmxpbmVQYXJzZXI7XG59KCkpO1xuXG52YXIgcmVUYXNrTGlzdEl0ZW1NYXJrZXIgPSAvXlxcWyhbIFxcdHhYXSlcXF1bIFxcdF0rLztcbi8vIGZpbmFsaXplIGZvciBibG9jayBoYW5kbGVyXG5mdW5jdGlvbiB0YXNrTGlzdEl0ZW1GaW5hbGl6ZShfLCBibG9jaykge1xuICAgIGlmIChibG9jay5maXJzdENoaWxkICYmIGJsb2NrLmZpcnN0Q2hpbGQudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgdmFyIHAgPSBibG9jay5maXJzdENoaWxkO1xuICAgICAgICB2YXIgbSA9IHAuc3RyaW5nQ29udGVudC5tYXRjaChyZVRhc2tMaXN0SXRlbU1hcmtlcik7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICB2YXIgbUxlbiA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcC5zdHJpbmdDb250ZW50ID0gcC5zdHJpbmdDb250ZW50LnN1YnN0cmluZyhtTGVuIC0gMSk7XG4gICAgICAgICAgICBwLnNvdXJjZXBvc1swXVsxXSArPSBtTGVuO1xuICAgICAgICAgICAgcC5saW5lT2Zmc2V0c1swXSArPSBtTGVuO1xuICAgICAgICAgICAgYmxvY2subGlzdERhdGEudGFzayA9IHRydWU7XG4gICAgICAgICAgICBibG9jay5saXN0RGF0YS5jaGVja2VkID0gL1t4WF0vLnRlc3QobVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciB0YWJsZSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZUhlYWQnIHx8IHQgPT09ICd0YWJsZUJvZHknO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVCb2R5JDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVSb3cnO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVIZWFkJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZVJvdycgfHwgdCA9PT0gJ3RhYmxlRGVsaW1Sb3cnO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVEZWxpbVJvdyA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ3RhYmxlRGVsaW1DZWxsJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlRGVsaW1DZWxsID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVSb3cgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZUNlbGwnO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgdGFibGVDZWxsID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG5cbnZhciBDT0RFX0lOREVOVCA9IDQ7XG52YXIgQ19UQUIgPSA5O1xudmFyIENfR1JFQVRFUlRIQU4gPSA2MjtcbnZhciBDX0xFU1NUSEFOID0gNjA7XG52YXIgQ19TUEFDRSA9IDMyO1xudmFyIENfT1BFTl9CUkFDS0VUID0gOTE7XG52YXIgcmVOb25TcGFjZSA9IC9bXiBcXHRcXGZcXHZcXHJcXG5dLztcbnZhciByZUNsb3NpbmdDb2RlRmVuY2UgPSAvXig/OmB7Myx9fH57Myx9KSg/PSAqJCkvO1xuLy8gUmV0dXJucyB0cnVlIGlmIGJsb2NrIGVuZHMgd2l0aCBhIGJsYW5rIGxpbmUsIGRlc2NlbmRpbmcgaWYgbmVlZGVkXG4vLyBpbnRvIGxpc3RzIGFuZCBzdWJsaXN0cy5cbmZ1bmN0aW9uIGVuZHNXaXRoQmxhbmtMaW5lKGJsb2NrKSB7XG4gICAgdmFyIGN1ckJsb2NrID0gYmxvY2s7XG4gICAgd2hpbGUgKGN1ckJsb2NrKSB7XG4gICAgICAgIGlmIChjdXJCbG9jay5sYXN0TGluZUJsYW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdCA9IGN1ckJsb2NrLnR5cGU7XG4gICAgICAgIGlmICghY3VyQmxvY2subGFzdExpbmVDaGVja2VkICYmICh0ID09PSAnbGlzdCcgfHwgdCA9PT0gJ2l0ZW0nKSkge1xuICAgICAgICAgICAgY3VyQmxvY2subGFzdExpbmVDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1ckJsb2NrID0gY3VyQmxvY2subGFzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VyQmxvY2subGFzdExpbmVDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBlZWsobG4sIHBvcykge1xuICAgIGlmIChwb3MgPCBsbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGxuLmNoYXJDb2RlQXQocG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLy8gUmV0dXJucyB0cnVlIGlmIHN0cmluZyBjb250YWlucyBvbmx5IHNwYWNlIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiBpc0JsYW5rKHMpIHtcbiAgICByZXR1cm4gIXJlTm9uU3BhY2UudGVzdChzKTtcbn1cbmZ1bmN0aW9uIGlzU3BhY2VPclRhYihjKSB7XG4gICAgcmV0dXJuIGMgPT09IENfU1BBQ0UgfHwgYyA9PT0gQ19UQUI7XG59XG5cbnZhciByZUNsb3NpbmdDdXN0b21CbG9jayA9IC9eXFwkXFwkJC87XG52YXIgY3VzdG9tQmxvY2skMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBsaW5lID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKHJlQ2xvc2luZ0N1c3RvbUJsb2NrKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBjbG9zaW5nIGN1c3RvbSBibG9ja1xuICAgICAgICAgICAgcGFyc2VyLmxhc3RMaW5lTGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgcGFyc2VyLmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIDIgLyogRmluaXNoZWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBvcHRpb25hbCBzcGFjZXMgb2YgY3VzdG9tIGJsb2NrIG9mZnNldFxuICAgICAgICB2YXIgaSA9IGNvbnRhaW5lci5vZmZzZXQ7XG4gICAgICAgIHdoaWxlIChpID4gMCAmJiBpc1NwYWNlT3JUYWIocGVlayhsaW5lLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChfLCBibG9jaykge1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IGxpbmUgYmVjb21lcyBpbmZvIHN0cmluZ1xuICAgICAgICB2YXIgY29udGVudCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgIHZhciBuZXdsaW5lUG9zID0gY29udGVudC5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGNvbnRlbnQuc2xpY2UoMCwgbmV3bGluZVBvcyk7XG4gICAgICAgIHZhciByZXN0ID0gY29udGVudC5zbGljZShuZXdsaW5lUG9zICsgMSk7XG4gICAgICAgIHZhciBpbmZvU3RyaW5nID0gZmlyc3RMaW5lLm1hdGNoKC9eKFxccyopKC4qKS8pO1xuICAgICAgICBibG9jay5pbmZvID0gdW5lc2NhcGVTdHJpbmcoaW5mb1N0cmluZ1syXS50cmltKCkpO1xuICAgICAgICBibG9jay5saXRlcmFsID0gcmVzdDtcbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG5cbnZhciBub29wID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciBkb2N1bWVudCQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCAhPT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgbGlzdCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBibG9jay5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG5vbi1maW5hbCBsaXN0IGl0ZW0gZW5kaW5nIHdpdGggYmxhbmsgbGluZTpcbiAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZShpdGVtKSAmJiBpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICBibG9jay5saXN0RGF0YS50aWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVjdXJzZSBpbnRvIGNoaWxkcmVuIG9mIGxpc3QgaXRlbSwgdG8gc2VlIGlmIHRoZXJlIGFyZVxuICAgICAgICAgICAgLy8gc3BhY2VzIGJldHdlZW4gYW55IG9mIHRoZW06XG4gICAgICAgICAgICB2YXIgc3ViaXRlbSA9IGl0ZW0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChzdWJpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKHN1Yml0ZW0pICYmIChpdGVtLm5leHQgfHwgc3ViaXRlbS5uZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBibG9jay5saXN0RGF0YS50aWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViaXRlbSA9IHN1Yml0ZW0ubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLm5leHQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAnaXRlbSc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciBibG9ja1F1b3RlJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICAgICAgdmFyIGxuID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiBwZWVrKGxuLCBwYXJzZXIubmV4dE5vbnNwYWNlKSA9PT0gQ19HUkVBVEVSVEhBTikge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChpc1NwYWNlT3JUYWIocGVlayhsbiwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCAhPT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgaXRlbSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEJsYW5rIGxpbmUgYWZ0ZXIgZW1wdHkgbGlzdCBpdGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VyLmluZGVudCA+PSBjb250YWluZXIubGlzdERhdGEubWFya2VyT2Zmc2V0ICsgY29udGFpbmVyLmxpc3REYXRhLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KGNvbnRhaW5lci5saXN0RGF0YS5tYXJrZXJPZmZzZXQgKyBjb250YWluZXIubGlzdERhdGEucGFkZGluZywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IHRhc2tMaXN0SXRlbUZpbmFsaXplLFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ICE9PSAnaXRlbSc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciBoZWFkaW5nID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGEgaGVhZGluZyBjYW4gbmV2ZXIgY29udGFpbmVyID4gMSBsaW5lLCBzbyBmYWlsIHRvIG1hdGNoOlxuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRoZW1hdGljQnJlYWskMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhIHRoZW1hdGljIGJyZWFrIGNhbiBuZXZlciBjb250YWluZXIgPiAxIGxpbmUsIHNvIGZhaWwgdG8gbWF0Y2g6XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgY29kZUJsb2NrID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGxuID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgaW5kZW50ID0gcGFyc2VyLmluZGVudDtcbiAgICAgICAgaWYgKGNvbnRhaW5lci5pc0ZlbmNlZCkge1xuICAgICAgICAgICAgLy8gZmVuY2VkXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBpbmRlbnQgPD0gMyAmJlxuICAgICAgICAgICAgICAgIGxuLmNoYXJBdChwYXJzZXIubmV4dE5vbnNwYWNlKSA9PT0gY29udGFpbmVyLmZlbmNlQ2hhciAmJlxuICAgICAgICAgICAgICAgIGxuLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpLm1hdGNoKHJlQ2xvc2luZ0NvZGVGZW5jZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMF0ubGVuZ3RoID49IGNvbnRhaW5lci5mZW5jZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGNsb3NpbmcgZmVuY2UgLSB3ZSdyZSBhdCBlbmQgb2YgbGluZSwgc28gd2UgY2FuIHJldHVyblxuICAgICAgICAgICAgICAgIHBhcnNlci5sYXN0TGluZUxlbmd0aCA9IHBhcnNlci5vZmZzZXQgKyBpbmRlbnQgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgcGFyc2VyLmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIEZpbmlzaGVkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCBvcHRpb25hbCBzcGFjZXMgb2YgZmVuY2Ugb2Zmc2V0XG4gICAgICAgICAgICB2YXIgaSA9IGNvbnRhaW5lci5mZW5jZU9mZnNldDtcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBpc1NwYWNlT3JUYWIocGVlayhsbiwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5kZW50ZWRcbiAgICAgICAgICAgIGlmIChpbmRlbnQgPj0gQ09ERV9JTkRFTlQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChDT0RFX0lOREVOVCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9jay5pc0ZlbmNlZCkge1xuICAgICAgICAgICAgLy8gZmVuY2VkXG4gICAgICAgICAgICAvLyBmaXJzdCBsaW5lIGJlY29tZXMgaW5mbyBzdHJpbmdcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gYmxvY2suc3RyaW5nQ29udGVudDtcbiAgICAgICAgICAgIHZhciBuZXdsaW5lUG9zID0gY29udGVudC5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgICAgIHZhciBmaXJzdExpbmUgPSBjb250ZW50LnNsaWNlKDAsIG5ld2xpbmVQb3MpO1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBjb250ZW50LnNsaWNlKG5ld2xpbmVQb3MgKyAxKTtcbiAgICAgICAgICAgIHZhciBpbmZvU3RyaW5nID0gZmlyc3RMaW5lLm1hdGNoKC9eKFxccyopKC4qKS8pO1xuICAgICAgICAgICAgYmxvY2suaW5mb1BhZGRpbmcgPSBpbmZvU3RyaW5nWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIGJsb2NrLmluZm8gPSB1bmVzY2FwZVN0cmluZyhpbmZvU3RyaW5nWzJdLnRyaW0oKSk7XG4gICAgICAgICAgICBibG9jay5saXRlcmFsID0gcmVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluZGVudGVkXG4gICAgICAgICAgICBibG9jay5saXRlcmFsID0gKF9hID0gYmxvY2suc3RyaW5nQ29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2UoLyhcXG4gKikrJC8sICdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDsgLy8gYWxsb3cgR0NcbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciBodG1sQmxvY2skMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIuYmxhbmsgJiYgKGNvbnRhaW5lci5odG1sQmxvY2tUeXBlID09PSA2IHx8IGNvbnRhaW5lci5odG1sQmxvY2tUeXBlID09PSA3KVxuICAgICAgICAgICAgPyAxIC8qIFN0b3AgKi9cbiAgICAgICAgICAgIDogMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBibG9jay5saXRlcmFsID0gKChfYSA9IGJsb2NrLnN0cmluZ0NvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC8oXFxuICopKyQvLCAnJykpIHx8IG51bGw7XG4gICAgICAgIGJsb2NrLnN0cmluZ0NvbnRlbnQgPSBudWxsOyAvLyBhbGxvdyBHQ1xuICAgIH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IHRydWUsXG59O1xudmFyIHBhcmFncmFwaCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gcGFyc2VyLmJsYW5rID8gMSAvKiBTdG9wICovIDogMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAocGFyc2VyLCBibG9jaykge1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb3M7XG4gICAgICAgIHZhciBoYXNSZWZlcmVuY2VEZWZzID0gZmFsc2U7XG4gICAgICAgIC8vIHRyeSBwYXJzaW5nIHRoZSBiZWdpbm5pbmcgYXMgbGluayByZWZlcmVuY2UgZGVmaW5pdGlvbnM6XG4gICAgICAgIHdoaWxlIChwZWVrKGJsb2NrLnN0cmluZ0NvbnRlbnQsIDApID09PSBDX09QRU5fQlJBQ0tFVCAmJlxuICAgICAgICAgICAgKHBvcyA9IHBhcnNlci5pbmxpbmVQYXJzZXIucGFyc2VSZWZlcmVuY2UoYmxvY2ssIHBhcnNlci5yZWZNYXApKSkge1xuICAgICAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgIGhhc1JlZmVyZW5jZURlZnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2VEZWZzICYmIGlzQmxhbmsoYmxvY2suc3RyaW5nQ29udGVudCkpIHtcbiAgICAgICAgICAgIGJsb2NrLnVubGluaygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgcmVmRGVmID0gbm9vcDtcbnZhciBmcm9udE1hdHRlciQyID0gbm9vcDtcbnZhciBibG9ja0hhbmRsZXJzID0ge1xuICAgIGRvY3VtZW50OiBkb2N1bWVudCQxLFxuICAgIGxpc3Q6IGxpc3QsXG4gICAgYmxvY2tRdW90ZTogYmxvY2tRdW90ZSQxLFxuICAgIGl0ZW06IGl0ZW0sXG4gICAgaGVhZGluZzogaGVhZGluZyxcbiAgICB0aGVtYXRpY0JyZWFrOiB0aGVtYXRpY0JyZWFrJDEsXG4gICAgY29kZUJsb2NrOiBjb2RlQmxvY2ssXG4gICAgaHRtbEJsb2NrOiBodG1sQmxvY2skMSxcbiAgICBwYXJhZ3JhcGg6IHBhcmFncmFwaCxcbiAgICB0YWJsZTogdGFibGUsXG4gICAgdGFibGVCb2R5OiB0YWJsZUJvZHkkMSxcbiAgICB0YWJsZUhlYWQ6IHRhYmxlSGVhZCQxLFxuICAgIHRhYmxlUm93OiB0YWJsZVJvdyxcbiAgICB0YWJsZUNlbGw6IHRhYmxlQ2VsbCxcbiAgICB0YWJsZURlbGltUm93OiB0YWJsZURlbGltUm93LFxuICAgIHRhYmxlRGVsaW1DZWxsOiB0YWJsZURlbGltQ2VsbCxcbiAgICByZWZEZWY6IHJlZkRlZixcbiAgICBjdXN0b21CbG9jazogY3VzdG9tQmxvY2skMSxcbiAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIkMixcbn07XG5cbmZ1bmN0aW9uIHBhcnNlUm93Q29udGVudChjb250ZW50KSB7XG4gICAgdmFyIHN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGNvbnRlbnRbaV0gPT09ICd8JyAmJiBjb250ZW50W2kgLSAxXSAhPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0SWR4LCBpKTtcbiAgICAgICAgICAgIGlmIChzdGFydElkeCA9PT0gMCAmJiBpc0VtcHR5KGNlbGwpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRJZHggPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnRJZHggPCBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICB2YXIgY2VsbCA9IGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0SWR4LCBjb250ZW50Lmxlbmd0aCk7XG4gICAgICAgIGlmICghaXNFbXB0eShjZWxsKSkge1xuICAgICAgICAgICAgY2VsbHMucHVzaChjZWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW29mZnNldCwgY2VsbHNdO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVUYWJsZUNlbGxzKGNlbGxUeXBlLCBjb250ZW50cywgbGluZU51bSwgY2hQb3MpIHtcbiAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvbnRlbnRzXzEgPSBjb250ZW50czsgX2kgPCBjb250ZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29udGVudCA9IGNvbnRlbnRzXzFbX2ldO1xuICAgICAgICB2YXIgcHJlU3BhY2VzID0gY29udGVudC5tYXRjaCgvXlsgXFx0XSsvKTtcbiAgICAgICAgdmFyIHBhZGRpbmdMZWZ0ID0gcHJlU3BhY2VzID8gcHJlU3BhY2VzWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgIHZhciBwYWRkaW5nUmlnaHQgPSB2b2lkIDAsIHRyaW1tZWQgPSB2b2lkIDA7XG4gICAgICAgIGlmIChwYWRkaW5nTGVmdCA9PT0gY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IDA7XG4gICAgICAgICAgICB0cmltbWVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcG9zdFNwYWNlcyA9IGNvbnRlbnQubWF0Y2goL1sgXFx0XSskLyk7XG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBwb3N0U3BhY2VzID8gcG9zdFNwYWNlc1swXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgdHJpbW1lZCA9IGNvbnRlbnQuc2xpY2UocGFkZGluZ0xlZnQsIGNvbnRlbnQubGVuZ3RoIC0gcGFkZGluZ1JpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hQb3NTdGFydCA9IGNoUG9zICsgcGFkZGluZ0xlZnQ7XG4gICAgICAgIHZhciB0YWJsZUNlbGwgPSBjcmVhdGVOb2RlJDEoY2VsbFR5cGUsIFtcbiAgICAgICAgICAgIFtsaW5lTnVtLCBjaFBvc10sXG4gICAgICAgICAgICBbbGluZU51bSwgY2hQb3MgKyBjb250ZW50Lmxlbmd0aCAtIDFdLFxuICAgICAgICBdKTtcbiAgICAgICAgdGFibGVDZWxsLnN0cmluZ0NvbnRlbnQgPSB0cmltbWVkLnJlcGxhY2UoL1xcXFxcXHwvZywgJ3wnKTsgLy8gcmVwbGFjZSBlc2FjcGVkIHBpcGUoXFx8KVxuICAgICAgICB0YWJsZUNlbGwuc3RhcnRJZHggPSBjZWxscy5sZW5ndGg7XG4gICAgICAgIHRhYmxlQ2VsbC5lbmRJZHggPSBjZWxscy5sZW5ndGg7XG4gICAgICAgIHRhYmxlQ2VsbC5saW5lT2Zmc2V0cyA9IFtjaFBvc1N0YXJ0IC0gMV07XG4gICAgICAgIHRhYmxlQ2VsbC5wYWRkaW5nTGVmdCA9IHBhZGRpbmdMZWZ0O1xuICAgICAgICB0YWJsZUNlbGwucGFkZGluZ1JpZ2h0ID0gcGFkZGluZ1JpZ2h0O1xuICAgICAgICBjZWxscy5wdXNoKHRhYmxlQ2VsbCk7XG4gICAgICAgIGNoUG9zICs9IGNvbnRlbnQubGVuZ3RoICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzO1xufVxuZnVuY3Rpb24gZ2V0Q29sdW1uRnJvbURlbGltQ2VsbChjZWxsTm9kZSkge1xuICAgIHZhciBhbGlnbiA9IG51bGw7XG4gICAgdmFyIGNvbnRlbnQgPSBjZWxsTm9kZS5zdHJpbmdDb250ZW50O1xuICAgIHZhciBmaXJzdENoID0gY29udGVudFswXTtcbiAgICB2YXIgbGFzdENoID0gY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2ggPT09ICc6Jykge1xuICAgICAgICBhbGlnbiA9IGZpcnN0Q2ggPT09ICc6JyA/ICdjZW50ZXInIDogJ3JpZ2h0JztcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RDaCA9PT0gJzonKSB7XG4gICAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH1cbiAgICByZXR1cm4geyBhbGlnbjogYWxpZ24gfTtcbn1cbnZhciB0YWJsZUhlYWQgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgc3RyaW5nQ29udGVudCA9IGNvbnRhaW5lci5zdHJpbmdDb250ZW50O1xuICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiYgIXBhcnNlci5pbmRlbnRlZCAmJiAhcGFyc2VyLmJsYW5rKSB7XG4gICAgICAgIHZhciBsYXN0TmV3TGluZUlkeCA9IHN0cmluZ0NvbnRlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGxhc3RMaW5lU3RhcnRJZHggPSBzdHJpbmdDb250ZW50Lmxhc3RJbmRleE9mKCdcXG4nLCBsYXN0TmV3TGluZUlkeCAtIDEpICsgMTtcbiAgICAgICAgdmFyIGhlYWRlckNvbnRlbnQgPSBzdHJpbmdDb250ZW50LnNsaWNlKGxhc3RMaW5lU3RhcnRJZHgsIGxhc3ROZXdMaW5lSWR4KTtcbiAgICAgICAgdmFyIGRlbGltQ29udGVudCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VSb3dDb250ZW50KGhlYWRlckNvbnRlbnQpLCBoZWFkZXJPZmZzZXQgPSBfYVswXSwgaGVhZGVyQ2VsbHMgPSBfYVsxXTtcbiAgICAgICAgdmFyIF9iID0gcGFyc2VSb3dDb250ZW50KGRlbGltQ29udGVudCksIGRlbGltT2Zmc2V0ID0gX2JbMF0sIGRlbGltQ2VsbHMgPSBfYlsxXTtcbiAgICAgICAgdmFyIHJlVmFsaWREZWxpbUNlbGxfMSA9IC9eWyBcXHRdKjo/LSs6P1sgXFx0XSokLztcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgY2hlY2tpbmcgaWYgdGhlIG51bWJlciBvZiBoZWFkZXIgY2VsbHMgYW5kIGRlbGltaXRlciBjZWxscyBhcmUgdGhlIHNhbWVcbiAgICAgICAgLy8gdG8gY29uc2lkZXIgdGhlIGNhc2Ugb2YgbWVyZ2VkLWNvbHVtbiAodmlhIHBsdWdpbilcbiAgICAgICAgIWhlYWRlckNlbGxzLmxlbmd0aCB8fFxuICAgICAgICAgICAgIWRlbGltQ2VsbHMubGVuZ3RoIHx8XG4gICAgICAgICAgICBkZWxpbUNlbGxzLnNvbWUoZnVuY3Rpb24gKGNlbGwpIHsgcmV0dXJuICFyZVZhbGlkRGVsaW1DZWxsXzEudGVzdChjZWxsKTsgfSkgfHxcbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgdG8gcmVnYXJkIHNldFRleHRIZWFkaW5nIGFzIHRhYmVsIGRlbGltIGNlbGwgd2l0aCAnZGlzYWxsb3dEZWVwSGVhZGluZycgb3B0aW9uXG4gICAgICAgICAgICAoZGVsaW1DZWxscy5sZW5ndGggPT09IDEgJiYgZGVsaW1Db250ZW50LmluZGV4T2YoJ3wnKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gY29udGFpbmVyLmxpbmVPZmZzZXRzO1xuICAgICAgICB2YXIgZmlyc3RMaW5lTnVtID0gcGFyc2VyLmxpbmVOdW1iZXIgLSAxO1xuICAgICAgICB2YXIgZmlyc3RMaW5lU3RhcnQgPSBsYXN0KGxpbmVPZmZzZXRzKSArIDE7XG4gICAgICAgIHZhciB0YWJsZSA9IGNyZWF0ZU5vZGUkMSgndGFibGUnLCBbXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydF0sXG4gICAgICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5vZmZzZXRdLFxuICAgICAgICBdKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycm93LWJvZHktc3R5bGVcbiAgICAgICAgdGFibGUuY29sdW1ucyA9IGRlbGltQ2VsbHMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IGFsaWduOiBudWxsIH0pOyB9KTtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEFmdGVyKHRhYmxlKTtcbiAgICAgICAgaWYgKGxpbmVPZmZzZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnVubGluaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgPSBzdHJpbmdDb250ZW50LnNsaWNlKDAsIGxhc3RMaW5lU3RhcnRJZHgpO1xuICAgICAgICAgICAgdmFyIHBhcmFMYXN0TGluZVN0YXJ0SWR4ID0gc3RyaW5nQ29udGVudC5sYXN0SW5kZXhPZignXFxuJywgbGFzdExpbmVTdGFydElkeCAtIDIpICsgMTtcbiAgICAgICAgICAgIHZhciBwYXJhTGFzdExpbmVMZW4gPSBsYXN0TGluZVN0YXJ0SWR4IC0gcGFyYUxhc3RMaW5lU3RhcnRJZHggLSAxO1xuICAgICAgICAgICAgcGFyc2VyLmxhc3RMaW5lTGVuZ3RoID0gbGluZU9mZnNldHNbbGluZU9mZnNldHMubGVuZ3RoIC0gMl0gKyBwYXJhTGFzdExpbmVMZW47XG4gICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBmaXJzdExpbmVOdW0gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoIC0gcGFyc2VyLm9mZnNldCwgZmFsc2UpO1xuICAgICAgICB2YXIgdGFibGVIZWFkXzEgPSBjcmVhdGVOb2RlJDEoJ3RhYmxlSGVhZCcsIFtcbiAgICAgICAgICAgIFtmaXJzdExpbmVOdW0sIGZpcnN0TGluZVN0YXJ0XSxcbiAgICAgICAgICAgIFtwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm9mZnNldF0sXG4gICAgICAgIF0pO1xuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZCh0YWJsZUhlYWRfMSk7XG4gICAgICAgIHZhciB0YWJsZUhlYWRSb3dfMSA9IGNyZWF0ZU5vZGUkMSgndGFibGVSb3cnLCBbXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydF0sXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydCArIGhlYWRlckNvbnRlbnQubGVuZ3RoIC0gMV0sXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgdGFibGVEZWxpbVJvd18xID0gY3JlYXRlTm9kZSQxKCd0YWJsZURlbGltUm93JywgW1xuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgMV0sXG4gICAgICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5vZmZzZXRdLFxuICAgICAgICBdKTtcbiAgICAgICAgdGFibGVIZWFkXzEuYXBwZW5kQ2hpbGQodGFibGVIZWFkUm93XzEpO1xuICAgICAgICB0YWJsZUhlYWRfMS5hcHBlbmRDaGlsZCh0YWJsZURlbGltUm93XzEpO1xuICAgICAgICBnZW5lcmF0ZVRhYmxlQ2VsbHMoJ3RhYmxlQ2VsbCcsIGhlYWRlckNlbGxzLCBmaXJzdExpbmVOdW0sIGZpcnN0TGluZVN0YXJ0ICsgaGVhZGVyT2Zmc2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsTm9kZSkge1xuICAgICAgICAgICAgdGFibGVIZWFkUm93XzEuYXBwZW5kQ2hpbGQoY2VsbE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRlbGltQ2VsbE5vZGVzID0gZ2VuZXJhdGVUYWJsZUNlbGxzKCd0YWJsZURlbGltQ2VsbCcsIGRlbGltQ2VsbHMsIHBhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgMSArIGRlbGltT2Zmc2V0KTtcbiAgICAgICAgZGVsaW1DZWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoY2VsbE5vZGUpIHtcbiAgICAgICAgICAgIHRhYmxlRGVsaW1Sb3dfMS5hcHBlbmRDaGlsZChjZWxsTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0YWJsZS5jb2x1bW5zID0gZGVsaW1DZWxsTm9kZXMubWFwKGdldENvbHVtbkZyb21EZWxpbUNlbGwpO1xuICAgICAgICBwYXJzZXIudGlwID0gdGFibGU7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIHRhYmxlQm9keSA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIGlmICgoY29udGFpbmVyLnR5cGUgIT09ICd0YWJsZScgJiYgY29udGFpbmVyLnR5cGUgIT09ICd0YWJsZUJvZHknKSB8fFxuICAgICAgICAoIXBhcnNlci5ibGFuayAmJiBwYXJzZXIuY3VycmVudExpbmUuaW5kZXhPZignfCcpID09PSAtMSkpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICB9XG4gICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICBpZiAocGFyc2VyLmJsYW5rKSB7XG4gICAgICAgIHZhciB0YWJsZV8xID0gY29udGFpbmVyO1xuICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICd0YWJsZUJvZHknKSB7XG4gICAgICAgICAgICB0YWJsZV8xID0gY29udGFpbmVyLnBhcmVudDtcbiAgICAgICAgICAgIHBhcnNlci5maW5hbGl6ZShjb250YWluZXIsIHBhcnNlci5saW5lTnVtYmVyIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmZpbmFsaXplKHRhYmxlXzEsIHBhcnNlci5saW5lTnVtYmVyIC0gMSk7XG4gICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIHZhciB0YWJsZUJvZHkgPSBjb250YWluZXI7XG4gICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAndGFibGUnKSB7XG4gICAgICAgIHRhYmxlQm9keSA9IHBhcnNlci5hZGRDaGlsZCgndGFibGVCb2R5JywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHRhYmxlQm9keS5zdHJpbmdDb250ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHRhYmxlUm93ID0gY3JlYXRlTm9kZSQxKCd0YWJsZVJvdycsIFtcbiAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgMV0sXG4gICAgICAgIFtwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aF0sXG4gICAgXSk7XG4gICAgdGFibGVCb2R5LmFwcGVuZENoaWxkKHRhYmxlUm93KTtcbiAgICB2YXIgdGFibGUgPSB0YWJsZUJvZHkucGFyZW50O1xuICAgIHZhciBjb250ZW50ID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgIHZhciBfYSA9IHBhcnNlUm93Q29udGVudChjb250ZW50KSwgb2Zmc2V0ID0gX2FbMF0sIGNlbGxDb250ZW50cyA9IF9hWzFdO1xuICAgIGdlbmVyYXRlVGFibGVDZWxscygndGFibGVDZWxsJywgY2VsbENvbnRlbnRzLCBwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm5leHROb25zcGFjZSArIDEgKyBvZmZzZXQpLmZvckVhY2goZnVuY3Rpb24gKGNlbGxOb2RlLCBpZHgpIHtcbiAgICAgICAgaWYgKGlkeCA+PSB0YWJsZS5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgY2VsbE5vZGUuaWdub3JlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGVSb3cuYXBwZW5kQ2hpbGQoY2VsbE5vZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiAyIC8qIExlYWYgKi87XG59O1xuXG52YXIgcmVDdXN0b21CbG9jayA9IC9eKFxcJFxcJCkoXFxzKlthLXpBLVpdKSsvO1xudmFyIHJlQ2FuQmVDdXN0b21JbmxpbmUgPSAvXihcXCRcXCQpKFxccypbYS16QS1aXSkrLiooXFwkXFwkKS87XG52YXIgY3VzdG9tQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgICFyZUNhbkJlQ3VzdG9tSW5saW5lLnRlc3QocGFyc2VyLmN1cnJlbnRMaW5lKSAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUubWF0Y2gocmVDdXN0b21CbG9jaykpKSB7XG4gICAgICAgIHZhciBzeW50YXhMZW5ndGggPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gcGFyc2VyLmFkZENoaWxkKCdjdXN0b21CbG9jaycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBjb250YWluZXIuc3ludGF4TGVuZ3RoID0gc3ludGF4TGVuZ3RoO1xuICAgICAgICBjb250YWluZXIub2Zmc2V0ID0gcGFyc2VyLmluZGVudDtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoc3ludGF4TGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xuXG52YXIgcmVDb2RlRmVuY2UgPSAvXmB7Myx9KD8hLipgKXxefnszLH0vO1xudmFyIHJlSHRtbEJsb2NrT3BlbiA9IFtcbiAgICAvLi8sXG4gICAgL148KD86c2NyaXB0fHByZXxzdHlsZSkoPzpcXHN8PnwkKS9pLFxuICAgIC9ePCEtLS8sXG4gICAgL148Wz9dLyxcbiAgICAvXjwhW0EtWl0vLFxuICAgIC9ePCFcXFtDREFUQVxcWy8sXG4gICAgL148Wy9dPyg/OmFkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9ufGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8Zm9ybXxmcmFtZXxmcmFtZXNldHxoWzEyMzQ1Nl18aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWV8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb258cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyfHRyYWNrfHVsKSg/Olxcc3xbL10/Wz5dfCQpL2ksXG4gICAgbmV3IFJlZ0V4cChcIl4oPzpcIiArIE9QRU5UQUcgKyBcInxcIiArIENMT1NFVEFHICsgXCIpXFxcXHMqJFwiLCAnaScpLFxuXTtcbnZhciByZVNldGV4dEhlYWRpbmdMaW5lID0gL14oPzo9K3wtKylbIFxcdF0qJC87XG52YXIgcmVBVFhIZWFkaW5nTWFya2VyID0gL14jezEsNn0oPzpbIFxcdF0rfCQpLztcbnZhciByZVRoZW1hdGljQnJlYWsgPSAvXig/Oig/OlxcKlsgXFx0XSopezMsfXwoPzpfWyBcXHRdKil7Myx9fCg/Oi1bIFxcdF0qKXszLH0pWyBcXHRdKiQvO1xudmFyIHJlQnVsbGV0TGlzdE1hcmtlciA9IC9eWyorLV0vO1xudmFyIHJlT3JkZXJlZExpc3RNYXJrZXIgPSAvXihcXGR7MSw5fSkoWy4pXSkvO1xuLy8gUGFyc2UgYSBsaXN0IG1hcmtlciBhbmQgcmV0dXJuIGRhdGEgb24gdGhlIG1hcmtlciAodHlwZSxcbi8vIHN0YXJ0LCBkZWxpbWl0ZXIsIGJ1bGxldCBjaGFyYWN0ZXIsIHBhZGRpbmcpIG9yIG51bGwuXG5mdW5jdGlvbiBwYXJzZUxpc3RNYXJrZXIocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgcmVzdCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICB2YXIgbWF0Y2g7XG4gICAgdmFyIG5leHRjO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICB0eXBlOiAnYnVsbGV0JyxcbiAgICAgICAgdGlnaHQ6IHRydWUsXG4gICAgICAgIGJ1bGxldENoYXI6ICcnLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZGVsaW1pdGVyOiAnJyxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgbWFya2VyT2Zmc2V0OiBwYXJzZXIuaW5kZW50LFxuICAgICAgICAvLyBHRk06IFRhc2sgTGlzdCBJdGVtXG4gICAgICAgIHRhc2s6IGZhbHNlLFxuICAgICAgICBjaGVja2VkOiBmYWxzZSxcbiAgICB9O1xuICAgIGlmIChwYXJzZXIuaW5kZW50ID49IDQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSByZXN0Lm1hdGNoKHJlQnVsbGV0TGlzdE1hcmtlcikpKSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICdidWxsZXQnO1xuICAgICAgICBkYXRhLmJ1bGxldENoYXIgPSBtYXRjaFswXVswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG1hdGNoID0gcmVzdC5tYXRjaChyZU9yZGVyZWRMaXN0TWFya2VyKSkgJiZcbiAgICAgICAgKGNvbnRhaW5lci50eXBlICE9PSAncGFyYWdyYXBoJyB8fCBtYXRjaFsxXSA9PT0gJzEnKSkge1xuICAgICAgICBkYXRhLnR5cGUgPSAnb3JkZXJlZCc7XG4gICAgICAgIGRhdGEuc3RhcnQgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICBkYXRhLmRlbGltaXRlciA9IG1hdGNoWzJdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIHNwYWNlcyBhZnRlclxuICAgIG5leHRjID0gcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UgKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgIGlmICghKG5leHRjID09PSAtMSB8fCBuZXh0YyA9PT0gQ19UQUIgfHwgbmV4dGMgPT09IENfU1BBQ0UpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBpZiBpdCBpbnRlcnJ1cHRzIHBhcmFncmFwaCwgbWFrZSBzdXJlIGZpcnN0IGxpbmUgaXNuJ3QgYmxhbmtcbiAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICdwYXJhZ3JhcGgnICYmXG4gICAgICAgICFwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSArIG1hdGNoWzBdLmxlbmd0aCkubWF0Y2gocmVOb25TcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIHdlJ3ZlIGdvdCBhIG1hdGNoISBhZHZhbmNlIG9mZnNldCBhbmQgY2FsY3VsYXRlIHBhZGRpbmdcbiAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpOyAvLyB0byBzdGFydCBvZiBtYXJrZXJcbiAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChtYXRjaFswXS5sZW5ndGgsIHRydWUpOyAvLyB0byBlbmQgb2YgbWFya2VyXG4gICAgdmFyIHNwYWNlc1N0YXJ0Q29sID0gcGFyc2VyLmNvbHVtbjtcbiAgICB2YXIgc3BhY2VzU3RhcnRPZmZzZXQgPSBwYXJzZXIub2Zmc2V0O1xuICAgIGRvIHtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgIG5leHRjID0gcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5vZmZzZXQpO1xuICAgIH0gd2hpbGUgKHBhcnNlci5jb2x1bW4gLSBzcGFjZXNTdGFydENvbCA8IDUgJiYgaXNTcGFjZU9yVGFiKG5leHRjKSk7XG4gICAgdmFyIGJsYW5rSXRlbSA9IHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KSA9PT0gLTE7XG4gICAgdmFyIHNwYWNlc0FmdGVyTWFya2VyID0gcGFyc2VyLmNvbHVtbiAtIHNwYWNlc1N0YXJ0Q29sO1xuICAgIGlmIChzcGFjZXNBZnRlck1hcmtlciA+PSA1IHx8IHNwYWNlc0FmdGVyTWFya2VyIDwgMSB8fCBibGFua0l0ZW0pIHtcbiAgICAgICAgZGF0YS5wYWRkaW5nID0gbWF0Y2hbMF0ubGVuZ3RoICsgMTtcbiAgICAgICAgcGFyc2VyLmNvbHVtbiA9IHNwYWNlc1N0YXJ0Q29sO1xuICAgICAgICBwYXJzZXIub2Zmc2V0ID0gc3BhY2VzU3RhcnRPZmZzZXQ7XG4gICAgICAgIGlmIChpc1NwYWNlT3JUYWIocGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGEucGFkZGluZyA9IG1hdGNoWzBdLmxlbmd0aCArIHNwYWNlc0FmdGVyTWFya2VyO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGxpc3QgaXRlbXMgYXJlIG9mIHRoZSBzYW1lIHR5cGUsXG4vLyB3aXRoIHRoZSBzYW1lIGRlbGltaXRlciBhbmQgYnVsbGV0IGNoYXJhY3Rlci4gIFRoaXMgaXMgdXNlZFxuLy8gaW4gYWdnbG9tZXJhdGluZyBsaXN0IGl0ZW1zIGludG8gbGlzdHMuXG5mdW5jdGlvbiBsaXN0c01hdGNoKGxpc3REYXRhLCBpdGVtRGF0YSkge1xuICAgIHJldHVybiAobGlzdERhdGEudHlwZSA9PT0gaXRlbURhdGEudHlwZSAmJlxuICAgICAgICBsaXN0RGF0YS5kZWxpbWl0ZXIgPT09IGl0ZW1EYXRhLmRlbGltaXRlciAmJlxuICAgICAgICBsaXN0RGF0YS5idWxsZXRDaGFyID09PSBpdGVtRGF0YS5idWxsZXRDaGFyKTtcbn1cbmZ1bmN0aW9uIGlzRGlzYWxsb3dlZERlZXBIZWFkaW5nKHBhcnNlciwgbm9kZSkge1xuICAgIHJldHVybiBwYXJzZXIub3B0aW9ucy5kaXNhbGxvd0RlZXBIZWFkaW5nICYmIChub2RlLnR5cGUgPT09ICdibG9ja1F1b3RlJyB8fCBub2RlLnR5cGUgPT09ICdpdGVtJyk7XG59XG52YXIgYmxvY2tRdW90ZSA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm5leHROb25zcGFjZSkgPT09IENfR1JFQVRFUlRIQU4pIHtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgZmFsc2UpO1xuICAgICAgICAvLyBvcHRpb25hbCBmb2xsb3dpbmcgc3BhY2VcbiAgICAgICAgaWYgKGlzU3BhY2VPclRhYihwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgcGFyc2VyLmFkZENoaWxkKCdibG9ja1F1b3RlJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHJldHVybiAxIC8qIENvbnRhaW5lciAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgYXR4SGVhZGluZyA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICAvLyBUaGUgbmVzdGVkIEhlYWRpbmcgaXMgZGlzYWxsb3dlZCBpbiBsaXN0IGFuZCBibG9ja3F1b3RlIHdpdGggJ2Rpc2FsbG93RGVlcEhlYWRpbmcnIG9wdGlvblxuICAgICAgICAhaXNEaXNhbGxvd2VkRGVlcEhlYWRpbmcocGFyc2VyLCBjb250YWluZXIpICYmXG4gICAgICAgIChtYXRjaCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZUFUWEhlYWRpbmdNYXJrZXIpKSkge1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChtYXRjaFswXS5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHZhciBoZWFkaW5nID0gcGFyc2VyLmFkZENoaWxkKCdoZWFkaW5nJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIGhlYWRpbmcubGV2ZWwgPSBtYXRjaFswXS50cmltKCkubGVuZ3RoOyAvLyBudW1iZXIgb2YgI3NcbiAgICAgICAgaGVhZGluZy5oZWFkaW5nVHlwZSA9ICdhdHgnO1xuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgIyMjczpcbiAgICAgICAgaGVhZGluZy5zdHJpbmdDb250ZW50ID0gcGFyc2VyLmN1cnJlbnRMaW5lXG4gICAgICAgICAgICAuc2xpY2UocGFyc2VyLm9mZnNldClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eWyBcXHRdKiMrWyBcXHRdKiQvLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bIFxcdF0rIytbIFxcdF0qJC8sICcnKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBmZW5jZWRDb2RlQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgIChtYXRjaCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZUNvZGVGZW5jZSkpKSB7XG4gICAgICAgIHZhciBmZW5jZUxlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBwYXJzZXIuYWRkQ2hpbGQoJ2NvZGVCbG9jaycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBjb250YWluZXIuaXNGZW5jZWQgPSB0cnVlO1xuICAgICAgICBjb250YWluZXIuZmVuY2VMZW5ndGggPSBmZW5jZUxlbmd0aDtcbiAgICAgICAgY29udGFpbmVyLmZlbmNlQ2hhciA9IG1hdGNoWzBdWzBdO1xuICAgICAgICBjb250YWluZXIuZmVuY2VPZmZzZXQgPSBwYXJzZXIuaW5kZW50O1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChmZW5jZUxlbmd0aCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBodG1sQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm5leHROb25zcGFjZSkgPT09IENfTEVTU1RIQU4pIHtcbiAgICAgICAgdmFyIHMgPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHZhciBkaXNhbGxvd2VkVGFncyA9IHBhcnNlci5vcHRpb25zLmRpc2FsbG93ZWRIdG1sQmxvY2tUYWdzO1xuICAgICAgICB2YXIgYmxvY2tUeXBlID0gdm9pZCAwO1xuICAgICAgICBmb3IgKGJsb2NrVHlwZSA9IDE7IGJsb2NrVHlwZSA8PSA3OyBibG9ja1R5cGUrKykge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBzLm1hdGNoKHJlSHRtbEJsb2NrT3BlbltibG9ja1R5cGVdKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrVHlwZSA9PT0gNykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNhbGxvd2VkVGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVEaXNhbGxvd2VkVGFncyA9IG5ldyBSZWdFeHAoXCI8Lz8oPzpcIiArIGRpc2FsbG93ZWRUYWdzLmpvaW4oJ3wnKSArIFwiKVwiLCAnaScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlRGlzYWxsb3dlZFRhZ3MudGVzdChtYXRjaGVkWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYWRqdXN0IHBhcnNlci5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgLy8gc3BhY2VzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MIGJsb2NrOlxuICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VyLmFkZENoaWxkKCdodG1sQmxvY2snLCBwYXJzZXIub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBiLmh0bWxCbG9ja1R5cGUgPSBibG9ja1R5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBzZVRleHRIZWFkaW5nID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmIChjb250YWluZXIuc3RyaW5nQ29udGVudCAhPT0gbnVsbCAmJlxuICAgICAgICAhcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgIGNvbnRhaW5lci50eXBlID09PSAncGFyYWdyYXBoJyAmJlxuICAgICAgICAvLyBUaGUgbmVzdGVkIEhlYWRpbmcgaXMgZGlzYWxsb3dlZCBpbiBsaXN0IGFuZCBibG9ja3F1b3RlIHdpdGggJ2Rpc2FsbG93RGVlcEhlYWRpbmcnIG9wdGlvblxuICAgICAgICAhaXNEaXNhbGxvd2VkRGVlcEhlYWRpbmcocGFyc2VyLCBjb250YWluZXIucGFyZW50KSAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkubWF0Y2gocmVTZXRleHRIZWFkaW5nTGluZSkpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAvLyByZXNvbHZlIHJlZmVyZW5jZSBsaW5rIGRlZmluaXRpb25zXG4gICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG4gICAgICAgIHdoaWxlIChwZWVrKGNvbnRhaW5lci5zdHJpbmdDb250ZW50LCAwKSA9PT0gQ19PUEVOX0JSQUNLRVQgJiZcbiAgICAgICAgICAgIChwb3MgPSBwYXJzZXIuaW5saW5lUGFyc2VyLnBhcnNlUmVmZXJlbmNlKGNvbnRhaW5lciwgcGFyc2VyLnJlZk1hcCkpKSB7XG4gICAgICAgICAgICBjb250YWluZXIuc3RyaW5nQ29udGVudCA9IGNvbnRhaW5lci5zdHJpbmdDb250ZW50LnNsaWNlKHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRhaW5lci5zdHJpbmdDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBoZWFkaW5nID0gY3JlYXRlTm9kZSQxKCdoZWFkaW5nJywgY29udGFpbmVyLnNvdXJjZXBvcyk7XG4gICAgICAgICAgICBoZWFkaW5nLmxldmVsID0gbWF0Y2hbMF1bMF0gPT09ICc9JyA/IDEgOiAyO1xuICAgICAgICAgICAgaGVhZGluZy5oZWFkaW5nVHlwZSA9ICdzZXRleHQnO1xuICAgICAgICAgICAgaGVhZGluZy5zdHJpbmdDb250ZW50ID0gY29udGFpbmVyLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QWZ0ZXIoaGVhZGluZyk7XG4gICAgICAgICAgICBjb250YWluZXIudW5saW5rKCk7XG4gICAgICAgICAgICBwYXJzZXIudGlwID0gaGVhZGluZztcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIHRoZW1hdGljQnJlYWsgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiYgcmVUaGVtYXRpY0JyZWFrLnRlc3QocGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpKSkge1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgcGFyc2VyLmFkZENoaWxkKCd0aGVtYXRpY0JyZWFrJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIGxpc3RJdGVtID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIGN1cnJOb2RlID0gY29udGFpbmVyO1xuICAgIGlmICgoIXBhcnNlci5pbmRlbnRlZCB8fCBjb250YWluZXIudHlwZSA9PT0gJ2xpc3QnKSAmJlxuICAgICAgICAoZGF0YSA9IHBhcnNlTGlzdE1hcmtlcihwYXJzZXIsIGN1cnJOb2RlKSkpIHtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIC8vIGFkZCB0aGUgbGlzdCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHBhcnNlci50aXAudHlwZSAhPT0gJ2xpc3QnIHx8ICFsaXN0c01hdGNoKGN1cnJOb2RlLmxpc3REYXRhLCBkYXRhKSkge1xuICAgICAgICAgICAgY3Vyck5vZGUgPSBwYXJzZXIuYWRkQ2hpbGQoJ2xpc3QnLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgICAgIGN1cnJOb2RlLmxpc3REYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIGxpc3QgaXRlbVxuICAgICAgICBjdXJyTm9kZSA9IHBhcnNlci5hZGRDaGlsZCgnaXRlbScsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBjdXJyTm9kZS5saXN0RGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiAxIC8qIENvbnRhaW5lciAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG4vLyBpbmRlbnRlZCBjb2RlIGJsb2NrXG52YXIgaW5kZW50ZWRDb2RlQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgaWYgKHBhcnNlci5pbmRlbnRlZCAmJiBwYXJzZXIudGlwLnR5cGUgIT09ICdwYXJhZ3JhcGgnICYmICFwYXJzZXIuYmxhbmspIHtcbiAgICAgICAgLy8gaW5kZW50ZWQgY29kZVxuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChDT0RFX0lOREVOVCwgdHJ1ZSk7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICBwYXJzZXIuYWRkQ2hpbGQoJ2NvZGVCbG9jaycsIHBhcnNlci5vZmZzZXQpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBibG9ja1N0YXJ0cyA9IFtcbiAgICBibG9ja1F1b3RlLFxuICAgIGF0eEhlYWRpbmcsXG4gICAgZmVuY2VkQ29kZUJsb2NrLFxuICAgIGh0bWxCbG9jayxcbiAgICBzZVRleHRIZWFkaW5nLFxuICAgIHRoZW1hdGljQnJlYWssXG4gICAgbGlzdEl0ZW0sXG4gICAgaW5kZW50ZWRDb2RlQmxvY2ssXG4gICAgdGFibGVIZWFkLFxuICAgIHRhYmxlQm9keSxcbiAgICBjdXN0b21CbG9jayxcbl07XG5cbi8vIGAtLS1gIGZvciBZQU1MLCBgKysrYCBmb3IgVE9NTCwgYDs7O2AgZm9yIEpTT05cbnZhciByZUZyb250TWF0dGVyID0gL14oLXszfXxcXCt7M318O3szfSkkLztcbnZhciBmcm9udE1hdHRlciQxID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIGN1cnJlbnRMaW5lID0gcGFyc2VyLmN1cnJlbnRMaW5lLCBsaW5lTnVtYmVyID0gcGFyc2VyLmxpbmVOdW1iZXIsIGluZGVudGVkID0gcGFyc2VyLmluZGVudGVkO1xuICAgIGlmIChsaW5lTnVtYmVyID09PSAxICYmXG4gICAgICAgICFpbmRlbnRlZCAmJlxuICAgICAgICBjb250YWluZXIudHlwZSA9PT0gJ2RvY3VtZW50JyAmJlxuICAgICAgICByZUZyb250TWF0dGVyLnRlc3QoY3VycmVudExpbmUpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgZnJvbnRNYXR0ZXJfMSA9IHBhcnNlci5hZGRDaGlsZCgnZnJvbnRNYXR0ZXInLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgZnJvbnRNYXR0ZXJfMS5zdHJpbmdDb250ZW50ID0gY3VycmVudExpbmU7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KGN1cnJlbnRMaW5lLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcblxudmFyIGZyb250TWF0dGVyID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBwYXJzZXIuY3VycmVudExpbmU7XG4gICAgICAgIHZhciBtYXRjaCA9IGxpbmUubWF0Y2gocmVGcm9udE1hdHRlcik7XG4gICAgICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ2Zyb250TWF0dGVyJyAmJiBtYXRjaCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgKz0gbGluZTtcbiAgICAgICAgICAgIHBhcnNlci5sYXN0TGluZUxlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcnNlci5maW5hbGl6ZShjb250YWluZXIsIHBhcnNlci5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgIHJldHVybiAyIC8qIEZpbmlzaGVkICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChfLCBibG9jaykge1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrLmxpdGVyYWwgPSBibG9jay5zdHJpbmdDb250ZW50O1xuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDtcbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcblxudmFyIHJlSHRtbEJsb2NrQ2xvc2UgPSBbXG4gICAgLy4vLFxuICAgIC88XFwvKD86c2NyaXB0fHByZXxzdHlsZSk+L2ksXG4gICAgLy0tPi8sXG4gICAgL1xcPz4vLFxuICAgIC8+LyxcbiAgICAvXFxdXFxdPi8sXG5dO1xudmFyIHJlTWF5YmVTcGVjaWFsID0gL15bI2B+KitfPTw+MC05LTskXS87XG52YXIgcmVMaW5lRW5kaW5nJDEgPSAvXFxyXFxufFxcbnxcXHIvO1xuZnVuY3Rpb24gZG9jdW1lbnQkMigpIHtcbiAgICByZXR1cm4gY3JlYXRlTm9kZSQxKCdkb2N1bWVudCcsIFtcbiAgICAgICAgWzEsIDFdLFxuICAgICAgICBbMCwgMF0sXG4gICAgXSk7XG59XG52YXIgZGVmYXVsdE9wdGlvbnMkMSA9IHtcbiAgICBzbWFydDogZmFsc2UsXG4gICAgdGFnRmlsdGVyOiBmYWxzZSxcbiAgICBleHRlbmRlZEF1dG9saW5rczogZmFsc2UsXG4gICAgZGlzYWxsb3dlZEh0bWxCbG9ja1RhZ3M6IFtdLFxuICAgIHJlZmVyZW5jZURlZmluaXRpb246IGZhbHNlLFxuICAgIGRpc2FsbG93RGVlcEhlYWRpbmc6IGZhbHNlLFxuICAgIGN1c3RvbVBhcnNlcjogbnVsbCxcbiAgICBmcm9udE1hdHRlcjogZmFsc2UsXG59O1xudmFyIFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMkMSksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRvYyA9IGRvY3VtZW50JDIoKTtcbiAgICAgICAgdGhpcy50aXAgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5vbGR0aXAgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMubmV4dE5vbnNwYWNlID0gMDtcbiAgICAgICAgdGhpcy5uZXh0Tm9uc3BhY2VDb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLmluZGVudCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUgPSAnJztcbiAgICAgICAgdGhpcy5pbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsYW5rID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbGxDbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RNYXRjaGVkQ29udGFpbmVyID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMucmVmTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5saW5lcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZyb250TWF0dGVyKSB7XG4gICAgICAgICAgICBibG9ja0hhbmRsZXJzLmZyb250TWF0dGVyID0gZnJvbnRNYXR0ZXI7XG4gICAgICAgICAgICBibG9ja1N0YXJ0cy51bnNoaWZ0KGZyb250TWF0dGVyJDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyID0gbmV3IElubGluZVBhcnNlcih0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBQYXJzZXIucHJvdG90eXBlLmFkdmFuY2VPZmZzZXQgPSBmdW5jdGlvbiAoY291bnQsIGNvbHVtbnMpIHtcbiAgICAgICAgaWYgKGNvbHVtbnMgPT09IHZvaWQgMCkgeyBjb2x1bW5zID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gdGhpcy5jdXJyZW50TGluZTtcbiAgICAgICAgdmFyIGNoYXJzVG9UYWIsIGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICB2YXIgYztcbiAgICAgICAgd2hpbGUgKGNvdW50ID4gMCAmJiAoYyA9IGN1cnJlbnRMaW5lW3RoaXMub2Zmc2V0XSkpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIGNoYXJzVG9UYWIgPSA0IC0gKHRoaXMuY29sdW1uICUgNCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGNoYXJzVG9UYWIgPiBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNUb0FkdmFuY2UgPSBjaGFyc1RvVGFiID4gY291bnQgPyBjb3VudCA6IGNoYXJzVG9UYWI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50IC09IGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArPSBjaGFyc1RvVGFiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IDE7IC8vIGFzc3VtZSBhc2NpaTsgYmxvY2sgc3RhcnRzIGFyZSBhc2NpaVxuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuYWR2YW5jZU5leHROb25zcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLm5leHROb25zcGFjZTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSB0aGlzLm5leHROb25zcGFjZUNvbHVtbjtcbiAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5maW5kTmV4dE5vbnNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudExpbmUgPSB0aGlzLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgaSA9IHRoaXMub2Zmc2V0O1xuICAgICAgICB2YXIgY29scyA9IHRoaXMuY29sdW1uO1xuICAgICAgICB2YXIgYztcbiAgICAgICAgd2hpbGUgKChjID0gY3VycmVudExpbmUuY2hhckF0KGkpKSAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29scysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29scyArPSA0IC0gKGNvbHMgJSA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmxhbmsgPSBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJyB8fCBjID09PSAnJztcbiAgICAgICAgdGhpcy5uZXh0Tm9uc3BhY2UgPSBpO1xuICAgICAgICB0aGlzLm5leHROb25zcGFjZUNvbHVtbiA9IGNvbHM7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gdGhpcy5uZXh0Tm9uc3BhY2VDb2x1bW4gLSB0aGlzLmNvbHVtbjtcbiAgICAgICAgdGhpcy5pbmRlbnRlZCA9IHRoaXMuaW5kZW50ID49IENPREVfSU5ERU5UO1xuICAgIH07XG4gICAgLy8gQWRkIGEgbGluZSB0byB0aGUgYmxvY2sgYXQgdGhlIHRpcC4gIFdlIGFzc3VtZSB0aGUgdGlwXG4gICAgLy8gY2FuIGFjY2VwdCBsaW5lcyAtLSB0aGF0IGNoZWNrIHNob3VsZCBiZSBkb25lIGJlZm9yZSBjYWxsaW5nIHRoaXMuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5hZGRMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYikge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMTsgLy8gc2tpcCBvdmVyIHRhYlxuICAgICAgICAgICAgLy8gYWRkIHNwYWNlIGNoYXJhY3RlcnM6XG4gICAgICAgICAgICB2YXIgY2hhcnNUb1RhYiA9IDQgLSAodGhpcy5jb2x1bW4gJSA0KTtcbiAgICAgICAgICAgIHRoaXMudGlwLnN0cmluZ0NvbnRlbnQgKz0gcmVwZWF0KCcgJywgY2hhcnNUb1RhYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGlwLmxpbmVPZmZzZXRzKSB7XG4gICAgICAgICAgICB0aGlzLnRpcC5saW5lT2Zmc2V0cy5wdXNoKHRoaXMub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGlwLmxpbmVPZmZzZXRzID0gW3RoaXMub2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpcC5zdHJpbmdDb250ZW50ICs9IHRoaXMuY3VycmVudExpbmUuc2xpY2UodGhpcy5vZmZzZXQpICsgXCJcXG5cIjtcbiAgICB9O1xuICAgIC8vIEFkZCBibG9jayBvZiB0eXBlIHRhZyBhcyBhIGNoaWxkIG9mIHRoZSB0aXAuICBJZiB0aGUgdGlwIGNhbid0XG4gICAgLy8gYWNjZXB0IGNoaWxkcmVuLCBjbG9zZSBhbmQgZmluYWxpemUgaXQgYW5kIHRyeSBpdHMgcGFyZW50LFxuICAgIC8vIGFuZCBzbyBvbiB0aWwgd2UgZmluZCBhIGJsb2NrIHRoYXQgY2FuIGFjY2VwdCBjaGlsZHJlbi5cbiAgICBQYXJzZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKHRhZywgb2Zmc2V0KSB7XG4gICAgICAgIHdoaWxlICghYmxvY2tIYW5kbGVyc1t0aGlzLnRpcC50eXBlXS5jYW5Db250YWluKHRhZykpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemUodGhpcy50aXAsIHRoaXMubGluZU51bWJlciAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBvZmZzZXQgKyAxOyAvLyBvZmZzZXQgMCA9IGNvbHVtbiAxXG4gICAgICAgIHZhciBuZXdCbG9jayA9IGNyZWF0ZU5vZGUkMSh0YWcsIFtcbiAgICAgICAgICAgIFt0aGlzLmxpbmVOdW1iZXIsIGNvbHVtbk51bWJlcl0sXG4gICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgIF0pO1xuICAgICAgICBuZXdCbG9jay5zdHJpbmdDb250ZW50ID0gJyc7XG4gICAgICAgIHRoaXMudGlwLmFwcGVuZENoaWxkKG5ld0Jsb2NrKTtcbiAgICAgICAgdGhpcy50aXAgPSBuZXdCbG9jaztcbiAgICAgICAgcmV0dXJuIG5ld0Jsb2NrO1xuICAgIH07XG4gICAgLy8gRmluYWxpemUgYW5kIGNsb3NlIGFueSB1bm1hdGNoZWQgYmxvY2tzLlxuICAgIFBhcnNlci5wcm90b3R5cGUuY2xvc2VVbm1hdGNoZWRCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxDbG9zZWQpIHtcbiAgICAgICAgICAgIC8vIGZpbmFsaXplIGFueSBibG9ja3Mgbm90IG1hdGNoZWRcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLm9sZHRpcCAhPT0gdGhpcy5sYXN0TWF0Y2hlZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMub2xkdGlwLnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKHRoaXMub2xkdGlwLCB0aGlzLmxpbmVOdW1iZXIgLSAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9sZHRpcCA9IHBhcmVudF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbGxDbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBGaW5hbGl6ZSBhIGJsb2NrLiAgQ2xvc2UgaXQgYW5kIGRvIGFueSBuZWNlc3NhcnkgcG9zdHByb2Nlc3NpbmcsXG4gICAgLy8gZS5nLiBjcmVhdGluZyBzdHJpbmdDb250ZW50IGZyb20gc3RyaW5ncywgc2V0dGluZyB0aGUgJ3RpZ2h0J1xuICAgIC8vIG9yICdsb29zZScgc3RhdHVzIG9mIGEgbGlzdCwgYW5kIHBhcnNpbmcgdGhlIGJlZ2lubmluZ3NcbiAgICAvLyBvZiBwYXJhZ3JhcGhzIGZvciByZWZlcmVuY2UgZGVmaW5pdGlvbnMuICBSZXNldCB0aGUgdGlwIHRvIHRoZVxuICAgIC8vIHBhcmVudCBvZiB0aGUgY2xvc2VkIGJsb2NrLlxuICAgIFBhcnNlci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoYmxvY2ssIGxpbmVOdW1iZXIpIHtcbiAgICAgICAgdmFyIGFib3ZlID0gYmxvY2sucGFyZW50O1xuICAgICAgICBibG9jay5vcGVuID0gZmFsc2U7XG4gICAgICAgIGJsb2NrLnNvdXJjZXBvc1sxXSA9IFtsaW5lTnVtYmVyLCB0aGlzLmxhc3RMaW5lTGVuZ3RoXTtcbiAgICAgICAgYmxvY2tIYW5kbGVyc1tibG9jay50eXBlXS5maW5hbGl6ZSh0aGlzLCBibG9jayk7XG4gICAgICAgIHRoaXMudGlwID0gYWJvdmU7XG4gICAgfTtcbiAgICAvLyBXYWxrIHRocm91Z2ggYSBibG9jayAmIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LCBwYXJzaW5nIHN0cmluZyBjb250ZW50XG4gICAgLy8gaW50byBpbmxpbmUgY29udGVudCB3aGVyZSBhcHByb3ByaWF0ZS5cbiAgICBQYXJzZXIucHJvdG90eXBlLnByb2Nlc3NJbmxpbmVzID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBldmVudDtcbiAgICAgICAgdmFyIGN1c3RvbVBhcnNlciA9IHRoaXMub3B0aW9ucy5jdXN0b21QYXJzZXI7XG4gICAgICAgIHZhciB3YWxrZXIgPSBibG9jay53YWxrZXIoKTtcbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIucmVmTWFwID0gdGhpcy5yZWZNYXA7XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXA7XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyLnJlZkRlZkNhbmRpZGF0ZU1hcCA9IHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwO1xuICAgICAgICB0aGlzLmlubGluZVBhcnNlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgICAgIHZhciB0ID0gbm9kZS50eXBlO1xuICAgICAgICAgICAgaWYgKGN1c3RvbVBhcnNlciAmJiBjdXN0b21QYXJzZXJbdF0pIHtcbiAgICAgICAgICAgICAgICBjdXN0b21QYXJzZXJbdF0obm9kZSwgeyBlbnRlcmluZzogZW50ZXJpbmcsIG9wdGlvbnM6IHRoaXMub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZW50ZXJpbmcgJiZcbiAgICAgICAgICAgICAgICAodCA9PT0gJ3BhcmFncmFwaCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdCA9PT0gJ2hlYWRpbmcnIHx8XG4gICAgICAgICAgICAgICAgICAgICh0ID09PSAndGFibGVDZWxsJyAmJiAhbm9kZS5pZ25vcmVkKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubGluZVBhcnNlci5wYXJzZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQW5hbHl6ZSBhIGxpbmUgb2YgdGV4dCBhbmQgdXBkYXRlIHRoZSBkb2N1bWVudCBhcHByb3ByaWF0ZWx5LlxuICAgIC8vIFdlIHBhcnNlIG1hcmtkb3duIHRleHQgYnkgY2FsbGluZyB0aGlzIG9uIGVhY2ggbGluZSBvZiBpbnB1dCxcbiAgICAvLyB0aGVuIGZpbmFsaXppbmcgdGhlIGRvY3VtZW50LlxuICAgIFBhcnNlci5wcm90b3R5cGUuaW5jb3Jwb3JhdGVMaW5lID0gZnVuY3Rpb24gKGxuKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5vbGR0aXAgPSB0aGlzLnRpcDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMuYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgKz0gMTtcbiAgICAgICAgLy8gcmVwbGFjZSBOVUwgY2hhcmFjdGVycyBmb3Igc2VjdXJpdHlcbiAgICAgICAgaWYgKGxuLmluZGV4T2YoJ1xcdTAwMDAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxuID0gbG4ucmVwbGFjZSgvXFwwL2csICdcXHVGRkZEJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9IGxuO1xuICAgICAgICAvLyBGb3IgZWFjaCBjb250YWluaW5nIGJsb2NrLCB0cnkgdG8gcGFyc2UgdGhlIGFzc29jaWF0ZWQgbGluZSBzdGFydC5cbiAgICAgICAgLy8gQmFpbCBvdXQgb24gZmFpbHVyZTogY29udGFpbmVyIHdpbGwgcG9pbnQgdG8gdGhlIGxhc3QgbWF0Y2hpbmcgYmxvY2suXG4gICAgICAgIC8vIFNldCBhbGxNYXRjaGVkIHRvIGZhbHNlIGlmIG5vdCBhbGwgY29udGFpbmVycyBtYXRjaC5cbiAgICAgICAgdmFyIGFsbE1hdGNoZWQgPSB0cnVlO1xuICAgICAgICB2YXIgbGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAoKGxhc3RDaGlsZCA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpICYmIGxhc3RDaGlsZC5vcGVuKSB7XG4gICAgICAgICAgICBjb250YWluZXIgPSBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmZpbmROZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoYmxvY2tIYW5kbGVyc1tjb250YWluZXIudHlwZV1bJ2NvbnRpbnVlJ10odGhpcywgY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBHbyAqLzogLy8gd2UndmUgbWF0Y2hlZCwga2VlcCBnb2luZ1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogU3RvcCAqLzogLy8gd2UndmUgZmFpbGVkIHRvIG1hdGNoIGEgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgYWxsTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogRmluaXNoZWQgKi86IC8vIHdlJ3ZlIGhpdCBlbmQgb2YgbGluZSBmb3IgZmVuY2VkIGNvZGUgY2xvc2UgYW5kIGNhbiByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IGxuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udGludWUgcmV0dXJuZWQgaWxsZWdhbCB2YWx1ZSwgbXVzdCBiZSAwLCAxLCBvciAyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbE1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIucGFyZW50OyAvLyBiYWNrIHVwIHRvIGxhc3QgbWF0Y2hpbmcgYmxvY2tcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbENsb3NlZCA9IGNvbnRhaW5lciA9PT0gdGhpcy5vbGR0aXA7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHZhciBtYXRjaGVkTGVhZiA9IGNvbnRhaW5lci50eXBlICE9PSAncGFyYWdyYXBoJyAmJiBibG9ja0hhbmRsZXJzW2NvbnRhaW5lci50eXBlXS5hY2NlcHRzTGluZXM7XG4gICAgICAgIHZhciBibG9ja1N0YXJ0c0xlbiA9IGJsb2NrU3RhcnRzLmxlbmd0aDtcbiAgICAgICAgLy8gVW5sZXNzIGxhc3QgbWF0Y2hlZCBjb250YWluZXIgaXMgYSBjb2RlIGJsb2NrLCB0cnkgbmV3IGNvbnRhaW5lciBzdGFydHMsXG4gICAgICAgIC8vIGFkZGluZyBjaGlsZHJlbiB0byB0aGUgbGFzdCBtYXRjaGVkIGNvbnRhaW5lcjpcbiAgICAgICAgd2hpbGUgKCFtYXRjaGVkTGVhZikge1xuICAgICAgICAgICAgdGhpcy5maW5kTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgbGl0dGxlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjpcbiAgICAgICAgICAgIGlmIChjb250YWluZXIudHlwZSAhPT0gJ3RhYmxlJyAmJlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci50eXBlICE9PSAndGFibGVCb2R5JyAmJlxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci50eXBlICE9PSAncGFyYWdyYXBoJyAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmluZGVudGVkICYmXG4gICAgICAgICAgICAgICAgIXJlTWF5YmVTcGVjaWFsLnRlc3QobG4uc2xpY2UodGhpcy5uZXh0Tm9uc3BhY2UpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBibG9ja1N0YXJ0c0xlbikge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBibG9ja1N0YXJ0c1tpXSh0aGlzLCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgPT09IDEgLyogQ29udGFpbmVyICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMudGlwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzID09PSAyIC8qIExlYWYgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy50aXA7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRMZWFmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IGJsb2NrU3RhcnRzTGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZyBtYXRjaGVkXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hhdCByZW1haW5zIGF0IHRoZSBvZmZzZXQgaXMgYSB0ZXh0IGxpbmUuICBBZGQgdGhlIHRleHQgdG8gdGhlXG4gICAgICAgIC8vIGFwcHJvcHJpYXRlIGNvbnRhaW5lci5cbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgZm9yIGEgbGF6eSBwYXJhZ3JhcGggY29udGludWF0aW9uOlxuICAgICAgICBpZiAoIXRoaXMuYWxsQ2xvc2VkICYmICF0aGlzLmJsYW5rICYmIHRoaXMudGlwLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAvLyBsYXp5IHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgICAgICAgICAgIHRoaXMuYWRkTGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm90IGEgbGF6eSBjb250aW51YXRpb25cbiAgICAgICAgICAgIC8vIGZpbmFsaXplIGFueSBibG9ja3Mgbm90IG1hdGNoZWRcbiAgICAgICAgICAgIHRoaXMuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJsYW5rICYmIGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIubGFzdENoaWxkLmxhc3RMaW5lQmxhbmsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQgPSBjb250YWluZXIudHlwZTtcbiAgICAgICAgICAgIC8vIEJsb2NrIHF1b3RlIGxpbmVzIGFyZSBuZXZlciBibGFuayBhcyB0aGV5IHN0YXJ0IHdpdGggPlxuICAgICAgICAgICAgLy8gYW5kIHdlIGRvbid0IGNvdW50IGJsYW5rcyBpbiBmZW5jZWQgY29kZSBmb3IgcHVycG9zZXMgb2YgdGlnaHQvbG9vc2VcbiAgICAgICAgICAgIC8vIGxpc3RzIG9yIGJyZWFraW5nIG91dCBvZiBsaXN0cy4gV2UgYWxzbyBkb24ndCBzZXQgX2xhc3RMaW5lQmxhbmtcbiAgICAgICAgICAgIC8vIG9uIGFuIGVtcHR5IGxpc3QgaXRlbSwgb3IgaWYgd2UganVzdCBjbG9zZWQgYSBmZW5jZWQgYmxvY2suXG4gICAgICAgICAgICB2YXIgbGFzdExpbmVCbGFuayA9IHRoaXMuYmxhbmsgJiZcbiAgICAgICAgICAgICAgICAhKHQgPT09ICdibG9ja1F1b3RlJyB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNDb2RlQmxvY2soY29udGFpbmVyKSAmJiBjb250YWluZXIuaXNGZW5jZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0ID09PSAnaXRlbScgJiYgIWNvbnRhaW5lci5maXJzdENoaWxkICYmIGNvbnRhaW5lci5zb3VyY2Vwb3NbMF1bMF0gPT09IHRoaXMubGluZU51bWJlcikpO1xuICAgICAgICAgICAgLy8gcHJvcGFnYXRlIGxhc3RMaW5lQmxhbmsgdXAgdGhyb3VnaCBwYXJlbnRzOlxuICAgICAgICAgICAgdmFyIGNvbnQgPSBjb250YWluZXI7XG4gICAgICAgICAgICB3aGlsZSAoY29udCkge1xuICAgICAgICAgICAgICAgIGNvbnQubGFzdExpbmVCbGFuayA9IGxhc3RMaW5lQmxhbms7XG4gICAgICAgICAgICAgICAgY29udCA9IGNvbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFuZGxlcnNbdF0uYWNjZXB0c0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaW5lKCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgSHRtbEJsb2NrLCBjaGVjayBmb3IgZW5kIGNvbmRpdGlvblxuICAgICAgICAgICAgICAgIGlmIChpc0h0bWxCbG9jayhjb250YWluZXIpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5odG1sQmxvY2tUeXBlID49IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmh0bWxCbG9ja1R5cGUgPD0gNSAmJlxuICAgICAgICAgICAgICAgICAgICByZUh0bWxCbG9ja0Nsb3NlW2NvbnRhaW5lci5odG1sQmxvY2tUeXBlXS50ZXN0KHRoaXMuY3VycmVudExpbmUuc2xpY2UodGhpcy5vZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gbG4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKGNvbnRhaW5lciwgdGhpcy5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9mZnNldCA8IGxuLmxlbmd0aCAmJiAhdGhpcy5ibGFuaykge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBwYXJhZ3JhcGggY29udGFpbmVyIGZvciBsaW5lXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5hZGRDaGlsZCgncGFyYWdyYXBoJywgdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSBsbi5sZW5ndGg7XG4gICAgfTtcbiAgICAvLyBUaGUgbWFpbiBwYXJzaW5nIGZ1bmN0aW9uLiAgUmV0dXJucyBhIHBhcnNlZCBkb2N1bWVudCBBU1QuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChpbnB1dCwgbGluZVRleHRzKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jdW1lbnQkMigpO1xuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSAwO1xuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9ICcnO1xuICAgICAgICB2YXIgbGluZXMgPSBpbnB1dC5zcGxpdChyZUxpbmVFbmRpbmckMSk7XG4gICAgICAgIHZhciBsZW4gPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lVGV4dHMgPyBsaW5lVGV4dHMgOiBsaW5lcztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyUmVmTWFwcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpID09PSBDX05FV0xJTkUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBsYXN0IGJsYW5rIGxpbmUgY3JlYXRlZCBieSBmaW5hbCBuZXdsaW5lXG4gICAgICAgICAgICBsZW4gLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluY29ycG9yYXRlTGluZShsaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMudGlwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplKHRoaXMudGlwLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc0lubGluZXModGhpcy5kb2MpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2M7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnRpYWxQYXJzZVN0YXJ0ID0gZnVuY3Rpb24gKGxpbmVOdW1iZXIsIGxpbmVzKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jdW1lbnQkMigpO1xuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyIC0gMTtcbiAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLmxhc3RNYXRjaGVkQ29udGFpbmVyID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUgPSAnJztcbiAgICAgICAgdmFyIGxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pbmNvcnBvcmF0ZUxpbmUobGluZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRvYztcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFydGlhbFBhcnNlRXh0ZW5kcyA9IGZ1bmN0aW9uIChsaW5lcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluY29ycG9yYXRlTGluZShsaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFydGlhbFBhcnNlRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy50aXApIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemUodGhpcy50aXAsIHRoaXMubGluZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzSW5saW5lcyh0aGlzLmRvYyk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnNldFJlZk1hcHMgPSBmdW5jdGlvbiAocmVmTWFwLCByZWZMaW5rQ2FuZGlkYXRlTWFwLCByZWZEZWZDYW5kaWRhdGVNYXApIHtcbiAgICAgICAgdGhpcy5yZWZNYXAgPSByZWZNYXA7XG4gICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCA9IHJlZkxpbmtDYW5kaWRhdGVNYXA7XG4gICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwID0gcmVmRGVmQ2FuZGlkYXRlTWFwO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5jbGVhclJlZk1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFt0aGlzLnJlZk1hcCwgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwLCB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcF0uZm9yRWFjaChmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBjbGVhck9iaihtYXApO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXI7XG59KCkpO1xuXG5mdW5jdGlvbiBjb21wYXJlUG9zKHAxLCBwMikge1xuICAgIGlmIChwMVswXSA8IHAyWzBdKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAocDFbMF0gPiBwMlswXSkge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIGlmIChwMVsxXSA8IHAyWzFdKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAocDFbMV0gPiBwMlsxXSkge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIEVRICovO1xufVxuZnVuY3Rpb24gY29tcGFyZVJhbmdlQW5kUG9zKF9hLCBwb3MpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBfYVswXSwgZW5kUG9zID0gX2FbMV07XG4gICAgaWYgKGNvbXBhcmVQb3MoZW5kUG9zLCBwb3MpID09PSAxIC8qIExUICovKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZVBvcyhzdGFydFBvcywgcG9zKSA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgcmV0dXJuIC0xIC8qIEdUICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBFUSAqLztcbn1cbmZ1bmN0aW9uIHJlbW92ZU5leHRVbnRpbChub2RlLCBsYXN0KSB7XG4gICAgaWYgKG5vZGUucGFyZW50ICE9PSBsYXN0LnBhcmVudCB8fCBub2RlID09PSBsYXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBub2RlLm5leHQ7XG4gICAgd2hpbGUgKG5leHQgJiYgbmV4dCAhPT0gbGFzdCkge1xuICAgICAgICB2YXIgdGVtcCA9IG5leHQubmV4dDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFsncGFyZW50JywgJ3ByZXYnLCAnbmV4dCddOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAobmV4dFt0eXBlXSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGVCeUlkKG5leHRbdHlwZV0uaWQpO1xuICAgICAgICAgICAgICAgIG5leHRbdHlwZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQgPSB0ZW1wO1xuICAgIH1cbiAgICBub2RlLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgaWYgKGxhc3QubmV4dCkge1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLnBhcmVudC5sYXN0Q2hpbGQgPSBub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkTm9kZXMocGFyZW50KSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIGN1cnIgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY3Vycikge1xuICAgICAgICBub2Rlcy5wdXNoKGN1cnIpO1xuICAgICAgICBjdXJyID0gY3Vyci5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBpbnNlcnROb2Rlc0JlZm9yZSh0YXJnZXQsIG5vZGVzKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBub2Rlc18xID0gbm9kZXM7IF9pIDwgbm9kZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc18xW19pXTtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVwZW5kQ2hpbGROb2RlcyhwYXJlbnQsIG5vZGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHBhcmVudC5wcmVwZW5kQ2hpbGQobm9kZXNbaV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZU5leHRMaW5lTnVtYmVycyhiYXNlLCBkaWZmKSB7XG4gICAgaWYgKCFiYXNlIHx8ICFiYXNlLnBhcmVudCB8fCBkaWZmID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHdhbGtlciA9IGJhc2UucGFyZW50LndhbGtlcigpO1xuICAgIHdhbGtlci5yZXN1bWVBdChiYXNlLCB0cnVlKTtcbiAgICB2YXIgZXZlbnQ7XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBub2RlLnNvdXJjZXBvc1swXVswXSArPSBkaWZmO1xuICAgICAgICAgICAgbm9kZS5zb3VyY2Vwb3NbMV1bMF0gKz0gZGlmZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZUFuZExpbmUoX2EsIGxpbmUpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBfYVswXSwgZW5kUG9zID0gX2FbMV07XG4gICAgaWYgKGVuZFBvc1swXSA8IGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogTFQgKi87XG4gICAgfVxuICAgIGlmIChzdGFydFBvc1swXSA+IGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIC0xIC8qIEdUICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBFUSAqLztcbn1cbmZ1bmN0aW9uIGZpbmRDaGlsZE5vZGVBdExpbmUocGFyZW50LCBsaW5lKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmVSYW5nZUFuZExpbmUobm9kZS5zb3VyY2Vwb3MsIGxpbmUpO1xuICAgICAgICBpZiAoY29tcCA9PT0gMCAvKiBFUSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAgPT09IC0xIC8qIEdUICovKSB7XG4gICAgICAgICAgICAvLyBUbyBjb25zaWRlciB0aGF0IHRvcCBsaW5lIGlzIGJsYW5rIGxpbmVcbiAgICAgICAgICAgIHJldHVybiBub2RlLnByZXYgfHwgbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Lmxhc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIGxhc3RMZWFmTm9kZShub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzYW1lTGluZVRvcEFuY2VzdG9yKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5wYXJlbnQgJiZcbiAgICAgICAgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2RvY3VtZW50JyAmJlxuICAgICAgICBub2RlLnBhcmVudC5zb3VyY2Vwb3NbMF1bMF0gPT09IG5vZGUuc291cmNlcG9zWzBdWzBdKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmaW5kRmlyc3ROb2RlQXRMaW5lKHBhcmVudCwgbGluZSkge1xuICAgIHZhciBub2RlID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHByZXYgPSBudWxsO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciBjb21wID0gY29tcGFyZVJhbmdlQW5kTGluZShub2RlLnNvdXJjZXBvcywgbGluZSk7XG4gICAgICAgIGlmIChjb21wID09PSAwIC8qIEVRICovKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5zb3VyY2Vwb3NbMF1bMF0gPT09IGxpbmUgfHwgIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXAgPT09IC0xIC8qIEdUICovKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldikge1xuICAgICAgICByZXR1cm4gc2FtZUxpbmVUb3BBbmNlc3RvcihsYXN0TGVhZk5vZGUocHJldikpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlQXRQb3NpdGlvbihwYXJlbnQsIHBvcykge1xuICAgIHZhciBub2RlID0gcGFyZW50O1xuICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmVSYW5nZUFuZFBvcyhub2RlLnNvdXJjZXBvcywgcG9zKTtcbiAgICAgICAgaWYgKGNvbXAgPT09IDAgLyogRVEgKi8pIHtcbiAgICAgICAgICAgIGlmIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcCA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubmV4dCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZmluZE5vZGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGdldE5vZGVCeUlkKGlkKSB8fCBudWxsO1xufVxuZnVuY3Rpb24gaW52b2tlTmV4dFVudGlsKGNhbGxiYWNrLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IG51bGw7IH1cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIHdhbGtlciA9IHN0YXJ0LndhbGtlcigpO1xuICAgICAgICB3aGlsZSAoc3RhcnQgJiYgc3RhcnQgIT09IGVuZCkge1xuICAgICAgICAgICAgY2FsbGJhY2soc3RhcnQpO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IG5leHQubm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNVbmxpbmtlZChpZCkge1xuICAgIHZhciBub2RlID0gZmluZE5vZGVCeUlkKGlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG5vZGUudHlwZSAhPT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgIGlmICghbm9kZS5wYXJlbnQgJiYgIW5vZGUucHJldiAmJiAhbm9kZS5uZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHJlTGluZUVuZGluZyA9IC9cXHJcXG58XFxufFxcci87XG5mdW5jdGlvbiBjYW5CZUNvbnRpbnVlZExpc3RJdGVtKGxpbmVUZXh0KSB7XG4gICAgdmFyIHNwYWNlTWF0Y2ggPSBsaW5lVGV4dC5tYXRjaCgvXlsgXFx0XSsvKTtcbiAgICBpZiAoc3BhY2VNYXRjaCAmJiAoc3BhY2VNYXRjaFswXS5sZW5ndGggPj0gMiB8fCAvXFx0Ly50ZXN0KHNwYWNlTWF0Y2hbMF0pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGxlZnRUcmltbWVkID0gc3BhY2VNYXRjaCA/IGxpbmVUZXh0LnNsaWNlKHNwYWNlTWF0Y2gubGVuZ3RoKSA6IGxpbmVUZXh0O1xuICAgIHJldHVybiByZUJ1bGxldExpc3RNYXJrZXIudGVzdChsZWZ0VHJpbW1lZCkgfHwgcmVPcmRlcmVkTGlzdE1hcmtlci50ZXN0KGxlZnRUcmltbWVkKTtcbn1cbmZ1bmN0aW9uIGNhbkJlQ29udGludWVkVGFibGVCb2R5KGxpbmVUZXh0KSB7XG4gICAgcmV0dXJuICFpc0JsYW5rKGxpbmVUZXh0KSAmJiBsaW5lVGV4dC5pbmRleE9mKCd8JykgIT09IC0xO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmRGVmU3RhdGUobm9kZSkge1xuICAgIHZhciBpZCA9IG5vZGUuaWQsIHRpdGxlID0gbm9kZS50aXRsZSwgc291cmNlcG9zID0gbm9kZS5zb3VyY2Vwb3MsIGRlc3QgPSBub2RlLmRlc3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIHNvdXJjZXBvczogc291cmNlcG9zLFxuICAgICAgICB1bmxpbmtlZDogZmFsc2UsXG4gICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0LFxuICAgIH07XG59XG52YXIgVG9hc3RNYXJrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0TWFyayhjb250ZW50cywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uID0gISEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pO1xuICAgICAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGFyc2VyLnNldFJlZk1hcHModGhpcy5yZWZNYXAsIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCwgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXApO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1hcCA9IHsgY2hhbmdlOiBbXSB9O1xuICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzIHx8ICcnO1xuICAgICAgICB0aGlzLmxpbmVUZXh0cyA9IGNvbnRlbnRzLnNwbGl0KHJlTGluZUVuZGluZyk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucGFyc2VyLnBhcnNlKGNvbnRlbnRzLCB0aGlzLmxpbmVUZXh0cyk7XG4gICAgfVxuICAgIFRvYXN0TWFyay5wcm90b3R5cGUudXBkYXRlTGluZVRleHRzID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBlbmRQb3MsIG5ld1RleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgc3RhcnRMaW5lID0gc3RhcnRQb3NbMF0sIHN0YXJ0Q29sID0gc3RhcnRQb3NbMV07XG4gICAgICAgIHZhciBlbmRMaW5lID0gZW5kUG9zWzBdLCBlbmRDb2wgPSBlbmRQb3NbMV07XG4gICAgICAgIHZhciBuZXdMaW5lcyA9IG5ld1RleHQuc3BsaXQocmVMaW5lRW5kaW5nKTtcbiAgICAgICAgdmFyIG5ld0xpbmVMZW4gPSBuZXdMaW5lcy5sZW5ndGg7XG4gICAgICAgIHZhciBzdGFydExpbmVUZXh0ID0gdGhpcy5saW5lVGV4dHNbc3RhcnRMaW5lIC0gMV07XG4gICAgICAgIHZhciBlbmRMaW5lVGV4dCA9IHRoaXMubGluZVRleHRzW2VuZExpbmUgLSAxXTtcbiAgICAgICAgbmV3TGluZXNbMF0gPSBzdGFydExpbmVUZXh0LnNsaWNlKDAsIHN0YXJ0Q29sIC0gMSkgKyBuZXdMaW5lc1swXTtcbiAgICAgICAgbmV3TGluZXNbbmV3TGluZUxlbiAtIDFdID0gbmV3TGluZXNbbmV3TGluZUxlbiAtIDFdICsgZW5kTGluZVRleHQuc2xpY2UoZW5kQ29sIC0gMSk7XG4gICAgICAgIHZhciByZW1vdmVkTGluZUxlbiA9IGVuZExpbmUgLSBzdGFydExpbmUgKyAxO1xuICAgICAgICAoX2EgPSB0aGlzLmxpbmVUZXh0cykuc3BsaWNlLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFtzdGFydExpbmUgLSAxLCByZW1vdmVkTGluZUxlbl0sIG5ld0xpbmVzKSk7XG4gICAgICAgIHJldHVybiBuZXdMaW5lTGVuIC0gcmVtb3ZlZExpbmVMZW47XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnVwZGF0ZVJvb3ROb2RlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVUZXh0cy5sZW5ndGggPT09IDEgJiYgdGhpcy5saW5lVGV4dHNbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QubGFzdExpbmVCbGFuayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJvb3Quc291cmNlcG9zID0gW1xuICAgICAgICAgICAgICAgIFsxLCAxXSxcbiAgICAgICAgICAgICAgICBbMSwgMF0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvb3QubGFzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QubGFzdExpbmVCbGFuayA9IHRoaXMucm9vdC5sYXN0Q2hpbGQubGFzdExpbmVCbGFuaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZVRleHRzID0gdGhpcy5saW5lVGV4dHM7XG4gICAgICAgIHZhciBpZHggPSBsaW5lVGV4dHMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGxpbmVUZXh0c1tpZHhdID09PSAnJykge1xuICAgICAgICAgICAgaWR4IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVUZXh0cy5sZW5ndGggLSAyID4gaWR4KSB7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvb3Quc291cmNlcG9zWzFdID0gW2lkeCArIDEsIGxpbmVUZXh0c1tpZHhdLmxlbmd0aF07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlcGxhY2VSYW5nZU5vZGVzID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbmV3Tm9kZXMpIHtcbiAgICAgICAgaWYgKCFzdGFydE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0Tm9kZXNCZWZvcmUoZW5kTm9kZSwgbmV3Tm9kZXMpO1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGVCeUlkKGVuZE5vZGUuaWQpO1xuICAgICAgICAgICAgICAgIGVuZE5vZGUudW5saW5rKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVwZW5kQ2hpbGROb2Rlcyh0aGlzLnJvb3QsIG5ld05vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydE5vZGVzQmVmb3JlKHN0YXJ0Tm9kZSwgbmV3Tm9kZXMpO1xuICAgICAgICAgICAgcmVtb3ZlTmV4dFVudGlsKHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XG4gICAgICAgICAgICBbc3RhcnROb2RlLmlkLCBlbmROb2RlLmlkXS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVtb3ZlTm9kZUJ5SWQoaWQpOyB9KTtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZS51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXROb2RlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIGVuZFBvcykge1xuICAgICAgICB2YXIgc3RhcnROb2RlID0gZmluZENoaWxkTm9kZUF0TGluZSh0aGlzLnJvb3QsIHN0YXJ0UG9zWzBdKTtcbiAgICAgICAgdmFyIGVuZE5vZGUgPSBmaW5kQ2hpbGROb2RlQXRMaW5lKHRoaXMucm9vdCwgZW5kUG9zWzBdKTtcbiAgICAgICAgLy8gZXh0ZW5kIG5vZGUgcmFuZ2UgdG8gaW5jbHVkZSBhIGZvbGxvd2luZyBibG9jayB3aGljaCBkb2Vzbid0IGhhdmUgcHJlY2VkaW5nIGJsYW5rIGxpbmVcbiAgICAgICAgaWYgKGVuZE5vZGUgJiYgZW5kTm9kZS5uZXh0ICYmIGVuZFBvc1swXSArIDEgPT09IGVuZE5vZGUubmV4dC5zb3VyY2Vwb3NbMF1bMF0pIHtcbiAgICAgICAgICAgIGVuZE5vZGUgPSBlbmROb2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzdGFydE5vZGUsIGVuZE5vZGVdO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcGFyYW0pIHtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJNYXBbZXZlbnROYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHBhcmFtKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmV4dGVuZEVuZExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5saW5lVGV4dHNbbGluZV0gPT09ICcnKSB7XG4gICAgICAgICAgICBsaW5lICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnBhcnNlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlLCBzdGFydExpbmUsIGVuZExpbmUpIHtcbiAgICAgICAgLy8gZXh0ZW5kcyBzdGFydGluZyByYW5nZSBpZiB0aGUgZmlyc3Qgbm9kZSBjYW4gYmUgYSBjb250aW51ZWQgbGlzdCBpdGVtXG4gICAgICAgIGlmIChzdGFydE5vZGUgJiZcbiAgICAgICAgICAgIHN0YXJ0Tm9kZS5wcmV2ICYmXG4gICAgICAgICAgICAoKGlzTGlzdChzdGFydE5vZGUucHJldikgJiYgY2FuQmVDb250aW51ZWRMaXN0SXRlbSh0aGlzLmxpbmVUZXh0c1tzdGFydExpbmUgLSAxXSkpIHx8XG4gICAgICAgICAgICAgICAgKGlzVGFibGUoc3RhcnROb2RlLnByZXYpICYmIGNhbkJlQ29udGludWVkVGFibGVCb2R5KHRoaXMubGluZVRleHRzW3N0YXJ0TGluZSAtIDFdKSkpKSB7XG4gICAgICAgICAgICBzdGFydE5vZGUgPSBzdGFydE5vZGUucHJldjtcbiAgICAgICAgICAgIHN0YXJ0TGluZSA9IHN0YXJ0Tm9kZS5zb3VyY2Vwb3NbMF1bMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVkaXRlZExpbmVzID0gdGhpcy5saW5lVGV4dHMuc2xpY2Uoc3RhcnRMaW5lIC0gMSwgZW5kTGluZSk7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5wYXJzZXIucGFydGlhbFBhcnNlU3RhcnQoc3RhcnRMaW5lLCBlZGl0ZWRMaW5lcyk7XG4gICAgICAgIC8vIGV4dGVuZHMgZW5kaW5nIHJhbmdlIGlmIHRoZSBmb2xsb3dpbmcgbm9kZSBjYW4gYmUgYSBmZW5jZWQgY29kZSBibG9jayBvciBhIGNvbnRpbnVlZCBsaXN0IGl0ZW1cbiAgICAgICAgdmFyIG5leHROb2RlID0gZW5kTm9kZSA/IGVuZE5vZGUubmV4dCA6IHRoaXMucm9vdC5maXJzdENoaWxkO1xuICAgICAgICB2YXIgbGFzdENoaWxkID0gcm9vdC5sYXN0Q2hpbGQ7XG4gICAgICAgIHZhciBpc09wZW5lZExhc3RDaGlsZENvZGVCbG9jayA9IGxhc3RDaGlsZCAmJiBpc0NvZGVCbG9jayhsYXN0Q2hpbGQpICYmIGxhc3RDaGlsZC5vcGVuO1xuICAgICAgICB2YXIgaXNPcGVuZWRMYXN0Q2hpbGRDdXN0b21CbG9jayA9IGxhc3RDaGlsZCAmJiBpc0N1c3RvbUJsb2NrKGxhc3RDaGlsZCkgJiYgbGFzdENoaWxkLm9wZW47XG4gICAgICAgIHZhciBpc0xhc3RDaGlsZExpc3QgPSBsYXN0Q2hpbGQgJiYgaXNMaXN0KGxhc3RDaGlsZCk7XG4gICAgICAgIHdoaWxlICgoKGlzT3BlbmVkTGFzdENoaWxkQ29kZUJsb2NrIHx8IGlzT3BlbmVkTGFzdENoaWxkQ3VzdG9tQmxvY2spICYmIG5leHROb2RlKSB8fFxuICAgICAgICAgICAgKGlzTGFzdENoaWxkTGlzdCAmJiBuZXh0Tm9kZSAmJiAobmV4dE5vZGUudHlwZSA9PT0gJ2xpc3QnIHx8IG5leHROb2RlLnNvdXJjZXBvc1swXVsxXSA+PSAyKSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbmRMaW5lID0gdGhpcy5leHRlbmRFbmRMaW5lKG5leHROb2RlLnNvdXJjZXBvc1sxXVswXSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5wYXJ0aWFsUGFyc2VFeHRlbmRzKHRoaXMubGluZVRleHRzLnNsaWNlKGVuZExpbmUsIG5ld0VuZExpbmUpKTtcbiAgICAgICAgICAgIGlmICghc3RhcnROb2RlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnROb2RlID0gZW5kTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZE5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgIGVuZExpbmUgPSBuZXdFbmRMaW5lO1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0Tm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VyLnBhcnRpYWxQYXJzZUZpbmlzaCgpO1xuICAgICAgICB2YXIgbmV3Tm9kZXMgPSBnZXRDaGlsZE5vZGVzKHJvb3QpO1xuICAgICAgICByZXR1cm4geyBuZXdOb2RlczogbmV3Tm9kZXMsIGV4dFN0YXJ0Tm9kZTogc3RhcnROb2RlLCBleHRFbmROb2RlOiBlbmROb2RlIH07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldFJlbW92ZWROb2RlUmFuZ2UgPSBmdW5jdGlvbiAoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlKSB7XG4gICAgICAgIGlmICghZXh0U3RhcnROb2RlIHx8XG4gICAgICAgICAgICAoZXh0U3RhcnROb2RlICYmIGlzUmVmRGVmKGV4dFN0YXJ0Tm9kZSkpIHx8XG4gICAgICAgICAgICAoZXh0RW5kTm9kZSAmJiBpc1JlZkRlZihleHRFbmROb2RlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogW2V4dFN0YXJ0Tm9kZS5pZCwgZXh0RW5kTm9kZS5pZF0sXG4gICAgICAgICAgICBsaW5lOiBbZXh0U3RhcnROb2RlLnNvdXJjZXBvc1swXVswXSAtIDEsIGV4dEVuZE5vZGUuc291cmNlcG9zWzFdWzBdIC0gMV0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLm1hcmtEZWxldGVkUmVmTWFwID0gZnVuY3Rpb24gKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZNYXApKSB7XG4gICAgICAgICAgICB2YXIgbWFya0RlbGV0ZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlZkRlZihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmRGVmU3RhdGUgPSBfdGhpcy5yZWZNYXBbbm9kZS5sYWJlbF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZEZWZTdGF0ZSAmJiBub2RlLmlkID09PSByZWZEZWZTdGF0ZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmRGVmU3RhdGUudW5saW5rZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChleHRTdGFydE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VOZXh0VW50aWwobWFya0RlbGV0ZWQsIGV4dFN0YXJ0Tm9kZS5wYXJlbnQsIGV4dEVuZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dEVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VOZXh0VW50aWwobWFya0RlbGV0ZWQsIGV4dEVuZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlcGxhY2VXaXRoTmV3UmVmRGVmU3RhdGUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpc0VtcHR5T2JqKHRoaXMucmVmTWFwKSkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VXaXRoXzEgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlZkRlZihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBub2RlLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmRGVmU3RhdGUgPSBfdGhpcy5yZWZNYXBbbGFiZWxdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZkRlZlN0YXRlIHx8IHJlZkRlZlN0YXRlLnVubGlua2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZNYXBbbGFiZWxdID0gY3JlYXRlUmVmRGVmU3RhdGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGludm9rZU5leHRVbnRpbChyZXBsYWNlV2l0aF8xLCBub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlcGxhY2VXaXRoUmVmRGVmQ2FuZGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZEZWZDYW5kaWRhdGVNYXApKSB7XG4gICAgICAgICAgICBpdGVyYXRlT2JqZWN0KHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwLCBmdW5jdGlvbiAoXywgY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gY2FuZGlkYXRlLmxhYmVsLCBzb3VyY2Vwb3MgPSBjYW5kaWRhdGUuc291cmNlcG9zO1xuICAgICAgICAgICAgICAgIHZhciByZWZEZWZTdGF0ZSA9IF90aGlzLnJlZk1hcFtsYWJlbF07XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZEZWZTdGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICByZWZEZWZTdGF0ZS51bmxpbmtlZCB8fFxuICAgICAgICAgICAgICAgICAgICByZWZEZWZTdGF0ZS5zb3VyY2Vwb3NbMF1bMF0gPiBzb3VyY2Vwb3NbMF1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmTWFwW2xhYmVsXSA9IGNyZWF0ZVJlZkRlZlN0YXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZ2V0UmFuZ2VXaXRoUmVmRGVmID0gZnVuY3Rpb24gKHN0YXJ0TGluZSwgZW5kTGluZSwgc3RhcnROb2RlLCBlbmROb2RlLCBsaW5lRGlmZikge1xuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uICYmICFpc0VtcHR5T2JqKHRoaXMucmVmTWFwKSkge1xuICAgICAgICAgICAgdmFyIHByZXZOb2RlID0gZmluZENoaWxkTm9kZUF0TGluZSh0aGlzLnJvb3QsIHN0YXJ0TGluZSAtIDEpO1xuICAgICAgICAgICAgdmFyIG5leHROb2RlID0gZmluZENoaWxkTm9kZUF0TGluZSh0aGlzLnJvb3QsIGVuZExpbmUgKyAxKTtcbiAgICAgICAgICAgIGlmIChwcmV2Tm9kZSAmJiBpc1JlZkRlZihwcmV2Tm9kZSkgJiYgcHJldk5vZGUgIT09IHN0YXJ0Tm9kZSAmJiBwcmV2Tm9kZSAhPT0gZW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHByZXZOb2RlO1xuICAgICAgICAgICAgICAgIHN0YXJ0TGluZSA9IHN0YXJ0Tm9kZS5zb3VyY2Vwb3NbMF1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dE5vZGUgJiYgaXNSZWZEZWYobmV4dE5vZGUpICYmIG5leHROb2RlICE9PSBzdGFydE5vZGUgJiYgbmV4dE5vZGUgIT09IGVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBlbmROb2RlID0gbmV4dE5vZGU7XG4gICAgICAgICAgICAgICAgZW5kTGluZSA9IHRoaXMuZXh0ZW5kRW5kTGluZShlbmROb2RlLnNvdXJjZXBvc1sxXVswXSArIGxpbmVEaWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N0YXJ0Tm9kZSwgZW5kTm9kZSwgc3RhcnRMaW5lLCBlbmRMaW5lXTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIGVuZFBvcywgbGluZURpZmYpIHtcbiAgICAgICAgaWYgKGxpbmVEaWZmID09PSB2b2lkIDApIHsgbGluZURpZmYgPSAwOyB9XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Tm9kZVJhbmdlKHN0YXJ0UG9zLCBlbmRQb3MpO1xuICAgICAgICB2YXIgc3RhcnROb2RlID0gcmFuZ2VbMF0sIGVuZE5vZGUgPSByYW5nZVsxXTtcbiAgICAgICAgdmFyIHN0YXJ0TGluZSA9IHN0YXJ0Tm9kZSA/IE1hdGgubWluKHN0YXJ0Tm9kZS5zb3VyY2Vwb3NbMF1bMF0sIHN0YXJ0UG9zWzBdKSA6IHN0YXJ0UG9zWzBdO1xuICAgICAgICB2YXIgZW5kTGluZSA9IHRoaXMuZXh0ZW5kRW5kTGluZSgoZW5kTm9kZSA/IE1hdGgubWF4KGVuZE5vZGUuc291cmNlcG9zWzFdWzBdLCBlbmRQb3NbMF0pIDogZW5kUG9zWzBdKSArIGxpbmVEaWZmKTtcbiAgICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gdGhpcy5wYXJzZVJhbmdlLmFwcGx5KHRoaXMsIHRoaXMuZ2V0UmFuZ2VXaXRoUmVmRGVmKHN0YXJ0TGluZSwgZW5kTGluZSwgc3RhcnROb2RlLCBlbmROb2RlLCBsaW5lRGlmZikpO1xuICAgICAgICB2YXIgbmV3Tm9kZXMgPSBwYXJzZVJlc3VsdC5uZXdOb2RlcywgZXh0U3RhcnROb2RlID0gcGFyc2VSZXN1bHQuZXh0U3RhcnROb2RlLCBleHRFbmROb2RlID0gcGFyc2VSZXN1bHQuZXh0RW5kTm9kZTtcbiAgICAgICAgdmFyIHJlbW92ZWROb2RlUmFuZ2UgPSB0aGlzLmdldFJlbW92ZWROb2RlUmFuZ2UoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlKTtcbiAgICAgICAgdmFyIG5leHROb2RlID0gZXh0RW5kTm9kZSA/IGV4dEVuZE5vZGUubmV4dCA6IHRoaXMucm9vdC5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtEZWxldGVkUmVmTWFwKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VSYW5nZU5vZGVzKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSwgbmV3Tm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aE5ld1JlZkRlZlN0YXRlKG5ld05vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVJhbmdlTm9kZXMoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IG5ld05vZGVzLCByZW1vdmVkTm9kZVJhbmdlOiByZW1vdmVkTm9kZVJhbmdlLCBuZXh0Tm9kZTogbmV4dE5vZGUgfTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucGFyc2VSZWZMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZk1hcCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QodGhpcy5yZWZNYXAsIGZ1bmN0aW9uIChsYWJlbCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudW5saW5rZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnJlZk1hcFtsYWJlbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QoX3RoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCwgZnVuY3Rpb24gKF8sIGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNhbmRpZGF0ZS5ub2RlLCByZWZMYWJlbCA9IGNhbmRpZGF0ZS5yZWZMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZkxhYmVsID09PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goX3RoaXMucGFyc2Uobm9kZS5zb3VyY2Vwb3NbMF0sIG5vZGUuc291cmNlcG9zWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlbW92ZVVubGlua2VkQ2FuZGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZEZWZDYW5kaWRhdGVNYXApKSB7XG4gICAgICAgICAgICBbdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwLCB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcF0uZm9yRWFjaChmdW5jdGlvbiAoY2FuZGlkYXRlTWFwKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZU9iamVjdChjYW5kaWRhdGVNYXAsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmxpbmtlZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYW5kaWRhdGVNYXBbaWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5lZGl0TWFya2Rvd24gPSBmdW5jdGlvbiAoc3RhcnRQb3MsIGVuZFBvcywgbmV3VGV4dCkge1xuICAgICAgICB2YXIgbGluZURpZmYgPSB0aGlzLnVwZGF0ZUxpbmVUZXh0cyhzdGFydFBvcywgZW5kUG9zLCBuZXdUZXh0KTtcbiAgICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gdGhpcy5wYXJzZShzdGFydFBvcywgZW5kUG9zLCBsaW5lRGlmZik7XG4gICAgICAgIHZhciBlZGl0UmVzdWx0ID0gb21pdChwYXJzZVJlc3VsdCwgJ25leHROb2RlJyk7XG4gICAgICAgIHVwZGF0ZU5leHRMaW5lTnVtYmVycyhwYXJzZVJlc3VsdC5uZXh0Tm9kZSwgbGluZURpZmYpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJvb3ROb2RlU3RhdGUoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtlZGl0UmVzdWx0XTtcbiAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVVbmxpbmtlZENhbmRpZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aFJlZkRlZkNhbmRpZGF0ZSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLnBhcnNlUmVmTGluaygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldExpbmVUZXh0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZVRleHRzO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXRSb290Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZmluZE5vZGVBdFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgbm9kZSA9IGZpbmROb2RlQXRQb3NpdGlvbih0aGlzLnJvb3QsIHBvcyk7XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5maW5kRmlyc3ROb2RlQXRMaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRGaXJzdE5vZGVBdExpbmUodGhpcy5yb290LCBsaW5lKTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1hcFtldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmV2ZW50SGFuZGxlck1hcFtldmVudE5hbWVdO1xuICAgICAgICB2YXIgaWR4ID0gaGFuZGxlcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5maW5kTm9kZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGZpbmROb2RlQnlJZChpZCk7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlbW92ZUFsbE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUFsbE5vZGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUb2FzdE1hcms7XG59KCkpO1xuXG52YXIgZGlzYWxsb3dlZFRhZ3MgPSBbXG4gICAgJ3RpdGxlJyxcbiAgICAndGV4dGFyZWEnLFxuICAgICdzdHlsZScsXG4gICAgJ3htcCcsXG4gICAgJ2lmcmFtZScsXG4gICAgJ25vZW1iZWQnLFxuICAgICdub2ZyYW1lcycsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ3BsYWludGV4dCcsXG5dO1xudmFyIHJlRGlzYWxsb3dlZFRhZyA9IG5ldyBSZWdFeHAoXCI8KC8/KD86XCIgKyBkaXNhbGxvd2VkVGFncy5qb2luKCd8JykgKyBcIilbXj5dKj4pXCIsICdpZycpO1xuZnVuY3Rpb24gZmlsdGVyRGlzYWxsb3dlZFRhZ3Moc3RyKSB7XG4gICAgaWYgKHJlRGlzYWxsb3dlZFRhZy50ZXN0KHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlRGlzYWxsb3dlZFRhZywgZnVuY3Rpb24gKF8sIGdyb3VwKSB7IHJldHVybiBcIiZsdDtcIiArIGdyb3VwOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJhc2VDb252ZXJ0b3JzJDEgPSB7XG4gICAgaGVhZGluZzogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogXCJoXCIgKyBub2RlLmxldmVsLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGV4dDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNvZnRicmVhazogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG9wdGlvbnMuc29mdGJyZWFrLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbGluZWJyZWFrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICBjb250ZW50OiAnPGJyIC8+XFxuJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGVtcGg6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdlbScsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzdHJvbmc6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdzdHJvbmcnLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcGFyYWdyYXBoOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIGdyYW5kcGFyZW50ID0gKF9iID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQ7XG4gICAgICAgIGlmIChncmFuZHBhcmVudCAmJiBncmFuZHBhcmVudC50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgICAgIGlmIChncmFuZHBhcmVudC5saXN0RGF0YS50aWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAncCcsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0aGVtYXRpY0JyZWFrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnaHInLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgc2VsZkNsb3NlOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYmxvY2tRdW90ZTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgaW5uZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbGlzdDogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgX2IgPSBub2RlLmxpc3REYXRhLCB0eXBlID0gX2IudHlwZSwgc3RhcnQgPSBfYi5zdGFydDtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0eXBlID09PSAnYnVsbGV0JyA/ICd1bCcgOiAnb2wnO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ29sJyAmJiBzdGFydCAhPT0gbnVsbCAmJiBzdGFydCAhPT0gMSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5zdGFydCA9IHN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaXRlbTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGh0bWxJbmxpbmU6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBjb250ZW50ID0gb3B0aW9ucy50YWdGaWx0ZXIgPyBmaWx0ZXJEaXNhbGxvd2VkVGFncyhub2RlLmxpdGVyYWwpIDogbm9kZS5saXRlcmFsO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGNvbnRlbnQgfTtcbiAgICB9LFxuICAgIGh0bWxCbG9jazogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBvcHRpb25zLnRhZ0ZpbHRlciA/IGZpbHRlckRpc2FsbG93ZWRUYWdzKG5vZGUubGl0ZXJhbCkgOiBub2RlLmxpdGVyYWw7XG4gICAgICAgIGlmIChvcHRpb25zLm5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2h0bWwnLCBjb250ZW50OiBjb250ZW50IH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdodG1sJywgY29udGVudDogY29udGVudCwgb3V0ZXJOZXdMaW5lOiB0cnVlIH07XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGluZm9TdHIgPSBub2RlLmluZm87XG4gICAgICAgIHZhciBpbmZvV29yZHMgPSBpbmZvU3RyID8gaW5mb1N0ci5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgICAgIHZhciBjb2RlQ2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICBpZiAoaW5mb1dvcmRzLmxlbmd0aCA+IDAgJiYgaW5mb1dvcmRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvZGVDbGFzc05hbWVzLnB1c2goXCJsYW5ndWFnZS1cIiArIGVzY2FwZVhtbChpbmZvV29yZHNbMF0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdwcmUnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnY29kZScsIGNsYXNzTmFtZXM6IGNvZGVDbGFzc05hbWVzIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogbm9kZS5saXRlcmFsIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAncHJlJywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIF9iID0gbm9kZSwgdGl0bGUgPSBfYi50aXRsZSwgZGVzdGluYXRpb24gPSBfYi5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdhJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBfX2Fzc2lnbih7IGhyZWY6IGVzY2FwZVhtbChkZXN0aW5hdGlvbikgfSwgKHRpdGxlICYmIHsgdGl0bGU6IGVzY2FwZVhtbCh0aXRsZSkgfSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnYScgfTtcbiAgICB9LFxuICAgIGltYWdlOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGdldENoaWxkcmVuVGV4dCA9IF9hLmdldENoaWxkcmVuVGV4dCwgc2tpcENoaWxkcmVuID0gX2Euc2tpcENoaWxkcmVuO1xuICAgICAgICB2YXIgX2IgPSBub2RlLCB0aXRsZSA9IF9iLnRpdGxlLCBkZXN0aW5hdGlvbiA9IF9iLmRlc3RpbmF0aW9uO1xuICAgICAgICBza2lwQ2hpbGRyZW4oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdpbWcnLFxuICAgICAgICAgICAgc2VsZkNsb3NlOiB0cnVlLFxuICAgICAgICAgICAgYXR0cmlidXRlczogX19hc3NpZ24oeyBzcmM6IGVzY2FwZVhtbChkZXN0aW5hdGlvbiksIGFsdDogZ2V0Q2hpbGRyZW5UZXh0KG5vZGUpIH0sICh0aXRsZSAmJiB7IHRpdGxlOiBlc2NhcGVYbWwodGl0bGUpIH0pKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGN1c3RvbUJsb2NrOiBmdW5jdGlvbiAobm9kZSwgY29udGV4dCwgY29udmVydG9ycykge1xuICAgICAgICB2YXIgaW5mbyA9IG5vZGUuaW5mby50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGNvbnZlcnRvcnNbaW5mb107XG4gICAgICAgIGlmIChjdXN0b21Db252ZXJ0b3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0B0b2FzdC11aS9lZGl0b3JdIC0gVGhlIGVycm9yIG9jY3VycmVkIHdoZW4gXCIgKyBpbmZvICsgXCIgYmxvY2sgbm9kZSB3YXMgcGFyc2VkIGluIG1hcmtkb3duIHJlbmRlcmVyOiBcIiArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBmcm9udE1hdHRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2RpdicsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgZnJvbnQgbWF0dGVyIGlzIG1ldGFkYXRhLCBpdCBzaG91bGQgbm90IGJlIHJlbmRlci5cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IHN0eWxlOiAnd2hpdGUtc3BhY2U6IHByZTsgZGlzcGxheTogbm9uZTsnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBjdXN0b21JbmxpbmU6IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0LCBjb252ZXJ0b3JzKSB7XG4gICAgICAgIHZhciBfYSA9IG5vZGUsIGluZm8gPSBfYS5pbmZvLCBmaXJzdENoaWxkID0gX2EuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIG5vbWFsaXplZEluZm8gPSBpbmZvLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgY3VzdG9tQ29udmVydG9yID0gY29udmVydG9yc1tub21hbGl6ZWRJbmZvXTtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gY29udGV4dC5lbnRlcmluZztcbiAgICAgICAgaWYgKGN1c3RvbUNvbnZlcnRvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tQ29udmVydG9yKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbQHRvYXN0LXVpL2VkaXRvcl0gLSBUaGUgZXJyb3Igb2NjdXJyZWQgd2hlbiBcIiArIG5vbWFsaXplZEluZm8gKyBcIiBpbmxpbmUgbm9kZSB3YXMgcGFyc2VkIGluIG1hcmtkb3duIHJlbmRlcmVyOiBcIiArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRlcmluZ1xuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdzcGFuJyB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBcIiQkXCIgKyBpbmZvICsgKGZpcnN0Q2hpbGQgPyAnICcgOiAnJykgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiAnJCQnIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnc3BhbicgfSxcbiAgICAgICAgICAgIF07XG4gICAgfSxcbn07XG5cbnZhciBnZm1Db252ZXJ0b3JzID0ge1xuICAgIHN0cmlrZTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2RlbCcsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBpdGVtOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBfYiA9IG5vZGUubGlzdERhdGEsIGNoZWNrZWQgPSBfYi5jaGVja2VkLCB0YXNrID0gX2IudGFzaztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgaXRlbVRhZyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBpdGVtVGFnLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZkNsb3NlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogX19hc3NpZ24oX19hc3NpZ24oe30sIChjaGVja2VkICYmIHsgY2hlY2tlZDogJycgfSkpLCB7IGRpc2FibGVkOiAnJywgdHlwZTogJ2NoZWNrYm94JyB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyAnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbVRhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3RhYmxlJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlSGVhZDogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3RoZWFkJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlQm9keTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3Rib2R5JyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlUm93OiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ3RyJyxcbiAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uTGVuID0gbm9kZS5wYXJlbnQucGFyZW50LmNvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGxhc3RDb2xJZHggPSBub2RlLmxhc3RDaGlsZC5lbmRJZHg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGFzdENvbElkeCArIDE7IGkgPCBjb2x1bW5MZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAndGQnLFxuICAgICAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAndGQnLFxuICAgICAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0cicsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgdGFibGVDZWxsOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChub2RlLmlnbm9yZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFibGVQYXJ0ID0gbm9kZS5wYXJlbnQucGFyZW50O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHRhYmxlUGFydC50eXBlID09PSAndGFibGVIZWFkJyA/ICd0aCcgOiAndGQnO1xuICAgICAgICB2YXIgdGFibGUgPSB0YWJsZVBhcnQucGFyZW50O1xuICAgICAgICB2YXIgY29sdW1uSW5mbyA9IHRhYmxlLmNvbHVtbnNbbm9kZS5zdGFydElkeF07XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gKGNvbHVtbkluZm8gPT09IG51bGwgfHwgY29sdW1uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uSW5mby5hbGlnbikgPyB7IGFsaWduOiBjb2x1bW5JbmZvLmFsaWduIH0gOiBudWxsO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogdGFnTmFtZSwgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sIChhdHRyaWJ1dGVzICYmIHsgYXR0cmlidXRlczogYXR0cmlidXRlcyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc29mdGJyZWFrOiAnXFxuJyxcbiAgICBnZm06IGZhbHNlLFxuICAgIHRhZ0ZpbHRlcjogZmFsc2UsXG4gICAgbm9kZUlkOiBmYWxzZSxcbn07XG5mdW5jdGlvbiBnZXRDaGlsZHJlblRleHQobm9kZSkge1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgd2Fsa2VyID0gbm9kZS53YWxrZXIoKTtcbiAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgbm9kZV8xID0gZXZlbnQubm9kZTtcbiAgICAgICAgaWYgKG5vZGVfMS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vZGVfMS5saXRlcmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xufVxudmFyIFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKGN1c3RvbU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zKSwgY3VzdG9tT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29udmVydG9ycyA9IHRoaXMuY3JlYXRlQ29udmVydG9ycygpO1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLmNvbnZlcnRvcnM7XG4gICAgfVxuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb252ZXJ0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udmVydG9ycyA9IF9fYXNzaWduKHt9LCBiYXNlQ29udmVydG9ycyQxKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgICAgICAgIGNvbnZlcnRvcnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udmVydG9ycyksIGdmbUNvbnZlcnRvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udmVydG9ycykge1xuICAgICAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvcnNfMSA9IHRoaXMub3B0aW9ucy5jb252ZXJ0b3JzO1xuICAgICAgICAgICAgdmFyIG5vZGVUeXBlcyA9IE9iamVjdC5rZXlzKGN1c3RvbUNvbnZlcnRvcnNfMSk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdENvbnZlcnRvcnNfMSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBiYXNlQ29udmVydG9ycyQxKSwgZ2ZtQ29udmVydG9ycyk7XG4gICAgICAgICAgICBub2RlVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JnQ29udmVydG9yID0gY29udmVydG9yc1tub2RlVHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRvciA9IGN1c3RvbUNvbnZlcnRvcnNfMVtub2RlVHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRvclR5cGUgPSBPYmplY3Qua2V5cyhkZWZhdWx0Q29udmVydG9yc18xKS5pbmRleE9mKG5vZGVUeXBlKSA9PT0gLTFcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlVHlwZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIDogbm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKG9yZ0NvbnZlcnRvcikge1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW2NvbnZlcnRvclR5cGVdID0gZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQsIGNvbnZlcnRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub3JpZ2luID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JnQ29udmVydG9yKG5vZGUsIGNvbnRleHQsIGNvbnZlcnRvcnMpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRvcnNbY29udmVydG9yVHlwZV0gPSBjb252ZXJ0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRvcnM7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q29udmVydG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydG9ycztcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5nZXRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChyb290Tm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB2YXIgd2Fsa2VyID0gcm9vdE5vZGUud2Fsa2VyKCk7XG4gICAgICAgIHZhciBldmVudCA9IG51bGw7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBldmVudC5ub2RlLCBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nO1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRvciA9IHRoaXNfMS5jb252ZXJ0b3JzW25vZGUudHlwZV07XG4gICAgICAgICAgICBpZiAoIWNvbnZlcnRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2tpcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgZW50ZXJpbmc6IGVudGVyaW5nLFxuICAgICAgICAgICAgICAgIGxlYWY6ICFpc0NvbnRhaW5lciQxKG5vZGUpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXNfMS5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGdldENoaWxkcmVuVGV4dDogZ2V0Q2hpbGRyZW5UZXh0LFxuICAgICAgICAgICAgICAgIHNraXBDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZWQgPSBpc0N1c3RvbUJsb2NrKG5vZGUpIHx8IGlzQ3VzdG9tSW5saW5lKG5vZGUpXG4gICAgICAgICAgICAgICAgPyBjb252ZXJ0b3Iobm9kZSwgY29udGV4dCwgdGhpc18xLmNvbnZlcnRvcnMpXG4gICAgICAgICAgICAgICAgOiBjb252ZXJ0b3Iobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoY29udmVydGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWxOb2RlcyA9IEFycmF5LmlzQXJyYXkoY29udmVydGVkKSA/IGNvbnZlcnRlZCA6IFtjb252ZXJ0ZWRdO1xuICAgICAgICAgICAgICAgIGh0bWxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChodG1sTm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh0bWxOb2RlLnR5cGUgPT09ICdvcGVuVGFnJyAmJiBfdGhpcy5vcHRpb25zLm5vZGVJZCAmJiBpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFodG1sTm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbE5vZGUuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbE5vZGUuYXR0cmlidXRlc1snZGF0YS1ub2RlaWQnXSA9IFN0cmluZyhub2RlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJIVE1MTm9kZShodG1sTm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLnJlc3VtZUF0KG5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgIF9sb29wXzEoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZE5ld0xpbmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmpvaW4oJycpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckhUTUxOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29wZW5UYWcnOlxuICAgICAgICAgICAgY2FzZSAnY2xvc2VUYWcnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRWxlbWVudE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRleHROb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJSYXdIdG1sTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIG5vLWRlZmF1bHQtY2FzZVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVPcGVuVGFnU3RyaW5nID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBub2RlLnRhZ05hbWUsIGNsYXNzTmFtZXMgPSBub2RlLmNsYXNzTmFtZXMsIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCI8XCIgKyB0YWdOYW1lKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZXMgJiYgY2xhc3NOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiIGNsYXNzPVxcXCJcIiArIGNsYXNzTmFtZXMuam9pbignICcpICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcbiAgICAgICAgICAgICAgICBfdGhpcy5idWZmZXIucHVzaChcIiBcIiArIGF0dHJOYW1lICsgXCI9XFxcIlwiICsgYXR0clZhbHVlICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuc2VsZkNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKCcgLycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goJz4nKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZUNsb3NlVGFnU3RyaW5nID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0YWdOYW1lID0gX2EudGFnTmFtZTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChcIjwvXCIgKyB0YWdOYW1lICsgXCI+XCIpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmFkZE5ld0xpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggJiYgbGFzdChsYXN0KHRoaXMuYnVmZmVyKSkgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKCdcXG4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmFkZE91dGVyTmV3TGluZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm91dGVyTmV3TGluZSkge1xuICAgICAgICAgICAgdGhpcy5hZGROZXdMaW5lKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5hZGRJbm5lck5ld0xpbmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5pbm5lck5ld0xpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTmV3TGluZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVGV4dE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGVzY2FwZVhtbChub2RlLmNvbnRlbnQpKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJSYXdIdG1sTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuYWRkT3V0ZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG5vZGUuY29udGVudCk7XG4gICAgICAgIHRoaXMuYWRkT3V0ZXJOZXdMaW5lKG5vZGUpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckVsZW1lbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ29wZW5UYWcnKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVPcGVuVGFnU3RyaW5nKG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUuc2VsZkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZElubmVyTmV3TGluZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSW5uZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUNsb3NlVGFnU3RyaW5nKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oKSk7XG5cbi8qISBAbGljZW5zZSBET01QdXJpZnkgMi4zLjMgfCAoYykgQ3VyZTUzIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIGxpY2Vuc2UgMi4wIGFuZCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlIDIuMCB8IGdpdGh1Yi5jb20vY3VyZTUzL0RPTVB1cmlmeS9ibG9iLzIuMy4zL0xJQ0VOU0UgKi9cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eSxcbiAgICBzZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZixcbiAgICBpc0Zyb3plbiA9IE9iamVjdC5pc0Zyb3plbixcbiAgICBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemUsXG4gICAgc2VhbCA9IE9iamVjdC5zZWFsLFxuICAgIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0c1xuXG52YXIgX3JlZiA9IHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0LFxuICAgIGFwcGx5ID0gX3JlZi5hcHBseSxcbiAgICBjb25zdHJ1Y3QgPSBfcmVmLmNvbnN0cnVjdDtcblxuaWYgKCFhcHBseSkge1xuICBhcHBseSA9IGZ1bmN0aW9uIGFwcGx5KGZ1biwgdGhpc1ZhbHVlLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZ1bi5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpO1xuICB9O1xufVxuXG5pZiAoIWZyZWV6ZSkge1xuICBmcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5pZiAoIXNlYWwpIHtcbiAgc2VhbCA9IGZ1bmN0aW9uIHNlYWwoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5pZiAoIWNvbnN0cnVjdCkge1xuICBjb25zdHJ1Y3QgPSBmdW5jdGlvbiBjb25zdHJ1Y3QoRnVuYywgYXJncykge1xuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KEZ1bmMsIFtudWxsXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKSkpKCk7XG4gIH07XG59XG5cbnZhciBhcnJheUZvckVhY2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcbnZhciBhcnJheVBvcCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnBvcCk7XG52YXIgYXJyYXlQdXNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucHVzaCk7XG5cbnZhciBzdHJpbmdUb0xvd2VyQ2FzZSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZSk7XG52YXIgc3RyaW5nTWF0Y2ggPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUubWF0Y2gpO1xudmFyIHN0cmluZ1JlcGxhY2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgc3RyaW5nSW5kZXhPZiA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mKTtcbnZhciBzdHJpbmdUcmltID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRyaW0pO1xuXG52YXIgcmVnRXhwVGVzdCA9IHVuYXBwbHkoUmVnRXhwLnByb3RvdHlwZS50ZXN0KTtcblxudmFyIHR5cGVFcnJvckNyZWF0ZSA9IHVuY29uc3RydWN0KFR5cGVFcnJvcik7XG5cbmZ1bmN0aW9uIHVuYXBwbHkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW5jb25zdHJ1Y3QoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnN0cnVjdChmdW5jLCBhcmdzKTtcbiAgfTtcbn1cblxuLyogQWRkIHByb3BlcnRpZXMgdG8gYSBsb29rdXAgdGFibGUgKi9cbmZ1bmN0aW9uIGFkZFRvU2V0KHNldCwgYXJyYXkpIHtcbiAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgLy8gTWFrZSAnaW4nIGFuZCB0cnV0aHkgY2hlY2tzIGxpa2UgQm9vbGVhbihzZXQuY29uc3RydWN0b3IpXG4gICAgLy8gaW5kZXBlbmRlbnQgb2YgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiBPYmplY3QucHJvdG90eXBlLlxuICAgIC8vIFByZXZlbnQgcHJvdG90eXBlIHNldHRlcnMgZnJvbSBpbnRlcmNlcHRpbmcgc2V0IGFzIGEgdGhpcyB2YWx1ZS5cbiAgICBzZXRQcm90b3R5cGVPZihzZXQsIG51bGwpO1xuICB9XG5cbiAgdmFyIGwgPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsLS0pIHtcbiAgICB2YXIgZWxlbWVudCA9IGFycmF5W2xdO1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBsY0VsZW1lbnQgPSBzdHJpbmdUb0xvd2VyQ2FzZShlbGVtZW50KTtcbiAgICAgIGlmIChsY0VsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgLy8gQ29uZmlnIHByZXNldHMgKGUuZy4gdGFncy5qcywgYXR0cnMuanMpIGFyZSBpbW11dGFibGUuXG4gICAgICAgIGlmICghaXNGcm96ZW4oYXJyYXkpKSB7XG4gICAgICAgICAgYXJyYXlbbF0gPSBsY0VsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50ID0gbGNFbGVtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldFtlbGVtZW50XSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gc2V0O1xufVxuXG4vKiBTaGFsbG93IGNsb25lIGFuIG9iamVjdCAqL1xuZnVuY3Rpb24gY2xvbmUob2JqZWN0KSB7XG4gIHZhciBuZXdPYmplY3QgPSBjcmVhdGUobnVsbCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gdm9pZCAwO1xuICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgIGlmIChhcHBseShoYXNPd25Qcm9wZXJ0eSwgb2JqZWN0LCBbcHJvcGVydHldKSkge1xuICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld09iamVjdDtcbn1cblxuLyogSUUxMCBkb2Vzbid0IHN1cHBvcnQgX19sb29rdXBHZXR0ZXJfXyBzbyBsZXRzJ1xuICogc2ltdWxhdGUgaXQuIEl0IGFsc28gYXV0b21hdGljYWxseSBjaGVja3NcbiAqIGlmIHRoZSBwcm9wIGlzIGZ1bmN0aW9uIG9yIGdldHRlciBhbmQgYmVoYXZlc1xuICogYWNjb3JkaW5nbHkuICovXG5mdW5jdGlvbiBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wKSB7XG4gIHdoaWxlIChvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZGVzYyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3ApO1xuICAgIGlmIChkZXNjKSB7XG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIHVuYXBwbHkoZGVzYy5nZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHVuYXBwbHkoZGVzYy52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhbGxiYWNrVmFsdWUoZWxlbWVudCkge1xuICAgIGNvbnNvbGUud2FybignZmFsbGJhY2sgdmFsdWUgZm9yJywgZWxlbWVudCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZmFsbGJhY2tWYWx1ZTtcbn1cblxudmFyIGh0bWwkMiA9IGZyZWV6ZShbJ2EnLCAnYWJicicsICdhY3JvbnltJywgJ2FkZHJlc3MnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2F1ZGlvJywgJ2InLCAnYmRpJywgJ2JkbycsICdiaWcnLCAnYmxpbmsnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY2l0ZScsICdjb2RlJywgJ2NvbCcsICdjb2xncm91cCcsICdjb250ZW50JywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGQnLCAnZGVjb3JhdG9yJywgJ2RlbCcsICdkZXRhaWxzJywgJ2RmbicsICdkaWFsb2cnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbGVtZW50JywgJ2VtJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2ZvbnQnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaScsICdpbWcnLCAnaW5wdXQnLCAnaW5zJywgJ2tiZCcsICdsYWJlbCcsICdsZWdlbmQnLCAnbGknLCAnbWFpbicsICdtYXAnLCAnbWFyaycsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0ZXInLCAnbmF2JywgJ25vYnInLCAnb2wnLCAnb3B0Z3JvdXAnLCAnb3B0aW9uJywgJ291dHB1dCcsICdwJywgJ3BpY3R1cmUnLCAncHJlJywgJ3Byb2dyZXNzJywgJ3EnLCAncnAnLCAncnQnLCAncnVieScsICdzJywgJ3NhbXAnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc2hhZG93JywgJ3NtYWxsJywgJ3NvdXJjZScsICdzcGFjZXInLCAnc3BhbicsICdzdHJpa2UnLCAnc3Ryb25nJywgJ3N0eWxlJywgJ3N1YicsICdzdW1tYXJ5JywgJ3N1cCcsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aW1lJywgJ3RyJywgJ3RyYWNrJywgJ3R0JywgJ3UnLCAndWwnLCAndmFyJywgJ3ZpZGVvJywgJ3diciddKTtcblxuLy8gU1ZHXG52YXIgc3ZnID0gZnJlZXplKFsnc3ZnJywgJ2EnLCAnYWx0Z2x5cGgnLCAnYWx0Z2x5cGhkZWYnLCAnYWx0Z2x5cGhpdGVtJywgJ2FuaW1hdGVjb2xvcicsICdhbmltYXRlbW90aW9uJywgJ2FuaW1hdGV0cmFuc2Zvcm0nLCAnY2lyY2xlJywgJ2NsaXBwYXRoJywgJ2RlZnMnLCAnZGVzYycsICdlbGxpcHNlJywgJ2ZpbHRlcicsICdmb250JywgJ2cnLCAnZ2x5cGgnLCAnZ2x5cGhyZWYnLCAnaGtlcm4nLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lYXJncmFkaWVudCcsICdtYXJrZXInLCAnbWFzaycsICdtZXRhZGF0YScsICdtcGF0aCcsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxncmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAnc3R5bGUnLCAnc3dpdGNoJywgJ3N5bWJvbCcsICd0ZXh0JywgJ3RleHRwYXRoJywgJ3RpdGxlJywgJ3RyZWYnLCAndHNwYW4nLCAndmlldycsICd2a2VybiddKTtcblxudmFyIHN2Z0ZpbHRlcnMgPSBmcmVlemUoWydmZUJsZW5kJywgJ2ZlQ29sb3JNYXRyaXgnLCAnZmVDb21wb25lbnRUcmFuc2ZlcicsICdmZUNvbXBvc2l0ZScsICdmZUNvbnZvbHZlTWF0cml4JywgJ2ZlRGlmZnVzZUxpZ2h0aW5nJywgJ2ZlRGlzcGxhY2VtZW50TWFwJywgJ2ZlRGlzdGFudExpZ2h0JywgJ2ZlRmxvb2QnLCAnZmVGdW5jQScsICdmZUZ1bmNCJywgJ2ZlRnVuY0cnLCAnZmVGdW5jUicsICdmZUdhdXNzaWFuQmx1cicsICdmZU1lcmdlJywgJ2ZlTWVyZ2VOb2RlJywgJ2ZlTW9ycGhvbG9neScsICdmZU9mZnNldCcsICdmZVBvaW50TGlnaHQnLCAnZmVTcGVjdWxhckxpZ2h0aW5nJywgJ2ZlU3BvdExpZ2h0JywgJ2ZlVGlsZScsICdmZVR1cmJ1bGVuY2UnXSk7XG5cbi8vIExpc3Qgb2YgU1ZHIGVsZW1lbnRzIHRoYXQgYXJlIGRpc2FsbG93ZWQgYnkgZGVmYXVsdC5cbi8vIFdlIHN0aWxsIG5lZWQgdG8ga25vdyB0aGVtIHNvIHRoYXQgd2UgY2FuIGRvIG5hbWVzcGFjZVxuLy8gY2hlY2tzIHByb3Blcmx5IGluIGNhc2Ugb25lIHdhbnRzIHRvIGFkZCB0aGVtIHRvXG4vLyBhbGxvdy1saXN0LlxudmFyIHN2Z0Rpc2FsbG93ZWQgPSBmcmVlemUoWydhbmltYXRlJywgJ2NvbG9yLXByb2ZpbGUnLCAnY3Vyc29yJywgJ2Rpc2NhcmQnLCAnZmVkcm9wc2hhZG93JywgJ2ZlaW1hZ2UnLCAnZm9udC1mYWNlJywgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXNyYycsICdmb250LWZhY2UtdXJpJywgJ2ZvcmVpZ25vYmplY3QnLCAnaGF0Y2gnLCAnaGF0Y2hwYXRoJywgJ21lc2gnLCAnbWVzaGdyYWRpZW50JywgJ21lc2hwYXRjaCcsICdtZXNocm93JywgJ21pc3NpbmctZ2x5cGgnLCAnc2NyaXB0JywgJ3NldCcsICdzb2xpZGNvbG9yJywgJ3Vua25vd24nLCAndXNlJ10pO1xuXG52YXIgbWF0aE1sID0gZnJlZXplKFsnbWF0aCcsICdtZW5jbG9zZScsICdtZXJyb3InLCAnbWZlbmNlZCcsICdtZnJhYycsICdtZ2x5cGgnLCAnbWknLCAnbWxhYmVsZWR0cicsICdtbXVsdGlzY3JpcHRzJywgJ21uJywgJ21vJywgJ21vdmVyJywgJ21wYWRkZWQnLCAnbXBoYW50b20nLCAnbXJvb3QnLCAnbXJvdycsICdtcycsICdtc3BhY2UnLCAnbXNxcnQnLCAnbXN0eWxlJywgJ21zdWInLCAnbXN1cCcsICdtc3Vic3VwJywgJ210YWJsZScsICdtdGQnLCAnbXRleHQnLCAnbXRyJywgJ211bmRlcicsICdtdW5kZXJvdmVyJ10pO1xuXG4vLyBTaW1pbGFybHkgdG8gU1ZHLCB3ZSB3YW50IHRvIGtub3cgYWxsIE1hdGhNTCBlbGVtZW50cyxcbi8vIGV2ZW4gdGhvc2UgdGhhdCB3ZSBkaXNhbGxvdyBieSBkZWZhdWx0LlxudmFyIG1hdGhNbERpc2FsbG93ZWQgPSBmcmVlemUoWydtYWN0aW9uJywgJ21hbGlnbmdyb3VwJywgJ21hbGlnbm1hcmsnLCAnbWxvbmdkaXYnLCAnbXNjYXJyaWVzJywgJ21zY2FycnknLCAnbXNncm91cCcsICdtc3RhY2snLCAnbXNsaW5lJywgJ21zcm93JywgJ3NlbWFudGljcycsICdhbm5vdGF0aW9uJywgJ2Fubm90YXRpb24teG1sJywgJ21wcmVzY3JpcHRzJywgJ25vbmUnXSk7XG5cbnZhciB0ZXh0ID0gZnJlZXplKFsnI3RleHQnXSk7XG5cbnZhciBodG1sJDEkMSA9IGZyZWV6ZShbJ2FjY2VwdCcsICdhY3Rpb24nLCAnYWxpZ24nLCAnYWx0JywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9jb21wbGV0ZScsICdhdXRvcGljdHVyZWlucGljdHVyZScsICdhdXRvcGxheScsICdiYWNrZ3JvdW5kJywgJ2JnY29sb3InLCAnYm9yZGVyJywgJ2NhcHR1cmUnLCAnY2VsbHBhZGRpbmcnLCAnY2VsbHNwYWNpbmcnLCAnY2hlY2tlZCcsICdjaXRlJywgJ2NsYXNzJywgJ2NsZWFyJywgJ2NvbG9yJywgJ2NvbHMnLCAnY29sc3BhbicsICdjb250cm9scycsICdjb250cm9sc2xpc3QnLCAnY29vcmRzJywgJ2Nyb3Nzb3JpZ2luJywgJ2RhdGV0aW1lJywgJ2RlY29kaW5nJywgJ2RlZmF1bHQnLCAnZGlyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVwaWN0dXJlaW5waWN0dXJlJywgJ2Rpc2FibGVyZW1vdGVwbGF5YmFjaycsICdkb3dubG9hZCcsICdkcmFnZ2FibGUnLCAnZW5jdHlwZScsICdlbnRlcmtleWhpbnQnLCAnZmFjZScsICdmb3InLCAnaGVhZGVycycsICdoZWlnaHQnLCAnaGlkZGVuJywgJ2hpZ2gnLCAnaHJlZicsICdocmVmbGFuZycsICdpZCcsICdpbnB1dG1vZGUnLCAnaW50ZWdyaXR5JywgJ2lzbWFwJywgJ2tpbmQnLCAnbGFiZWwnLCAnbGFuZycsICdsaXN0JywgJ2xvYWRpbmcnLCAnbG9vcCcsICdsb3cnLCAnbWF4JywgJ21heGxlbmd0aCcsICdtZWRpYScsICdtZXRob2QnLCAnbWluJywgJ21pbmxlbmd0aCcsICdtdWx0aXBsZScsICdtdXRlZCcsICduYW1lJywgJ25vc2hhZGUnLCAnbm92YWxpZGF0ZScsICdub3dyYXAnLCAnb3BlbicsICdvcHRpbXVtJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncGxheXNpbmxpbmUnLCAncG9zdGVyJywgJ3ByZWxvYWQnLCAncHViZGF0ZScsICdyYWRpb2dyb3VwJywgJ3JlYWRvbmx5JywgJ3JlbCcsICdyZXF1aXJlZCcsICdyZXYnLCAncmV2ZXJzZWQnLCAncm9sZScsICdyb3dzJywgJ3Jvd3NwYW4nLCAnc3BlbGxjaGVjaycsICdzY29wZScsICdzZWxlY3RlZCcsICdzaGFwZScsICdzaXplJywgJ3NpemVzJywgJ3NwYW4nLCAnc3JjbGFuZycsICdzdGFydCcsICdzcmMnLCAnc3Jjc2V0JywgJ3N0ZXAnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJpbmRleCcsICd0aXRsZScsICd0cmFuc2xhdGUnLCAndHlwZScsICd1c2VtYXAnLCAndmFsaWduJywgJ3ZhbHVlJywgJ3dpZHRoJywgJ3htbG5zJywgJ3Nsb3QnXSk7XG5cbnZhciBzdmckMSA9IGZyZWV6ZShbJ2FjY2VudC1oZWlnaHQnLCAnYWNjdW11bGF0ZScsICdhZGRpdGl2ZScsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXNjZW50JywgJ2F0dHJpYnV0ZW5hbWUnLCAnYXR0cmlidXRldHlwZScsICdhemltdXRoJywgJ2Jhc2VmcmVxdWVuY3knLCAnYmFzZWxpbmUtc2hpZnQnLCAnYmVnaW4nLCAnYmlhcycsICdieScsICdjbGFzcycsICdjbGlwJywgJ2NsaXBwYXRodW5pdHMnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvcicsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdjeCcsICdjeScsICdkJywgJ2R4JywgJ2R5JywgJ2RpZmZ1c2Vjb25zdGFudCcsICdkaXJlY3Rpb24nLCAnZGlzcGxheScsICdkaXZpc29yJywgJ2R1cicsICdlZGdlbW9kZScsICdlbGV2YXRpb24nLCAnZW5kJywgJ2ZpbGwnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmaWx0ZXInLCAnZmlsdGVydW5pdHMnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZngnLCAnZnknLCAnZzEnLCAnZzInLCAnZ2x5cGgtbmFtZScsICdnbHlwaHJlZicsICdncmFkaWVudHVuaXRzJywgJ2dyYWRpZW50dHJhbnNmb3JtJywgJ2hlaWdodCcsICdocmVmJywgJ2lkJywgJ2ltYWdlLXJlbmRlcmluZycsICdpbicsICdpbjInLCAnaycsICdrMScsICdrMicsICdrMycsICdrNCcsICdrZXJuaW5nJywgJ2tleXBvaW50cycsICdrZXlzcGxpbmVzJywgJ2tleXRpbWVzJywgJ2xhbmcnLCAnbGVuZ3RoYWRqdXN0JywgJ2xldHRlci1zcGFjaW5nJywgJ2tlcm5lbG1hdHJpeCcsICdrZXJuZWx1bml0bGVuZ3RoJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ2xvY2FsJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnbWFya2VyaGVpZ2h0JywgJ21hcmtlcnVuaXRzJywgJ21hcmtlcndpZHRoJywgJ21hc2tjb250ZW50dW5pdHMnLCAnbWFza3VuaXRzJywgJ21heCcsICdtYXNrJywgJ21lZGlhJywgJ21ldGhvZCcsICdtb2RlJywgJ21pbicsICduYW1lJywgJ251bW9jdGF2ZXMnLCAnb2Zmc2V0JywgJ29wZXJhdG9yJywgJ29wYWNpdHknLCAnb3JkZXInLCAnb3JpZW50JywgJ29yaWVudGF0aW9uJywgJ29yaWdpbicsICdvdmVyZmxvdycsICdwYWludC1vcmRlcicsICdwYXRoJywgJ3BhdGhsZW5ndGgnLCAncGF0dGVybmNvbnRlbnR1bml0cycsICdwYXR0ZXJudHJhbnNmb3JtJywgJ3BhdHRlcm51bml0cycsICdwb2ludHMnLCAncHJlc2VydmVhbHBoYScsICdwcmVzZXJ2ZWFzcGVjdHJhdGlvJywgJ3ByaW1pdGl2ZXVuaXRzJywgJ3InLCAncngnLCAncnknLCAncmFkaXVzJywgJ3JlZngnLCAncmVmeScsICdyZXBlYXRjb3VudCcsICdyZXBlYXRkdXInLCAncmVzdGFydCcsICdyZXN1bHQnLCAncm90YXRlJywgJ3NjYWxlJywgJ3NlZWQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3NwZWN1bGFyY29uc3RhbnQnLCAnc3BlY3VsYXJleHBvbmVudCcsICdzcHJlYWRtZXRob2QnLCAnc3RhcnRvZmZzZXQnLCAnc3RkZGV2aWF0aW9uJywgJ3N0aXRjaHRpbGVzJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZScsICdzdHJva2Utd2lkdGgnLCAnc3R5bGUnLCAnc3VyZmFjZXNjYWxlJywgJ3N5c3RlbWxhbmd1YWdlJywgJ3RhYmluZGV4JywgJ3RhcmdldHgnLCAndGFyZ2V0eScsICd0cmFuc2Zvcm0nLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3RleHRsZW5ndGgnLCAndHlwZScsICd1MScsICd1MicsICd1bmljb2RlJywgJ3ZhbHVlcycsICd2aWV3Ym94JywgJ3Zpc2liaWxpdHknLCAndmVyc2lvbicsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3aWR0aCcsICd3b3JkLXNwYWNpbmcnLCAnd3JhcCcsICd3cml0aW5nLW1vZGUnLCAneGNoYW5uZWxzZWxlY3RvcicsICd5Y2hhbm5lbHNlbGVjdG9yJywgJ3gnLCAneDEnLCAneDInLCAneG1sbnMnLCAneScsICd5MScsICd5MicsICd6JywgJ3pvb21hbmRwYW4nXSk7XG5cbnZhciBtYXRoTWwkMSA9IGZyZWV6ZShbJ2FjY2VudCcsICdhY2NlbnR1bmRlcicsICdhbGlnbicsICdiZXZlbGxlZCcsICdjbG9zZScsICdjb2x1bW5zYWxpZ24nLCAnY29sdW1ubGluZXMnLCAnY29sdW1uc3BhbicsICdkZW5vbWFsaWduJywgJ2RlcHRoJywgJ2RpcicsICdkaXNwbGF5JywgJ2Rpc3BsYXlzdHlsZScsICdlbmNvZGluZycsICdmZW5jZScsICdmcmFtZScsICdoZWlnaHQnLCAnaHJlZicsICdpZCcsICdsYXJnZW9wJywgJ2xlbmd0aCcsICdsaW5ldGhpY2tuZXNzJywgJ2xzcGFjZScsICdscXVvdGUnLCAnbWF0aGJhY2tncm91bmQnLCAnbWF0aGNvbG9yJywgJ21hdGhzaXplJywgJ21hdGh2YXJpYW50JywgJ21heHNpemUnLCAnbWluc2l6ZScsICdtb3ZhYmxlbGltaXRzJywgJ25vdGF0aW9uJywgJ251bWFsaWduJywgJ29wZW4nLCAncm93YWxpZ24nLCAncm93bGluZXMnLCAncm93c3BhY2luZycsICdyb3dzcGFuJywgJ3JzcGFjZScsICdycXVvdGUnLCAnc2NyaXB0bGV2ZWwnLCAnc2NyaXB0bWluc2l6ZScsICdzY3JpcHRzaXplbXVsdGlwbGllcicsICdzZWxlY3Rpb24nLCAnc2VwYXJhdG9yJywgJ3NlcGFyYXRvcnMnLCAnc3RyZXRjaHknLCAnc3Vic2NyaXB0c2hpZnQnLCAnc3Vwc2NyaXB0c2hpZnQnLCAnc3ltbWV0cmljJywgJ3ZvZmZzZXQnLCAnd2lkdGgnLCAneG1sbnMnXSk7XG5cbnZhciB4bWwgPSBmcmVlemUoWyd4bGluazpocmVmJywgJ3htbDppZCcsICd4bGluazp0aXRsZScsICd4bWw6c3BhY2UnLCAneG1sbnM6eGxpbmsnXSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxudmFyIE1VU1RBQ0hFX0VYUFIgPSBzZWFsKC9cXHtcXHtbXFxzXFxTXSp8W1xcc1xcU10qXFx9XFx9L2dtKTsgLy8gU3BlY2lmeSB0ZW1wbGF0ZSBkZXRlY3Rpb24gcmVnZXggZm9yIFNBRkVfRk9SX1RFTVBMQVRFUyBtb2RlXG52YXIgRVJCX0VYUFIgPSBzZWFsKC88JVtcXHNcXFNdKnxbXFxzXFxTXSolPi9nbSk7XG52YXIgREFUQV9BVFRSID0gc2VhbCgvXmRhdGEtW1xcLVxcdy5cXHUwMEI3LVxcdUZGRkZdLyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbnZhciBBUklBX0FUVFIgPSBzZWFsKC9eYXJpYS1bXFwtXFx3XSskLyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbnZhciBJU19BTExPV0VEX1VSSSA9IHNlYWwoL14oPzooPzooPzpmfGh0KXRwcz98bWFpbHRvfHRlbHxjYWxsdG98Y2lkfHhtcHApOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2kgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuKTtcbnZhciBJU19TQ1JJUFRfT1JfREFUQSA9IHNlYWwoL14oPzpcXHcrc2NyaXB0fGRhdGEpOi9pKTtcbnZhciBBVFRSX1dISVRFU1BBQ0UgPSBzZWFsKC9bXFx1MDAwMC1cXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDI5XFx1MjA1RlxcdTMwMDBdL2cgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG4pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheSQxKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuby1vcCBwb2xpY3kgZm9yIGludGVybmFsIHVzZSBvbmx5LlxuICogRG9uJ3QgZXhwb3J0IHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0aGlzIG1vZHVsZSFcbiAqIEBwYXJhbSB7P1RydXN0ZWRUeXBlUG9saWN5RmFjdG9yeX0gdHJ1c3RlZFR5cGVzIFRoZSBwb2xpY3kgZmFjdG9yeS5cbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY3VtZW50IFRoZSBkb2N1bWVudCBvYmplY3QgKHRvIGRldGVybWluZSBwb2xpY3kgbmFtZSBzdWZmaXgpXG4gKiBAcmV0dXJuIHs/VHJ1c3RlZFR5cGVQb2xpY3l9IFRoZSBwb2xpY3kgY3JlYXRlZCAob3IgbnVsbCwgaWYgVHJ1c3RlZCBUeXBlc1xuICogYXJlIG5vdCBzdXBwb3J0ZWQpLlxuICovXG52YXIgX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSA9IGZ1bmN0aW9uIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kodHJ1c3RlZFR5cGVzLCBkb2N1bWVudCkge1xuICBpZiAoKHR5cGVvZiB0cnVzdGVkVHlwZXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRydXN0ZWRUeXBlcykpICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsb3cgdGhlIGNhbGxlcnMgdG8gY29udHJvbCB0aGUgdW5pcXVlIHBvbGljeSBuYW1lXG4gIC8vIGJ5IGFkZGluZyBhIGRhdGEtdHQtcG9saWN5LXN1ZmZpeCB0byB0aGUgc2NyaXB0IGVsZW1lbnQgd2l0aCB0aGUgRE9NUHVyaWZ5LlxuICAvLyBQb2xpY3kgY3JlYXRpb24gd2l0aCBkdXBsaWNhdGUgbmFtZXMgdGhyb3dzIGluIFRydXN0ZWQgVHlwZXMuXG4gIHZhciBzdWZmaXggPSBudWxsO1xuICB2YXIgQVRUUl9OQU1FID0gJ2RhdGEtdHQtcG9saWN5LXN1ZmZpeCc7XG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpIHtcbiAgICBzdWZmaXggPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShBVFRSX05BTUUpO1xuICB9XG5cbiAgdmFyIHBvbGljeU5hbWUgPSAnZG9tcHVyaWZ5JyArIChzdWZmaXggPyAnIycgKyBzdWZmaXggOiAnJyk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShwb2xpY3lOYW1lLCB7XG4gICAgICBjcmVhdGVIVE1MOiBmdW5jdGlvbiBjcmVhdGVIVE1MKGh0bWwkJDEpIHtcbiAgICAgICAgcmV0dXJuIGh0bWwkJDE7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBQb2xpY3kgY3JlYXRpb24gZmFpbGVkIChtb3N0IGxpa2VseSBhbm90aGVyIERPTVB1cmlmeSBzY3JpcHQgaGFzXG4gICAgLy8gYWxyZWFkeSBydW4pLiBTa2lwIGNyZWF0aW5nIHRoZSBwb2xpY3ksIGFzIHRoaXMgd2lsbCBvbmx5IGNhdXNlIGVycm9yc1xuICAgIC8vIGlmIFRUIGFyZSBlbmZvcmNlZC5cbiAgICBjb25zb2xlLndhcm4oJ1RydXN0ZWRUeXBlcyBwb2xpY3kgJyArIHBvbGljeU5hbWUgKyAnIGNvdWxkIG5vdCBiZSBjcmVhdGVkLicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVET01QdXJpZnkoKSB7XG4gIHZhciB3aW5kb3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGdldEdsb2JhbCgpO1xuXG4gIHZhciBET01QdXJpZnkgPSBmdW5jdGlvbiBET01QdXJpZnkocm9vdCkge1xuICAgIHJldHVybiBjcmVhdGVET01QdXJpZnkocm9vdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFZlcnNpb24gbGFiZWwsIGV4cG9zZWQgZm9yIGVhc2llciBjaGVja3NcbiAgICogaWYgRE9NUHVyaWZ5IGlzIHVwIHRvIGRhdGUgb3Igbm90XG4gICAqL1xuICBET01QdXJpZnkudmVyc2lvbiA9ICcyLjMuMyc7XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgRE9NUHVyaWZ5IHJlbW92ZWQgZHVyaW5nIHNhbml0YXRpb24uXG4gICAqIEVtcHR5IGlmIG5vdGhpbmcgd2FzIHJlbW92ZWQuXG4gICAqL1xuICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuXG4gIGlmICghd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50Lm5vZGVUeXBlICE9PSA5KSB7XG4gICAgLy8gTm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLCBwcm92aWRlIGEgZmFjdG9yeSBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgeW91IGNhbiBwYXNzIHlvdXIgb3duIFdpbmRvd1xuICAgIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIERPTVB1cmlmeTtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbERvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG4gIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgdmFyIERvY3VtZW50RnJhZ21lbnQgPSB3aW5kb3cuRG9jdW1lbnRGcmFnbWVudCxcbiAgICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPSB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudCxcbiAgICAgIE5vZGUgPSB3aW5kb3cuTm9kZSxcbiAgICAgIEVsZW1lbnQgPSB3aW5kb3cuRWxlbWVudCxcbiAgICAgIE5vZGVGaWx0ZXIgPSB3aW5kb3cuTm9kZUZpbHRlcixcbiAgICAgIF93aW5kb3ckTmFtZWROb2RlTWFwID0gd2luZG93Lk5hbWVkTm9kZU1hcCxcbiAgICAgIE5hbWVkTm9kZU1hcCA9IF93aW5kb3ckTmFtZWROb2RlTWFwID09PSB1bmRlZmluZWQgPyB3aW5kb3cuTmFtZWROb2RlTWFwIHx8IHdpbmRvdy5Nb3pOYW1lZEF0dHJNYXAgOiBfd2luZG93JE5hbWVkTm9kZU1hcCxcbiAgICAgIFRleHQgPSB3aW5kb3cuVGV4dCxcbiAgICAgIENvbW1lbnQgPSB3aW5kb3cuQ29tbWVudCxcbiAgICAgIERPTVBhcnNlciA9IHdpbmRvdy5ET01QYXJzZXIsXG4gICAgICB0cnVzdGVkVHlwZXMgPSB3aW5kb3cudHJ1c3RlZFR5cGVzO1xuXG5cbiAgdmFyIEVsZW1lbnRQcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcblxuICB2YXIgY2xvbmVOb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjbG9uZU5vZGUnKTtcbiAgdmFyIGdldE5leHRTaWJsaW5nID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICduZXh0U2libGluZycpO1xuICB2YXIgZ2V0Q2hpbGROb2RlcyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2hpbGROb2RlcycpO1xuICB2YXIgZ2V0UGFyZW50Tm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAncGFyZW50Tm9kZScpO1xuXG4gIC8vIEFzIHBlciBpc3N1ZSAjNDcsIHRoZSB3ZWItY29tcG9uZW50cyByZWdpc3RyeSBpcyBpbmhlcml0ZWQgYnkgYVxuICAvLyBuZXcgZG9jdW1lbnQgY3JlYXRlZCB2aWEgY3JlYXRlSFRNTERvY3VtZW50LiBBcyBwZXIgdGhlIHNwZWNcbiAgLy8gKGh0dHA6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2NyZWF0aW5nLWFuZC1wYXNzaW5nLXJlZ2lzdHJpZXMpXG4gIC8vIGEgbmV3IGVtcHR5IHJlZ2lzdHJ5IGlzIHVzZWQgd2hlbiBjcmVhdGluZyBhIHRlbXBsYXRlIGNvbnRlbnRzIG93bmVyXG4gIC8vIGRvY3VtZW50LCBzbyB3ZSB1c2UgdGhhdCBhcyBvdXIgcGFyZW50IGRvY3VtZW50IHRvIGVuc3VyZSBub3RoaW5nXG4gIC8vIGlzIGluaGVyaXRlZC5cbiAgaWYgKHR5cGVvZiBIVE1MVGVtcGxhdGVFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICBpZiAodGVtcGxhdGUuY29udGVudCAmJiB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQpIHtcbiAgICAgIGRvY3VtZW50ID0gdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgfVxuXG4gIHZhciB0cnVzdGVkVHlwZXNQb2xpY3kgPSBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgb3JpZ2luYWxEb2N1bWVudCk7XG4gIHZhciBlbXB0eUhUTUwgPSB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKCcnKSA6ICcnO1xuXG4gIHZhciBfZG9jdW1lbnQgPSBkb2N1bWVudCxcbiAgICAgIGltcGxlbWVudGF0aW9uID0gX2RvY3VtZW50LmltcGxlbWVudGF0aW9uLFxuICAgICAgY3JlYXRlTm9kZUl0ZXJhdG9yID0gX2RvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcixcbiAgICAgIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSBfZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCxcbiAgICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lID0gX2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lO1xuICB2YXIgaW1wb3J0Tm9kZSA9IG9yaWdpbmFsRG9jdW1lbnQuaW1wb3J0Tm9kZTtcblxuXG4gIHZhciBkb2N1bWVudE1vZGUgPSB7fTtcbiAgdHJ5IHtcbiAgICBkb2N1bWVudE1vZGUgPSBjbG9uZShkb2N1bWVudCkuZG9jdW1lbnRNb2RlID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDoge307XG4gIH0gY2F0Y2ggKF8pIHt9XG5cbiAgdmFyIGhvb2tzID0ge307XG5cbiAgLyoqXG4gICAqIEV4cG9zZSB3aGV0aGVyIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBydW5uaW5nIHRoZSBmdWxsIERPTVB1cmlmeS5cbiAgICovXG4gIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IHR5cGVvZiBnZXRQYXJlbnROb2RlID09PSAnZnVuY3Rpb24nICYmIGltcGxlbWVudGF0aW9uICYmIHR5cGVvZiBpbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50TW9kZSAhPT0gOTtcblxuICB2YXIgTVVTVEFDSEVfRVhQUiQkMSA9IE1VU1RBQ0hFX0VYUFIsXG4gICAgICBFUkJfRVhQUiQkMSA9IEVSQl9FWFBSLFxuICAgICAgREFUQV9BVFRSJCQxID0gREFUQV9BVFRSLFxuICAgICAgQVJJQV9BVFRSJCQxID0gQVJJQV9BVFRSLFxuICAgICAgSVNfU0NSSVBUX09SX0RBVEEkJDEgPSBJU19TQ1JJUFRfT1JfREFUQSxcbiAgICAgIEFUVFJfV0hJVEVTUEFDRSQkMSA9IEFUVFJfV0hJVEVTUEFDRTtcbiAgdmFyIElTX0FMTE9XRURfVVJJJCQxID0gSVNfQUxMT1dFRF9VUkk7XG5cbiAgLyoqXG4gICAqIFdlIGNvbnNpZGVyIHRoZSBlbGVtZW50cyBhbmQgYXR0cmlidXRlcyBiZWxvdyB0byBiZSBzYWZlLiBJZGVhbGx5XG4gICAqIGRvbid0IGFkZCBhbnkgbmV3IG9uZXMgYnV0IGZlZWwgZnJlZSB0byByZW1vdmUgdW53YW50ZWQgb25lcy5cbiAgICovXG5cbiAgLyogYWxsb3dlZCBlbGVtZW50IG5hbWVzICovXG5cbiAgdmFyIEFMTE9XRURfVEFHUyA9IG51bGw7XG4gIHZhciBERUZBVUxUX0FMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEoaHRtbCQyKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoc3ZnKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoc3ZnRmlsdGVycyksIF90b0NvbnN1bWFibGVBcnJheSQxKG1hdGhNbCksIF90b0NvbnN1bWFibGVBcnJheSQxKHRleHQpKSk7XG5cbiAgLyogQWxsb3dlZCBhdHRyaWJ1dGUgbmFtZXMgKi9cbiAgdmFyIEFMTE9XRURfQVRUUiA9IG51bGw7XG4gIHZhciBERUZBVUxUX0FMTE9XRURfQVRUUiA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEoaHRtbCQxJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShzdmckMSksIF90b0NvbnN1bWFibGVBcnJheSQxKG1hdGhNbCQxKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoeG1sKSkpO1xuXG4gIC8qIEV4cGxpY2l0bHkgZm9yYmlkZGVuIHRhZ3MgKG92ZXJyaWRlcyBBTExPV0VEX1RBR1MvQUREX1RBR1MpICovXG4gIHZhciBGT1JCSURfVEFHUyA9IG51bGw7XG5cbiAgLyogRXhwbGljaXRseSBmb3JiaWRkZW4gYXR0cmlidXRlcyAob3ZlcnJpZGVzIEFMTE9XRURfQVRUUi9BRERfQVRUUikgKi9cbiAgdmFyIEZPUkJJRF9BVFRSID0gbnVsbDtcblxuICAvKiBEZWNpZGUgaWYgQVJJQSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gIHZhciBBTExPV19BUklBX0FUVFIgPSB0cnVlO1xuXG4gIC8qIERlY2lkZSBpZiBjdXN0b20gZGF0YSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gIHZhciBBTExPV19EQVRBX0FUVFIgPSB0cnVlO1xuXG4gIC8qIERlY2lkZSBpZiB1bmtub3duIHByb3RvY29scyBhcmUgb2theSAqL1xuICB2YXIgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBmYWxzZTtcblxuICAvKiBPdXRwdXQgc2hvdWxkIGJlIHNhZmUgZm9yIGNvbW1vbiB0ZW1wbGF0ZSBlbmdpbmVzLlxuICAgKiBUaGlzIG1lYW5zLCBET01QdXJpZnkgcmVtb3ZlcyBkYXRhIGF0dHJpYnV0ZXMsIG11c3RhY2hlcyBhbmQgRVJCXG4gICAqL1xuICB2YXIgU0FGRV9GT1JfVEVNUExBVEVTID0gZmFsc2U7XG5cbiAgLyogRGVjaWRlIGlmIGRvY3VtZW50IHdpdGggPGh0bWw+Li4uIHNob3VsZCBiZSByZXR1cm5lZCAqL1xuICB2YXIgV0hPTEVfRE9DVU1FTlQgPSBmYWxzZTtcblxuICAvKiBUcmFjayB3aGV0aGVyIGNvbmZpZyBpcyBhbHJlYWR5IHNldCBvbiB0aGlzIGluc3RhbmNlIG9mIERPTVB1cmlmeS4gKi9cbiAgdmFyIFNFVF9DT05GSUcgPSBmYWxzZTtcblxuICAvKiBEZWNpZGUgaWYgYWxsIGVsZW1lbnRzIChlLmcuIHN0eWxlLCBzY3JpcHQpIG11c3QgYmUgY2hpbGRyZW4gb2ZcbiAgICogZG9jdW1lbnQuYm9keS4gQnkgZGVmYXVsdCwgYnJvd3NlcnMgbWlnaHQgbW92ZSB0aGVtIHRvIGRvY3VtZW50LmhlYWQgKi9cbiAgdmFyIEZPUkNFX0JPRFkgPSBmYWxzZTtcblxuICAvKiBEZWNpZGUgaWYgYSBET00gYEhUTUxCb2R5RWxlbWVudGAgc2hvdWxkIGJlIHJldHVybmVkLCBpbnN0ZWFkIG9mIGEgaHRtbFxuICAgKiBzdHJpbmcgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkuXG4gICAqIElmIGBXSE9MRV9ET0NVTUVOVGAgaXMgZW5hYmxlZCBhIGBIVE1MSHRtbEVsZW1lbnRgIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZFxuICAgKi9cbiAgdmFyIFJFVFVSTl9ET00gPSBmYWxzZTtcblxuICAvKiBEZWNpZGUgaWYgYSBET00gYERvY3VtZW50RnJhZ21lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICogc3RyaW5nICAob3IgYSBUcnVzdGVkSFRNTCBvYmplY3QgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgc3VwcG9ydGVkKSAqL1xuICB2YXIgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGZhbHNlO1xuXG4gIC8qIElmIGBSRVRVUk5fRE9NYCBvciBgUkVUVVJOX0RPTV9GUkFHTUVOVGAgaXMgZW5hYmxlZCwgZGVjaWRlIGlmIHRoZSByZXR1cm5lZCBET01cbiAgICogYE5vZGVgIGlzIGltcG9ydGVkIGludG8gdGhlIGN1cnJlbnQgYERvY3VtZW50YC4gSWYgdGhpcyBmbGFnIGlzIG5vdCBlbmFibGVkIHRoZVxuICAgKiBgTm9kZWAgd2lsbCBiZWxvbmcgKGl0cyBvd25lckRvY3VtZW50KSB0byBhIGZyZXNoIGBIVE1MRG9jdW1lbnRgLCBjcmVhdGVkIGJ5XG4gICAqIERPTVB1cmlmeS5cbiAgICpcbiAgICogVGhpcyBkZWZhdWx0cyB0byBgdHJ1ZWAgc3RhcnRpbmcgRE9NUHVyaWZ5IDIuMi4wLiBOb3RlIHRoYXQgc2V0dGluZyBpdCB0byBgZmFsc2VgXG4gICAqIG1pZ2h0IGNhdXNlIFhTUyBmcm9tIGF0dGFja3MgaGlkZGVuIGluIGNsb3NlZCBzaGFkb3dyb290cyBpbiBjYXNlIHRoZSBicm93c2VyXG4gICAqIHN1cHBvcnRzIERlY2xhcmF0aXZlIFNoYWRvdzogRE9NIGh0dHBzOi8vd2ViLmRldi9kZWNsYXJhdGl2ZS1zaGFkb3ctZG9tL1xuICAgKi9cbiAgdmFyIFJFVFVSTl9ET01fSU1QT1JUID0gdHJ1ZTtcblxuICAvKiBUcnkgdG8gcmV0dXJuIGEgVHJ1c3RlZCBUeXBlIG9iamVjdCBpbnN0ZWFkIG9mIGEgc3RyaW5nLCByZXR1cm4gYSBzdHJpbmcgaW5cbiAgICogY2FzZSBUcnVzdGVkIFR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkICAqL1xuICB2YXIgUkVUVVJOX1RSVVNURURfVFlQRSA9IGZhbHNlO1xuXG4gIC8qIE91dHB1dCBzaG91bGQgYmUgZnJlZSBmcm9tIERPTSBjbG9iYmVyaW5nIGF0dGFja3M/ICovXG4gIHZhciBTQU5JVElaRV9ET00gPSB0cnVlO1xuXG4gIC8qIEtlZXAgZWxlbWVudCBjb250ZW50IHdoZW4gcmVtb3ZpbmcgZWxlbWVudD8gKi9cbiAgdmFyIEtFRVBfQ09OVEVOVCA9IHRydWU7XG5cbiAgLyogSWYgYSBgTm9kZWAgaXMgcGFzc2VkIHRvIHNhbml0aXplKCksIHRoZW4gcGVyZm9ybXMgc2FuaXRpemF0aW9uIGluLXBsYWNlIGluc3RlYWRcbiAgICogb2YgaW1wb3J0aW5nIGl0IGludG8gYSBuZXcgRG9jdW1lbnQgYW5kIHJldHVybmluZyBhIHNhbml0aXplZCBjb3B5ICovXG4gIHZhciBJTl9QTEFDRSA9IGZhbHNlO1xuXG4gIC8qIEFsbG93IHVzYWdlIG9mIHByb2ZpbGVzIGxpa2UgaHRtbCwgc3ZnIGFuZCBtYXRoTWwgKi9cbiAgdmFyIFVTRV9QUk9GSUxFUyA9IHt9O1xuXG4gIC8qIFRhZ3MgdG8gaWdub3JlIGNvbnRlbnQgb2Ygd2hlbiBLRUVQX0NPTlRFTlQgaXMgdHJ1ZSAqL1xuICB2YXIgRk9SQklEX0NPTlRFTlRTID0gbnVsbDtcbiAgdmFyIERFRkFVTFRfRk9SQklEX0NPTlRFTlRTID0gYWRkVG9TZXQoe30sIFsnYW5ub3RhdGlvbi14bWwnLCAnYXVkaW8nLCAnY29sZ3JvdXAnLCAnZGVzYycsICdmb3JlaWdub2JqZWN0JywgJ2hlYWQnLCAnaWZyYW1lJywgJ21hdGgnLCAnbWknLCAnbW4nLCAnbW8nLCAnbXMnLCAnbXRleHQnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdwbGFpbnRleHQnLCAnc2NyaXB0JywgJ3N0eWxlJywgJ3N2ZycsICd0ZW1wbGF0ZScsICd0aGVhZCcsICd0aXRsZScsICd2aWRlbycsICd4bXAnXSk7XG5cbiAgLyogVGFncyB0aGF0IGFyZSBzYWZlIGZvciBkYXRhOiBVUklzICovXG4gIHZhciBEQVRBX1VSSV9UQUdTID0gbnVsbDtcbiAgdmFyIERFRkFVTFRfREFUQV9VUklfVEFHUyA9IGFkZFRvU2V0KHt9LCBbJ2F1ZGlvJywgJ3ZpZGVvJywgJ2ltZycsICdzb3VyY2UnLCAnaW1hZ2UnLCAndHJhY2snXSk7XG5cbiAgLyogQXR0cmlidXRlcyBzYWZlIGZvciB2YWx1ZXMgbGlrZSBcImphdmFzY3JpcHQ6XCIgKi9cbiAgdmFyIFVSSV9TQUZFX0FUVFJJQlVURVMgPSBudWxsO1xuICB2YXIgREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTID0gYWRkVG9TZXQoe30sIFsnYWx0JywgJ2NsYXNzJywgJ2ZvcicsICdpZCcsICdsYWJlbCcsICduYW1lJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncm9sZScsICdzdW1tYXJ5JywgJ3RpdGxlJywgJ3ZhbHVlJywgJ3N0eWxlJywgJ3htbG5zJ10pO1xuXG4gIHZhciBNQVRITUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xuICB2YXIgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIHZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgLyogRG9jdW1lbnQgbmFtZXNwYWNlICovXG4gIHZhciBOQU1FU1BBQ0UgPSBIVE1MX05BTUVTUEFDRTtcbiAgdmFyIElTX0VNUFRZX0lOUFVUID0gZmFsc2U7XG5cbiAgLyogUGFyc2luZyBvZiBzdHJpY3QgWEhUTUwgZG9jdW1lbnRzICovXG4gIHZhciBQQVJTRVJfTUVESUFfVFlQRSA9IHZvaWQgMDtcbiAgdmFyIFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMgPSBbJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcsICd0ZXh0L2h0bWwnXTtcbiAgdmFyIERFRkFVTFRfUEFSU0VSX01FRElBX1RZUEUgPSAndGV4dC9odG1sJztcbiAgdmFyIHRyYW5zZm9ybUNhc2VGdW5jID0gdm9pZCAwO1xuXG4gIC8qIEtlZXAgYSByZWZlcmVuY2UgdG8gY29uZmlnIHRvIHBhc3MgdG8gaG9va3MgKi9cbiAgdmFyIENPTkZJRyA9IG51bGw7XG5cbiAgLyogSWRlYWxseSwgZG8gbm90IHRvdWNoIGFueXRoaW5nIGJlbG93IHRoaXMgbGluZSAqL1xuICAvKiBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fICovXG5cbiAgdmFyIGZvcm1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuXG4gIC8qKlxuICAgKiBfcGFyc2VDb25maWdcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjZmcgb3B0aW9uYWwgY29uZmlnIGxpdGVyYWxcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIHZhciBfcGFyc2VDb25maWcgPSBmdW5jdGlvbiBfcGFyc2VDb25maWcoY2ZnKSB7XG4gICAgaWYgKENPTkZJRyAmJiBDT05GSUcgPT09IGNmZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHRhbXBlcmluZyAqL1xuICAgIGlmICghY2ZnIHx8ICh0eXBlb2YgY2ZnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjZmcpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGNmZyA9IHt9O1xuICAgIH1cblxuICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHByb3RvdHlwZSBwb2xsdXRpb24gKi9cbiAgICBjZmcgPSBjbG9uZShjZmcpO1xuXG4gICAgLyogU2V0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuICAgIEFMTE9XRURfVEFHUyA9ICdBTExPV0VEX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9UQUdTKSA6IERFRkFVTFRfQUxMT1dFRF9UQUdTO1xuICAgIEFMTE9XRURfQVRUUiA9ICdBTExPV0VEX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9BVFRSKSA6IERFRkFVTFRfQUxMT1dFRF9BVFRSO1xuICAgIFVSSV9TQUZFX0FUVFJJQlVURVMgPSAnQUREX1VSSV9TQUZFX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KGNsb25lKERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyksIGNmZy5BRERfVVJJX1NBRkVfQVRUUikgOiBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVM7XG4gICAgREFUQV9VUklfVEFHUyA9ICdBRERfREFUQV9VUklfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9EQVRBX1VSSV9UQUdTKSwgY2ZnLkFERF9EQVRBX1VSSV9UQUdTKSA6IERFRkFVTFRfREFUQV9VUklfVEFHUztcbiAgICBGT1JCSURfQ09OVEVOVFMgPSAnRk9SQklEX0NPTlRFTlRTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9DT05URU5UUykgOiBERUZBVUxUX0ZPUkJJRF9DT05URU5UUztcbiAgICBGT1JCSURfVEFHUyA9ICdGT1JCSURfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfVEFHUykgOiB7fTtcbiAgICBGT1JCSURfQVRUUiA9ICdGT1JCSURfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQVRUUikgOiB7fTtcbiAgICBVU0VfUFJPRklMRVMgPSAnVVNFX1BST0ZJTEVTJyBpbiBjZmcgPyBjZmcuVVNFX1BST0ZJTEVTIDogZmFsc2U7XG4gICAgQUxMT1dfQVJJQV9BVFRSID0gY2ZnLkFMTE9XX0FSSUFfQVRUUiAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIEFMTE9XX0RBVEFfQVRUUiA9IGNmZy5BTExPV19EQVRBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGNmZy5BTExPV19VTktOT1dOX1BST1RPQ09MUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFNBRkVfRk9SX1RFTVBMQVRFUyA9IGNmZy5TQUZFX0ZPUl9URU1QTEFURVMgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBXSE9MRV9ET0NVTUVOVCA9IGNmZy5XSE9MRV9ET0NVTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET00gPSBjZmcuUkVUVVJOX0RPTSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET01fRlJBR01FTlQgPSBjZmcuUkVUVVJOX0RPTV9GUkFHTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET01fSU1QT1JUID0gY2ZnLlJFVFVSTl9ET01fSU1QT1JUICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgUkVUVVJOX1RSVVNURURfVFlQRSA9IGNmZy5SRVRVUk5fVFJVU1RFRF9UWVBFIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgRk9SQ0VfQk9EWSA9IGNmZy5GT1JDRV9CT0RZIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgU0FOSVRJWkVfRE9NID0gY2ZnLlNBTklUSVpFX0RPTSAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIEtFRVBfQ09OVEVOVCA9IGNmZy5LRUVQX0NPTlRFTlQgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBJTl9QTEFDRSA9IGNmZy5JTl9QTEFDRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIElTX0FMTE9XRURfVVJJJCQxID0gY2ZnLkFMTE9XRURfVVJJX1JFR0VYUCB8fCBJU19BTExPV0VEX1VSSSQkMTtcbiAgICBOQU1FU1BBQ0UgPSBjZmcuTkFNRVNQQUNFIHx8IEhUTUxfTkFNRVNQQUNFO1xuXG4gICAgUEFSU0VSX01FRElBX1RZUEUgPVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgIFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMuaW5kZXhPZihjZmcuUEFSU0VSX01FRElBX1RZUEUpID09PSAtMSA/IFBBUlNFUl9NRURJQV9UWVBFID0gREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSA6IFBBUlNFUl9NRURJQV9UWVBFID0gY2ZnLlBBUlNFUl9NRURJQV9UWVBFO1xuXG4gICAgLy8gSFRNTCB0YWdzIGFuZCBhdHRyaWJ1dGVzIGFyZSBub3QgY2FzZS1zZW5zaXRpdmUsIGNvbnZlcnRpbmcgdG8gbG93ZXJjYXNlLiBLZWVwaW5nIFhIVE1MIGFzIGlzLlxuICAgIHRyYW5zZm9ybUNhc2VGdW5jID0gUEFSU0VSX01FRElBX1RZUEUgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0gOiBzdHJpbmdUb0xvd2VyQ2FzZTtcblxuICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgIEFMTE9XX0RBVEFfQVRUUiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICBSRVRVUk5fRE9NID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBQYXJzZSBwcm9maWxlIGluZm8gKi9cbiAgICBpZiAoVVNFX1BST0ZJTEVTKSB7XG4gICAgICBBTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSQxKHRleHQpKSk7XG4gICAgICBBTExPV0VEX0FUVFIgPSBbXTtcbiAgICAgIGlmIChVU0VfUFJPRklMRVMuaHRtbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGh0bWwkMik7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgaHRtbCQxJDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2ZyA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Zyk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnJDEpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVU0VfUFJPRklMRVMuc3ZnRmlsdGVycyA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Z0ZpbHRlcnMpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2ZyQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLm1hdGhNbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIG1hdGhNbCk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgbWF0aE1sJDEpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogTWVyZ2UgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgaWYgKGNmZy5BRERfVEFHUykge1xuICAgICAgaWYgKEFMTE9XRURfVEFHUyA9PT0gREVGQVVMVF9BTExPV0VEX1RBR1MpIHtcbiAgICAgICAgQUxMT1dFRF9UQUdTID0gY2xvbmUoQUxMT1dFRF9UQUdTKTtcbiAgICAgIH1cblxuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBjZmcuQUREX1RBR1MpO1xuICAgIH1cblxuICAgIGlmIChjZmcuQUREX0FUVFIpIHtcbiAgICAgIGlmIChBTExPV0VEX0FUVFIgPT09IERFRkFVTFRfQUxMT1dFRF9BVFRSKSB7XG4gICAgICAgIEFMTE9XRURfQVRUUiA9IGNsb25lKEFMTE9XRURfQVRUUik7XG4gICAgICB9XG5cbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgY2ZnLkFERF9BVFRSKTtcbiAgICB9XG5cbiAgICBpZiAoY2ZnLkFERF9VUklfU0FGRV9BVFRSKSB7XG4gICAgICBhZGRUb1NldChVUklfU0FGRV9BVFRSSUJVVEVTLCBjZmcuQUREX1VSSV9TQUZFX0FUVFIpO1xuICAgIH1cblxuICAgIGlmIChjZmcuRk9SQklEX0NPTlRFTlRTKSB7XG4gICAgICBpZiAoRk9SQklEX0NPTlRFTlRTID09PSBERUZBVUxUX0ZPUkJJRF9DT05URU5UUykge1xuICAgICAgICBGT1JCSURfQ09OVEVOVFMgPSBjbG9uZShGT1JCSURfQ09OVEVOVFMpO1xuICAgICAgfVxuXG4gICAgICBhZGRUb1NldChGT1JCSURfQ09OVEVOVFMsIGNmZy5GT1JCSURfQ09OVEVOVFMpO1xuICAgIH1cblxuICAgIC8qIEFkZCAjdGV4dCBpbiBjYXNlIEtFRVBfQ09OVEVOVCBpcyBzZXQgdG8gdHJ1ZSAqL1xuICAgIGlmIChLRUVQX0NPTlRFTlQpIHtcbiAgICAgIEFMTE9XRURfVEFHU1snI3RleHQnXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyogQWRkIGh0bWwsIGhlYWQgYW5kIGJvZHkgdG8gQUxMT1dFRF9UQUdTIGluIGNhc2UgV0hPTEVfRE9DVU1FTlQgaXMgdHJ1ZSAqL1xuICAgIGlmIChXSE9MRV9ET0NVTUVOVCkge1xuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ2h0bWwnLCAnaGVhZCcsICdib2R5J10pO1xuICAgIH1cblxuICAgIC8qIEFkZCB0Ym9keSB0byBBTExPV0VEX1RBR1MgaW4gY2FzZSB0YWJsZXMgYXJlIHBlcm1pdHRlZCwgc2VlICMyODYsICMzNjUgKi9cbiAgICBpZiAoQUxMT1dFRF9UQUdTLnRhYmxlKSB7XG4gICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFsndGJvZHknXSk7XG4gICAgICBkZWxldGUgRk9SQklEX1RBR1MudGJvZHk7XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBmdXJ0aGVyIG1hbmlwdWxhdGlvbiBvZiBjb25maWd1cmF0aW9uLlxuICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gSUU4LCBTYWZhcmkgNSwgZXRjLlxuICAgIGlmIChmcmVlemUpIHtcbiAgICAgIGZyZWV6ZShjZmcpO1xuICAgIH1cblxuICAgIENPTkZJRyA9IGNmZztcbiAgfTtcblxuICB2YXIgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFsnbWknLCAnbW8nLCAnbW4nLCAnbXMnLCAnbXRleHQnXSk7XG5cbiAgdmFyIEhUTUxfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFsnZm9yZWlnbm9iamVjdCcsICdkZXNjJywgJ3RpdGxlJywgJ2Fubm90YXRpb24teG1sJ10pO1xuXG4gIC8qIEtlZXAgdHJhY2sgb2YgYWxsIHBvc3NpYmxlIFNWRyBhbmQgTWF0aE1MIHRhZ3NcbiAgICogc28gdGhhdCB3ZSBjYW4gcGVyZm9ybSB0aGUgbmFtZXNwYWNlIGNoZWNrc1xuICAgKiBjb3JyZWN0bHkuICovXG4gIHZhciBBTExfU1ZHX1RBR1MgPSBhZGRUb1NldCh7fSwgc3ZnKTtcbiAgYWRkVG9TZXQoQUxMX1NWR19UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgYWRkVG9TZXQoQUxMX1NWR19UQUdTLCBzdmdEaXNhbGxvd2VkKTtcblxuICB2YXIgQUxMX01BVEhNTF9UQUdTID0gYWRkVG9TZXQoe30sIG1hdGhNbCk7XG4gIGFkZFRvU2V0KEFMTF9NQVRITUxfVEFHUywgbWF0aE1sRGlzYWxsb3dlZCk7XG5cbiAgLyoqXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgYSBET00gZWxlbWVudCB3aG9zZSBuYW1lc3BhY2UgaXMgYmVpbmcgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJuIGZhbHNlIGlmIHRoZSBlbGVtZW50IGhhcyBhXG4gICAqICBuYW1lc3BhY2UgdGhhdCBhIHNwZWMtY29tcGxpYW50IHBhcnNlciB3b3VsZCBuZXZlclxuICAgKiAgcmV0dXJuLiBSZXR1cm4gdHJ1ZSBvdGhlcndpc2UuXG4gICAqL1xuICB2YXIgX2NoZWNrVmFsaWROYW1lc3BhY2UgPSBmdW5jdGlvbiBfY2hlY2tWYWxpZE5hbWVzcGFjZShlbGVtZW50KSB7XG4gICAgdmFyIHBhcmVudCA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgICAvLyBJbiBKU0RPTSwgaWYgd2UncmUgaW5zaWRlIHNoYWRvdyBET00sIHRoZW4gcGFyZW50Tm9kZVxuICAgIC8vIGNhbiBiZSBudWxsLiBXZSBqdXN0IHNpbXVsYXRlIHBhcmVudCBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC50YWdOYW1lKSB7XG4gICAgICBwYXJlbnQgPSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSTogSFRNTF9OQU1FU1BBQ0UsXG4gICAgICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZSdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShlbGVtZW50LnRhZ05hbWUpO1xuICAgIHZhciBwYXJlbnRUYWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UocGFyZW50LnRhZ05hbWUpO1xuXG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gSFRNTCBuYW1lc3BhY2UgdG8gU1ZHXG4gICAgICAvLyBpcyB2aWEgPHN2Zz4uIElmIGl0IGhhcHBlbnMgdmlhIGFueSBvdGhlciB0YWcsIHRoZW5cbiAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gTWF0aE1MIHRvIFNWRyBpcyB2aWFcbiAgICAgIC8vIHN2ZyBpZiBwYXJlbnQgaXMgZWl0aGVyIDxhbm5vdGF0aW9uLXhtbD4gb3IgTWF0aE1MXG4gICAgICAvLyB0ZXh0IGludGVncmF0aW9uIHBvaW50cy5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJyAmJiAocGFyZW50VGFnTmFtZSA9PT0gJ2Fubm90YXRpb24teG1sJyB8fCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gU1ZHXG4gICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIFNWRyBuYW1lc3BhY2UuXG4gICAgICByZXR1cm4gQm9vbGVhbihBTExfU1ZHX1RBR1NbdGFnTmFtZV0pO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSkge1xuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIEhUTUwgbmFtZXNwYWNlIHRvIE1hdGhNTFxuICAgICAgLy8gaXMgdmlhIDxtYXRoPi4gSWYgaXQgaGFwcGVucyB2aWEgYW55IG90aGVyIHRhZywgdGhlblxuICAgICAgLy8gaXQgc2hvdWxkIGJlIGtpbGxlZC5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ21hdGgnO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIE1hdGhNTCBpcyB2aWFcbiAgICAgIC8vIDxtYXRoPiBhbmQgSFRNTCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCcgJiYgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIG9ubHkgYWxsb3cgZWxlbWVudHMgdGhhdCBhcmUgZGVmaW5lZCBpbiBNYXRoTUxcbiAgICAgIC8vIHNwZWMuIEFsbCBvdGhlcnMgYXJlIGRpc2FsbG93ZWQgaW4gTWF0aE1MIG5hbWVzcGFjZS5cbiAgICAgIHJldHVybiBCb29sZWFuKEFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIFNWRyB0byBIVE1MIGlzIHZpYVxuICAgICAgLy8gSFRNTCBpbnRlZ3JhdGlvbiBwb2ludHMsIGFuZCBmcm9tIE1hdGhNTCB0byBIVE1MXG4gICAgICAvLyBpcyB2aWEgTWF0aE1MIHRleHQgaW50ZWdyYXRpb24gcG9pbnRzXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSAmJiAhSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSAmJiAhTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2VydGFpbiBlbGVtZW50cyBhcmUgYWxsb3dlZCBpbiBib3RoIFNWRyBhbmQgSFRNTFxuICAgICAgLy8gbmFtZXNwYWNlLiBXZSBuZWVkIHRvIHNwZWNpZnkgdGhlbSBleHBsaWNpdGx5XG4gICAgICAvLyBzbyB0aGF0IHRoZXkgZG9uJ3QgZ2V0IGVycm9ub3VzbHkgZGVsZXRlZCBmcm9tXG4gICAgICAvLyBIVE1MIG5hbWVzcGFjZS5cbiAgICAgIHZhciBjb21tb25TdmdBbmRIVE1MRWxlbWVudHMgPSBhZGRUb1NldCh7fSwgWyd0aXRsZScsICdzdHlsZScsICdmb250JywgJ2EnLCAnc2NyaXB0J10pO1xuXG4gICAgICAvLyBXZSBkaXNhbGxvdyB0YWdzIHRoYXQgYXJlIHNwZWNpZmljIGZvciBNYXRoTUxcbiAgICAgIC8vIG9yIFNWRyBhbmQgc2hvdWxkIG5ldmVyIGFwcGVhciBpbiBIVE1MIG5hbWVzcGFjZVxuICAgICAgcmV0dXJuICFBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0gJiYgKGNvbW1vblN2Z0FuZEhUTUxFbGVtZW50c1t0YWdOYW1lXSB8fCAhQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgY29kZSBzaG91bGQgbmV2ZXIgcmVhY2ggdGhpcyBwbGFjZSAodGhpcyBtZWFuc1xuICAgIC8vIHRoYXQgdGhlIGVsZW1lbnQgc29tZWhvdyBnb3QgbmFtZXNwYWNlIHRoYXQgaXMgbm90XG4gICAgLy8gSFRNTCwgU1ZHIG9yIE1hdGhNTCkuIFJldHVybiBmYWxzZSBqdXN0IGluIGNhc2UuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfZm9yY2VSZW1vdmVcbiAgICpcbiAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBhIERPTSBub2RlXG4gICAqL1xuICB2YXIgX2ZvcmNlUmVtb3ZlID0gZnVuY3Rpb24gX2ZvcmNlUmVtb3ZlKG5vZGUpIHtcbiAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogbm9kZSB9KTtcbiAgICB0cnkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLXJlbW92ZVxuICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vZGUub3V0ZXJIVE1MID0gZW1wdHlIVE1MO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogX3JlbW92ZUF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgYW4gQXR0cmlidXRlIG5hbWVcbiAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBhIERPTSBub2RlXG4gICAqL1xuICB2YXIgX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgbm9kZSkge1xuICAgIHRyeSB7XG4gICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgYXR0cmlidXRlOiBub2RlLmdldEF0dHJpYnV0ZU5vZGUobmFtZSksXG4gICAgICAgIGZyb206IG5vZGVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICBhdHRyaWJ1dGU6IG51bGwsXG4gICAgICAgIGZyb206IG5vZGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXG4gICAgLy8gV2Ugdm9pZCBhdHRyaWJ1dGUgdmFsdWVzIGZvciB1bnJlbW92YWJsZSBcImlzXCJcIiBhdHRyaWJ1dGVzXG4gICAgaWYgKG5hbWUgPT09ICdpcycgJiYgIUFMTE9XRURfQVRUUltuYW1lXSkge1xuICAgICAgaWYgKFJFVFVSTl9ET00gfHwgUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9mb3JjZVJlbW92ZShub2RlKTtcbiAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogX2luaXREb2N1bWVudFxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcnR5IGEgc3RyaW5nIG9mIGRpcnR5IG1hcmt1cFxuICAgKiBAcmV0dXJuIHtEb2N1bWVudH0gYSBET00sIGZpbGxlZCB3aXRoIHRoZSBkaXJ0eSBtYXJrdXBcbiAgICovXG4gIHZhciBfaW5pdERvY3VtZW50ID0gZnVuY3Rpb24gX2luaXREb2N1bWVudChkaXJ0eSkge1xuICAgIC8qIENyZWF0ZSBhIEhUTUwgZG9jdW1lbnQgKi9cbiAgICB2YXIgZG9jID0gdm9pZCAwO1xuICAgIHZhciBsZWFkaW5nV2hpdGVzcGFjZSA9IHZvaWQgMDtcblxuICAgIGlmIChGT1JDRV9CT0RZKSB7XG4gICAgICBkaXJ0eSA9ICc8cmVtb3ZlPjwvcmVtb3ZlPicgKyBkaXJ0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogSWYgRk9SQ0VfQk9EWSBpc24ndCB1c2VkLCBsZWFkaW5nIHdoaXRlc3BhY2UgbmVlZHMgdG8gYmUgcHJlc2VydmVkIG1hbnVhbGx5ICovXG4gICAgICB2YXIgbWF0Y2hlcyA9IHN0cmluZ01hdGNoKGRpcnR5LCAvXltcXHJcXG5cXHQgXSsvKTtcbiAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIGlmIChQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcpIHtcbiAgICAgIC8vIFJvb3Qgb2YgWEhUTUwgZG9jIG11c3QgY29udGFpbiB4bWxucyBkZWNsYXJhdGlvbiAoc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvbm9ybWF0aXZlLmh0bWwjc3RyaWN0KVxuICAgICAgZGlydHkgPSAnPGh0bWwgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI+PGhlYWQ+PC9oZWFkPjxib2R5PicgKyBkaXJ0eSArICc8L2JvZHk+PC9odG1sPic7XG4gICAgfVxuXG4gICAgdmFyIGRpcnR5UGF5bG9hZCA9IHRydXN0ZWRUeXBlc1BvbGljeSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKGRpcnR5KSA6IGRpcnR5O1xuICAgIC8qXG4gICAgICogVXNlIHRoZSBET01QYXJzZXIgQVBJIGJ5IGRlZmF1bHQsIGZhbGxiYWNrIGxhdGVyIGlmIG5lZWRzIGJlXG4gICAgICogRE9NUGFyc2VyIG5vdCB3b3JrIGZvciBzdmcgd2hlbiBoYXMgbXVsdGlwbGUgcm9vdCBlbGVtZW50LlxuICAgICAqL1xuICAgIGlmIChOQU1FU1BBQ0UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGRpcnR5UGF5bG9hZCwgUEFSU0VSX01FRElBX1RZUEUpO1xuICAgICAgfSBjYXRjaCAoXykge31cbiAgICB9XG5cbiAgICAvKiBVc2UgY3JlYXRlSFRNTERvY3VtZW50IGluIGNhc2UgRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAgICBpZiAoIWRvYyB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTkFNRVNQQUNFLCAndGVtcGxhdGUnLCBudWxsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MID0gSVNfRU1QVFlfSU5QVVQgPyAnJyA6IGRpcnR5UGF5bG9hZDtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gU3ludGF4IGVycm9yIGlmIGRpcnR5UGF5bG9hZCBpcyBpbnZhbGlkIHhtbFxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBib2R5ID0gZG9jLmJvZHkgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAgIGlmIChkaXJ0eSAmJiBsZWFkaW5nV2hpdGVzcGFjZSkge1xuICAgICAgYm9keS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGVhZGluZ1doaXRlc3BhY2UpLCBib2R5LmNoaWxkTm9kZXNbMF0gfHwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyogV29yayBvbiB3aG9sZSBkb2N1bWVudCBvciBqdXN0IGl0cyBib2R5ICovXG4gICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5VGFnTmFtZS5jYWxsKGRvYywgV0hPTEVfRE9DVU1FTlQgPyAnaHRtbCcgOiAnYm9keScpWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBXSE9MRV9ET0NVTUVOVCA/IGRvYy5kb2N1bWVudEVsZW1lbnQgOiBib2R5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBfY3JlYXRlSXRlcmF0b3JcbiAgICpcbiAgICogQHBhcmFtICB7RG9jdW1lbnR9IHJvb3QgZG9jdW1lbnQvZnJhZ21lbnQgdG8gY3JlYXRlIGl0ZXJhdG9yIGZvclxuICAgKiBAcmV0dXJuIHtJdGVyYXRvcn0gaXRlcmF0b3IgaW5zdGFuY2VcbiAgICovXG4gIHZhciBfY3JlYXRlSXRlcmF0b3IgPSBmdW5jdGlvbiBfY3JlYXRlSXRlcmF0b3Iocm9vdCkge1xuICAgIHJldHVybiBjcmVhdGVOb2RlSXRlcmF0b3IuY2FsbChyb290Lm93bmVyRG9jdW1lbnQgfHwgcm9vdCwgcm9vdCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19URVhULCBudWxsLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9pc0Nsb2JiZXJlZFxuICAgKlxuICAgKiBAcGFyYW0gIHtOb2RlfSBlbG0gZWxlbWVudCB0byBjaGVjayBmb3IgY2xvYmJlcmluZyBhdHRhY2tzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgY2xvYmJlcmVkLCBmYWxzZSBpZiBzYWZlXG4gICAqL1xuICB2YXIgX2lzQ2xvYmJlcmVkID0gZnVuY3Rpb24gX2lzQ2xvYmJlcmVkKGVsbSkge1xuICAgIGlmIChlbG0gaW5zdGFuY2VvZiBUZXh0IHx8IGVsbSBpbnN0YW5jZW9mIENvbW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVsbS5ub2RlTmFtZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS50ZXh0Q29udGVudCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS5yZW1vdmVDaGlsZCAhPT0gJ2Z1bmN0aW9uJyB8fCAhKGVsbS5hdHRyaWJ1dGVzIGluc3RhbmNlb2YgTmFtZWROb2RlTWFwKSB8fCB0eXBlb2YgZWxtLnJlbW92ZUF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxtLnNldEF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxtLm5hbWVzcGFjZVVSSSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsbS5pbnNlcnRCZWZvcmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogX2lzTm9kZVxuICAgKlxuICAgKiBAcGFyYW0gIHtOb2RlfSBvYmogb2JqZWN0IHRvIGNoZWNrIHdoZXRoZXIgaXQncyBhIERPTSBub2RlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaXMgb2JqZWN0IGlzIGEgRE9NIG5vZGVcbiAgICovXG4gIHZhciBfaXNOb2RlID0gZnVuY3Rpb24gX2lzTm9kZShvYmplY3QpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBOb2RlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihOb2RlKSkgPT09ICdvYmplY3QnID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6IG9iamVjdCAmJiAodHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqZWN0KSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfZXhlY3V0ZUhvb2tcbiAgICogRXhlY3V0ZSB1c2VyIGNvbmZpZ3VyYWJsZSBob29rc1xuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVudHJ5UG9pbnQgIE5hbWUgb2YgdGhlIGhvb2sncyBlbnRyeSBwb2ludFxuICAgKiBAcGFyYW0gIHtOb2RlfSBjdXJyZW50Tm9kZSBub2RlIHRvIHdvcmsgb24gd2l0aCB0aGUgaG9va1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgYWRkaXRpb25hbCBob29rIHBhcmFtZXRlcnNcbiAgICovXG4gIHZhciBfZXhlY3V0ZUhvb2sgPSBmdW5jdGlvbiBfZXhlY3V0ZUhvb2soZW50cnlQb2ludCwgY3VycmVudE5vZGUsIGRhdGEpIHtcbiAgICBpZiAoIWhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXJyYXlGb3JFYWNoKGhvb2tzW2VudHJ5UG9pbnRdLCBmdW5jdGlvbiAoaG9vaykge1xuICAgICAgaG9vay5jYWxsKERPTVB1cmlmeSwgY3VycmVudE5vZGUsIGRhdGEsIENPTkZJRyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9zYW5pdGl6ZUVsZW1lbnRzXG4gICAqXG4gICAqIEBwcm90ZWN0IG5vZGVOYW1lXG4gICAqIEBwcm90ZWN0IHRleHRDb250ZW50XG4gICAqIEBwcm90ZWN0IHJlbW92ZUNoaWxkXG4gICAqXG4gICAqIEBwYXJhbSAgIHtOb2RlfSBjdXJyZW50Tm9kZSB0byBjaGVjayBmb3IgcGVybWlzc2lvbiB0byBleGlzdFxuICAgKiBAcmV0dXJuICB7Qm9vbGVhbn0gdHJ1ZSBpZiBub2RlIHdhcyBraWxsZWQsIGZhbHNlIGlmIGxlZnQgYWxpdmVcbiAgICovXG4gIHZhciBfc2FuaXRpemVFbGVtZW50cyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUVsZW1lbnRzKGN1cnJlbnROb2RlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB2b2lkIDA7XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuXG4gICAgLyogQ2hlY2sgaWYgZWxlbWVudCBpcyBjbG9iYmVyZWQgb3IgY2FuIGNsb2JiZXIgKi9cbiAgICBpZiAoX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qIENoZWNrIGlmIHRhZ25hbWUgY29udGFpbnMgVW5pY29kZSAqL1xuICAgIGlmIChzdHJpbmdNYXRjaChjdXJyZW50Tm9kZS5ub2RlTmFtZSwgL1tcXHUwMDgwLVxcdUZGRkZdLykpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBOb3cgbGV0J3MgY2hlY2sgdGhlIGVsZW1lbnQncyB0eXBlIGFuZCBuYW1lICovXG4gICAgdmFyIHRhZ05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhjdXJyZW50Tm9kZS5ub2RlTmFtZSk7XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVFbGVtZW50JywgY3VycmVudE5vZGUsIHtcbiAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICBhbGxvd2VkVGFnczogQUxMT1dFRF9UQUdTXG4gICAgfSk7XG5cbiAgICAvKiBEZXRlY3QgbVhTUyBhdHRlbXB0cyBhYnVzaW5nIG5hbWVzcGFjZSBjb25mdXNpb24gKi9cbiAgICBpZiAoIV9pc05vZGUoY3VycmVudE5vZGUuZmlyc3RFbGVtZW50Q2hpbGQpICYmICghX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50KSB8fCAhX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkKSkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUudGV4dENvbnRlbnQpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyogTWl0aWdhdGUgYSBwcm9ibGVtIHdpdGggdGVtcGxhdGVzIGluc2lkZSBzZWxlY3QgKi9cbiAgICBpZiAodGFnTmFtZSA9PT0gJ3NlbGVjdCcgJiYgcmVnRXhwVGVzdCgvPHRlbXBsYXRlL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBSZW1vdmUgZWxlbWVudCBpZiBhbnl0aGluZyBmb3JiaWRzIGl0cyBwcmVzZW5jZSAqL1xuICAgIGlmICghQUxMT1dFRF9UQUdTW3RhZ05hbWVdIHx8IEZPUkJJRF9UQUdTW3RhZ05hbWVdKSB7XG4gICAgICAvKiBLZWVwIGNvbnRlbnQgZXhjZXB0IGZvciBiYWQtbGlzdGVkIGVsZW1lbnRzICovXG4gICAgICBpZiAoS0VFUF9DT05URU5UICYmICFGT1JCSURfQ09OVEVOVFNbdGFnTmFtZV0pIHtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKSB8fCBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGdldENoaWxkTm9kZXMoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZXMgJiYgcGFyZW50Tm9kZSkge1xuICAgICAgICAgIHZhciBjaGlsZENvdW50ID0gY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRDb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZU5vZGUoY2hpbGROb2Rlc1tpXSwgdHJ1ZSksIGdldE5leHRTaWJsaW5nKGN1cnJlbnROb2RlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBDaGVjayB3aGV0aGVyIGVsZW1lbnQgaGFzIGEgdmFsaWQgbmFtZXNwYWNlICovXG4gICAgaWYgKGN1cnJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiAhX2NoZWNrVmFsaWROYW1lc3BhY2UoY3VycmVudE5vZGUpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCh0YWdOYW1lID09PSAnbm9zY3JpcHQnIHx8IHRhZ05hbWUgPT09ICdub2VtYmVkJykgJiYgcmVnRXhwVGVzdCgvPFxcL25vKHNjcmlwdHxlbWJlZCkvaSwgY3VycmVudE5vZGUuaW5uZXJIVE1MKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qIFNhbml0aXplIGVsZW1lbnQgY29udGVudCB0byBiZSB0ZW1wbGF0ZS1zYWZlICovXG4gICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUyAmJiBjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgLyogR2V0IHRoZSBlbGVtZW50J3MgdGV4dCBjb250ZW50ICovXG4gICAgICBjb250ZW50ID0gY3VycmVudE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBNVVNUQUNIRV9FWFBSJCQxLCAnICcpO1xuICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgRVJCX0VYUFIkJDEsICcgJyk7XG4gICAgICBpZiAoY3VycmVudE5vZGUudGV4dENvbnRlbnQgIT09IGNvbnRlbnQpIHtcbiAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7IGVsZW1lbnQ6IGN1cnJlbnROb2RlLmNsb25lTm9kZSgpIH0pO1xuICAgICAgICBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfaXNWYWxpZEF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxjVGFnIExvd2VyY2FzZSB0YWcgbmFtZSBvZiBjb250YWluaW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbGNOYW1lIExvd2VyY2FzZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLCBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICB2YXIgX2lzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSkge1xuICAgIC8qIE1ha2Ugc3VyZSBhdHRyaWJ1dGUgY2Fubm90IGNsb2JiZXIgKi9cbiAgICBpZiAoU0FOSVRJWkVfRE9NICYmIChsY05hbWUgPT09ICdpZCcgfHwgbGNOYW1lID09PSAnbmFtZScpICYmICh2YWx1ZSBpbiBkb2N1bWVudCB8fCB2YWx1ZSBpbiBmb3JtRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiBBbGxvdyB2YWxpZCBkYXRhLSogYXR0cmlidXRlczogQXQgbGVhc3Qgb25lIGNoYXJhY3RlciBhZnRlciBcIi1cIlxuICAgICAgICAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjZW1iZWRkaW5nLWN1c3RvbS1ub24tdmlzaWJsZS1kYXRhLXdpdGgtdGhlLWRhdGEtKi1hdHRyaWJ1dGVzKVxuICAgICAgICBYTUwtY29tcGF0aWJsZSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN4bWwtY29tcGF0aWJsZSBhbmQgaHR0cDovL3d3dy53My5vcmcvVFIveG1sLyNkMGU4MDQpXG4gICAgICAgIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgdGhlIHZhbHVlOyBpdCdzIGFsd2F5cyBVUkkgc2FmZS4gKi9cbiAgICBpZiAoQUxMT1dfREFUQV9BVFRSICYmICFGT1JCSURfQVRUUltsY05hbWVdICYmIHJlZ0V4cFRlc3QoREFUQV9BVFRSJCQxLCBsY05hbWUpKSA7IGVsc2UgaWYgKEFMTE9XX0FSSUFfQVRUUiAmJiByZWdFeHBUZXN0KEFSSUFfQVRUUiQkMSwgbGNOYW1lKSkgOyBlbHNlIGlmICghQUxMT1dFRF9BVFRSW2xjTmFtZV0gfHwgRk9SQklEX0FUVFJbbGNOYW1lXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvKiBDaGVjayB2YWx1ZSBpcyBzYWZlLiBGaXJzdCwgaXMgYXR0ciBpbmVydD8gSWYgc28sIGlzIHNhZmUgKi9cbiAgICB9IGVsc2UgaWYgKFVSSV9TQUZFX0FUVFJJQlVURVNbbGNOYW1lXSkgOyBlbHNlIGlmIChyZWdFeHBUZXN0KElTX0FMTE9XRURfVVJJJCQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UkJDEsICcnKSkpIDsgZWxzZSBpZiAoKGxjTmFtZSA9PT0gJ3NyYycgfHwgbGNOYW1lID09PSAneGxpbms6aHJlZicgfHwgbGNOYW1lID09PSAnaHJlZicpICYmIGxjVGFnICE9PSAnc2NyaXB0JyAmJiBzdHJpbmdJbmRleE9mKHZhbHVlLCAnZGF0YTonKSA9PT0gMCAmJiBEQVRBX1VSSV9UQUdTW2xjVGFnXSkgOyBlbHNlIGlmIChBTExPV19VTktOT1dOX1BST1RPQ09MUyAmJiAhcmVnRXhwVGVzdChJU19TQ1JJUFRfT1JfREFUQSQkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJCQxLCAnJykpKSA7IGVsc2UgaWYgKCF2YWx1ZSkgOyBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogX3Nhbml0aXplQXR0cmlidXRlc1xuICAgKlxuICAgKiBAcHJvdGVjdCBhdHRyaWJ1dGVzXG4gICAqIEBwcm90ZWN0IG5vZGVOYW1lXG4gICAqIEBwcm90ZWN0IHJlbW92ZUF0dHJpYnV0ZVxuICAgKiBAcHJvdGVjdCBzZXRBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtICB7Tm9kZX0gY3VycmVudE5vZGUgdG8gc2FuaXRpemVcbiAgICovXG4gIHZhciBfc2FuaXRpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSkge1xuICAgIHZhciBhdHRyID0gdm9pZCAwO1xuICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICB2YXIgbGNOYW1lID0gdm9pZCAwO1xuICAgIHZhciBsID0gdm9pZCAwO1xuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2soJ2JlZm9yZVNhbml0aXplQXR0cmlidXRlcycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gY3VycmVudE5vZGUuYXR0cmlidXRlcztcblxuICAgIC8qIENoZWNrIGlmIHdlIGhhdmUgYXR0cmlidXRlczsgaWYgbm90IHdlIG1pZ2h0IGhhdmUgYSB0ZXh0IG5vZGUgKi9cblxuICAgIGlmICghYXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBob29rRXZlbnQgPSB7XG4gICAgICBhdHRyTmFtZTogJycsXG4gICAgICBhdHRyVmFsdWU6ICcnLFxuICAgICAga2VlcEF0dHI6IHRydWUsXG4gICAgICBhbGxvd2VkQXR0cmlidXRlczogQUxMT1dFRF9BVFRSXG4gICAgfTtcbiAgICBsID0gYXR0cmlidXRlcy5sZW5ndGg7XG5cbiAgICAvKiBHbyBiYWNrd2FyZHMgb3ZlciBhbGwgYXR0cmlidXRlczsgc2FmZWx5IHJlbW92ZSBiYWQgb25lcyAqL1xuICAgIHdoaWxlIChsLS0pIHtcbiAgICAgIGF0dHIgPSBhdHRyaWJ1dGVzW2xdO1xuICAgICAgdmFyIF9hdHRyID0gYXR0cixcbiAgICAgICAgICBuYW1lID0gX2F0dHIubmFtZSxcbiAgICAgICAgICBuYW1lc3BhY2VVUkkgPSBfYXR0ci5uYW1lc3BhY2VVUkk7XG5cbiAgICAgIHZhbHVlID0gc3RyaW5nVHJpbShhdHRyLnZhbHVlKTtcbiAgICAgIGxjTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKG5hbWUpO1xuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBob29rRXZlbnQuYXR0ck5hbWUgPSBsY05hbWU7XG4gICAgICBob29rRXZlbnQuYXR0clZhbHVlID0gdmFsdWU7XG4gICAgICBob29rRXZlbnQua2VlcEF0dHIgPSB0cnVlO1xuICAgICAgaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIgPSB1bmRlZmluZWQ7IC8vIEFsbG93cyBkZXZlbG9wZXJzIHRvIHNlZSB0aGlzIGlzIGEgcHJvcGVydHkgdGhleSBjYW4gc2V0XG4gICAgICBfZXhlY3V0ZUhvb2soJ3Vwb25TYW5pdGl6ZUF0dHJpYnV0ZScsIGN1cnJlbnROb2RlLCBob29rRXZlbnQpO1xuICAgICAgdmFsdWUgPSBob29rRXZlbnQuYXR0clZhbHVlO1xuICAgICAgLyogRGlkIHRoZSBob29rcyBhcHByb3ZlIG9mIHRoZSBhdHRyaWJ1dGU/ICovXG4gICAgICBpZiAoaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFJlbW92ZSBhdHRyaWJ1dGUgKi9cbiAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuXG4gICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cbiAgICAgIGlmICghaG9va0V2ZW50LmtlZXBBdHRyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBXb3JrIGFyb3VuZCBhIHNlY3VyaXR5IGlzc3VlIGluIGpRdWVyeSAzLjAgKi9cbiAgICAgIGlmIChyZWdFeHBUZXN0KC9cXC8+L2ksIHZhbHVlKSkge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFNhbml0aXplIGF0dHJpYnV0ZSBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cbiAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBNVVNUQUNIRV9FWFBSJCQxLCAnICcpO1xuICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIEVSQl9FWFBSJCQxLCAnICcpO1xuICAgICAgfVxuXG4gICAgICAvKiBJcyBgdmFsdWVgIHZhbGlkIGZvciB0aGlzIGF0dHJpYnV0ZT8gKi9cbiAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAgIGlmICghX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBIYW5kbGUgaW52YWxpZCBkYXRhLSogYXR0cmlidXRlIHNldCBieSB0cnktY2F0Y2hpbmcgaXQgKi9cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBGYWxsYmFjayB0byBzZXRBdHRyaWJ1dGUoKSBmb3IgYnJvd3Nlci11bnJlY29nbml6ZWQgbmFtZXNwYWNlcyBlLmcuIFwieC1zY2hlbWFcIi4gKi9cbiAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlQb3AoRE9NUHVyaWZ5LnJlbW92ZWQpO1xuICAgICAgfSBjYXRjaCAoXykge31cbiAgICB9XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdhZnRlclNhbml0aXplQXR0cmlidXRlcycsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogX3Nhbml0aXplU2hhZG93RE9NXG4gICAqXG4gICAqIEBwYXJhbSAge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdtZW50IHRvIGl0ZXJhdGUgb3ZlciByZWN1cnNpdmVseVxuICAgKi9cbiAgdmFyIF9zYW5pdGl6ZVNoYWRvd0RPTSA9IGZ1bmN0aW9uIF9zYW5pdGl6ZVNoYWRvd0RPTShmcmFnbWVudCkge1xuICAgIHZhciBzaGFkb3dOb2RlID0gdm9pZCAwO1xuICAgIHZhciBzaGFkb3dJdGVyYXRvciA9IF9jcmVhdGVJdGVyYXRvcihmcmFnbWVudCk7XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZVNoYWRvd0RPTScsIGZyYWdtZW50LCBudWxsKTtcblxuICAgIHdoaWxlIChzaGFkb3dOb2RlID0gc2hhZG93SXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVTaGFkb3dOb2RlJywgc2hhZG93Tm9kZSwgbnVsbCk7XG5cbiAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICBpZiAoX3Nhbml0aXplRWxlbWVudHMoc2hhZG93Tm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIERlZXAgc2hhZG93IERPTSBkZXRlY3RlZCAqL1xuICAgICAgaWYgKHNoYWRvd05vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKHNoYWRvd05vZGUuY29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMsIHNhbml0aXplIGlmIG5lY2Vzc2FyeSAqL1xuICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhzaGFkb3dOb2RlKTtcbiAgICB9XG5cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdhZnRlclNhbml0aXplU2hhZG93RE9NJywgZnJhZ21lbnQsIG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTYW5pdGl6ZVxuICAgKiBQdWJsaWMgbWV0aG9kIHByb3ZpZGluZyBjb3JlIHNhbml0YXRpb24gZnVuY3Rpb25hbGl0eVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOb2RlfSBkaXJ0eSBzdHJpbmcgb3IgRE9NIG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBET01QdXJpZnkuc2FuaXRpemUgPSBmdW5jdGlvbiAoZGlydHksIGNmZykge1xuICAgIHZhciBib2R5ID0gdm9pZCAwO1xuICAgIHZhciBpbXBvcnRlZE5vZGUgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnROb2RlID0gdm9pZCAwO1xuICAgIHZhciBvbGROb2RlID0gdm9pZCAwO1xuICAgIHZhciByZXR1cm5Ob2RlID0gdm9pZCAwO1xuICAgIC8qIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgc3RyaW5nIHRvIHNhbml0aXplLlxuICAgICAgRE8gTk9UIHJldHVybiBlYXJseSwgYXMgdGhpcyB3aWxsIHJldHVybiB0aGUgd3JvbmcgdHlwZSBpZlxuICAgICAgdGhlIHVzZXIgaGFzIHJlcXVlc3RlZCBhIERPTSBvYmplY3QgcmF0aGVyIHRoYW4gYSBzdHJpbmcgKi9cbiAgICBJU19FTVBUWV9JTlBVVCA9ICFkaXJ0eTtcbiAgICBpZiAoSVNfRU1QVFlfSU5QVVQpIHtcbiAgICAgIGRpcnR5ID0gJzwhLS0+JztcbiAgICB9XG5cbiAgICAvKiBTdHJpbmdpZnksIGluIGNhc2UgZGlydHkgaXMgYW4gb2JqZWN0ICovXG4gICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycgJiYgIV9pc05vZGUoZGlydHkpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVnYXRlZC1jb25kaXRpb25cbiAgICAgIGlmICh0eXBlb2YgZGlydHkudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCd0b1N0cmluZyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlydHkgPSBkaXJ0eS50b1N0cmluZygpO1xuICAgICAgICBpZiAodHlwZW9mIGRpcnR5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgnZGlydHkgaXMgbm90IGEgc3RyaW5nLCBhYm9ydGluZycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogQ2hlY2sgd2UgY2FuIHJ1bi4gT3RoZXJ3aXNlIGZhbGwgYmFjayBvciBpZ25vcmUgKi9cbiAgICBpZiAoIURPTVB1cmlmeS5pc1N1cHBvcnRlZCkge1xuICAgICAgaWYgKF90eXBlb2Yod2luZG93LnRvU3RhdGljSFRNTCkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB3aW5kb3cudG9TdGF0aWNIVE1MID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy50b1N0YXRpY0hUTUwoZGlydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9pc05vZGUoZGlydHkpKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy50b1N0YXRpY0hUTUwoZGlydHkub3V0ZXJIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuXG4gICAgLyogQXNzaWduIGNvbmZpZyB2YXJzICovXG4gICAgaWYgKCFTRVRfQ09ORklHKSB7XG4gICAgICBfcGFyc2VDb25maWcoY2ZnKTtcbiAgICB9XG5cbiAgICAvKiBDbGVhbiB1cCByZW1vdmVkIGVsZW1lbnRzICovXG4gICAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcblxuICAgIC8qIENoZWNrIGlmIGRpcnR5IGlzIGNvcnJlY3RseSB0eXBlZCBmb3IgSU5fUExBQ0UgKi9cbiAgICBpZiAodHlwZW9mIGRpcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgSU5fUExBQ0UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoSU5fUExBQ0UpIDsgZWxzZSBpZiAoZGlydHkgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAvKiBJZiBkaXJ0eSBpcyBhIERPTSBlbGVtZW50LCBhcHBlbmQgdG8gYW4gZW1wdHkgZG9jdW1lbnQgdG8gYXZvaWRcbiAgICAgICAgIGVsZW1lbnRzIGJlaW5nIHN0cmlwcGVkIGJ5IHRoZSBwYXJzZXIgKi9cbiAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KCc8IS0tLS0+Jyk7XG4gICAgICBpbXBvcnRlZE5vZGUgPSBib2R5Lm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShkaXJ0eSwgdHJ1ZSk7XG4gICAgICBpZiAoaW1wb3J0ZWROb2RlLm5vZGVUeXBlID09PSAxICYmIGltcG9ydGVkTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIC8qIE5vZGUgaXMgYWxyZWFkeSBhIGJvZHksIHVzZSBhcyBpcyAqL1xuICAgICAgICBib2R5ID0gaW1wb3J0ZWROb2RlO1xuICAgICAgfSBlbHNlIGlmIChpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICBib2R5ID0gaW1wb3J0ZWROb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGltcG9ydGVkTm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIEV4aXQgZGlyZWN0bHkgaWYgd2UgaGF2ZSBub3RoaW5nIHRvIGRvICovXG4gICAgICBpZiAoIVJFVFVSTl9ET00gJiYgIVNBRkVfRk9SX1RFTVBMQVRFUyAmJiAhV0hPTEVfRE9DVU1FTlQgJiZcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgZGlydHkuaW5kZXhPZignPCcpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1c3RlZFR5cGVzUG9saWN5ICYmIFJFVFVSTl9UUlVTVEVEX1RZUEUgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgIH1cblxuICAgICAgLyogSW5pdGlhbGl6ZSB0aGUgZG9jdW1lbnQgdG8gd29yayBvbiAqL1xuICAgICAgYm9keSA9IF9pbml0RG9jdW1lbnQoZGlydHkpO1xuXG4gICAgICAvKiBDaGVjayB3ZSBoYXZlIGEgRE9NIG5vZGUgZnJvbSB0aGUgZGF0YSAqL1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiBSRVRVUk5fRE9NID8gbnVsbCA6IGVtcHR5SFRNTDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBSZW1vdmUgZmlyc3QgZWxlbWVudCBub2RlIChvdXJzKSBpZiBGT1JDRV9CT0RZIGlzIHNldCAqL1xuICAgIGlmIChib2R5ICYmIEZPUkNFX0JPRFkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShib2R5LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIC8qIEdldCBub2RlIGl0ZXJhdG9yICovXG4gICAgdmFyIG5vZGVJdGVyYXRvciA9IF9jcmVhdGVJdGVyYXRvcihJTl9QTEFDRSA/IGRpcnR5IDogYm9keSk7XG5cbiAgICAvKiBOb3cgc3RhcnQgaXRlcmF0aW5nIG92ZXIgdGhlIGNyZWF0ZWQgZG9jdW1lbnQgKi9cbiAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgLyogRml4IElFJ3Mgc3RyYW5nZSBiZWhhdmlvciB3aXRoIG1hbmlwdWxhdGVkIHRleHROb2RlcyAjODkgKi9cbiAgICAgIGlmIChjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMyAmJiBjdXJyZW50Tm9kZSA9PT0gb2xkTm9kZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLyogU2FuaXRpemUgdGFncyBhbmQgZWxlbWVudHMgKi9cbiAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFNoYWRvdyBET00gZGV0ZWN0ZWQsIHNhbml0aXplIGl0ICovXG4gICAgICBpZiAoY3VycmVudE5vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKGN1cnJlbnROb2RlLmNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICAvKiBDaGVjayBhdHRyaWJ1dGVzLCBzYW5pdGl6ZSBpZiBuZWNlc3NhcnkgKi9cbiAgICAgIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoY3VycmVudE5vZGUpO1xuXG4gICAgICBvbGROb2RlID0gY3VycmVudE5vZGU7XG4gICAgfVxuXG4gICAgb2xkTm9kZSA9IG51bGw7XG5cbiAgICAvKiBJZiB3ZSBzYW5pdGl6ZWQgYGRpcnR5YCBpbi1wbGFjZSwgcmV0dXJuIGl0LiAqL1xuICAgIGlmIChJTl9QTEFDRSkge1xuICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cblxuICAgIC8qIFJldHVybiBzYW5pdGl6ZWQgc3RyaW5nIG9yIERPTSAqL1xuICAgIGlmIChSRVRVUk5fRE9NKSB7XG4gICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICByZXR1cm5Ob2RlID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudC5jYWxsKGJvZHkub3duZXJEb2N1bWVudCk7XG5cbiAgICAgICAgd2hpbGUgKGJvZHkuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1hcHBlbmRcbiAgICAgICAgICByZXR1cm5Ob2RlLmFwcGVuZENoaWxkKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybk5vZGUgPSBib2R5O1xuICAgICAgfVxuXG4gICAgICBpZiAoUkVUVVJOX0RPTV9JTVBPUlQpIHtcbiAgICAgICAgLypcbiAgICAgICAgICBBZG9wdE5vZGUoKSBpcyBub3QgdXNlZCBiZWNhdXNlIGludGVybmFsIHN0YXRlIGlzIG5vdCByZXNldFxuICAgICAgICAgIChlLmcuIHRoZSBwYXN0IG5hbWVzIG1hcCBvZiBhIEhUTUxGb3JtRWxlbWVudCksIHRoaXMgaXMgc2FmZVxuICAgICAgICAgIGluIHRoZW9yeSBidXQgd2Ugd291bGQgcmF0aGVyIG5vdCByaXNrIGFub3RoZXIgYXR0YWNrIHZlY3Rvci5cbiAgICAgICAgICBUaGUgc3RhdGUgdGhhdCBpcyBjbG9uZWQgYnkgaW1wb3J0Tm9kZSgpIGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgICAgICAgIGJ5IHRoZSBzcGVjcy5cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuTm9kZSA9IGltcG9ydE5vZGUuY2FsbChvcmlnaW5hbERvY3VtZW50LCByZXR1cm5Ob2RlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHVybk5vZGU7XG4gICAgfVxuXG4gICAgdmFyIHNlcmlhbGl6ZWRIVE1MID0gV0hPTEVfRE9DVU1FTlQgPyBib2R5Lm91dGVySFRNTCA6IGJvZHkuaW5uZXJIVE1MO1xuXG4gICAgLyogU2FuaXRpemUgZmluYWwgc3RyaW5nIHRlbXBsYXRlLXNhZmUgKi9cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICBzZXJpYWxpemVkSFRNTCA9IHN0cmluZ1JlcGxhY2Uoc2VyaWFsaXplZEhUTUwsIE1VU1RBQ0hFX0VYUFIkJDEsICcgJyk7XG4gICAgICBzZXJpYWxpemVkSFRNTCA9IHN0cmluZ1JlcGxhY2Uoc2VyaWFsaXplZEhUTUwsIEVSQl9FWFBSJCQxLCAnICcpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHNlcmlhbGl6ZWRIVE1MKSA6IHNlcmlhbGl6ZWRIVE1MO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHNldCB0aGUgY29uZmlndXJhdGlvbiBvbmNlXG4gICAqIHNldENvbmZpZ1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBET01QdXJpZnkuc2V0Q29uZmlnID0gZnVuY3Rpb24gKGNmZykge1xuICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgIFNFVF9DT05GSUcgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHJlbW92ZSB0aGUgY29uZmlndXJhdGlvblxuICAgKiBjbGVhckNvbmZpZ1xuICAgKlxuICAgKi9cbiAgRE9NUHVyaWZ5LmNsZWFyQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIENPTkZJRyA9IG51bGw7XG4gICAgU0VUX0NPTkZJRyA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kIHRvIGNoZWNrIGlmIGFuIGF0dHJpYnV0ZSB2YWx1ZSBpcyB2YWxpZC5cbiAgICogVXNlcyBsYXN0IHNldCBjb25maWcsIGlmIGFueS4gT3RoZXJ3aXNlLCB1c2VzIGNvbmZpZyBkZWZhdWx0cy5cbiAgICogaXNWYWxpZEF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUYWcgbmFtZSBvZiBjb250YWluaW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXR0ciBBdHRyaWJ1dGUgbmFtZS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLiBPdGhlcndpc2UsIHJldHVybnMgZmFsc2UuXG4gICAqL1xuICBET01QdXJpZnkuaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHIsIHZhbHVlKSB7XG4gICAgLyogSW5pdGlhbGl6ZSBzaGFyZWQgY29uZmlnIHZhcnMgaWYgbmVjZXNzYXJ5LiAqL1xuICAgIGlmICghQ09ORklHKSB7XG4gICAgICBfcGFyc2VDb25maWcoe30pO1xuICAgIH1cblxuICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKHRhZyk7XG4gICAgdmFyIGxjTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGF0dHIpO1xuICAgIHJldHVybiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZEhvb2tcbiAgICogUHVibGljIG1ldGhvZCB0byBhZGQgRE9NUHVyaWZ5IGhvb2tzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRyeVBvaW50IGVudHJ5IHBvaW50IGZvciB0aGUgaG9vayB0byBhZGRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va0Z1bmN0aW9uIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICovXG4gIERPTVB1cmlmeS5hZGRIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQsIGhvb2tGdW5jdGlvbikge1xuICAgIGlmICh0eXBlb2YgaG9va0Z1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaG9va3NbZW50cnlQb2ludF0gPSBob29rc1tlbnRyeVBvaW50XSB8fCBbXTtcbiAgICBhcnJheVB1c2goaG9va3NbZW50cnlQb2ludF0sIGhvb2tGdW5jdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZUhvb2tcbiAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYSBET01QdXJpZnkgaG9vayBhdCBhIGdpdmVuIGVudHJ5UG9pbnRcbiAgICogKHBvcHMgaXQgZnJvbSB0aGUgc3RhY2sgb2YgaG9va3MgaWYgbW9yZSBhcmUgcHJlc2VudClcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVudHJ5UG9pbnQgZW50cnkgcG9pbnQgZm9yIHRoZSBob29rIHRvIHJlbW92ZVxuICAgKi9cbiAgRE9NUHVyaWZ5LnJlbW92ZUhvb2sgPSBmdW5jdGlvbiAoZW50cnlQb2ludCkge1xuICAgIGlmIChob29rc1tlbnRyeVBvaW50XSkge1xuICAgICAgYXJyYXlQb3AoaG9va3NbZW50cnlQb2ludF0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlSG9va3NcbiAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYWxsIERPTVB1cmlmeSBob29rcyBhdCBhIGdpdmVuIGVudHJ5UG9pbnRcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBlbnRyeVBvaW50IGVudHJ5IHBvaW50IGZvciB0aGUgaG9va3MgdG8gcmVtb3ZlXG4gICAqL1xuICBET01QdXJpZnkucmVtb3ZlSG9va3MgPSBmdW5jdGlvbiAoZW50cnlQb2ludCkge1xuICAgIGlmIChob29rc1tlbnRyeVBvaW50XSkge1xuICAgICAgaG9va3NbZW50cnlQb2ludF0gPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZUFsbEhvb2tzXG4gICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIGFsbCBET01QdXJpZnkgaG9va3NcbiAgICpcbiAgICovXG4gIERPTVB1cmlmeS5yZW1vdmVBbGxIb29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBob29rcyA9IHt9O1xuICB9O1xuXG4gIHJldHVybiBET01QdXJpZnk7XG59XG5cbnZhciBwdXJpZnkgPSBjcmVhdGVET01QdXJpZnkoKTtcblxudmFyIENBTl9CRV9XSElURV9UQUdfTElTVCA9IFsnaWZyYW1lJywgJ2VtYmVkJ107XG52YXIgd2hpdGVUYWdMaXN0ID0gW107XG5mdW5jdGlvbiByZWdpc3RlclRhZ1doaXRlbGlzdElmUG9zc2libGUodGFnTmFtZSkge1xuICAgIGlmIChpbmNsdWRlcyhDQU5fQkVfV0hJVEVfVEFHX0xJU1QsIHRhZ05hbWUpKSB7XG4gICAgICAgIHdoaXRlVGFnTGlzdC5wdXNoKHRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FuaXRpemVIVE1MKGh0bWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHVyaWZ5LnNhbml0aXplKGh0bWwsIF9fYXNzaWduJDEoeyBBRERfVEFHUzogd2hpdGVUYWdMaXN0LCBBRERfQVRUUjogWydyZWwnLCAndGFyZ2V0JywgJ2hyZWZsYW5nJywgJ3R5cGUnXSwgRk9SQklEX1RBR1M6IFtcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICAnc2NyaXB0JyxcbiAgICAgICAgICAgICd0ZXh0YXJlYScsXG4gICAgICAgICAgICAnZm9ybScsXG4gICAgICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgICAgICdzZWxlY3QnLFxuICAgICAgICAgICAgJ21ldGEnLFxuICAgICAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgICAgICdsaW5rJyxcbiAgICAgICAgICAgICd0aXRsZScsXG4gICAgICAgICAgICAnb2JqZWN0JyxcbiAgICAgICAgICAgICdiYXNlJyxcbiAgICAgICAgXSB9LCBvcHRpb25zKSk7XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuSFRNTChub2RlLCB0eXBlTmFtZSkge1xuICAgIHJldHVybiBub2RlXG4gICAgICAgIC5saXRlcmFsLnJlcGxhY2UobmV3IFJlZ0V4cChcIig8XFxcXHMqXCIgKyB0eXBlTmFtZSArIFwiW14+XSo+KXwoPC9cIiArIHR5cGVOYW1lICsgXCJcXFxccypbPl0pXCIsICdpZycpLCAnJylcbiAgICAgICAgLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIGdldEhUTUxBdHRyc0J5SFRNTFN0cmluZyhodG1sKSB7XG4gICAgaHRtbCA9IGh0bWwubWF0Y2gocmVIVE1MVGFnKVswXTtcbiAgICB2YXIgYXR0cnMgPSBodG1sLm1hdGNoKG5ldyBSZWdFeHAoQVRUUklCVVRFJDEsICdnJykpO1xuICAgIHJldHVybiBhdHRyc1xuICAgICAgICA/IGF0dHJzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBhdHRyLnRyaW0oKS5zcGxpdCgnPScpLCBuYW1lID0gX2FbMF0sIHZhbHVlcyA9IF9hLnNsaWNlKDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhY2NbbmFtZV0gPSB2YWx1ZXMuam9pbignPScpLnJlcGxhY2UoLyd8XCIvZywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KVxuICAgICAgICA6IHt9O1xufVxuZnVuY3Rpb24gZ2V0SFRNTEF0dHJzKGRvbSkge1xuICAgIHJldHVybiB0b0FycmF5XzEoZG9tLmF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyKSB7XG4gICAgICAgIGFjY1thdHRyLm5vZGVOYW1lXSA9IGF0dHIubm9kZVZhbHVlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplRE9NKG5vZGUsIHR5cGVOYW1lLCBzYW5pdGl6ZXIsIHd3VG9ET01BZGFwdG9yKSB7XG4gICAgdmFyIGRvbSA9IHd3VG9ET01BZGFwdG9yLmdldFRvRE9NTm9kZSh0eXBlTmFtZSkobm9kZSk7XG4gICAgdmFyIGh0bWwgPSBzYW5pdGl6ZXIoZG9tLm91dGVySFRNTCk7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgIGRvbSA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIHZhciBodG1sQXR0cnMgPSBnZXRIVE1MQXR0cnMoZG9tKTtcbiAgICByZXR1cm4geyBkb206IGRvbSwgaHRtbEF0dHJzOiBodG1sQXR0cnMgfTtcbn1cbnZhciBzY2hlbWFGYWN0b3J5ID0ge1xuICAgIGh0bWxCbG9jazogZnVuY3Rpb24gKHR5cGVOYW1lLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdG9tOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudDogJ2Jsb2NrKycsXG4gICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgaHRtbEF0dHJzOiB7IGRlZmF1bHQ6IHt9IH0sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5IVE1MOiB7IGRlZmF1bHQ6ICcnIH0sXG4gICAgICAgICAgICAgICAgaHRtbEJsb2NrOiB7IGRlZmF1bHQ6IHRydWUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEF0dHJzOiBnZXRIVE1MQXR0cnMoZG9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkhUTUw6IGRvbS5pbm5lckhUTUwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gc2FuaXRpemVET00obm9kZSwgdHlwZU5hbWUsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpLCBkb20gPSBfYS5kb20sIGh0bWxBdHRycyA9IF9hLmh0bWxBdHRycztcbiAgICAgICAgICAgICAgICBodG1sQXR0cnMuY2xhc3MgPSBodG1sQXR0cnMuY2xhc3MgPyBodG1sQXR0cnMuY2xhc3MgKyBcIiBodG1sLWJsb2NrXCIgOiAnaHRtbC1ibG9jayc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkkMShbdHlwZU5hbWUsIGh0bWxBdHRyc10sIHRvQXJyYXlfMShkb20uY2hpbGROb2RlcykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGh0bWxJbmxpbmU6IGZ1bmN0aW9uICh0eXBlTmFtZSwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBodG1sQXR0cnM6IHsgZGVmYXVsdDoge30gfSxcbiAgICAgICAgICAgICAgICBodG1sSW5saW5lOiB7IGRlZmF1bHQ6IHRydWUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0eXBlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEF0dHJzOiBnZXRIVE1MQXR0cnMoZG9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbEF0dHJzID0gc2FuaXRpemVET00obm9kZSwgdHlwZU5hbWUsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpLmh0bWxBdHRycztcbiAgICAgICAgICAgICAgICByZXR1cm4gW3R5cGVOYW1lLCBodG1sQXR0cnMsIDBdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUhUTUxTY2hlbWFNYXAoY29udmVydG9yTWFwLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKSB7XG4gICAgdmFyIGh0bWxTY2hlbWFNYXAgPSB7IG5vZGVzOiB7fSwgbWFya3M6IHt9IH07XG4gICAgWydodG1sQmxvY2snLCAnaHRtbElubGluZSddLmZvckVhY2goZnVuY3Rpb24gKGh0bWxUeXBlKSB7XG4gICAgICAgIGlmIChjb252ZXJ0b3JNYXBbaHRtbFR5cGVdKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb252ZXJ0b3JNYXBbaHRtbFR5cGVdKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFR5cGUgPSBodG1sVHlwZSA9PT0gJ2h0bWxCbG9jaycgPyAnbm9kZXMnIDogJ21hcmtzJztcbiAgICAgICAgICAgICAgICAvLyByZWdpc3RlciB0YWcgd2hpdGUgbGlzdCBmb3IgcHJldmVudGluZyB0byByZW1vdmUgdGhlIGh0bWwgaW4gc2FuaXRpemVyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJUYWdXaGl0ZWxpc3RJZlBvc3NpYmxlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGh0bWxTY2hlbWFNYXBbdGFyZ2V0VHlwZV1bdHlwZV0gPSBzY2hlbWFGYWN0b3J5W2h0bWxUeXBlXSh0eXBlLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGh0bWxTY2hlbWFNYXA7XG59XG5cbnZhciByZUNsb3NlVGFnID0gL15cXHMqPFxccypcXC8vO1xudmFyIGJhc2VDb252ZXJ0b3JzID0ge1xuICAgIHBhcmFncmFwaDogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBvcmlnaW4gPSBfYS5vcmlnaW4sIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5ub2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAncCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW4oKTtcbiAgICB9LFxuICAgIHNvZnRicmVhazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGlzUHJldk5vZGVIVE1MID0gbm9kZS5wcmV2ICYmIG5vZGUucHJldi50eXBlID09PSAnaHRtbElubGluZSc7XG4gICAgICAgIHZhciBpc1ByZXZCUiA9IGlzUHJldk5vZGVIVE1MICYmIC88YnIgP1xcLz8+Ly50ZXN0KG5vZGUucHJldi5saXRlcmFsKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBpc1ByZXZCUiA/ICdcXG4nIDogJzxicj5cXG4nO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGNvbnRlbnQgfTtcbiAgICB9LFxuICAgIGl0ZW06IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChub2RlLmxpc3REYXRhLnRhc2spIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzWydkYXRhLXRhc2snXSA9ICcnO1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgndGFzay1saXN0LWl0ZW0nKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0RGF0YS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnY2hlY2tlZCcpO1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzWydkYXRhLXRhc2stY2hlY2tlZCddID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzOiBjbGFzc05hbWVzLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHsgJ2RhdGEtYmFja3RpY2tzJzogU3RyaW5nKG5vZGUudGlja0NvdW50KSB9O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdjb2RlJywgYXR0cmlidXRlczogYXR0cmlidXRlcyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF9hID0gbm9kZSwgZmVuY2VMZW5ndGggPSBfYS5mZW5jZUxlbmd0aCwgaW5mbyA9IF9hLmluZm87XG4gICAgICAgIHZhciBpbmZvV29yZHMgPSBpbmZvID8gaW5mby5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgICAgIHZhciBwcmVDbGFzc2VzID0gW107XG4gICAgICAgIHZhciBjb2RlQXR0cnMgPSB7fTtcbiAgICAgICAgaWYgKGZlbmNlTGVuZ3RoID4gMykge1xuICAgICAgICAgICAgY29kZUF0dHJzWydkYXRhLWJhY2t0aWNrcyddID0gZmVuY2VMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm9Xb3Jkcy5sZW5ndGggPiAwICYmIGluZm9Xb3Jkc1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGFuZyA9IGluZm9Xb3Jkc1swXTtcbiAgICAgICAgICAgIHByZUNsYXNzZXMucHVzaChcImxhbmctXCIgKyBsYW5nKTtcbiAgICAgICAgICAgIGNvZGVBdHRyc1snZGF0YS1sYW5ndWFnZSddID0gbGFuZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdwcmUnLCBjbGFzc05hbWVzOiBwcmVDbGFzc2VzIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2NvZGUnLCBhdHRyaWJ1dGVzOiBjb2RlQXR0cnMgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2NvZGUnIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdwcmUnIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBjdXN0b21JbmxpbmU6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgb3JpZ2luID0gX2Eub3JpZ2luLCBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBza2lwQ2hpbGRyZW4gPSBfYS5za2lwQ2hpbGRyZW47XG4gICAgICAgIHZhciBpbmZvID0gbm9kZS5pbmZvO1xuICAgICAgICBpZiAoaW5mby5pbmRleE9mKCd3aWRnZXQnKSAhPT0gLTEgJiYgZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHNraXBDaGlsZHJlbigpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBnZXRXaWRnZXRDb250ZW50KG5vZGUpO1xuICAgICAgICAgICAgdmFyIGh0bWxJbmxpbmUgPSB3aWRnZXRUb0RPTShpbmZvLCBjb250ZW50KS5vdXRlckhUTUw7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnc3BhbicsIGNsYXNzTmFtZXM6IFsndHVpLXdpZGdldCddIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGh0bWxJbmxpbmUgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdzcGFuJyB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luKCk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRIVE1MUmVuZGVyQ29udmVydG9ycyhsaW5rQXR0cmlidXRlcywgY3VzdG9tQ29udmVydG9ycykge1xuICAgIHZhciBjb252ZXJ0b3JzID0gX19hc3NpZ24kMSh7fSwgYmFzZUNvbnZlcnRvcnMpO1xuICAgIGlmIChsaW5rQXR0cmlidXRlcykge1xuICAgICAgICBjb252ZXJ0b3JzLmxpbmsgPSBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBvcmlnaW4gPSBfYS5vcmlnaW47XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3JpZ2luKCk7XG4gICAgICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXR0cmlidXRlcyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgcmVzdWx0LmF0dHJpYnV0ZXMpLCBsaW5rQXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY3VzdG9tQ29udmVydG9ycykge1xuICAgICAgICBPYmplY3Qua2V5cyhjdXN0b21Db252ZXJ0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlVHlwZSkge1xuICAgICAgICAgICAgdmFyIG9yZ0NvbnZlcnRvciA9IGNvbnZlcnRvcnNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGN1c3RvbUNvbnZlcnRvcnNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgaWYgKG9yZ0NvbnZlcnRvciAmJiBpc0Z1bmN0aW9uXzEoY3VzdG9tQ29udmVydG9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRvcnNbbm9kZVR5cGVdID0gZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0NvbnRleHQgPSBfX2Fzc2lnbiQxKHt9LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dC5vcmlnaW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmdDb252ZXJ0b3Iobm9kZSwgY29udGV4dCk7IH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21Db252ZXJ0b3Iobm9kZSwgbmV3Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluY2x1ZGVzKFsnaHRtbEJsb2NrJywgJ2h0bWxJbmxpbmUnXSwgbm9kZVR5cGUpICYmICFpc0Z1bmN0aW9uXzEoY3VzdG9tQ29udmVydG9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRvcnNbbm9kZVR5cGVdID0gZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBub2RlLmxpdGVyYWwubWF0Y2gocmVIVE1MVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb290SFRNTCA9IG1hdGNoZWRbMF0sIG9wZW5UYWdOYW1lID0gbWF0Y2hlZFsxXSwgY2xvc2VUYWdOYW1lID0gbWF0Y2hlZFszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IChvcGVuVGFnTmFtZSB8fCBjbG9zZVRhZ05hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbENvbnZlcnRvciA9IGN1c3RvbUNvbnZlcnRvclt0eXBlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5IVE1MID0gZ2V0Q2hpbGRyZW5IVE1MKG5vZGUsIHR5cGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodG1sQ29udmVydG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29weSBmb3IgcHJldmVudGluZyB0byBvdmVyd3JpdGUgdGhlIG9yaWdpbmlhbCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gX19hc3NpZ24kMSh7fSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5hdHRycyA9IGdldEhUTUxBdHRyc0J5SFRNTFN0cmluZyhyb290SFRNTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5jaGlsZHJlbkhUTUwgPSBjaGlsZHJlbkhUTUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS50eXBlID0gdHlwZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbnRlcmluZyA9ICFyZUNsb3NlVGFnLnRlc3Qobm9kZS5saXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHRtbENvbnZlcnRvcihuZXdOb2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5vcmlnaW4oKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udmVydG9yc1tub2RlVHlwZV0gPSBjdXN0b21Db252ZXJ0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydG9ycztcbn1cblxudmFyIG5lc3RhYmxlVHlwZXMgPSBbJ2xpc3QnLCAnaXRlbScsICdibG9ja1F1b3RlJ107XG52YXIgbmVzdGFibGVUYWdOYW1lcyA9IFsnVUwnLCAnT0wnLCAnQkxPQ0tRVU9URSddO1xuZnVuY3Rpb24gaXNCbGFua0xpbmUoZG9jLCBpbmRleCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcG1Ob2RlID0gZG9jLmNoaWxkKGluZGV4KTtcbiAgICByZXR1cm4gIXBtTm9kZS5jaGlsZENvdW50IHx8IChwbU5vZGUuY2hpbGRDb3VudCA9PT0gMSAmJiAhKChfYSA9IHBtTm9kZS5maXJzdENoaWxkLnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmltKCkpKTtcbn1cbmZ1bmN0aW9uIGdldEVkaXRvclJhbmdlSGVpZ2h0SW5mbyhkb2MsIG1kTm9kZSwgY2hpbGRyZW4pIHtcbiAgICB2YXIgc3RhcnQgPSBnZXRNZFN0YXJ0TGluZShtZE5vZGUpIC0gMTtcbiAgICB2YXIgZW5kID0gZ2V0TWRFbmRMaW5lKG1kTm9kZSkgLSAxO1xuICAgIHZhciByZWN0ID0gY2hpbGRyZW5bc3RhcnRdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBoZWlnaHQgPSBjaGlsZHJlbltlbmRdLm9mZnNldFRvcCAtXG4gICAgICAgIGNoaWxkcmVuW3N0YXJ0XS5vZmZzZXRUb3AgK1xuICAgICAgICBjaGlsZHJlbltlbmRdLmNsaWVudEhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IGhlaWdodCA8PSAwXG4gICAgICAgICAgICA/IGNoaWxkcmVuW3N0YXJ0XS5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgIDogaGVpZ2h0ICsgZ2V0QmxhbmtMaW5lc0hlaWdodChkb2MsIGNoaWxkcmVuLCBNYXRoLm1pbihlbmQgKyAxLCBkb2MuY2hpbGRDb3VudCAtIDEpKSxcbiAgICAgICAgcmVjdDogcmVjdCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0QmxhbmtMaW5lc0hlaWdodChkb2MsIGNoaWxkcmVuLCBzdGFydCkge1xuICAgIHZhciBlbmQgPSBkb2MuY2hpbGRDb3VudCAtIDE7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCAmJiBpc0JsYW5rTGluZShkb2MsIHN0YXJ0KSkge1xuICAgICAgICBoZWlnaHQgKz0gY2hpbGRyZW5bc3RhcnRdLmNsaWVudEhlaWdodDtcbiAgICAgICAgc3RhcnQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodDtcbn1cbmZ1bmN0aW9uIGZpbmRBbmNlc3RvckhhdmluZ0lkKGVsLCByb290KSB7XG4gICAgd2hpbGUgKCFlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJykgJiYgZWwucGFyZW50RWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGdldFRvdGFsT2Zmc2V0VG9wKGVsLCByb290KSB7XG4gICAgdmFyIG9mZnNldFRvcCA9IDA7XG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSByb290KSB7XG4gICAgICAgIGlmICghaW5jbHVkZXMobmVzdGFibGVUYWdOYW1lcywgZWwudGFnTmFtZSkpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCArPSBlbC5vZmZzZXRUb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLm9mZnNldFBhcmVudCA9PT0gcm9vdC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldFRvcDtcbn1cbmZ1bmN0aW9uIGZpbmRBZGphY2VudEVsZW1lbnRUb1Njcm9sbFRvcChzY3JvbGxUb3AsIHJvb3QpIHtcbiAgICB2YXIgZWwgPSByb290O1xuICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgdmFyIGZpcnN0RWxlbWVudENoaWxkID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIGlmICghZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0U2libGluZyA9IGZpbmRMYXN0U2libGluZ0VsZW1lbnRUb1Njcm9sbFRvcChmaXJzdEVsZW1lbnRDaGlsZCwgc2Nyb2xsVG9wLCBnZXRUb3RhbE9mZnNldFRvcChlbCwgcm9vdCkpO1xuICAgICAgICBwcmV2ID0gZWw7XG4gICAgICAgIGVsID0gbGFzdFNpYmxpbmc7XG4gICAgfVxuICAgIHZhciBhZGphY2VudEVsID0gZWwgfHwgcHJldjtcbiAgICByZXR1cm4gYWRqYWNlbnRFbCA9PT0gcm9vdCA/IG51bGwgOiBhZGphY2VudEVsO1xufVxuZnVuY3Rpb24gZmluZExhc3RTaWJsaW5nRWxlbWVudFRvU2Nyb2xsVG9wKGVsLCBzY3JvbGxUb3AsIG9mZnNldFRvcCkge1xuICAgIGlmIChlbCAmJiBzY3JvbGxUb3AgPiBvZmZzZXRUb3AgKyBlbC5vZmZzZXRUb3ApIHtcbiAgICAgICAgcmV0dXJuIChmaW5kTGFzdFNpYmxpbmdFbGVtZW50VG9TY3JvbGxUb3AoZWwubmV4dEVsZW1lbnRTaWJsaW5nLCBzY3JvbGxUb3AsIG9mZnNldFRvcCkgfHwgZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEFkZGl0aW9uYWxQb3Moc2Nyb2xsVG9wLCBvZmZzZXRUb3AsIGhlaWdodCwgdGFyZ2V0Tm9kZUhlaWdodCkge1xuICAgIHZhciByYXRpbyA9IE1hdGgubWluKChzY3JvbGxUb3AgLSBvZmZzZXRUb3ApIC8gaGVpZ2h0LCAxKTtcbiAgICByZXR1cm4gcmF0aW8gKiB0YXJnZXROb2RlSGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZU9iaihwcmV2aWV3Q29udGVudCwgbWROb2RlKSB7XG4gICAgdmFyIGVsID0gcHJldmlld0NvbnRlbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLW5vZGVpZD1cXFwiXCIgKyBtZE5vZGUuaWQgKyBcIlxcXCJdXCIpO1xuICAgIHdoaWxlICghZWwgfHwgaXNTdHlsZWRJbmxpbmVOb2RlKG1kTm9kZSkpIHtcbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICAgICAgZWwgPSBwcmV2aWV3Q29udGVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtbm9kZWlkPVxcXCJcIiArIG1kTm9kZS5pZCArIFwiXFxcIl1cIik7XG4gICAgfVxuICAgIHJldHVybiBnZXROb25OZXN0YWJsZU5vZGVPYmooeyBtZE5vZGU6IG1kTm9kZSwgZWw6IGVsIH0pO1xufVxuZnVuY3Rpb24gZ2V0Tm9uTmVzdGFibGVOb2RlT2JqKF9hKSB7XG4gICAgdmFyIG1kTm9kZSA9IF9hLm1kTm9kZSwgZWwgPSBfYS5lbDtcbiAgICB3aGlsZSAoKGluY2x1ZGVzKG5lc3RhYmxlVHlwZXMsIG1kTm9kZS50eXBlKSB8fCBtZE5vZGUudHlwZSA9PT0gJ3RhYmxlJykgJiYgbWROb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbWROb2RlID0gbWROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGVsID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiB7IG1kTm9kZTogbWROb2RlLCBlbDogZWwgfTtcbn1cblxudmFyIG9mZnNldEluZm9NYXAgPSB7fTtcbmZ1bmN0aW9uIHNldEhlaWdodChpZCwgaGVpZ2h0KSB7XG4gICAgb2Zmc2V0SW5mb01hcFtpZF0gPSBvZmZzZXRJbmZvTWFwW2lkXSB8fCB7fTtcbiAgICBvZmZzZXRJbmZvTWFwW2lkXS5oZWlnaHQgPSBoZWlnaHQ7XG59XG5mdW5jdGlvbiBzZXRPZmZzZXRUb3AoaWQsIG9mZnNldFRvcCkge1xuICAgIG9mZnNldEluZm9NYXBbaWRdID0gb2Zmc2V0SW5mb01hcFtpZF0gfHwge307XG4gICAgb2Zmc2V0SW5mb01hcFtpZF0ub2Zmc2V0VG9wID0gb2Zmc2V0VG9wO1xufVxuZnVuY3Rpb24gZ2V0SGVpZ2h0KGlkKSB7XG4gICAgcmV0dXJuIG9mZnNldEluZm9NYXBbaWRdICYmIG9mZnNldEluZm9NYXBbaWRdLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGdldE9mZnNldFRvcChpZCkge1xuICAgIHJldHVybiBvZmZzZXRJbmZvTWFwW2lkXSAmJiBvZmZzZXRJbmZvTWFwW2lkXS5vZmZzZXRUb3A7XG59XG5mdW5jdGlvbiByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICBkZWxldGUgb2Zmc2V0SW5mb01hcFtOdW1iZXIobm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJykpXTtcbiAgICAgICAgdG9BcnJheV8xKG5vZGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QW5kU2F2ZU9mZnNldEluZm8obm9kZSwgcm9vdCwgbWROb2RlSWQpIHtcbiAgICB2YXIgY2FjaGVkSGVpZ2h0ID0gZ2V0SGVpZ2h0KG1kTm9kZUlkKTtcbiAgICB2YXIgY2FjaGVkVG9wID0gZ2V0T2Zmc2V0VG9wKG1kTm9kZUlkKTtcbiAgICB2YXIgbm9kZUhlaWdodCA9IGNhY2hlZEhlaWdodCB8fCBub2RlLmNsaWVudEhlaWdodDtcbiAgICB2YXIgb2Zmc2V0VG9wID0gY2FjaGVkVG9wIHx8IGdldFRvdGFsT2Zmc2V0VG9wKG5vZGUsIHJvb3QpIHx8IG5vZGUub2Zmc2V0VG9wO1xuICAgIGlmICghY2FjaGVkSGVpZ2h0KSB7XG4gICAgICAgIHNldEhlaWdodChtZE5vZGVJZCwgbm9kZUhlaWdodCk7XG4gICAgfVxuICAgIGlmICghY2FjaGVkVG9wKSB7XG4gICAgICAgIHNldE9mZnNldFRvcChtZE5vZGVJZCwgb2Zmc2V0VG9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZUhlaWdodDogbm9kZUhlaWdodCwgb2Zmc2V0VG9wOiBvZmZzZXRUb3AgfTtcbn1cblxudmFyIENMQVNTX0hJR0hMSUdIVCA9IGNscygnbWQtcHJldmlldy1oaWdobGlnaHQnKTtcbmZ1bmN0aW9uIGZpbmRUYWJsZUNlbGwodGFibGVSb3csIGNoT2Zmc2V0KSB7XG4gICAgdmFyIGNlbGwgPSB0YWJsZVJvdy5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjZWxsICYmIGNlbGwubmV4dCkge1xuICAgICAgICBpZiAoZ2V0TWRTdGFydENoKGNlbGwubmV4dCkgPiBjaE9mZnNldCArIDEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNlbGwgPSBjZWxsLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xufVxuLyoqXG4gKiBDbGFzcyBNYXJrZG93biBQcmV2aWV3XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIGJhc2UgZWxlbWVudFxuICogQHBhcmFtIHtldmVudEVtaXR0ZXJ9IGV2ZW50RW1pdHRlciAtIGV2ZW50IG1hbmFnZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaXNWaWV3ZXIgLSB0cnVlIGZvciB2aWV3LW9ubHkgbW9kZVxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmhpZ2hsaWdodCAtIHRydWUgZm9yIHVzaW5nIGxpdmUtaGlnaGxpZ2h0IGZlYXR1cmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcGl0b25zLmxpbmtBdHRyaWJ1dGVzIC0gYXR0cmlidXRlcyBmb3IgbGluayBlbGVtZW50XG4gKiBAcGFyYW0ge29iamVjdH0gb3BpdG9ucy5jdXN0b21IVE1MUmVuZGVyZXIgLSBtYXAgb2YgY3VzdG9tIEhUTUwgcmVuZGVyIGZ1bmN0aW9uc1xuICpcbiAqIEBpZ25vcmVcbiAqL1xudmFyIE1hcmtkb3duUHJldmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXJrZG93blByZXZpZXcoZXZlbnRFbWl0dGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLmlzVmlld2VyID0gISFvcHRpb25zLmlzVmlld2VyO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTmFtZSA9IGNscygnbWQtcHJldmlldycpO1xuICAgICAgICB2YXIgbGlua0F0dHJpYnV0ZXMgPSBvcHRpb25zLmxpbmtBdHRyaWJ1dGVzLCBjdXN0b21IVE1MUmVuZGVyZXIgPSBvcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlciwgc2FuaXRpemVyID0gb3B0aW9ucy5zYW5pdGl6ZXIsIF9hID0gb3B0aW9ucy5oaWdobGlnaHQsIGhpZ2hsaWdodCA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHtcbiAgICAgICAgICAgIGdmbTogdHJ1ZSxcbiAgICAgICAgICAgIG5vZGVJZDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnZlcnRvcnM6IGdldEhUTUxSZW5kZXJDb252ZXJ0b3JzKGxpbmtBdHRyaWJ1dGVzLCBjdXN0b21IVE1MUmVuZGVyZXIpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdXJzb3JOb2RlSWQgPSBudWxsO1xuICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcbiAgICAgICAgdGhpcy5pbml0RXZlbnQoaGlnaGxpZ2h0KTtcbiAgICAgICAgdGhpcy5pbml0Q29udGVudFNlY3Rpb24oKTtcbiAgICAgICAgLy8gVG8gcHJldmVudCBvdmVyZmxvd2luZyBjb250ZW50cyBpbiB0aGUgdmlld2VyXG4gICAgICAgIGlmICh0aGlzLmlzVmlld2VyKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXdDb250ZW50LnN0eWxlLm92ZXJmbG93V3JhcCA9ICdicmVhay13b3JkJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmluaXRDb250ZW50U2VjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcmV2aWV3Q29udGVudCA9IGNyZWF0ZUVsZW1lbnRXaXRoKFwiPGRpdiBjbGFzcz1cXFwiXCIgKyBjbHMoJ2NvbnRlbnRzJykgKyBcIlxcXCI+PC9kaXY+XCIpO1xuICAgICAgICBpZiAoIXRoaXMuaXNWaWV3ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5wcmV2aWV3Q29udGVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUudG9nZ2xlQWN0aXZlID0gZnVuY3Rpb24gKGFjdGl2ZSkge1xuICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLmVsLCAnYWN0aXZlJywgYWN0aXZlKTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24gKGhpZ2hsaWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ3VwZGF0ZVByZXZpZXcnLCB0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVRvb2xiYXJTdGF0ZScsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBtZE5vZGUgPSBfYS5tZE5vZGUsIGN1cnNvclBvcyA9IF9hLmN1cnNvclBvcztcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVDdXJzb3JOb2RlKG1kTm9kZSwgY3Vyc29yUG9zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb25fMSh0aGlzLmVsLCAnc2Nyb2xsJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnc2Nyb2xsJywgJ3ByZXZpZXcnLCBmaW5kQWRqYWNlbnRFbGVtZW50VG9TY3JvbGxUb3AoZXZlbnQudGFyZ2V0LnNjcm9sbFRvcCwgX3RoaXMucHJldmlld0NvbnRlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlUHJldmlld1RhYlByZXZpZXcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50b2dnbGVBY3RpdmUodHJ1ZSk7IH0pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRvZ2dsZUFjdGl2ZShmYWxzZSk7IH0pO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5yZW1vdmVIaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvck5vZGVJZCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRFbCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKHRoaXMuY3Vyc29yTm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RWwpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzc18xKGN1cnJlbnRFbCwgQ0xBU1NfSElHSExJR0hUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS51cGRhdGVDdXJzb3JOb2RlID0gZnVuY3Rpb24gKGN1cnNvck5vZGUsIGN1cnNvclBvcykge1xuICAgICAgICBpZiAoY3Vyc29yTm9kZSkge1xuICAgICAgICAgICAgY3Vyc29yTm9kZSA9IGZpbmRDbG9zZXN0Tm9kZShjdXJzb3JOb2RlLCBmdW5jdGlvbiAobWROb2RlKSB7IHJldHVybiAhaXNJbmxpbmVOb2RlJDEobWROb2RlKTsgfSk7XG4gICAgICAgICAgICBpZiAoY3Vyc29yTm9kZS50eXBlID09PSAndGFibGVSb3cnKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yTm9kZSA9IGZpbmRUYWJsZUNlbGwoY3Vyc29yTm9kZSwgY3Vyc29yUG9zWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnNvck5vZGUudHlwZSA9PT0gJ3RhYmxlQm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBsaW5lIG5leHQgdG8gdGFibGVcbiAgICAgICAgICAgICAgICBjdXJzb3JOb2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY3Vyc29yTm9kZUlkID0gY3Vyc29yTm9kZSA/IGN1cnNvck5vZGUuaWQgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5jdXJzb3JOb2RlSWQgPT09IGN1cnNvck5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRFTCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKHRoaXMuY3Vyc29yTm9kZUlkKTtcbiAgICAgICAgdmFyIG5ld0VMID0gdGhpcy5nZXRFbGVtZW50QnlOb2RlSWQoY3Vyc29yTm9kZUlkKTtcbiAgICAgICAgaWYgKG9sZEVMKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzc18xKG9sZEVMLCBDTEFTU19ISUdITElHSFQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdFTCkge1xuICAgICAgICAgICAgYWRkQ2xhc3NfMShuZXdFTCwgQ0xBU1NfSElHSExJR0hUKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnNvck5vZGVJZCA9IGN1cnNvck5vZGVJZDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZ2V0RWxlbWVudEJ5Tm9kZUlkID0gZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICByZXR1cm4gbm9kZUlkXG4gICAgICAgICAgICA/IHRoaXMucHJldmlld0NvbnRlbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLW5vZGVpZD1cXFwiXCIgKyBub2RlSWQgKyBcIlxcXCJdXCIpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjaGFuZ2VkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNoYW5nZWQuZm9yRWFjaChmdW5jdGlvbiAoZWRpdFJlc3VsdCkgeyByZXR1cm4gX3RoaXMucmVwbGFjZVJhbmdlTm9kZXMoZWRpdFJlc3VsdCk7IH0pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdhZnRlclByZXZpZXdSZW5kZXInLCB0aGlzKTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUucmVwbGFjZVJhbmdlTm9kZXMgPSBmdW5jdGlvbiAoZWRpdFJlc3VsdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm9kZXMgPSBlZGl0UmVzdWx0Lm5vZGVzLCByZW1vdmVkTm9kZVJhbmdlID0gZWRpdFJlc3VsdC5yZW1vdmVkTm9kZVJhbmdlO1xuICAgICAgICB2YXIgY29udGVudEVsID0gdGhpcy5wcmV2aWV3Q29udGVudDtcbiAgICAgICAgdmFyIG5ld0h0bWwgPSB0aGlzLmV2ZW50RW1pdHRlci5lbWl0UmVkdWNlKCdiZWZvcmVQcmV2aWV3UmVuZGVyJywgdGhpcy5zYW5pdGl6ZXIobm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5yZW5kZXIobm9kZSk7IH0pLmpvaW4oJycpKSk7XG4gICAgICAgIGlmICghcmVtb3ZlZE5vZGVSYW5nZSkge1xuICAgICAgICAgICAgY29udGVudEVsLmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJiZWdpbicsIG5ld0h0bWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9hID0gcmVtb3ZlZE5vZGVSYW5nZS5pZCwgc3RhcnROb2RlSWQgPSBfYVswXSwgZW5kTm9kZUlkID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgc3RhcnRFbCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKHN0YXJ0Tm9kZUlkKTtcbiAgICAgICAgICAgIHZhciBlbmRFbCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKGVuZE5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRFbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIG5ld0h0bWwpO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHN0YXJ0RWw7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBlbmRFbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dEVsID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlJDEoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBuZXh0RWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gbnVsbCB8fCBlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlJDEoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZ2V0UmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZfMSh0aGlzLmVsLCAnc2Nyb2xsJyk7XG4gICAgICAgIHRoaXMuZWwgPSBudWxsO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZ2V0SFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKHRoaXMucHJldmlld0NvbnRlbnQuaW5uZXJIVE1MKTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuc2V0SFRNTCA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIHRoaXMucHJldmlld0NvbnRlbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICBjc3NfMSh0aGlzLmVsLCB7IGhlaWdodDogaGVpZ2h0ICsgXCJweFwiIH0pO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5zZXRNaW5IZWlnaHQgPSBmdW5jdGlvbiAobWluSGVpZ2h0KSB7XG4gICAgICAgIGNzc18xKHRoaXMuZWwsIHsgbWluSGVpZ2h0OiBtaW5IZWlnaHQgKyBcInB4XCIgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFya2Rvd25QcmV2aWV3O1xufSgpKTtcblxuZnVuY3Rpb24gZmluZE5vZGVCeShwb3MsIGNvbmRpdGlvbikge1xuICAgIHZhciBkZXB0aCA9IHBvcy5kZXB0aDtcbiAgICB3aGlsZSAoZGVwdGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwb3Mubm9kZShkZXB0aCk7XG4gICAgICAgIGlmIChjb25kaXRpb24obm9kZSwgZGVwdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZGVwdGggPiAwID8gcG9zLmJlZm9yZShkZXB0aCkgOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzSW5MaXN0Tm9kZShwb3MpIHtcbiAgICByZXR1cm4gISFmaW5kTm9kZUJ5KHBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ2xpc3RJdGVtJyB8fCB0eXBlLm5hbWUgPT09ICdidWxsZXRMaXN0JyB8fCB0eXBlLm5hbWUgPT09ICdvcmRlcmVkTGlzdCc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc0luVGFibGVOb2RlKHBvcykge1xuICAgIHJldHVybiAhIWZpbmROb2RlQnkocG9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAndGFibGVIZWFkQ2VsbCcgfHwgdHlwZS5uYW1lID09PSAndGFibGVCb2R5Q2VsbCc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaW5kTGlzdEl0ZW0ocG9zKSB7XG4gICAgcmV0dXJuIGZpbmROb2RlQnkocG9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAnbGlzdEl0ZW0nO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRE9NSW5mb1BhcnNlZFJhd0hUTUwodGFnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHt9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDZWxsQXR0cnMoYXR0cnMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyTmFtZSkge1xuICAgICAgICBpZiAoYXR0ck5hbWUgIT09ICdyYXdIVE1MJyAmJiBhdHRyc1thdHRyTmFtZV0pIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ck5hbWUgPT09ICdjbGFzc05hbWUnID8gJ2NsYXNzJyA6IGF0dHJOYW1lO1xuICAgICAgICAgICAgYWNjW2F0dHJOYW1lXSA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlZENlbGxET00odGFnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICByZXR1cm4gWydyYXdIVE1MJywgJ2NvbHNwYW4nLCAncm93c3BhbicsICdleHRlbmRlZCddLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZUluRE9NID0gYXR0ck5hbWUgPT09ICdyYXdIVE1MJyA/ICdkYXRhLXJhdy1odG1sJyA6IGF0dHJOYW1lO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBkb20uZ2V0QXR0cmlidXRlKGF0dHJOYW1lSW5ET00pO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2F0dHJOYW1lXSA9IGluY2x1ZGVzKFsncmF3SFRNTCcsICdleHRlbmRlZCddLCBhdHRyTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYXR0clZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE51bWJlcihhdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaHRtbEF0dHJzOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgY2xhc3NOYW1lczogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEN1c3RvbUF0dHJzKGF0dHJzKSB7XG4gICAgdmFyIGh0bWxBdHRycyA9IGF0dHJzLmh0bWxBdHRycywgY2xhc3NOYW1lcyA9IGF0dHJzLmNsYXNzTmFtZXM7XG4gICAgcmV0dXJuIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgaHRtbEF0dHJzKSwgeyBjbGFzczogY2xhc3NOYW1lcyA/IGNsYXNzTmFtZXMuam9pbignICcpIDogbnVsbCB9KTtcbn1cblxuZnVuY3Rpb24gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgdHlwZSkge1xuICAgIHZhciBwYXJlbnQgPSByYW5nZS5wYXJlbnQsIHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4LCBlbmRJbmRleCA9IHJhbmdlLmVuZEluZGV4O1xuICAgIHZhciBhcm91bmQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoc3RhcnRJbmRleCkuZmluZFdyYXBwaW5nKHR5cGUpO1xuICAgIGlmIChhcm91bmQpIHtcbiAgICAgICAgdmFyIG91dGVyID0gYXJvdW5kLmxlbmd0aCA/IGFyb3VuZFswXSA6IHR5cGU7XG4gICAgICAgIHJldHVybiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoc3RhcnRJbmRleCwgZW5kSW5kZXgsIG91dGVyKSA/IGFyb3VuZCA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nSW5zaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudCwgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXgsIGVuZEluZGV4ID0gcmFuZ2UuZW5kSW5kZXg7XG4gICAgdmFyIGlubmVyID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpO1xuICAgIHZhciBpbnNpZGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5maW5kV3JhcHBpbmcoaW5uZXIudHlwZSk7XG4gICAgaWYgKGluc2lkZSkge1xuICAgICAgICB2YXIgbGFzdFR5cGUgPSBpbnNpZGUubGVuZ3RoID8gaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXSA6IHR5cGU7XG4gICAgICAgIHZhciBpbm5lck1hdGNoID0gbGFzdFR5cGUuY29udGVudE1hdGNoO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaW5uZXJNYXRjaCAmJiBpIDwgZW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5uZXJNYXRjaCA9IGlubmVyTWF0Y2gubWF0Y2hUeXBlKHBhcmVudC5jaGlsZChpKS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5uZXJNYXRjaCAmJiBpbm5lck1hdGNoLnZhbGlkRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFdyYXBwZXJzKHJhbmdlLCBpbm5lclJhbmdlLCBub2RlVHlwZSwgYXR0cnMpIHtcbiAgICB2YXIgYXJvdW5kID0gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgbm9kZVR5cGUpO1xuICAgIHZhciBpbm5lciA9IGZpbmRXcmFwcGluZ0luc2lkZShpbm5lclJhbmdlLCBub2RlVHlwZSk7XG4gICAgaWYgKGFyb3VuZCAmJiBpbm5lcikge1xuICAgICAgICB2YXIgYXJvdW5kTm9kZXMgPSBhcm91bmQubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW5uZXJOb2RlcyA9IGlubmVyLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgYXR0cnM6IGF0dHJzIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXJvdW5kTm9kZXMuY29uY2F0KHsgdHlwZTogbm9kZVR5cGUgfSkuY29uY2F0KGlubmVyTm9kZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHdyYXBJbkxpc3QodHIsIF9hLCB3cmFwcGVycywgam9pbkJlZm9yZSwgbGlzdCkge1xuICAgIHZhciBzdGFydCA9IF9hLnN0YXJ0LCBlbmQgPSBfYS5lbmQsIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9hLmVuZEluZGV4LCBwYXJlbnQgPSBfYS5wYXJlbnQ7XG4gICAgdmFyIGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKHZhciBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQgLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgZW5kLCBzdGFydCwgZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuICAgIHZhciBmb3VuZExpc3RJbmRleCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3cmFwcGVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAod3JhcHBlcnNbaV0udHlwZSA9PT0gbGlzdCkge1xuICAgICAgICAgICAgZm91bmRMaXN0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzcGxpdERlcHRoID0gd3JhcHBlcnMubGVuZ3RoIC0gZm91bmRMaXN0SW5kZXg7XG4gICAgdmFyIHNwbGl0UG9zID0gc3RhcnQgKyB3cmFwcGVycy5sZW5ndGggLSAoam9pbkJlZm9yZSA/IDIgOiAwKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCwgbGVuID0gZW5kSW5kZXg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB2YXIgZmlyc3QgPSBpID09PSBzdGFydEluZGV4O1xuICAgICAgICBpZiAoIWZpcnN0ICYmIGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHNwbGl0RGVwdGgpKSB7XG4gICAgICAgICAgICB0ci5zcGxpdChzcGxpdFBvcywgc3BsaXREZXB0aCk7XG4gICAgICAgICAgICBzcGxpdFBvcyArPSBzcGxpdERlcHRoICogMjtcbiAgICAgICAgfVxuICAgICAgICBzcGxpdFBvcyArPSBwYXJlbnQuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGNoYW5nZVRvTGlzdCh0ciwgcmFuZ2UsIGxpc3QsIGF0dHJzKSB7XG4gICAgdmFyICRmcm9tID0gcmFuZ2UuJGZyb20sICR0byA9IHJhbmdlLiR0bywgZGVwdGggPSByYW5nZS5kZXB0aDtcbiAgICB2YXIgb3V0ZXJSYW5nZSA9IHJhbmdlO1xuICAgIHZhciBqb2luQmVmb3JlID0gZmFsc2U7XG4gICAgaWYgKGRlcHRoID49IDIgJiZcbiAgICAgICAgJGZyb20ubm9kZShkZXB0aCAtIDEpLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobGlzdCkgJiZcbiAgICAgICAgcmFuZ2Uuc3RhcnRJbmRleCA9PT0gMCAmJlxuICAgICAgICAkZnJvbS5pbmRleChkZXB0aCAtIDEpKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0IC0gMik7XG4gICAgICAgIG91dGVyUmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHN0YXJ0LCBzdGFydCwgZGVwdGgpO1xuICAgICAgICBpZiAocmFuZ2UuZW5kSW5kZXggPCByYW5nZS5wYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRmcm9tLCB0ci5kb2MucmVzb2x2ZSgkdG8uZW5kKGRlcHRoKSksIGRlcHRoKTtcbiAgICAgICAgfVxuICAgICAgICBqb2luQmVmb3JlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHdyYXBwZXJzID0gZmluZFdyYXBwZXJzKG91dGVyUmFuZ2UsIHJhbmdlLCBsaXN0LCBhdHRycyk7XG4gICAgaWYgKHdyYXBwZXJzKSB7XG4gICAgICAgIHJldHVybiB3cmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBnZXRCZWZvcmVMaW5lTGlzdEl0ZW0oZG9jLCBvZmZzZXQpIHtcbiAgICB2YXIgZW5kTGlzdEl0ZW1Qb3MgPSBkb2MucmVzb2x2ZShvZmZzZXQpO1xuICAgIHdoaWxlIChlbmRMaXN0SXRlbVBvcy5ub2RlKCkudHlwZS5uYW1lICE9PSAncGFyYWdyYXBoJykge1xuICAgICAgICBvZmZzZXQgLT0gMjsgLy8gVGhlIHBvc2l0aW9uIHZhbHVlIG9mIDwvbGk+PC91bD5cbiAgICAgICAgZW5kTGlzdEl0ZW1Qb3MgPSBkb2MucmVzb2x2ZShvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZmluZExpc3RJdGVtKGVuZExpc3RJdGVtUG9zKTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVRhc2tMaXN0SXRlbXModHIsIF9hKSB7XG4gICAgdmFyICRmcm9tID0gX2EuJGZyb20sICR0byA9IF9hLiR0bztcbiAgICB2YXIgc3RhcnRMaXN0SXRlbSA9IGZpbmRMaXN0SXRlbSgkZnJvbSk7XG4gICAgdmFyIGVuZExpc3RJdGVtID0gZmluZExpc3RJdGVtKCR0byk7XG4gICAgaWYgKHN0YXJ0TGlzdEl0ZW0gJiYgZW5kTGlzdEl0ZW0pIHtcbiAgICAgICAgd2hpbGUgKGVuZExpc3RJdGVtKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZW5kTGlzdEl0ZW0ub2Zmc2V0LCBub2RlID0gZW5kTGlzdEl0ZW0ubm9kZTtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHsgdGFzazogIW5vZGUuYXR0cnMudGFzaywgY2hlY2tlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAob2Zmc2V0LCBudWxsLCBhdHRycyk7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydExpc3RJdGVtLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTGlzdEl0ZW0gPSBnZXRCZWZvcmVMaW5lTGlzdEl0ZW0odHIuZG9jLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGNoYW5nZUxpc3RUeXBlKHRyLCBfYSwgbGlzdCkge1xuICAgIHZhciAkZnJvbSA9IF9hLiRmcm9tLCAkdG8gPSBfYS4kdG87XG4gICAgdmFyIHN0YXJ0TGlzdEl0ZW0gPSBmaW5kTGlzdEl0ZW0oJGZyb20pO1xuICAgIHZhciBlbmRMaXN0SXRlbSA9IGZpbmRMaXN0SXRlbSgkdG8pO1xuICAgIGlmIChzdGFydExpc3RJdGVtICYmIGVuZExpc3RJdGVtKSB7XG4gICAgICAgIHdoaWxlIChlbmRMaXN0SXRlbSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGVuZExpc3RJdGVtLm9mZnNldCwgbm9kZSA9IGVuZExpc3RJdGVtLm5vZGUsIGRlcHRoID0gZW5kTGlzdEl0ZW0uZGVwdGg7XG4gICAgICAgICAgICBpZiAobm9kZS5hdHRycy50YXNrKSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChvZmZzZXQsIG51bGwsIHsgdGFzazogZmFsc2UsIGNoZWNrZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc29sdmVkUG9zID0gdHIuZG9jLnJlc29sdmUob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZFBvcy5wYXJlbnQudHlwZSAhPT0gbGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRPZmZzZXQgPSByZXNvbHZlZFBvcy5iZWZvcmUoZGVwdGggLSAxKTtcbiAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBhcmVudE9mZnNldCwgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydExpc3RJdGVtLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTGlzdEl0ZW0gPSBnZXRCZWZvcmVMaW5lTGlzdEl0ZW0odHIuZG9jLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGNoYW5nZUxpc3QobGlzdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHI7XG4gICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICAgICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBuZXdUciA9IGlzSW5MaXN0Tm9kZSgkZnJvbSlcbiAgICAgICAgICAgICAgICA/IGNoYW5nZUxpc3RUeXBlKHRyLCByYW5nZSwgbGlzdClcbiAgICAgICAgICAgICAgICA6IGNoYW5nZVRvTGlzdCh0ciwgcmFuZ2UsIGxpc3QpO1xuICAgICAgICAgICAgZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5mdW5jdGlvbiB0b2dnbGVUYXNrKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHIsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgICAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIG5ld1RyID0gaXNJbkxpc3ROb2RlKCRmcm9tKVxuICAgICAgICAgICAgICAgID8gdG9nZ2xlVGFza0xpc3RJdGVtcyh0ciwgcmFuZ2UpXG4gICAgICAgICAgICAgICAgOiBjaGFuZ2VUb0xpc3QodHIsIHJhbmdlLCBzY2hlbWEubm9kZXMuYnVsbGV0TGlzdCwgeyB0YXNrOiB0cnVlIH0pO1xuICAgICAgICAgICAgZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0obGlzdEl0ZW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICB2YXIgdHIgPSBfYS50ciwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZENvdW50ID0gX2EuY2hpbGRDb3VudCwgZmlyc3RDaGlsZCA9IF9hLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICByZXR1cm4gISFjaGlsZENvdW50ICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gbGlzdEl0ZW07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmFuZ2UgJiYgcmFuZ2Uuc3RhcnRJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHJhbmdlLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBub2RlQmVmb3JlID0gcGFyZW50XzEuY2hpbGQocmFuZ2Uuc3RhcnRJbmRleCAtIDEpO1xuICAgICAgICAgICAgaWYgKG5vZGVCZWZvcmUudHlwZSAhPT0gbGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmVzdGVkQmVmb3JlID0gbm9kZUJlZm9yZS5sYXN0Q2hpbGQgJiYgbm9kZUJlZm9yZS5sYXN0Q2hpbGQudHlwZSA9PT0gcGFyZW50XzEudHlwZTtcbiAgICAgICAgICAgIHZhciBpbm5lciA9IG5lc3RlZEJlZm9yZSA/IEZyYWdtZW50LmZyb20obGlzdEl0ZW0uY3JlYXRlKCkpIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGxpc3RJdGVtLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKHBhcmVudF8xLnR5cGUuY3JlYXRlKG51bGwsIGlubmVyKSkpKSwgbmVzdGVkQmVmb3JlID8gMyA6IDEsIDApO1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgdmFyIGFmdGVyID0gcmFuZ2UuZW5kO1xuICAgICAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoYmVmb3JlIC0gKG5lc3RlZEJlZm9yZSA/IDMgOiAxKSwgYWZ0ZXIsIGJlZm9yZSwgYWZ0ZXIsIHNsaWNlLCAxLCB0cnVlKSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpZnRUb091dGVyTGlzdCh0ciwgcmFuZ2UsIGxpc3RJdGVtKSB7XG4gICAgdmFyICRmcm9tID0gcmFuZ2UuJGZyb20sICR0byA9IHJhbmdlLiR0bywgZW5kID0gcmFuZ2UuZW5kLCBkZXB0aCA9IHJhbmdlLmRlcHRoLCBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gICAgdmFyIGVuZE9mTGlzdCA9ICR0by5lbmQoZGVwdGgpO1xuICAgIGlmIChlbmQgPCBlbmRPZkxpc3QpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHNpYmxpbmdzIGFmdGVyIHRoZSBsaWZ0ZWQgaXRlbXMsIHdoaWNoIG11c3QgYmVjb21lXG4gICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obGlzdEl0ZW0uY3JlYXRlKG51bGwsIHBhcmVudC5jb3B5KCkpKSwgMSwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgcmFuZ2UgPSBuZXcgTm9kZVJhbmdlKHRyLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyksIHRyLmRvYy5yZXNvbHZlKGVuZE9mTGlzdCksIGRlcHRoKTtcbiAgICB9XG4gICAgdHIubGlmdChyYW5nZSwgbGlmdFRhcmdldChyYW5nZSkpO1xuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGxpZnRPdXRPZkxpc3QodHIsIHJhbmdlKSB7XG4gICAgdmFyIGxpc3QgPSByYW5nZS5wYXJlbnQ7XG4gICAgdmFyIHBvcyA9IHJhbmdlLmVuZDtcbiAgICAvLyBNZXJnZSB0aGUgbGlzdCBpdGVtcyBpbnRvIGEgc2luZ2xlIGJpZyBpdGVtXG4gICAgZm9yICh2YXIgaSA9IHJhbmdlLmVuZEluZGV4IC0gMSwgbGVuID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGxlbjsgaSAtPSAxKSB7XG4gICAgICAgIHBvcyAtPSBsaXN0LmNoaWxkKGkpLm5vZGVTaXplO1xuICAgICAgICB0ci5kZWxldGUocG9zIC0gMSwgcG9zICsgMSk7XG4gICAgfVxuICAgIHZhciBzdGFydFBvcyA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0KTtcbiAgICB2YXIgbGlzdEl0ZW0gPSBzdGFydFBvcy5ub2RlQWZ0ZXI7XG4gICAgdmFyIGF0U3RhcnQgPSByYW5nZS5zdGFydEluZGV4ID09PSAwO1xuICAgIHZhciBhdEVuZCA9IHJhbmdlLmVuZEluZGV4ID09PSBsaXN0LmNoaWxkQ291bnQ7XG4gICAgdmFyIHBhcmVudCA9IHN0YXJ0UG9zLm5vZGUoLTEpO1xuICAgIHZhciBpbmRleEJlZm9yZSA9IHN0YXJ0UG9zLmluZGV4KC0xKTtcbiAgICB2YXIgY2FuUmVwbGFjZVBhcmVudCA9IHBhcmVudC5jYW5SZXBsYWNlKGluZGV4QmVmb3JlICsgKGF0U3RhcnQgPyAwIDogMSksIGluZGV4QmVmb3JlICsgMSwgbGlzdEl0ZW0gPT09IG51bGwgfHwgbGlzdEl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RJdGVtLmNvbnRlbnQuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QpKSk7XG4gICAgaWYgKGxpc3RJdGVtICYmIGNhblJlcGxhY2VQYXJlbnQpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gc3RhcnRQb3MucG9zO1xuICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBsaXN0SXRlbS5ub2RlU2l6ZTtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBzdXJyb3VuZGluZyBsaXN0LiBBdCB0aGUgc2lkZXMgd2hlcmUgd2UncmUgbm90IGF0XG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIGxpc3QsIHRoZSBleGlzdGluZyBsaXN0IGlzIGNsb3NlZC4gQXQgc2lkZXMgd2hlcmVcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kLCBpdCBpcyBvdmVyd3JpdHRlbiB0byBpdHMgZW5kLlxuICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSwgbmV3IFNsaWNlKChhdFN0YXJ0ID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKS5hcHBlbmQoYXRFbmQgPyBGcmFnbWVudC5lbXB0eSA6IEZyYWdtZW50LmZyb20obGlzdC5jb3B5KEZyYWdtZW50LmVtcHR5KSkpLCBhdFN0YXJ0ID8gMCA6IDEsIGF0RW5kID8gMCA6IDEpLCBhdFN0YXJ0ID8gMCA6IDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gbGlmdExpc3RJdGVtKGxpc3RJdGVtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHRyID0gX2EudHIsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgICAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRDb3VudCA9IF9hLmNoaWxkQ291bnQsIGZpcnN0Q2hpbGQgPSBfYS5maXJzdENoaWxkO1xuICAgICAgICAgICAgcmV0dXJuICEhY2hpbGRDb3VudCAmJiBmaXJzdENoaWxkLnR5cGUgPT09IGxpc3RJdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgdG9wTGlzdEl0ZW0gPSAkZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZSA9PT0gbGlzdEl0ZW07XG4gICAgICAgICAgICB2YXIgbmV3VHIgPSB0b3BMaXN0SXRlbSA/IGxpZnRUb091dGVyTGlzdCh0ciwgcmFuZ2UsIGxpc3RJdGVtKSA6IGxpZnRPdXRPZkxpc3QodHIsIHJhbmdlKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKG5ld1RyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3BsaXRMaXN0SXRlbShsaXN0SXRlbSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciB0ciA9IF9hLnRyLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb247XG4gICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICAgICAgaWYgKCRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XG4gICAgICAgIGlmIChncmFuZFBhcmVudC50eXBlICE9PSBsaXN0SXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09PSAwICYmICRmcm9tLm5vZGUoLTEpLmNoaWxkQ291bnQgPT09ICRmcm9tLmluZGV4QWZ0ZXIoLTEpKSB7XG4gICAgICAgICAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAgICAgICAgIC8vIGxpc3QgaXRlbSBzaG91bGQgYmUgc3BsaXQuIE90aGVyd2lzZSwgYmFpbCBvdXQgYW5kIGxldCBuZXh0XG4gICAgICAgICAgICAvLyBjb21tYW5kIGhhbmRsZSBsaWZ0aW5nLlxuICAgICAgICAgICAgaWYgKCRmcm9tLmRlcHRoID09PSAyIHx8XG4gICAgICAgICAgICAgICAgJGZyb20ubm9kZSgtMykudHlwZSAhPT0gbGlzdEl0ZW0gfHxcbiAgICAgICAgICAgICAgICAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtlZXBJdGVtID0gJGZyb20uaW5kZXgoLTEpID4gMDtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICAvLyBCdWlsZCBhIGZyYWdtZW50IGNvbnRhaW5pbmcgZW1wdHkgdmVyc2lvbnMgb2YgdGhlIHN0cnVjdHVyZVxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3V0ZXIgbGlzdCBpdGVtIHRvIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgY3Vyc29yXG4gICAgICAgICAgICBmb3IgKHZhciBkZXB0aCA9ICRmcm9tLmRlcHRoIC0gKGtlZXBJdGVtID8gMSA6IDIpOyBkZXB0aCA+PSAkZnJvbS5kZXB0aCAtIDM7IGRlcHRoIC09IDEpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGRlcHRoKS5jb3B5KHdyYXBwZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyLmFwcGVuZChGcmFnbWVudC5mcm9tKGxpc3RJdGVtLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICAgICAgdHIucmVwbGFjZShrZWVwSXRlbSA/ICRmcm9tLmJlZm9yZSgpIDogJGZyb20uYmVmb3JlKC0xKSwgJGZyb20uYWZ0ZXIoLTMpLCBuZXcgU2xpY2Uod3JhcHBlciwga2VlcEl0ZW0gPyAzIDogMiwgMikpO1xuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyArIChrZWVwSXRlbSA/IDMgOiAyKSkpKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0VHlwZSA9ICR0by5wb3MgPT09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgICAgICB2YXIgdHlwZXMgPSBuZXh0VHlwZSAmJiBbbnVsbCwgeyB0eXBlOiBuZXh0VHlwZSB9XTtcbiAgICAgICAgdHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgICAgIGlmIChjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMiwgdHlwZXMpKSB7XG4gICAgICAgICAgICB0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcbiAgICAgICAgaWYgKHJhbmdlICYmIGlzSW5MaXN0Tm9kZSgkZnJvbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5rTGlzdEl0ZW0oc2NoZW1hLm5vZGVzLmxpc3RJdGVtKShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9OyB9O1xufVxuZnVuY3Rpb24gb3V0ZGVudCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICAgICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgICAgICBpZiAocmFuZ2UgJiYgaXNJbkxpc3ROb2RlKCRmcm9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpZnRMaXN0SXRlbShzY2hlbWEubm9kZXMubGlzdEl0ZW0pKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07IH07XG59XG5mdW5jdGlvbiBnZXRXd0NvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGluZGVudDogaW5kZW50KCksXG4gICAgICAgIG91dGRlbnQ6IG91dGRlbnQoKSxcbiAgICB9O1xufVxuXG52YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbnZhciBUYWJsZU9mZnNldE1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZU9mZnNldE1hcCh0YWJsZSwgdGFibGVSb3dzLCB0YWJsZVN0YXJ0UG9zLCByb3dJbmZvKSB7XG4gICAgICAgIHRoaXMudGFibGUgPSB0YWJsZTtcbiAgICAgICAgdGhpcy50YWJsZVJvd3MgPSB0YWJsZVJvd3M7XG4gICAgICAgIHRoaXMudGFibGVTdGFydFBvcyA9IHRhYmxlU3RhcnRQb3M7XG4gICAgICAgIHRoaXMucm93SW5mbyA9IHJvd0luZm87XG4gICAgfVxuICAgIFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZSA9IGZ1bmN0aW9uIChjZWxsUG9zKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IGZpbmROb2RlQnkoY2VsbFBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAndGFibGUnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRhYmxlLm5vZGUsIGRlcHRoID0gdGFibGUuZGVwdGgsIG9mZnNldCA9IHRhYmxlLm9mZnNldDtcbiAgICAgICAgICAgIHZhciBjYWNoZWQgPSBjYWNoZS5nZXQobm9kZSk7XG4gICAgICAgICAgICBpZiAoKGNhY2hlZCA9PT0gbnVsbCB8fCBjYWNoZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhY2hlZC50YWJsZVN0YXJ0UG9zKSA9PT0gb2Zmc2V0ICsgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcm93c18xID0gW107XG4gICAgICAgICAgICB2YXIgdGFibGVQb3MgPSBjZWxsUG9zLnN0YXJ0KGRlcHRoKTtcbiAgICAgICAgICAgIHZhciB0aGVhZCA9IG5vZGUuY2hpbGQoMCk7XG4gICAgICAgICAgICB2YXIgdGJvZHkgPSBub2RlLmNoaWxkKDEpO1xuICAgICAgICAgICAgdmFyIHRoZWFkQ2VsbEluZm8gPSBjcmVhdGVPZmZzZXRNYXAodGhlYWQsIHRhYmxlUG9zKTtcbiAgICAgICAgICAgIHZhciB0Ym9keUNlbGxJbmZvID0gY3JlYXRlT2Zmc2V0TWFwKHRib2R5LCB0YWJsZVBvcyArIHRoZWFkLm5vZGVTaXplKTtcbiAgICAgICAgICAgIHRoZWFkLmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93c18xLnB1c2gocm93KTsgfSk7XG4gICAgICAgICAgICB0Ym9keS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd3NfMS5wdXNoKHJvdyk7IH0pO1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBUYWJsZU9mZnNldE1hcChub2RlLCByb3dzXzEsIHRhYmxlUG9zLCB0aGVhZENlbGxJbmZvLmNvbmNhdCh0Ym9keUNlbGxJbmZvKSk7XG4gICAgICAgICAgICBjYWNoZS5zZXQobm9kZSwgbWFwKTtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLCBcInRvdGFsUm93Q291bnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0luZm8ubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgXCJ0b3RhbENvbHVtbkNvdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dJbmZvWzBdLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIFwidGFibGVTdGFydE9mZnNldFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFibGVTdGFydFBvcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIFwidGFibGVFbmRPZmZzZXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYmxlU3RhcnRQb3MgKyB0aGlzLnRhYmxlLm5vZGVTaXplIC0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDZWxsSW5mbyA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5wb3NBdCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgcm93U3RhcnQgPSB0aGlzLnRhYmxlU3RhcnRQb3M7OyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciByb3dFbmQgPSByb3dTdGFydCArIHRoaXMudGFibGVSb3dzW2ldLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkgPT09IHJvd0lkeCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGNvbElkeDtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBjZWxscyBmcm9tIHByZXZpb3VzIHJvdyh2aWEgcm93c3BhbilcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCB0aGlzLnRvdGFsQ29sdW1uQ291bnQgJiYgdGhpcy5yb3dJbmZvW2ldW2luZGV4XS5vZmZzZXQgPCByb3dTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPT09IHRoaXMudG90YWxDb2x1bW5Db3VudCA/IHJvd0VuZCA6IHRoaXMucm93SW5mb1tpXVtpbmRleF0ub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93U3RhcnQgPSByb3dFbmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXROb2RlQW5kUG9zID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHZhciBjZWxsSW5mbyA9IHRoaXMucm93SW5mb1tyb3dJZHhdW2NvbElkeF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlOiB0aGlzLnRhYmxlLm5vZGVBdChjZWxsSW5mby5vZmZzZXQgLSB0aGlzLnRhYmxlU3RhcnRPZmZzZXQpLFxuICAgICAgICAgICAgcG9zOiBjZWxsSW5mby5vZmZzZXQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZXh0ZW5kZWRSb3dzcGFuID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5leHRlbmRlZENvbHNwYW4gPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldFJvd3NwYW5Db3VudCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDb2xzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZGVjcmVhc2VDb2xzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZGVjcmVhc2VSb3dzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q29sc3BhblN0YXJ0SW5mbyA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRSb3dzcGFuU3RhcnRJbmZvID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENlbGxTdGFydE9mZnNldCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XS5vZmZzZXQ7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuZGVkUm93c3Bhbihyb3dJZHgsIGNvbElkeCkgPyB0aGlzLnBvc0F0KHJvd0lkeCwgY29sSWR4KSA6IG9mZnNldDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDZWxsRW5kT2Zmc2V0ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucm93SW5mb1tyb3dJZHhdW2NvbElkeF0sIG9mZnNldCA9IF9hLm9mZnNldCwgbm9kZVNpemUgPSBfYS5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kZWRSb3dzcGFuKHJvd0lkeCwgY29sSWR4KSA/IHRoaXMucG9zQXQocm93SWR4LCBjb2xJZHgpIDogb2Zmc2V0ICsgbm9kZVNpemU7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q2VsbEluZGV4ID0gZnVuY3Rpb24gKGNlbGxQb3MpIHtcbiAgICAgICAgZm9yICh2YXIgcm93SWR4ID0gMDsgcm93SWR4IDwgdGhpcy50b3RhbFJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICAgICAgdmFyIHJvd0luZm8gPSB0aGlzLnJvd0luZm9bcm93SWR4XTtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbElkeCA9IDA7IGNvbElkeCA8IHRoaXMudG90YWxDb2x1bW5Db3VudDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocm93SW5mb1tjb2xJZHhdLm9mZnNldCArIDEgPiBjZWxsUG9zLnBvcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Jvd0lkeCwgY29sSWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRSZWN0T2Zmc2V0cyA9IGZ1bmN0aW9uIChzdGFydENlbGxQb3MsIGVuZENlbGxQb3MpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChlbmRDZWxsUG9zID09PSB2b2lkIDApIHsgZW5kQ2VsbFBvcyA9IHN0YXJ0Q2VsbFBvczsgfVxuICAgICAgICBpZiAoc3RhcnRDZWxsUG9zLnBvcyA+IGVuZENlbGxQb3MucG9zKSB7XG4gICAgICAgICAgICBfYSA9IFtlbmRDZWxsUG9zLCBzdGFydENlbGxQb3NdLCBzdGFydENlbGxQb3MgPSBfYVswXSwgZW5kQ2VsbFBvcyA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfZCA9IHRoaXMuZ2V0Q2VsbEluZGV4KHN0YXJ0Q2VsbFBvcyksIHN0YXJ0Um93SWR4ID0gX2RbMF0sIHN0YXJ0Q29sSWR4ID0gX2RbMV07XG4gICAgICAgIHZhciBfZSA9IHRoaXMuZ2V0Q2VsbEluZGV4KGVuZENlbGxQb3MpLCBlbmRSb3dJZHggPSBfZVswXSwgZW5kQ29sSWR4ID0gX2VbMV07XG4gICAgICAgIF9iID0gZ2V0U29ydGVkTnVtUGFpcihzdGFydFJvd0lkeCwgZW5kUm93SWR4KSwgc3RhcnRSb3dJZHggPSBfYlswXSwgZW5kUm93SWR4ID0gX2JbMV07XG4gICAgICAgIF9jID0gZ2V0U29ydGVkTnVtUGFpcihzdGFydENvbElkeCwgZW5kQ29sSWR4KSwgc3RhcnRDb2xJZHggPSBfY1swXSwgZW5kQ29sSWR4ID0gX2NbMV07XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNwYW5uZWRPZmZzZXRzKHsgc3RhcnRSb3dJZHg6IHN0YXJ0Um93SWR4LCBzdGFydENvbElkeDogc3RhcnRDb2xJZHgsIGVuZFJvd0lkeDogZW5kUm93SWR4LCBlbmRDb2xJZHg6IGVuZENvbElkeCB9KTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRTcGFubmVkT2Zmc2V0cyA9IGZ1bmN0aW9uIChzZWxlY3Rpb25JbmZvKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25JbmZvO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlT2Zmc2V0TWFwO1xufSgpKTtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG52YXIgY3JlYXRlT2Zmc2V0TWFwID0gZnVuY3Rpb24gKGhlYWRPckJvZHksIHN0YXJ0T2Zmc2V0KSB7XG4gICAgdmFyIGNlbGxJbmZvTWF0cml4ID0gW107XG4gICAgaGVhZE9yQm9keS5mb3JFYWNoKGZ1bmN0aW9uIChyb3csIHJvd09mZnNldCkge1xuICAgICAgICAvLyBnZXQgcm93IGluZGV4IGJhc2VkIG9uIHRhYmxlKG5vdCB0YWJsZSBoZWFkIG9yIHRhYmxlIGJvZHkpXG4gICAgICAgIHZhciByb3dJbmZvID0geyByb3dzcGFuTWFwOiB7fSwgY29sc3Bhbk1hcDoge30sIGxlbmd0aDogMCB9O1xuICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbiAoX2EsIGNlbGxPZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBub2RlU2l6ZSA9IF9hLm5vZGVTaXplO1xuICAgICAgICAgICAgdmFyIGNvbElkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocm93SW5mb1tjb2xJZHhdKSB7XG4gICAgICAgICAgICAgICAgY29sSWR4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dJbmZvW2NvbElkeF0gPSB7XG4gICAgICAgICAgICAgICAgLy8gMiBpcyB0aGUgc3VtIG9mIHRoZSBmcm9udCBhbmQgYmFjayBwb3NpdGlvbnMgb2YgdGhlIHRhZ1xuICAgICAgICAgICAgICAgIG9mZnNldDogc3RhcnRPZmZzZXQgKyByb3dPZmZzZXQgKyBjZWxsT2Zmc2V0ICsgMixcbiAgICAgICAgICAgICAgICBub2RlU2l6ZTogbm9kZVNpemUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcm93SW5mby5sZW5ndGggKz0gMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNlbGxJbmZvTWF0cml4LnB1c2gocm93SW5mbyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNlbGxJbmZvTWF0cml4O1xufTtcbmZ1bmN0aW9uIG1peGluVGFibGVPZmZzZXRNYXBQcm90b3R5cGUob2Zmc2V0TWFwTWl4aW4sIGNyZWF0ZU9mZnNldE1hcE1peGluKSB7XG4gICAgYXNzaWduKFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgb2Zmc2V0TWFwTWl4aW4pO1xuICAgIGNyZWF0ZU9mZnNldE1hcCA9IGNyZWF0ZU9mZnNldE1hcE1peGluO1xuICAgIHJldHVybiBUYWJsZU9mZnNldE1hcDtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmFuZ2VzKGRvYywgbWFwLCBfYSkge1xuICAgIHZhciBzdGFydFJvd0lkeCA9IF9hLnN0YXJ0Um93SWR4LCBzdGFydENvbElkeCA9IF9hLnN0YXJ0Q29sSWR4LCBlbmRSb3dJZHggPSBfYS5lbmRSb3dJZHgsIGVuZENvbElkeCA9IF9hLmVuZENvbElkeDtcbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgcm93SWR4ID0gc3RhcnRSb3dJZHg7IHJvd0lkeCA8PSBlbmRSb3dJZHg7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGNvbElkeCA9IHN0YXJ0Q29sSWR4OyBjb2xJZHggPD0gZW5kQ29sSWR4OyBjb2xJZHggKz0gMSkge1xuICAgICAgICAgICAgdmFyIF9iID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgY29sSWR4KSwgb2Zmc2V0ID0gX2Iub2Zmc2V0LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFNlbGVjdGlvblJhbmdlKGRvYy5yZXNvbHZlKG9mZnNldCArIDEpLCBkb2MucmVzb2x2ZShvZmZzZXQgKyBub2RlU2l6ZSAtIDEpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlRnJhZ21lbnQodGFibGVIZWFkLCB0YWJsZUJvZHkpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBbXTtcbiAgICBpZiAodGFibGVIZWFkLmNoaWxkQ291bnQpIHtcbiAgICAgICAgZnJhZ21lbnQucHVzaCh0YWJsZUhlYWQpO1xuICAgIH1cbiAgICBpZiAodGFibGVCb2R5LmNoaWxkQ291bnQpIHtcbiAgICAgICAgZnJhZ21lbnQucHVzaCh0YWJsZUJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShmcmFnbWVudCk7XG59XG52YXIgQ2VsbFNlbGVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDZWxsU2VsZWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENlbGxTZWxlY3Rpb24oc3RhcnRDZWxsUG9zLCBlbmRDZWxsUG9zKSB7XG4gICAgICAgIGlmIChlbmRDZWxsUG9zID09PSB2b2lkIDApIHsgZW5kQ2VsbFBvcyA9IHN0YXJ0Q2VsbFBvczsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZG9jID0gc3RhcnRDZWxsUG9zLm5vZGUoMCk7XG4gICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoc3RhcnRDZWxsUG9zKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkluZm8gPSBtYXAuZ2V0UmVjdE9mZnNldHMoc3RhcnRDZWxsUG9zLCBlbmRDZWxsUG9zKTtcbiAgICAgICAgdmFyIHJhbmdlcyA9IGdldFNlbGVjdGlvblJhbmdlcyhkb2MsIG1hcCwgc2VsZWN0aW9uSW5mbyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmFuZ2VzWzBdLiRmcm9tLCByYW5nZXNbMF0uJHRvLCByYW5nZXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXJ0Q2VsbCA9IHN0YXJ0Q2VsbFBvcztcbiAgICAgICAgX3RoaXMuZW5kQ2VsbCA9IGVuZENlbGxQb3M7XG4gICAgICAgIF90aGlzLm9mZnNldE1hcCA9IG1hcDtcbiAgICAgICAgX3RoaXMuaXNDZWxsU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBpcyB0aGUgYXBpIG9mIHRoZSAnU2VsZWN0aW9uJyBpbiBwcm9zZW1pcnJvcixcbiAgICAgICAgLy8gYW5kIGlzIHVzZWQgdG8gZGlzYWJsZSB0aGUgdGV4dCBzZWxlY3Rpb24uXG4gICAgICAgIF90aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnRDZWxsLnBvcztcbiAgICAgICAgdmFyIGVuZFBvcyA9IHRoaXMuZW5kQ2VsbC5wb3M7XG4gICAgICAgIHZhciBzdGFydENlbGwgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcChzdGFydFBvcykpO1xuICAgICAgICB2YXIgZW5kQ2VsbCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKGVuZFBvcykpO1xuICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKHN0YXJ0Q2VsbCk7XG4gICAgICAgIC8vIHRleHQgc2VsZWN0aW9uIHdoZW4gcm93cyBvciBjb2x1bW5zIGFyZSBkZWxldGVkXG4gICAgICAgIGlmICh0aGlzLm9mZnNldE1hcC50b3RhbENvbHVtbkNvdW50ID4gbWFwLnRvdGFsQ29sdW1uQ291bnQgfHxcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0TWFwLnRvdGFsUm93Q291bnQgPiBtYXAudG90YWxSb3dDb3VudCkge1xuICAgICAgICAgICAgdmFyIGRlcHRoTWFwID0geyB0YWJsZUJvZHk6IDEsIHRhYmxlUm93OiAyLCB0YWJsZUNlbGw6IDMsIHBhcmFncmFwaDogNCB9O1xuICAgICAgICAgICAgdmFyIGRlcHRoRnJvbVRhYmxlID0gZGVwdGhNYXBbZW5kQ2VsbC5wYXJlbnQudHlwZS5uYW1lXTtcbiAgICAgICAgICAgIHZhciB0YWJsZUVuZFBvcyA9IGVuZENlbGwuZW5kKGVuZENlbGwuZGVwdGggLSBkZXB0aEZyb21UYWJsZSk7XG4gICAgICAgICAgICAvLyBzdWJ0cmFjdCA0KDwvdGQ+PC90cj48L3Rib2R5PjwvdGFibGU+IHRhZyBsZW5ndGgpXG4gICAgICAgICAgICB2YXIgZnJvbSA9IE1hdGgubWluKHRhYmxlRW5kUG9zIC0gNCwgZW5kQ2VsbC5wb3MpO1xuICAgICAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsU2VsZWN0aW9uKHN0YXJ0Q2VsbCwgZW5kQ2VsbCk7XG4gICAgfTtcbiAgICBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgIHJldHVybiAoY2VsbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIGNlbGwuc3RhcnRDZWxsLnBvcyA9PT0gdGhpcy5zdGFydENlbGwucG9zICYmXG4gICAgICAgICAgICBjZWxsLmVuZENlbGwucG9zID09PSB0aGlzLmVuZENlbGwucG9zKTtcbiAgICB9O1xuICAgIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IHRoaXMuc3RhcnRDZWxsLm5vZGUoLTIpO1xuICAgICAgICB2YXIgdGFibGVPZmZzZXQgPSB0aGlzLnN0YXJ0Q2VsbC5zdGFydCgtMik7XG4gICAgICAgIHZhciByb3cgPSB0YWJsZS5jaGlsZCgxKS5maXJzdENoaWxkO1xuICAgICAgICB2YXIgdGFibGVIZWFkID0gdGFibGUuY2hpbGQoMCkudHlwZS5jcmVhdGUoKTtcbiAgICAgICAgdmFyIHRhYmxlQm9keSA9IHRhYmxlLmNoaWxkKDEpLnR5cGUuY3JlYXRlKCk7XG4gICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUodGhpcy5zdGFydENlbGwpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyh0aGlzLnN0YXJ0Q2VsbCwgdGhpcy5lbmRDZWxsKTtcbiAgICAgICAgdmFyIHN0YXJ0Um93SWR4ID0gc2VsZWN0aW9uSW5mby5zdGFydFJvd0lkeCwgc3RhcnRDb2xJZHggPSBzZWxlY3Rpb25JbmZvLnN0YXJ0Q29sSWR4LCBlbmRSb3dJZHggPSBzZWxlY3Rpb25JbmZvLmVuZFJvd0lkeCwgZW5kQ29sSWR4ID0gc2VsZWN0aW9uSW5mby5lbmRDb2xJZHg7XG4gICAgICAgIHZhciBpc1RhYmxlSGVhZENlbGwgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgcm93SWR4ID0gc3RhcnRSb3dJZHg7IHJvd0lkeCA8PSBlbmRSb3dJZHg7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbElkeCA9IHN0YXJ0Q29sSWR4OyBjb2xJZHggPD0gZW5kQ29sSWR4OyBjb2xJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCBjb2xJZHgpLm9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRhYmxlLm5vZGVBdChvZmZzZXQgLSB0YWJsZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNUYWJsZUhlYWRDZWxsID0gY2VsbC50eXBlLm5hbWUgPT09ICd0YWJsZUhlYWRDZWxsJztcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFyayB0aGUgZXh0ZW5kZWQgY2VsbCBmb3IgcGFzdGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLmV4dGVuZGVkUm93c3Bhbihyb3dJZHgsIGNvbElkeCkgfHwgbWFwLmV4dGVuZGVkQ29sc3Bhbihyb3dJZHgsIGNvbElkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goY2VsbC50eXBlLmNyZWF0ZSh7IGV4dGVuZGVkOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goY2VsbC5jb3B5KGNlbGwuY29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvcGllZFJvdyA9IHJvdy5jb3B5KEZyYWdtZW50LmZyb20oY2VsbHMpKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gaXNUYWJsZUhlYWRDZWxsID8gdGFibGVIZWFkIDogdGFibGVCb2R5O1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGFyZ2V0Tm9kZS5jb250ZW50ID0gdGFyZ2V0Tm9kZS5jb250ZW50LmFwcGVuZChGcmFnbWVudC5mcm9tKGNvcGllZFJvdykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoY3JlYXRlVGFibGVGcmFnbWVudCh0YWJsZUhlYWQsIHRhYmxlQm9keSksIDEsIDEpO1xuICAgIH07XG4gICAgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2VsbFNlbGVjdGlvbjtcbn0oU2VsZWN0aW9uKSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlSGVhZFJvdyhjb2x1bW5Db3VudCwgc2NoZW1hLCBkYXRhKSB7XG4gICAgdmFyIF9hID0gc2NoZW1hLm5vZGVzLCB0YWJsZVJvdyA9IF9hLnRhYmxlUm93LCB0YWJsZUhlYWRDZWxsID0gX2EudGFibGVIZWFkQ2VsbCwgcGFyYWdyYXBoID0gX2EucGFyYWdyYXBoO1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjb2x1bW5Db3VudDsgaW5kZXggKz0gMSkge1xuICAgICAgICB2YXIgdGV4dCA9IGRhdGEgJiYgZGF0YVtpbmRleF07XG4gICAgICAgIHZhciBwYXJhID0gcGFyYWdyYXBoLmNyZWF0ZShudWxsLCB0ZXh0ID8gc2NoZW1hLnRleHQodGV4dCkgOiBbXSk7XG4gICAgICAgIGNlbGxzLnB1c2godGFibGVIZWFkQ2VsbC5jcmVhdGUobnVsbCwgcGFyYSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RhYmxlUm93LmNyZWF0ZShudWxsLCBjZWxscyldO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGVCb2R5Um93cyhyb3dDb3VudCwgY29sdW1uQ291bnQsIHNjaGVtYSwgZGF0YSkge1xuICAgIHZhciBfYSA9IHNjaGVtYS5ub2RlcywgdGFibGVSb3cgPSBfYS50YWJsZVJvdywgdGFibGVCb2R5Q2VsbCA9IF9hLnRhYmxlQm9keUNlbGwsIHBhcmFncmFwaCA9IF9hLnBhcmFncmFwaDtcbiAgICB2YXIgdGFibGVSb3dzID0gW107XG4gICAgZm9yICh2YXIgcm93SWR4ID0gMDsgcm93SWR4IDwgcm93Q291bnQ7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgIHZhciBjZWxscyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjb2xJZHggPSAwOyBjb2xJZHggPCBjb2x1bW5Db3VudDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZGF0YSAmJiBkYXRhW3Jvd0lkeCAqIGNvbHVtbkNvdW50ICsgY29sSWR4XTtcbiAgICAgICAgICAgIHZhciBwYXJhID0gcGFyYWdyYXBoLmNyZWF0ZShudWxsLCB0ZXh0ID8gc2NoZW1hLnRleHQodGV4dCkgOiBbXSk7XG4gICAgICAgICAgICBjZWxscy5wdXNoKHRhYmxlQm9keUNlbGwuY3JlYXRlKG51bGwsIHBhcmEpKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZVJvd3MucHVzaCh0YWJsZVJvdy5jcmVhdGUobnVsbCwgY2VsbHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlUm93cztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUR1bW15Q2VsbHMoY29sdW1uQ291bnQsIHJvd0lkeCwgc2NoZW1hLCBhdHRycykge1xuICAgIGlmIChhdHRycyA9PT0gdm9pZCAwKSB7IGF0dHJzID0gbnVsbDsgfVxuICAgIHZhciBfYSA9IHNjaGVtYS5ub2RlcywgdGFibGVIZWFkQ2VsbCA9IF9hLnRhYmxlSGVhZENlbGwsIHRhYmxlQm9keUNlbGwgPSBfYS50YWJsZUJvZHlDZWxsLCBwYXJhZ3JhcGggPSBfYS5wYXJhZ3JhcGg7XG4gICAgdmFyIGNlbGwgPSByb3dJZHggPT09IDAgPyB0YWJsZUhlYWRDZWxsIDogdGFibGVCb2R5Q2VsbDtcbiAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY29sdW1uQ291bnQ7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgY2VsbHMucHVzaChjZWxsLmNyZWF0ZShhdHRycywgcGFyYWdyYXBoLmNyZWF0ZSgpKSk7XG4gICAgfVxuICAgIHJldHVybiBjZWxscztcbn1cbmZ1bmN0aW9uIGZpbmRDZWxsRWxlbWVudChub2RlLCByb290KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gcm9vdCkge1xuICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1REJyB8fCBub2RlLm5vZGVOYW1lID09PSAnVEgnKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRDZWxsKHBvcykge1xuICAgIHJldHVybiBmaW5kTm9kZUJ5KHBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ3RhYmxlSGVhZENlbGwnIHx8IHR5cGUubmFtZSA9PT0gJ3RhYmxlQm9keUNlbGwnO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyICRhbmNob3IgPSBzZWxlY3Rpb24uJGFuY2hvcjtcbiAgICAgICAgdmFyIGZvdW5kQ2VsbCA9IGZpbmRDZWxsKCRhbmNob3IpO1xuICAgICAgICBpZiAoZm91bmRDZWxsKSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gJGFuY2hvci5ub2RlKDApLnJlc29sdmUoJGFuY2hvci5iZWZvcmUoZm91bmRDZWxsLmRlcHRoKSk7XG4gICAgICAgICAgICByZXR1cm4geyBhbmNob3I6IGFuY2hvciwgaGVhZDogYW5jaG9yIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9hID0gc2VsZWN0aW9uLCBzdGFydENlbGwgPSBfYS5zdGFydENlbGwsIGVuZENlbGwgPSBfYS5lbmRDZWxsO1xuICAgIHJldHVybiB7IGFuY2hvcjogc3RhcnRDZWxsLCBoZWFkOiBlbmRDZWxsIH07XG59XG5mdW5jdGlvbiBnZXRUYWJsZUNvbnRlbnRGcm9tU2xpY2Uoc2xpY2UpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHNsaWNlLnNpemUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBzbGljZS5jb250ZW50LCBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQsIG9wZW5FbmQgPSBzbGljZS5vcGVuRW5kO1xuICAgICAgICBpZiAoY29udGVudC5jaGlsZENvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29udGVudC5jaGlsZENvdW50ID09PSAxICYmXG4gICAgICAgICAgICAoKG9wZW5TdGFydCA+IDAgJiYgb3BlbkVuZCA+IDApIHx8ICgoX2EgPSBjb250ZW50LmZpcnN0Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlLm5hbWUpID09PSAndGFibGUnKSkge1xuICAgICAgICAgICAgb3BlblN0YXJ0IC09IDE7XG4gICAgICAgICAgICBvcGVuRW5kIC09IDE7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLm5hbWUgPT09ICd0YWJsZUhlYWQnIHx8XG4gICAgICAgICAgICBjb250ZW50LmZpcnN0Q2hpbGQudHlwZS5uYW1lID09PSAndGFibGVCb2R5Jykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRSb3dBbmRDb2x1bW5Db3VudChfYSkge1xuICAgIHZhciBzdGFydFJvd0lkeCA9IF9hLnN0YXJ0Um93SWR4LCBzdGFydENvbElkeCA9IF9hLnN0YXJ0Q29sSWR4LCBlbmRSb3dJZHggPSBfYS5lbmRSb3dJZHgsIGVuZENvbElkeCA9IF9hLmVuZENvbElkeDtcbiAgICB2YXIgcm93Q291bnQgPSBlbmRSb3dJZHggLSBzdGFydFJvd0lkeCArIDE7XG4gICAgdmFyIGNvbHVtbkNvdW50ID0gZW5kQ29sSWR4IC0gc3RhcnRDb2xJZHggKyAxO1xuICAgIHJldHVybiB7IHJvd0NvdW50OiByb3dDb3VudCwgY29sdW1uQ291bnQ6IGNvbHVtbkNvdW50IH07XG59XG5mdW5jdGlvbiBzZXRBdHRycyhjZWxsLCBhdHRycykge1xuICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGNlbGwuYXR0cnMpLCBhdHRycyk7XG59XG5cbnZhciBwbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCdjZWxsU2VsZWN0aW9uJyk7XG52YXIgTU9VU0VfUklHSFRfQlVUVE9OID0gMjtcbnZhciBUYWJsZVNlbGVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZVNlbGVjdGlvbih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7XG4gICAgICAgICAgICBtb3VzZWRvd246IHRoaXMuaGFuZGxlTW91c2Vkb3duLmJpbmQodGhpcyksXG4gICAgICAgICAgICBtb3VzZW1vdmU6IHRoaXMuaGFuZGxlTW91c2Vtb3ZlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBtb3VzZXVwOiB0aGlzLmhhbmRsZU1vdXNldXAuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGFydENlbGxQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVycy5tb3VzZWRvd24pO1xuICAgIH07XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLmhhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgZm91bmRDZWxsID0gZmluZENlbGxFbGVtZW50KGV2LnRhcmdldCwgdGhpcy52aWV3LmRvbSk7XG4gICAgICAgIGlmIChldi5idXR0b24gPT09IE1PVVNFX1JJR0hUX0JVVFRPTikge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRDZWxsKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRDZWxsUG9zID0gdGhpcy5nZXRDZWxsUG9zKGV2KTtcbiAgICAgICAgICAgIGlmIChzdGFydENlbGxQb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q2VsbFBvcyA9IHN0YXJ0Q2VsbFBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmluZEV2ZW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVNb3VzZW1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIHByZXZFbmRDZWxsT2Zmc2V0ID0gcGx1Z2luS2V5LmdldFN0YXRlKHRoaXMudmlldy5zdGF0ZSk7XG4gICAgICAgIHZhciBlbmRDZWxsUG9zID0gdGhpcy5nZXRDZWxsUG9zKGV2KTtcbiAgICAgICAgdmFyIHN0YXJ0Q2VsbFBvcyA9IHRoaXMuc3RhcnRDZWxsUG9zO1xuICAgICAgICB2YXIgcHJldkVuZENlbGxQb3M7XG4gICAgICAgIGlmIChwcmV2RW5kQ2VsbE9mZnNldCkge1xuICAgICAgICAgICAgcHJldkVuZENlbGxQb3MgPSB0aGlzLnZpZXcuc3RhdGUuZG9jLnJlc29sdmUocHJldkVuZENlbGxPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0Q2VsbFBvcyAhPT0gZW5kQ2VsbFBvcykge1xuICAgICAgICAgICAgcHJldkVuZENlbGxQb3MgPSBzdGFydENlbGxQb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZFbmRDZWxsUG9zICYmIHN0YXJ0Q2VsbFBvcyAmJiBlbmRDZWxsUG9zKSB7XG4gICAgICAgICAgICB0aGlzLnNldENlbGxTZWxlY3Rpb24oc3RhcnRDZWxsUG9zLCBlbmRDZWxsUG9zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLmhhbmRsZU1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRDZWxsUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmJpbmRFdmVudCgpO1xuICAgICAgICBpZiAocGx1Z2luS2V5LmdldFN0YXRlKHRoaXMudmlldy5zdGF0ZSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0aGlzLnZpZXcuc3RhdGUudHIuc2V0TWV0YShwbHVnaW5LZXksIC0xKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS5iaW5kRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb20gPSB0aGlzLnZpZXcuZG9tO1xuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVycy5tb3VzZW1vdmUpO1xuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlcnMubW91c2V1cCk7XG4gICAgfTtcbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUudW5iaW5kRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb20gPSB0aGlzLnZpZXcuZG9tO1xuICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVycy5tb3VzZW1vdmUpO1xuICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlcnMubW91c2V1cCk7XG4gICAgfTtcbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0Q2VsbFBvcyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY2xpZW50WCA9IF9hLmNsaWVudFgsIGNsaWVudFkgPSBfYS5jbGllbnRZO1xuICAgICAgICB2YXIgbW91c2VQb3MgPSB0aGlzLnZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBjbGllbnRYLCB0b3A6IGNsaWVudFkgfSk7XG4gICAgICAgIGlmIChtb3VzZVBvcykge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHRoaXMudmlldy5zdGF0ZS5kb2M7XG4gICAgICAgICAgICB2YXIgY3VycmVudFBvcyA9IGRvYy5yZXNvbHZlKG1vdXNlUG9zLnBvcyk7XG4gICAgICAgICAgICB2YXIgZm91bmRDZWxsID0gZmluZENlbGwoY3VycmVudFBvcyk7XG4gICAgICAgICAgICBpZiAoZm91bmRDZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxPZmZzZXQgPSBjdXJyZW50UG9zLmJlZm9yZShmb3VuZENlbGwuZGVwdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2MucmVzb2x2ZShjZWxsT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS5zZXRDZWxsU2VsZWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0Q2VsbFBvcywgZW5kQ2VsbFBvcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50cjtcbiAgICAgICAgdmFyIHN0YXJ0aW5nID0gcGx1Z2luS2V5LmdldFN0YXRlKHRoaXMudmlldy5zdGF0ZSkgPT09IG51bGw7XG4gICAgICAgIHZhciBjZWxsU2VsZWN0aW9uID0gbmV3IENlbGxTZWxlY3Rpb24oc3RhcnRDZWxsUG9zLCBlbmRDZWxsUG9zKTtcbiAgICAgICAgaWYgKHN0YXJ0aW5nIHx8ICFzZWxlY3Rpb24uZXEoY2VsbFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBuZXdUciA9IHRyLnNldFNlbGVjdGlvbihjZWxsU2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdGFydGluZykge1xuICAgICAgICAgICAgICAgIG5ld1RyLnNldE1ldGEocGx1Z2luS2V5LCBlbmRDZWxsUG9zLnBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZXJzLm1vdXNlZG93bik7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVTZWxlY3Rpb247XG59KCkpO1xuXG52YXIgU0VMRUNURURfQ0VMTF9DTEFTU19OQU1FID0gY2xzKCdjZWxsLXNlbGVjdGVkJyk7XG5mdW5jdGlvbiBkcmF3Q2VsbFNlbGVjdGlvbihfYSkge1xuICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIGRvYyA9IF9hLmRvYztcbiAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikge1xuICAgICAgICB2YXIgY2VsbHNfMSA9IFtdO1xuICAgICAgICB2YXIgcmFuZ2VzID0gc2VsZWN0aW9uLnJhbmdlcztcbiAgICAgICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBfYS4kZnJvbSwgJHRvID0gX2EuJHRvO1xuICAgICAgICAgICAgY2VsbHNfMS5wdXNoKERlY29yYXRpb24ubm9kZSgkZnJvbS5wb3MgLSAxLCAkdG8ucG9zICsgMSwgeyBjbGFzczogU0VMRUNURURfQ0VMTF9DTEFTU19OQU1FIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGNlbGxzXzEpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRhYmxlU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBwbHVnaW5LZXksXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHk6IGZ1bmN0aW9uICh0ciwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbE9mZnNldCA9IHRyLmdldE1ldGEocGx1Z2luS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbE9mZnNldCA9PT0gLTEgPyBudWxsIDogY2VsbE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbF8xKHZhbHVlKSB8fCAhdHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBfYSA9IHRyLm1hcHBpbmcubWFwUmVzdWx0KHZhbHVlKSwgZGVsZXRlZCA9IF9hLmRlbGV0ZWQsIHBvcyA9IF9hLnBvcztcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlZCA/IG51bGwgOiBwb3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IGRyYXdDZWxsU2VsZWN0aW9uLFxuICAgICAgICAgICAgY3JlYXRlU2VsZWN0aW9uQmV0d2VlbjogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGxfMShwbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uIChlZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhYmxlU2VsZWN0aW9uKGVkaXRvclZpZXcpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEBjbGFzc1xuICogQGlnbm9yZVxuICogQGNsYXNzZGVzYyBFUzYgTWFwXG4gKi9cbnZhciBNYXAkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXAoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH1cbiAgICBNYXAucHJvdG90eXBlLmdldEtleUluZGV4ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gaW5BcnJheV8xKGtleSwgdGhpcy5rZXlzKTtcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbdGhpcy5nZXRLZXlJbmRleChrZXkpXTtcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGtleUluZGV4ID0gdGhpcy5nZXRLZXlJbmRleChrZXkpO1xuICAgICAgICBpZiAoa2V5SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXNba2V5SW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5SW5kZXgoa2V5KSA+IC0xO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBrZXlJbmRleCA9IHRoaXMuZ2V0S2V5SW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKGtleUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMua2V5cy5zcGxpY2Uoa2V5SW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGtleUluZGV4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpc0FyZyA9PT0gdm9pZCAwKSB7IHRoaXNBcmcgPSB0aGlzOyB9XG4gICAgICAgIHRoaXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIF90aGlzLmtleXNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgX3RoaXMua2V5c1tpbmRleF0sIF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICB9O1xuICAgIHJldHVybiBNYXA7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSW1wbGVtZW50cyBpMThuXG4gKiBAYXV0aG9yIE5ITiBDbG91ZCBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xudmFyIERFRkFVTFRfQ09ERSA9ICdlbi1VUyc7XG4vKipcbiAqIENsYXNzIEkxOG5cbiAqIEBpZ25vcmVcbiAqL1xudmFyIEkxOG4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSTE4bigpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gREVGQVVMVF9DT0RFO1xuICAgICAgICB0aGlzLmxhbmdzID0gbmV3IE1hcCQxKCk7XG4gICAgfVxuICAgIEkxOG4ucHJvdG90eXBlLnNldENvZGUgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlIHx8IERFRkFVTFRfQ09ERTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBsYW5ndWFnZSBzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gY29kZXMgbG9jYWxlIGNvZGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBsYW5ndWFnZSBzZXRcbiAgICAgKi9cbiAgICBJMThuLnByb3RvdHlwZS5zZXRMYW5ndWFnZSA9IGZ1bmN0aW9uIChjb2RlcywgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb2RlcyA9IFtdLmNvbmNhdChjb2Rlcyk7XG4gICAgICAgIGNvZGVzLmZvckVhY2goZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMubGFuZ3MuaGFzKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFuZ3Muc2V0KGNvZGUsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmdEYXRhID0gX3RoaXMubGFuZ3MuZ2V0KGNvZGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxhbmdzLnNldChjb2RlLCBleHRlbmRfMShsYW5nRGF0YSwgZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEkxOG4ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXksIGNvZGUpIHtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYW5nU2V0ID0gdGhpcy5sYW5ncy5nZXQoY29kZSk7XG4gICAgICAgIGlmICghbGFuZ1NldCkge1xuICAgICAgICAgICAgbGFuZ1NldCA9IHRoaXMubGFuZ3MuZ2V0KERFRkFVTFRfQ09ERSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSBsYW5nU2V0W2tleV07XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gdGV4dCBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGluIFwiICsgY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gSTE4bjtcbn0oKSk7XG52YXIgaTE4biA9IG5ldyBJMThuKCk7XG5cbnZhciBjb250ZXh0TWVudUdyb3VwcyA9IFtcbiAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ0FkZCByb3cgdG8gdXAnLFxuICAgICAgICAgICAgY29tbWFuZDogJ2FkZFJvd1RvVXAnLFxuICAgICAgICAgICAgZGlzYWJsZUluVGhlYWQ6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhZGQtcm93LXVwJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgYWN0aW9uOiAnQWRkIHJvdyB0byBkb3duJyxcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdhZGRSb3dUb0Rvd24nLFxuICAgICAgICAgICAgZGlzYWJsZUluVGhlYWQ6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhZGQtcm93LWRvd24nLFxuICAgICAgICB9LFxuICAgICAgICB7IGFjdGlvbjogJ1JlbW92ZSByb3cnLCBjb21tYW5kOiAncmVtb3ZlUm93JywgZGlzYWJsZUluVGhlYWQ6IHRydWUsIGNsYXNzTmFtZTogJ3JlbW92ZS1yb3cnIH0sXG4gICAgXSxcbiAgICBbXG4gICAgICAgIHsgYWN0aW9uOiAnQWRkIGNvbHVtbiB0byBsZWZ0JywgY29tbWFuZDogJ2FkZENvbHVtblRvTGVmdCcsIGNsYXNzTmFtZTogJ2FkZC1jb2x1bW4tbGVmdCcgfSxcbiAgICAgICAgeyBhY3Rpb246ICdBZGQgY29sdW1uIHRvIHJpZ2h0JywgY29tbWFuZDogJ2FkZENvbHVtblRvUmlnaHQnLCBjbGFzc05hbWU6ICdhZGQtY29sdW1uLXJpZ2h0JyB9LFxuICAgICAgICB7IGFjdGlvbjogJ1JlbW92ZSBjb2x1bW4nLCBjb21tYW5kOiAncmVtb3ZlQ29sdW1uJywgY2xhc3NOYW1lOiAncmVtb3ZlLWNvbHVtbicgfSxcbiAgICBdLFxuICAgIFtcbiAgICAgICAge1xuICAgICAgICAgICAgYWN0aW9uOiAnQWxpZ24gY29sdW1uIHRvIGxlZnQnLFxuICAgICAgICAgICAgY29tbWFuZDogJ2FsaWduQ29sdW1uJyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHsgYWxpZ246ICdsZWZ0JyB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYWxpZ24tY29sdW1uLWxlZnQnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBhY3Rpb246ICdBbGlnbiBjb2x1bW4gdG8gY2VudGVyJyxcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdhbGlnbkNvbHVtbicsXG4gICAgICAgICAgICBwYXlsb2FkOiB7IGFsaWduOiAnY2VudGVyJyB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYWxpZ24tY29sdW1uLWNlbnRlcicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ0FsaWduIGNvbHVtbiB0byByaWdodCcsXG4gICAgICAgICAgICBjb21tYW5kOiAnYWxpZ25Db2x1bW4nLFxuICAgICAgICAgICAgcGF5bG9hZDogeyBhbGlnbjogJ3JpZ2h0JyB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYWxpZ24tY29sdW1uLXJpZ2h0JyxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIFt7IGFjdGlvbjogJ1JlbW92ZSB0YWJsZScsIGNvbW1hbmQ6ICdyZW1vdmVUYWJsZScsIGNsYXNzTmFtZTogJ3JlbW92ZS10YWJsZScgfV0sXG5dO1xuZnVuY3Rpb24gZ2V0Q29udGV4dE1lbnVHcm91cHMoZXZlbnRFbWl0dGVyLCBpblRhYmxlSGVhZCkge1xuICAgIHJldHVybiBjb250ZXh0TWVudUdyb3Vwc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChjb250ZXh0TWVudUdyb3VwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWVudUdyb3VwLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfYS5hY3Rpb24sIGNvbW1hbmQgPSBfYS5jb21tYW5kLCBwYXlsb2FkID0gX2EucGF5bG9hZCwgZGlzYWJsZUluVGhlYWQgPSBfYS5kaXNhYmxlSW5UaGVhZCwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogaTE4bi5nZXQoYWN0aW9uKSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjb21tYW5kJywgY29tbWFuZCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogaW5UYWJsZUhlYWQgJiYgISFkaXNhYmxlSW5UaGVhZCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC5jb25jYXQoKTtcbn1cbmZ1bmN0aW9uIHRhYmxlQ29udGV4dE1lbnUoZXZlbnRFbWl0dGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgY29udGV4dG1lbnU6IGZ1bmN0aW9uICh2aWV3LCBldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVDZWxsID0gZmluZENlbGxFbGVtZW50KGV2LnRhcmdldCwgdmlldy5kb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFibGVDZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gZXYsIGNsaWVudFggPSBfYS5jbGllbnRYLCBjbGllbnRZID0gX2EuY2xpZW50WTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IHZpZXcuZG9tLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxlZnQgPSBfYi5sZWZ0LCB0b3BfMSA9IF9iLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpblRhYmxlSGVhZCA9IHRhYmxlQ2VsbC5ub2RlTmFtZSA9PT0gJ1RIJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjb250ZXh0bWVudScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHsgbGVmdDogY2xpZW50WCAtIGxlZnQgKyAxMCArIFwicHhcIiwgdG9wOiBjbGllbnRZIC0gdG9wXzEgKyAzMCArIFwicHhcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbnVHcm91cHM6IGdldENvbnRleHRNZW51R3JvdXBzKGV2ZW50RW1pdHRlciwgaW5UYWJsZUhlYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2VsbDogdGFibGVDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHRhc2soKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbiAodmlldywgZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gZXYsIGNsaWVudFggPSBfYS5jbGllbnRYLCBjbGllbnRZID0gX2EuY2xpZW50WTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IGxlZnQ6IGNsaWVudFgsIHRvcDogY2xpZW50WSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdXNlUG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSB2aWV3LnN0YXRlLCBkb2MgPSBfYi5kb2MsIHRyID0gX2IudHI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFBvcyA9IGRvYy5yZXNvbHZlKG1vdXNlUG9zLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdEl0ZW0gPSBmaW5kTGlzdEl0ZW0oY3VycmVudFBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQsICc6YmVmb3JlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBldiwgb2Zmc2V0WCA9IF9jLm9mZnNldFgsIG9mZnNldFkgPSBfYy5vZmZzZXRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaXN0SXRlbSB8fCAhaXNQb3NpdGlvbkluQm94KHN0eWxlLCBvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gY3VycmVudFBvcy5iZWZvcmUobGlzdEl0ZW0uZGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gbGlzdEl0ZW0ubm9kZS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAob2Zmc2V0LCBudWxsLCBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGF0dHJzKSwgeyBjaGVja2VkOiAhYXR0cnMuY2hlY2tlZCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxudmFyIEVYQ0VQVF9UWVBFUyA9IFsnaW1hZ2UnLCAnbGluaycsICdjdXN0b21CbG9jaycsICdmcm9udE1hdHRlciddO1xudmFyIE1BUktfVFlQRVMgPSBbJ3N0cm9uZycsICdzdHJpa2UnLCAnZW1waCcsICdjb2RlJ107XG52YXIgTElTVF9UWVBFUyA9IFsnYnVsbGV0TGlzdCcsICdvcmRlcmVkTGlzdCcsICd0YXNrTGlzdCddO1xuZnVuY3Rpb24gZ2V0VG9vbGJhclN0YXRlVHlwZShub2RlLCBwYXJlbnROb2RlKSB7XG4gICAgdmFyIHR5cGUgPSBub2RlLnR5cGUubmFtZTtcbiAgICBpZiAodHlwZSA9PT0gJ2xpc3RJdGVtJykge1xuICAgICAgICByZXR1cm4gbm9kZS5hdHRycy50YXNrID8gJ3Rhc2tMaXN0JyA6IHBhcmVudE5vZGUudHlwZS5uYW1lO1xuICAgIH1cbiAgICBpZiAodHlwZS5pbmRleE9mKCd0YWJsZScpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gJ3RhYmxlJztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG59XG5mdW5jdGlvbiBzZXRMaXN0Tm9kZVRvb2xiYXJTdGF0ZSh0eXBlLCBub2RlVHlwZVN0YXRlKSB7XG4gICAgbm9kZVR5cGVTdGF0ZVt0eXBlXSA9IHsgYWN0aXZlOiB0cnVlIH07XG4gICAgTElTVF9UWVBFUy5maWx0ZXIoZnVuY3Rpb24gKGxpc3ROYW1lKSB7IHJldHVybiBsaXN0TmFtZSAhPT0gdHlwZTsgfSkuZm9yRWFjaChmdW5jdGlvbiAobGlzdFR5cGUpIHtcbiAgICAgICAgaWYgKG5vZGVUeXBlU3RhdGVbbGlzdFR5cGVdKSB7XG4gICAgICAgICAgICBkZWxldGUgbm9kZVR5cGVTdGF0ZVtsaXN0VHlwZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldE1hcmtUeXBlU3RhdGVzKGZyb20sIHRvLCBzY2hlbWEsIHRvb2xiYXJTdGF0ZSkge1xuICAgIE1BUktfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgbWFyayA9IHNjaGVtYS5tYXJrc1t0eXBlXTtcbiAgICAgICAgdmFyIG1hcmtzQXRQb3MgPSBmcm9tLm1hcmtzQWNyb3NzKHRvKSB8fCBbXTtcbiAgICAgICAgdmFyIGZvdW5kTWFyayA9ICEhbWFyay5pc0luU2V0KG1hcmtzQXRQb3MpO1xuICAgICAgICBpZiAoZm91bmRNYXJrKSB7XG4gICAgICAgICAgICB0b29sYmFyU3RhdGVbdHlwZV0gPSB7IGFjdGl2ZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRUb29sYmFyU3RhdGUoc2VsZWN0aW9uLCBkb2MsIHNjaGVtYSkge1xuICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bywgZnJvbSA9IHNlbGVjdGlvbi5mcm9tLCB0byA9IHNlbGVjdGlvbi50bztcbiAgICB2YXIgdG9vbGJhclN0YXRlID0ge1xuICAgICAgICBpbmRlbnQ6IHsgYWN0aXZlOiBmYWxzZSwgZGlzYWJsZWQ6IHRydWUgfSxcbiAgICAgICAgb3V0ZGVudDogeyBhY3RpdmU6IGZhbHNlLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgIH07XG4gICAgZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIF8sIHBhcmVudE5vZGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUb29sYmFyU3RhdGVUeXBlKG5vZGUsIHBhcmVudE5vZGUpO1xuICAgICAgICBpZiAoaW5jbHVkZXMoRVhDRVBUX1RZUEVTLCB0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlcyhMSVNUX1RZUEVTLCB0eXBlKSkge1xuICAgICAgICAgICAgc2V0TGlzdE5vZGVUb29sYmFyU3RhdGUodHlwZSwgdG9vbGJhclN0YXRlKTtcbiAgICAgICAgICAgIHRvb2xiYXJTdGF0ZS5pbmRlbnQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRvb2xiYXJTdGF0ZS5vdXRkZW50LmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgdHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBzZXRNYXJrVHlwZVN0YXRlcygkZnJvbSwgJHRvLCBzY2hlbWEsIHRvb2xiYXJTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b29sYmFyU3RhdGVbdHlwZV0gPSB7IGFjdGl2ZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvb2xiYXJTdGF0ZTtcbn1cbmZ1bmN0aW9uIHRvb2xiYXJTdGF0ZUhpZ2hsaWdodChldmVudEVtaXR0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSB2aWV3LnN0YXRlLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIGRvYyA9IF9hLmRvYywgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlVG9vbGJhclN0YXRlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbGJhclN0YXRlOiBnZXRUb29sYmFyU3RhdGUoc2VsZWN0aW9uLCBkb2MsIHNjaGVtYSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG52YXIgQ3VzdG9tQmxvY2tWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEN1c3RvbUJsb2NrVmlldyhub2RlLCB2aWV3LCBnZXRQb3MsIHRvRE9NQWRhcHRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9wZW5FZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaW5uZXJFZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZWRpdG9yIGlzIGFscmVhZHkgb3BlbmVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZG9tLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMud3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgX3RoaXMuaW5uZXJWaWV3Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgX3RoaXMuaW5uZXJFZGl0b3JWaWV3ID0gbmV3IEVkaXRvclZpZXcoX3RoaXMuaW5uZXJWaWV3Q29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRvYzogX3RoaXMubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5bWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTW9kLXonOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRvKF90aGlzLmlubmVyRWRpdG9yVmlldy5zdGF0ZSwgX3RoaXMuaW5uZXJFZGl0b3JWaWV3LmRpc3BhdGNoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU2hpZnQtTW9kLXonOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWRvKF90aGlzLmlubmVyRWRpdG9yVmlldy5zdGF0ZSwgX3RoaXMuaW5uZXJFZGl0b3JWaWV3LmRpc3BhdGNoKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUYWI6IGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuaW5zZXJ0VGV4dCgnXFx0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVudGVyOiBuZXdsaW5lSW5Db2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVzY2FwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYW5jZWxFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0N0cmwtRW50ZXInOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNhdmVBbmRGaW5pc2hFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvcnkoKSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uOiBmdW5jdGlvbiAodHIpIHsgcmV0dXJuIF90aGlzLmRpc3BhdGNoSW5uZXIodHIpOyB9LFxuICAgICAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5lZGl0b3JWaWV3Lmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbm5lckVkaXRvclZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBibHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zYXZlQW5kRmluaXNoRWRpdGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuaW5uZXJFZGl0b3JWaWV3LmZvY3VzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZ2V0UG9zID0gZ2V0UG9zO1xuICAgICAgICB0aGlzLnRvRE9NQWRhcHRvciA9IHRvRE9NQWRhcHRvcjtcbiAgICAgICAgdGhpcy5pbm5lckVkaXRvclZpZXcgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IGNscygnY3VzdG9tLWJsb2NrJyk7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLndyYXBwZXIuY2xhc3NOYW1lID0gY2xzKCdjdXN0b20tYmxvY2stdmlldycpO1xuICAgICAgICB0aGlzLmNyZWF0ZUlubmVyVmlld0NvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLnJlbmRlckN1c3RvbUJsb2NrKCk7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuaW5uZXJWaWV3Q29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICB9XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5yZW5kZXJUb29sQXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRvb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgdG9vbC5jbGFzc05hbWUgPSAndG9vbCc7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0aGlzLm5vZGUuYXR0cnMuaW5mbztcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSAnaW5mbyc7XG4gICAgICAgIGJ1dHRvbi50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9wZW5FZGl0b3IoKTsgfSk7XG4gICAgICAgIHRvb2wuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICAgIHRvb2wuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRvb2wpO1xuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5yZW5kZXJDdXN0b21CbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvRE9NTm9kZSA9IHRoaXMudG9ET01BZGFwdG9yLmdldFRvRE9NTm9kZSh0aGlzLm5vZGUuYXR0cnMuaW5mbyk7XG4gICAgICAgIGlmICh0b0RPTU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdG9ET01Ob2RlKHRoaXMubm9kZSk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy53cmFwcGVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLndyYXBwZXIubGFzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUb29sQXJlYSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLmNyZWF0ZUlubmVyVmlld0NvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbm5lclZpZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5pbm5lclZpZXdDb250YWluZXIuY2xhc3NOYW1lID0gY2xzKCdjdXN0b20tYmxvY2stZWRpdG9yJyk7XG4gICAgICAgIHRoaXMuaW5uZXJWaWV3Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLmNsb3NlRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbm5lckVkaXRvclZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJFZGl0b3JWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJFZGl0b3JWaWV3ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJWaWV3Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5zYXZlQW5kRmluaXNoRWRpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgdmFyIG91dGVyU3RhdGUgPSB0aGlzLmVkaXRvclZpZXcuc3RhdGU7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldy5kaXNwYXRjaChvdXRlclN0YXRlLnRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKG91dGVyU3RhdGUudHIsIHRvKSkpO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXN0b21CbG9jaygpO1xuICAgICAgICB0aGlzLmNsb3NlRWRpdG9yKCk7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLmNhbmNlbEVkaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1bmRvYWJsZUNvdW50ID0gdW5kb0RlcHRoKHRoaXMuaW5uZXJFZGl0b3JWaWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIC8vIHNob3VsZCB1bmRvIGVkaXRpbmcgcmVzdWx0XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wbHVzcGx1c1xuICAgICAgICB3aGlsZSAodW5kb2FibGVDb3VudC0tKSB7XG4gICAgICAgICAgICB1bmRvKHRoaXMuaW5uZXJFZGl0b3JWaWV3LnN0YXRlLCB0aGlzLmlubmVyRWRpdG9yVmlldy5kaXNwYXRjaCk7XG4gICAgICAgICAgICB1bmRvKHRoaXMuZWRpdG9yVmlldy5zdGF0ZSwgdGhpcy5lZGl0b3JWaWV3LmRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciB0byA9IHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgICAgIHZhciBvdXRlclN0YXRlID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcuZGlzcGF0Y2gob3V0ZXJTdGF0ZS50ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUob3V0ZXJTdGF0ZS5kb2MsIHRvKSkpO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVkaXRvcigpO1xuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5kaXNwYXRjaElubmVyID0gZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuaW5uZXJFZGl0b3JWaWV3LnN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odHIpLCBzdGF0ZSA9IF9hLnN0YXRlLCB0cmFuc2FjdGlvbnMgPSBfYS50cmFuc2FjdGlvbnM7XG4gICAgICAgIHRoaXMuaW5uZXJFZGl0b3JWaWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICAgICAgaWYgKCF0aGlzLmNhbmNlbGVkICYmIGlzRnVuY3Rpb25fMSh0aGlzLmdldFBvcykpIHtcbiAgICAgICAgICAgIHZhciBvdXRlclRyID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIG9mZnNldE1hcCA9IFN0ZXBNYXAub2Zmc2V0KHRoaXMuZ2V0UG9zKCkgKyAxKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNhY3Rpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBzID0gdHJhbnNhY3Rpb25zW2ldLnN0ZXBzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RlcHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJUci5zdGVwKHN0ZXBzW2pdLm1hcChvZmZzZXRNYXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0ZXJUci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3JWaWV3LmRpc3BhdGNoKG91dGVyVHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICBpZiAoIXRoaXMuaW5uZXJFZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckN1c3RvbUJsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLnN0b3BFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gKCEhdGhpcy5pbm5lckVkaXRvclZpZXcgJiZcbiAgICAgICAgICAgICEhZXZlbnQudGFyZ2V0ICYmXG4gICAgICAgICAgICB0aGlzLmlubmVyRWRpdG9yVmlldy5kb20uY29udGFpbnMoZXZlbnQudGFyZ2V0KSk7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLmlnbm9yZU11dGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCB0aGlzLm9wZW5FZGl0b3IpO1xuICAgICAgICB0aGlzLmNsb3NlRWRpdG9yKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ3VzdG9tQmxvY2tWaWV3O1xufSgpKTtcblxudmFyIElNQUdFX0xJTktfQ0xBU1NfTkFNRSA9ICdpbWFnZS1saW5rJztcbnZhciBJbWFnZVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW1hZ2VWaWV3KG5vZGUsIHZpZXcsIGdldFBvcywgZXZlbnRFbWl0dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0LCBvZmZzZXRYID0gZXYub2Zmc2V0WCwgb2Zmc2V0WSA9IGV2Lm9mZnNldFk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaW1hZ2VMaW5rICYmXG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbl8xKF90aGlzLmdldFBvcykgJiZcbiAgICAgICAgICAgICAgICBoYXNDbGFzc18xKHRhcmdldCwgSU1BR0VfTElOS19DTEFTU19OQU1FKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0LCAnOmJlZm9yZScpO1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChpc1Bvc2l0aW9uSW5Cb3goc3R5bGUsIG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ciA9IF90aGlzLnZpZXcuc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBfdGhpcy5nZXRQb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHBvcywgcG9zICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ29wZW5Qb3B1cCcsICdsaW5rJywgX3RoaXMuaW1hZ2VMaW5rLmF0dHJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZ2V0UG9zID0gZ2V0UG9zO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5pbWFnZUxpbmsgPSAoX2EgPSBub2RlLm1hcmtzLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICdsaW5rJztcbiAgICAgICAgfSlbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gdGhpcy5jcmVhdGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuYmluZEV2ZW50KCk7XG4gICAgfVxuICAgIEltYWdlVmlldy5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5jcmVhdGVJbWFnZUVsZW1lbnQodGhpcy5ub2RlKTtcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VMaW5rKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gSU1BR0VfTElOS19DTEFTU19OQU1FO1xuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChpbWFnZSk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfTtcbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLmNyZWF0ZUltYWdlRWxlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICB2YXIgX2EgPSBub2RlLmF0dHJzLCBpbWFnZVVybCA9IF9hLmltYWdlVXJsLCBhbHRUZXh0ID0gX2EuYWx0VGV4dDtcbiAgICAgICAgdmFyIGF0dHJzID0gZ2V0Q3VzdG9tQXR0cnMobm9kZS5hdHRycyk7XG4gICAgICAgIGltYWdlLnNyYyA9IGltYWdlVXJsO1xuICAgICAgICBpZiAoYWx0VGV4dCkge1xuICAgICAgICAgICAgaW1hZ2UuYWx0ID0gYWx0VGV4dDtcbiAgICAgICAgfVxuICAgICAgICBzZXRBdHRyaWJ1dGVzKGF0dHJzLCBpbWFnZSk7XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9O1xuICAgIEltYWdlVmlldy5wcm90b3R5cGUuYmluZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbWFnZUxpbmspIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2Vkb3duKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW1hZ2VWaWV3LnByb3RvdHlwZS5zdG9wRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgSW1hZ2VWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbWFnZUxpbmspIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2Vkb3duKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEltYWdlVmlldztcbn0oKSk7XG5cbnZhciBXUkFQUEVSX0NMQVNTX05BTUUgPSAndG9hc3R1aS1lZGl0b3Itd3ctY29kZS1ibG9jayc7XG52YXIgQ09ERV9CTE9DS19MQU5HX0NMQVNTX05BTUUgPSAndG9hc3R1aS1lZGl0b3Itd3ctY29kZS1ibG9jay1sYW5ndWFnZSc7XG52YXIgQ29kZUJsb2NrVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2RlQmxvY2tWaWV3KG5vZGUsIHZpZXcsIGdldFBvcywgZXZlbnRFbWl0dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldi50YXJnZXQ7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCwgJzphZnRlcicpO1xuICAgICAgICAgICAgLy8ganVkZ2UgdG8gY2xpY2sgcHNldWRvIGVsZW1lbnQgd2l0aCBiYWNrZ3JvdW5kIGltYWdlIGZvciBJRTExXG4gICAgICAgICAgICBpZiAoc3R5bGUuYmFja2dyb3VuZEltYWdlICE9PSAnbm9uZScgJiYgaXNGdW5jdGlvbl8xKF90aGlzLmdldFBvcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy52aWV3LmNvb3Jkc0F0UG9zKF90aGlzLmdldFBvcygpKSwgdG9wXzEgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3JlYXRlTGFuZ3VhZ2VFZGl0b3IoeyB0b3A6IHRvcF8xLCByaWdodDogcmlnaHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlS2V5ZG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyAmJiBfdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlTGFuZ3VhZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5nZXRQb3MgPSBnZXRQb3M7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLmNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5iaW5kRE9NRXZlbnQoKTtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnQoKTtcbiAgICB9XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gdGhpcy5ub2RlLmF0dHJzLmxhbmd1YWdlO1xuICAgICAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZSgnZGF0YS1sYW5ndWFnZScsIGxhbmd1YWdlIHx8ICd0ZXh0Jyk7XG4gICAgICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gV1JBUFBFUl9DTEFTU19OQU1FO1xuICAgICAgICB2YXIgcHJlID0gdGhpcy5jcmVhdGVDb2RlQmxvY2tFbGVtZW50KCk7XG4gICAgICAgIHZhciBjb2RlID0gcHJlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQocHJlKTtcbiAgICAgICAgdGhpcy5kb20gPSB3cmFwcGVyO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBjb2RlO1xuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuY3JlYXRlQ29kZUJsb2NrRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuICAgICAgICB2YXIgY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKTtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gdGhpcy5ub2RlLmF0dHJzLmxhbmd1YWdlO1xuICAgICAgICB2YXIgYXR0cnMgPSBnZXRDdXN0b21BdHRycyh0aGlzLm5vZGUuYXR0cnMpO1xuICAgICAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIGNvZGUuc2V0QXR0cmlidXRlKCdkYXRhLWxhbmd1YWdlJywgbGFuZ3VhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHNldEF0dHJpYnV0ZXMoYXR0cnMsIHByZSk7XG4gICAgICAgIHByZS5hcHBlbmRDaGlsZChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHByZTtcbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLmNyZWF0ZUxhbmd1YWdlRWRpdG9yID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0b3AgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICB3cmFwcGVyLmNsYXNzTmFtZSA9IENPREVfQkxPQ0tfTEFOR19DTEFTU19OQU1FO1xuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBpbnB1dC50eXBlID0gJ3RleHQnO1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHRoaXMubm9kZS5hdHRycy5sYW5ndWFnZTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgdmFyIHdycHBlcldpZHRoID0gd3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgICAgY3NzXzEod3JhcHBlciwge1xuICAgICAgICAgICAgdG9wOiB0b3AgKyAxMCArIFwicHhcIixcbiAgICAgICAgICAgIGxlZnQ6IHJpZ2h0IC0gd3JwcGVyV2lkdGggLSAxMCArIFwicHhcIixcbiAgICAgICAgICAgIHdpZHRoOiB3cnBwZXJXaWR0aCArIFwicHhcIixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2hhbmdlTGFuZ3VhZ2UoKTsgfSk7XG4gICAgICAgIHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bik7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLmJpbmRET01FdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlTW91c2Vkb3duKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuYmluZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuY2hhbmdlTGFuZ3VhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0ICYmIGlzRnVuY3Rpb25fMSh0aGlzLmdldFBvcykpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaW5wdXQudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRQb3MoKTtcbiAgICAgICAgICAgIHZhciB0ciA9IHRoaXMudmlldy5zdGF0ZS50cjtcbiAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCBudWxsLCB7IGxhbmd1YWdlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLmlucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gdGhpcy5pbnB1dC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVOb2RlJDEocGFyZW50XzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5jbGVhclRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLnN0b3BFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVNb3VzZWRvd24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZUJsb2NrVmlldztcbn0oKSk7XG5cbnZhciByZU1TT0xpc3RDbGFzc05hbWUgPSAvTXNvTGlzdFBhcmFncmFwaC87XG52YXIgcmVNU09TdHlsZVByZWZpeCA9IC9zdHlsZT0oLnxcXG4pKm1zby0vO1xudmFyIHJlTVNPTGlzdFN0eWxlID0gL21zby1saXN0OiguKikvO1xudmFyIHJlTVNPVGFnTmFtZSA9IC9POlAvO1xudmFyIHJlTVNPTGlzdEJ1bGxldCA9IC9eKG58dXxsKS87XG52YXIgTVNPX0NMQVNTX05BTUVfTElTVF9QQVJBID0gJ3AuTXNvTGlzdFBhcmFncmFwaCc7XG5mdW5jdGlvbiBpc0Zyb21Nc28oaHRtbCkge1xuICAgIHJldHVybiByZU1TT1N0eWxlUHJlZml4LnRlc3QoaHRtbCk7XG59XG5mdW5jdGlvbiBnZXRMaXN0SXRlbUNvbnRlbnRzKHBhcmEpIHtcbiAgICB2YXIgcmVtb3ZlZE5vZGVzID0gW107XG4gICAgdmFyIHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIocGFyYSwgMSwgbnVsbCwgZmFsc2UpO1xuICAgIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICB2YXIgbm9kZSA9IHdhbGtlci5jdXJyZW50Tm9kZTtcbiAgICAgICAgaWYgKGlzRWxlbU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IG5vZGUsIG91dGVySFRNTCA9IF9hLm91dGVySFRNTCwgdGV4dENvbnRlbnQgPSBfYS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIHZhciBtc29TcGFuID0gcmVNU09TdHlsZVByZWZpeC50ZXN0KG91dGVySFRNTCk7XG4gICAgICAgICAgICB2YXIgYnVsbGV0U3BhbiA9IHJlTVNPTGlzdFN0eWxlLnRlc3Qob3V0ZXJIVE1MKTtcbiAgICAgICAgICAgIGlmIChtc29TcGFuICYmICFidWxsZXRTcGFuICYmIHRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGVzLnB1c2goW25vZGUsIHRydWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlTVNPVGFnTmFtZS50ZXN0KG5vZGUubm9kZU5hbWUpIHx8IChtc29TcGFuICYmICF0ZXh0Q29udGVudCkgfHwgYnVsbGV0U3Bhbikge1xuICAgICAgICAgICAgICAgIHJlbW92ZWROb2Rlcy5wdXNoKFtub2RlLCBmYWxzZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hWzBdLCBpc1Vud3JhcCA9IF9hWzFdO1xuICAgICAgICBpZiAoaXNVbndyYXApIHtcbiAgICAgICAgICAgIHVud3JhcE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlJDEobm9kZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGFyYS5pbm5lckhUTUwudHJpbSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlTGlzdEl0ZW1EYXRhRnJvbVBhcmFncmFwaChwYXJhLCBpbmRleCkge1xuICAgIHZhciBzdHlsZUF0dHIgPSBwYXJhLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICBpZiAoc3R5bGVBdHRyKSB7XG4gICAgICAgIHZhciBfYSA9IHN0eWxlQXR0ci5tYXRjaChyZU1TT0xpc3RTdHlsZSksIGxpc3RJdGVtSW5mbyA9IF9hWzFdO1xuICAgICAgICB2YXIgX2IgPSBsaXN0SXRlbUluZm8udHJpbSgpLnNwbGl0KCcgJyksIGxldmVsU3RyID0gX2JbMV07XG4gICAgICAgIHZhciBsZXZlbCA9IHBhcnNlSW50KGxldmVsU3RyLnJlcGxhY2UoJ2xldmVsJywgJycpLCAxMCk7XG4gICAgICAgIHZhciB1bm9yZGVyZWQgPSByZU1TT0xpc3RCdWxsZXQudGVzdChwYXJhLnRleHRDb250ZW50IHx8ICcnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBpbmRleCxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICB1bm9yZGVyZWQ6IHVub3JkZXJlZCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBnZXRMaXN0SXRlbUNvbnRlbnRzKHBhcmEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGFkZExpc3RJdGVtRGV0YWlsRGF0YShkYXRhLCBwcmV2RGF0YSkge1xuICAgIGlmIChwcmV2RGF0YS5sZXZlbCA8IGRhdGEubGV2ZWwpIHtcbiAgICAgICAgcHJldkRhdGEuY2hpbGRyZW4ucHVzaChkYXRhKTtcbiAgICAgICAgZGF0YS5wYXJlbnQgPSBwcmV2RGF0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdoaWxlIChwcmV2RGF0YSkge1xuICAgICAgICAgICAgaWYgKHByZXZEYXRhLmxldmVsID09PSBkYXRhLmxldmVsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RGF0YSA9IHByZXZEYXRhLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEucHJldiA9IHByZXZEYXRhO1xuICAgICAgICAgICAgZGF0YS5wYXJlbnQgPSBwcmV2RGF0YS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoZGF0YS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnBhcmVudC5jaGlsZHJlbi5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTGlzdERhdGEocGFyYXMpIHtcbiAgICB2YXIgbGlzdERhdGEgPSBbXTtcbiAgICBwYXJhcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhLCBpbmRleCkge1xuICAgICAgICB2YXIgcHJldkxpc3RJdGVtRGF0YSA9IGxpc3REYXRhW2luZGV4IC0gMV07XG4gICAgICAgIHZhciBsaXN0SXRlbURhdGEgPSBjcmVhdGVMaXN0SXRlbURhdGFGcm9tUGFyYWdyYXBoKHBhcmEsIGluZGV4KTtcbiAgICAgICAgaWYgKGxpc3RJdGVtRGF0YSkge1xuICAgICAgICAgICAgaWYgKHByZXZMaXN0SXRlbURhdGEpIHtcbiAgICAgICAgICAgICAgICBhZGRMaXN0SXRlbURldGFpbERhdGEobGlzdEl0ZW1EYXRhLCBwcmV2TGlzdEl0ZW1EYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3REYXRhLnB1c2gobGlzdEl0ZW1EYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsaXN0RGF0YTtcbn1cbmZ1bmN0aW9uIG1ha2VMaXN0KGxpc3REYXRhKSB7XG4gICAgdmFyIGxpc3RUYWdOYW1lID0gbGlzdERhdGFbMF0udW5vcmRlcmVkID8gJ3VsJyA6ICdvbCc7XG4gICAgdmFyIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGxpc3RUYWdOYW1lKTtcbiAgICBsaXN0RGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGRhdGEuY2hpbGRyZW4sIGNvbnRlbnRzID0gZGF0YS5jb250ZW50cztcbiAgICAgICAgdmFyIGxpc3RJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgbGlzdEl0ZW0uaW5uZXJIVE1MID0gY29udGVudHM7XG4gICAgICAgIGxpc3QuYXBwZW5kQ2hpbGQobGlzdEl0ZW0pO1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaXN0LmFwcGVuZENoaWxkKG1ha2VMaXN0KGNoaWxkcmVuKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbGlzdDtcbn1cbmZ1bmN0aW9uIG1ha2VMaXN0RnJvbVBhcmFncmFwaHMocGFyYXMpIHtcbiAgICB2YXIgbGlzdERhdGEgPSBjcmVhdGVMaXN0RGF0YShwYXJhcyk7XG4gICAgdmFyIHJvb3RDaGlsZHJlbiA9IGxpc3REYXRhLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IF9hLnBhcmVudDtcbiAgICAgICAgcmV0dXJuICFwYXJlbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1ha2VMaXN0KHJvb3RDaGlsZHJlbik7XG59XG5mdW5jdGlvbiBpc01zb0xpc3RQYXJhZ3JhcGhFbmQobm9kZSkge1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChpc0VsZW1Ob2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUgPyAhcmVNU09MaXN0Q2xhc3NOYW1lLnRlc3Qobm9kZS5jbGFzc05hbWUpIDogdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRNc29QYXJhZ3JhcGhzVG9MaXN0KGh0bWwpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgdmFyIHBhcmFzID0gW107XG4gICAgdmFyIGZvdW5kUGFyYXMgPSBmaW5kTm9kZXMoY29udGFpbmVyLCBNU09fQ0xBU1NfTkFNRV9MSVNUX1BBUkEpO1xuICAgIGZvdW5kUGFyYXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYSkge1xuICAgICAgICB2YXIgbXNvTGlzdFBhcmFFbmQgPSBpc01zb0xpc3RQYXJhZ3JhcGhFbmQocGFyYS5uZXh0U2libGluZyk7XG4gICAgICAgIHBhcmFzLnB1c2gocGFyYSk7XG4gICAgICAgIGlmIChtc29MaXN0UGFyYUVuZCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBtYWtlTGlzdEZyb21QYXJhZ3JhcGhzKHBhcmFzKTtcbiAgICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IHBhcmEubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmVOb2RlKGxpc3QsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcGVuZE5vZGVzKGNvbnRhaW5lciwgbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZU5vZGUkMShwYXJhKTtcbiAgICB9KTtcbiAgICAvLyB3aXRob3V0IGA8cD48L3A+YCwgdGhlIGxpc3Qgc3RyaW5nIHdhcyBwYXJzZWQgYXMgYSBwYXJhZ3JhcGggbm9kZSBhbmQgYWRkZWRcbiAgICB2YXIgZXh0cmFIVE1MID0gZm91bmRQYXJhcy5sZW5ndGggPyAnPHA+PC9wPicgOiAnJztcbiAgICByZXR1cm4gXCJcIiArIGV4dHJhSFRNTCArIGNvbnRhaW5lci5pbm5lckhUTUw7XG59XG5cbnZhciBTVEFSVF9GUkFHTUVOVF9DT01NRU5UID0gJzwhLS1TdGFydEZyYWdtZW50LS0+JztcbnZhciBFTkRfRlJBR01FTlRfQ09NTUVOVCA9ICc8IS0tRW5kRnJhZ21lbnQtLT4nO1xuZnVuY3Rpb24gZ2V0Q29udGVudEJldHdlZW5GcmFnbWVudENvbW1lbnRzKGh0bWwpIHtcbiAgICB2YXIgc3RhcnRGcmFnbWVudEluZGV4ID0gaHRtbC5pbmRleE9mKFNUQVJUX0ZSQUdNRU5UX0NPTU1FTlQpO1xuICAgIHZhciBlbmRGcmFnbWVudEluZGV4ID0gaHRtbC5sYXN0SW5kZXhPZihFTkRfRlJBR01FTlRfQ09NTUVOVCk7XG4gICAgaWYgKHN0YXJ0RnJhZ21lbnRJbmRleCA+IC0xICYmIGVuZEZyYWdtZW50SW5kZXggPiAtMSkge1xuICAgICAgICBodG1sID0gaHRtbC5zbGljZShzdGFydEZyYWdtZW50SW5kZXggKyBTVEFSVF9GUkFHTUVOVF9DT01NRU5ULmxlbmd0aCwgZW5kRnJhZ21lbnRJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBodG1sLnJlcGxhY2UoLzxicltePl0qPi9nLCBBTFRFUk5BVElWRV9UQUdfRk9SX0JSKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRNc29UYWJsZVRvQ29tcGxldGVkVGFibGUoaHRtbCkge1xuICAgIC8vIHdyYXAgd2l0aCA8dHI+IGlmIGh0bWwgY29udGFpbnMgZGFuZ2xpbmcgPHRkPiB0YWdzXG4gICAgLy8gZGFuZ2xpbmcgPHRkPiB0YWcgaXMgdGhhdCB0YWcgZG9lcyBub3QgaGF2ZSA8dHI+IGFzIHBhcmVudCBub2RlXG4gICAgaWYgKC88XFwvdGQ+KCg/ITxcXC90cj4pW1xcc1xcU10pKiQvaS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIGh0bWwgPSBcIjx0cj5cIiArIGh0bWwgKyBcIjwvdHI+XCI7XG4gICAgfVxuICAgIC8vIHdyYXAgd2l0aCA8dGFibGU+IGlmIGh0bWwgY29udGFpbnMgZGFuZ2xpbmcgPHRyPiB0YWdzXG4gICAgLy8gZGFuZ2xpbmcgPHRyPiB0YWcgaXMgdGhhdCB0YWcgZG9lcyBub3QgaGF2ZSA8dGFibGU+IGFzIHBhcmVudCBub2RlXG4gICAgaWYgKC88XFwvdHI+KCg/ITxcXC90YWJsZT4pW1xcc1xcU10pKiQvaS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIGh0bWwgPSBcIjx0YWJsZT5cIiArIGh0bWwgKyBcIjwvdGFibGU+XCI7XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xufVxuZnVuY3Rpb24gY2hhbmdlUGFzdGVkSFRNTChodG1sKSB7XG4gICAgaHRtbCA9IGdldENvbnRlbnRCZXR3ZWVuRnJhZ21lbnRDb21tZW50cyhodG1sKTtcbiAgICBodG1sID0gY29udmVydE1zb1RhYmxlVG9Db21wbGV0ZWRUYWJsZShodG1sKTtcbiAgICBpZiAoaXNGcm9tTXNvKGh0bWwpKSB7XG4gICAgICAgIGh0bWwgPSBjb252ZXJ0TXNvUGFyYWdyYXBoc1RvTGlzdChodG1sKTtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG59XG5mdW5jdGlvbiBnZXRNYXhDb2x1bW5Db3VudChyb3dzKSB7XG4gICAgdmFyIHJvdyA9IHJvd3MucmVkdWNlKGZ1bmN0aW9uIChwcmV2Um93LCBjdXJyZW50Um93KSB7XG4gICAgICAgIHJldHVybiBwcmV2Um93LmNoaWxkQ291bnQgPiBjdXJyZW50Um93LmNoaWxkQ291bnQgPyBwcmV2Um93IDogY3VycmVudFJvdztcbiAgICB9KTtcbiAgICByZXR1cm4gcm93LmNoaWxkQ291bnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVDZWxscyhvcmdSb3csIG1heENvbHVtbkNvdW50LCBjZWxsKSB7XG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgdmFyIGNlbGxDb3VudCA9IG9yZ1Jvdy5jaGlsZENvdW50O1xuICAgIGZvciAodmFyIGNvbElkeCA9IDA7IGNvbElkeCA8IGNlbGxDb3VudDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgaWYgKCFvcmdSb3cuY2hpbGQoY29sSWR4KS5hdHRycy5leHRlbmRlZCkge1xuICAgICAgICAgICAgdmFyIGNvcGllZENlbGwgPSBjb2xJZHggPCBjZWxsQ291bnRcbiAgICAgICAgICAgICAgICA/IGNlbGwuY3JlYXRlKG9yZ1Jvdy5jaGlsZChjb2xJZHgpLmF0dHJzLCBvcmdSb3cuY2hpbGQoY29sSWR4KS5jb250ZW50KVxuICAgICAgICAgICAgICAgIDogY2VsbC5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICAgICAgICBjZWxscy5wdXNoKGNvcGllZENlbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjZWxscztcbn1cbmZ1bmN0aW9uIGNvcHlUYWJsZUhlYWRSb3cob3JnUm93LCBtYXhDb2x1bW5Db3VudCwgc2NoZW1hKSB7XG4gICAgdmFyIF9hID0gc2NoZW1hLm5vZGVzLCB0YWJsZVJvdyA9IF9hLnRhYmxlUm93LCB0YWJsZUhlYWRDZWxsID0gX2EudGFibGVIZWFkQ2VsbDtcbiAgICB2YXIgY2VsbHMgPSBjcmVhdGVDZWxscyhvcmdSb3csIG1heENvbHVtbkNvdW50LCB0YWJsZUhlYWRDZWxsKTtcbiAgICByZXR1cm4gdGFibGVSb3cuY3JlYXRlKG51bGwsIGNlbGxzKTtcbn1cbmZ1bmN0aW9uIGNvcHlUYWJsZUJvZHlSb3cob3JnUm93LCBtYXhDb2x1bW5Db3VudCwgc2NoZW1hKSB7XG4gICAgdmFyIF9hID0gc2NoZW1hLm5vZGVzLCB0YWJsZVJvdyA9IF9hLnRhYmxlUm93LCB0YWJsZUJvZHlDZWxsID0gX2EudGFibGVCb2R5Q2VsbDtcbiAgICB2YXIgY2VsbHMgPSBjcmVhdGVDZWxscyhvcmdSb3csIG1heENvbHVtbkNvdW50LCB0YWJsZUJvZHlDZWxsKTtcbiAgICByZXR1cm4gdGFibGVSb3cuY3JlYXRlKG51bGwsIGNlbGxzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0VGFibGVCb2R5RHVtbXlSb3coY29sdW1uQ291bnQsIHNjaGVtYSkge1xuICAgIHZhciBfYSA9IHNjaGVtYS5ub2RlcywgdGFibGVSb3cgPSBfYS50YWJsZVJvdywgdGFibGVCb2R5Q2VsbCA9IF9hLnRhYmxlQm9keUNlbGw7XG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgZm9yICh2YXIgY29sdW1uSW5kZXggPSAwOyBjb2x1bW5JbmRleCA8IGNvbHVtbkNvdW50OyBjb2x1bW5JbmRleCArPSAxKSB7XG4gICAgICAgIHZhciBkdW1teUNlbGwgPSB0YWJsZUJvZHlDZWxsLmNyZWF0ZUFuZEZpbGwoKTtcbiAgICAgICAgY2VsbHMucHVzaChkdW1teUNlbGwpO1xuICAgIH1cbiAgICByZXR1cm4gdGFibGVSb3cuY3JlYXRlKHsgZHVtbXlSb3dGb3JQYXN0aW5nOiB0cnVlIH0sIGNlbGxzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvd3NGcm9tUGFzdGluZ1RhYmxlKHRhYmxlQ29udGVudCkge1xuICAgIHZhciB0YWJsZUhlYWRSb3dzID0gW107XG4gICAgdmFyIHRhYmxlQm9keVJvd3MgPSBbXTtcbiAgICBpZiAodGFibGVDb250ZW50LmZpcnN0Q2hpbGQudHlwZS5uYW1lID09PSAndGFibGVIZWFkJykge1xuICAgICAgICB2YXIgdGFibGVIZWFkID0gdGFibGVDb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRhYmxlSGVhZC5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHRhYmxlSGVhZFJvd3MucHVzaChyb3cpOyB9KTtcbiAgICB9XG4gICAgaWYgKHRhYmxlQ29udGVudC5sYXN0Q2hpbGQudHlwZS5uYW1lID09PSAndGFibGVCb2R5Jykge1xuICAgICAgICB2YXIgdGFibGVCb2R5ID0gdGFibGVDb250ZW50Lmxhc3RDaGlsZDtcbiAgICAgICAgdGFibGVCb2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gdGFibGVCb2R5Um93cy5wdXNoKHJvdyk7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gX19zcHJlYWRBcnJheSQxKF9fc3ByZWFkQXJyYXkkMShbXSwgdGFibGVIZWFkUm93cyksIHRhYmxlQm9keVJvd3MpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGVIZWFkKHRhYmxlSGVhZFJvdywgbWF4Q29sdW1uQ291bnQsIHNjaGVtYSkge1xuICAgIHZhciBjb3BpZWRSb3cgPSBjb3B5VGFibGVIZWFkUm93KHRhYmxlSGVhZFJvdywgbWF4Q29sdW1uQ291bnQsIHNjaGVtYSk7XG4gICAgcmV0dXJuIHNjaGVtYS5ub2Rlcy50YWJsZUhlYWQuY3JlYXRlKG51bGwsIGNvcGllZFJvdyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZUJvZHkodGFibGVCb2R5Um93cywgbWF4Q29sdW1uQ291bnQsIHNjaGVtYSkge1xuICAgIHZhciBjb3BpZWRSb3dzID0gdGFibGVCb2R5Um93cy5tYXAoZnVuY3Rpb24gKHRhYmxlQm9keVJvdykge1xuICAgICAgICByZXR1cm4gY29weVRhYmxlQm9keVJvdyh0YWJsZUJvZHlSb3csIG1heENvbHVtbkNvdW50LCBzY2hlbWEpO1xuICAgIH0pO1xuICAgIGlmICghdGFibGVCb2R5Um93cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGR1bW15VGFibGVSb3cgPSBjcmVhdFRhYmxlQm9keUR1bW15Um93KG1heENvbHVtbkNvdW50LCBzY2hlbWEpO1xuICAgICAgICBjb3BpZWRSb3dzLnB1c2goZHVtbXlUYWJsZVJvdyk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEubm9kZXMudGFibGVCb2R5LmNyZWF0ZShudWxsLCBjb3BpZWRSb3dzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlRnJvbVBhc3RpbmdUYWJsZShyb3dzLCBzY2hlbWEsIHN0YXJ0RnJvbUJvZHksIGlzSW5UYWJsZSkge1xuICAgIHZhciBjb2x1bW5Db3VudCA9IGdldE1heENvbHVtbkNvdW50KHJvd3MpO1xuICAgIGlmIChzdGFydEZyb21Cb2R5ICYmIGlzSW5UYWJsZSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLm5vZGVzLnRhYmxlLmNyZWF0ZShudWxsLCBbY3JlYXRlVGFibGVCb2R5KHJvd3MsIGNvbHVtbkNvdW50LCBzY2hlbWEpXSk7XG4gICAgfVxuICAgIHZhciB0YWJsZUhlYWRSb3cgPSByb3dzWzBdO1xuICAgIHZhciB0YWJsZUJvZHlSb3dzID0gcm93cy5zbGljZSgxKTtcbiAgICB2YXIgbm9kZXMgPSBbY3JlYXRlVGFibGVIZWFkKHRhYmxlSGVhZFJvdywgY29sdW1uQ291bnQsIHNjaGVtYSldO1xuICAgIGlmICh0YWJsZUJvZHlSb3dzLmxlbmd0aCkge1xuICAgICAgICBub2Rlcy5wdXNoKGNyZWF0ZVRhYmxlQm9keSh0YWJsZUJvZHlSb3dzLCBjb2x1bW5Db3VudCwgc2NoZW1hKSk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEubm9kZXMudGFibGUuY3JlYXRlKG51bGwsIG5vZGVzKTtcbn1cbmZ1bmN0aW9uIGNoYW5nZVBhc3RlZFNsaWNlKHNsaWNlLCBzY2hlbWEsIGlzSW5UYWJsZSkge1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBjb250ZW50ID0gc2xpY2UuY29udGVudCwgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0LCBvcGVuRW5kID0gc2xpY2Uub3BlbkVuZDtcbiAgICBjb250ZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZS5uYW1lID09PSAndGFibGUnKSB7XG4gICAgICAgICAgICB2YXIgdGFibGVDb250ZW50ID0gZ2V0VGFibGVDb250ZW50RnJvbVNsaWNlKG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG4gICAgICAgICAgICBpZiAodGFibGVDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBjcmVhdGVSb3dzRnJvbVBhc3RpbmdUYWJsZSh0YWJsZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEZyb21Cb2R5ID0gdGFibGVDb250ZW50LmZpcnN0Q2hpbGQudHlwZS5uYW1lID09PSAndGFibGVCb2R5JztcbiAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBjcmVhdGVUYWJsZUZyb21QYXN0aW5nVGFibGUocm93cywgc2NoZW1hLCBzdGFydEZyb21Cb2R5LCBpc0luVGFibGUpO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2godGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShub2RlcyksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbnZhciBEVU1NWV9DRUxMX1NJWkUgPSA0O1xudmFyIFRSX05PREVTX1NJWkUgPSAyO1xuZnVuY3Rpb24gZ2V0RHVtbXlDZWxsU2l6ZShkdW1teUNlbGxDb3VudCkge1xuICAgIHJldHVybiBkdW1teUNlbGxDb3VudCAqIERVTU1ZX0NFTExfU0laRTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhc3RpbmdDZWxscyh0YWJsZUNvbnRlbnQsIGN1clNlbGVjdGlvbkluZm8sIHNjaGVtYSkge1xuICAgIHZhciBwYXN0aW5nUm93cyA9IFtdO1xuICAgIHZhciBwYXN0aW5nVGFibGVSb3dzID0gY3JlYXRlUm93c0Zyb21QYXN0aW5nVGFibGUodGFibGVDb250ZW50KTtcbiAgICB2YXIgY29sdW1uQ291bnQgPSBwYXN0aW5nVGFibGVSb3dzWzBdLmNoaWxkQ291bnQ7XG4gICAgdmFyIHJvd0NvdW50ID0gcGFzdGluZ1RhYmxlUm93cy5sZW5ndGg7XG4gICAgdmFyIHN0YXJ0VG9UYWJsZUhlYWQgPSBjdXJTZWxlY3Rpb25JbmZvLnN0YXJ0Um93SWR4ID09PSAwO1xuICAgIHZhciBzbGljZWRSb3dzID0gcGFzdGluZ1RhYmxlUm93cy5zbGljZSgwLCByb3dDb3VudCk7XG4gICAgaWYgKHN0YXJ0VG9UYWJsZUhlYWQpIHtcbiAgICAgICAgdmFyIHRhYmxlSGVhZFJvdyA9IHNsaWNlZFJvd3Muc2hpZnQoKTtcbiAgICAgICAgaWYgKHRhYmxlSGVhZFJvdykge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjb3B5VGFibGVIZWFkUm93KHRhYmxlSGVhZFJvdywgY29sdW1uQ291bnQsIHNjaGVtYSkuY29udGVudDtcbiAgICAgICAgICAgIHBhc3RpbmdSb3dzLnB1c2goY29udGVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2xpY2VkUm93cy5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZUJvZHlSb3cpIHtcbiAgICAgICAgaWYgKCF0YWJsZUJvZHlSb3cuYXR0cnMuZHVtbXlSb3dGb3JQYXN0aW5nKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGNvcHlUYWJsZUJvZHlSb3codGFibGVCb2R5Um93LCBjb2x1bW5Db3VudCwgc2NoZW1hKS5jb250ZW50O1xuICAgICAgICAgICAgcGFzdGluZ1Jvd3MucHVzaChjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXN0aW5nUm93cztcbn1cbmZ1bmN0aW9uIGdldFBhc3RpbmdSYW5nZUluZm8obWFwLCBfYSwgcGFzdGluZ0NlbGxzKSB7XG4gICAgdmFyIHN0YXJ0Um93SWR4ID0gX2Euc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4ID0gX2Euc3RhcnRDb2xJZHg7XG4gICAgdmFyIHBhc3RpbmdSb3dDb3VudCA9IHBhc3RpbmdDZWxscy5sZW5ndGg7XG4gICAgdmFyIHBhc3RpbmdDb2x1bW5Db3VudCA9IDA7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgY29sdW1uQ291bnQgPSBwYXN0aW5nQ2VsbHNbaV0uY2hpbGRDb3VudDtcbiAgICAgICAgcGFzdGluZ0NlbGxzW2ldLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgIHZhciBjb2xzcGFuID0gYXR0cnMuY29sc3BhbjtcbiAgICAgICAgICAgIGlmIChjb2xzcGFuID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbkNvdW50ICs9IGNvbHNwYW4gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFzdGluZ0NvbHVtbkNvdW50ID0gTWF0aC5tYXgocGFzdGluZ0NvbHVtbkNvdW50LCBjb2x1bW5Db3VudCk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhc3RpbmdSb3dDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIF9sb29wXzEoaSk7XG4gICAgfVxuICAgIHZhciBlbmRSb3dJZHggPSBzdGFydFJvd0lkeCArIHBhc3RpbmdSb3dDb3VudCAtIDE7XG4gICAgdmFyIGVuZENvbElkeCA9IHN0YXJ0Q29sSWR4ICsgcGFzdGluZ0NvbHVtbkNvdW50IC0gMTtcbiAgICB2YXIgYWRkZWRSb3dDb3VudCA9IE1hdGgubWF4KGVuZFJvd0lkeCArIDEgLSBtYXAudG90YWxSb3dDb3VudCwgMCk7XG4gICAgdmFyIGFkZGVkQ29sdW1uQ291bnQgPSBNYXRoLm1heChlbmRDb2xJZHggKyAxIC0gbWFwLnRvdGFsQ29sdW1uQ291bnQsIDApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0Um93SWR4OiBzdGFydFJvd0lkeCxcbiAgICAgICAgc3RhcnRDb2xJZHg6IHN0YXJ0Q29sSWR4LFxuICAgICAgICBlbmRSb3dJZHg6IGVuZFJvd0lkeCxcbiAgICAgICAgZW5kQ29sSWR4OiBlbmRDb2xJZHgsXG4gICAgICAgIGFkZGVkUm93Q291bnQ6IGFkZGVkUm93Q291bnQsXG4gICAgICAgIGFkZGVkQ29sdW1uQ291bnQ6IGFkZGVkQ29sdW1uQ291bnQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZFJlcGxhY2VkT2Zmc2V0cyhfYSwgY2VsbHNPZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0Um93SWR4ID0gX2Euc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4ID0gX2Euc3RhcnRDb2xJZHgsIGVuZFJvd0lkeCA9IF9hLmVuZFJvd0lkeCwgZW5kQ29sSWR4ID0gX2EuZW5kQ29sSWR4LCBhZGRlZFJvd0NvdW50ID0gX2EuYWRkZWRSb3dDb3VudCwgYWRkZWRDb2x1bW5Db3VudCA9IF9hLmFkZGVkQ29sdW1uQ291bnQ7XG4gICAgZm9yICh2YXIgcm93SWR4ID0gc3RhcnRSb3dJZHg7IHJvd0lkeCA8PSBlbmRSb3dJZHggLSBhZGRlZFJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICBjZWxsc09mZnNldHMucHVzaCh7XG4gICAgICAgICAgICByb3dJZHg6IHJvd0lkeCxcbiAgICAgICAgICAgIHN0YXJ0Q29sSWR4OiBzdGFydENvbElkeCxcbiAgICAgICAgICAgIGVuZENvbElkeDogZW5kQ29sSWR4IC0gYWRkZWRDb2x1bW5Db3VudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXhwYW5kQ29sdW1ucyh0ciwgc2NoZW1hLCBtYXAsIF9hLCBjZWxsc09mZnNldHMpIHtcbiAgICB2YXIgc3RhcnRSb3dJZHggPSBfYS5zdGFydFJvd0lkeCwgc3RhcnRDb2xJZHggPSBfYS5zdGFydENvbElkeCwgZW5kUm93SWR4ID0gX2EuZW5kUm93SWR4LCBlbmRDb2xJZHggPSBfYS5lbmRDb2xJZHgsIGFkZGVkUm93Q291bnQgPSBfYS5hZGRlZFJvd0NvdW50LCBhZGRlZENvbHVtbkNvdW50ID0gX2EuYWRkZWRDb2x1bW5Db3VudDtcbiAgICB2YXIgdG90YWxSb3dDb3VudCA9IG1hcC50b3RhbFJvd0NvdW50O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgZm9yICh2YXIgcm93SWR4ID0gMDsgcm93SWR4IDwgdG90YWxSb3dDb3VudDsgcm93SWR4ICs9IDEpIHtcbiAgICAgICAgdmFyIF9iID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgZW5kQ29sSWR4IC0gYWRkZWRDb2x1bW5Db3VudCksIG9mZnNldCA9IF9iLm9mZnNldCwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZTtcbiAgICAgICAgdmFyIGluc2VydE9mZnNldCA9IHRyLm1hcHBpbmcubWFwKG9mZnNldCArIG5vZGVTaXplKTtcbiAgICAgICAgdmFyIGNlbGxzID0gY3JlYXRlRHVtbXlDZWxscyhhZGRlZENvbHVtbkNvdW50LCByb3dJZHgsIHNjaGVtYSk7XG4gICAgICAgIHRyLmluc2VydChpbnNlcnRPZmZzZXQsIGNlbGxzKTtcbiAgICAgICAgaWYgKHJvd0lkeCA+PSBzdGFydFJvd0lkeCAmJiByb3dJZHggPD0gZW5kUm93SWR4IC0gYWRkZWRSb3dDb3VudCkge1xuICAgICAgICAgICAgdmFyIGNlbGxJbmZvID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgZW5kQ29sSWR4IC0gYWRkZWRDb2x1bW5Db3VudCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRDZWxsT2Zmc2V0ID0gdHIubWFwcGluZy5tYXAoY2VsbEluZm8ub2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciBlbmRDZWxsT2Zmc2V0ID0gaW5zZXJ0T2Zmc2V0ICsgZ2V0RHVtbXlDZWxsU2l6ZShhZGRlZENvbHVtbkNvdW50KTtcbiAgICAgICAgICAgIGNlbGxzT2Zmc2V0c1tpbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgcm93SWR4OiByb3dJZHgsXG4gICAgICAgICAgICAgICAgc3RhcnRDb2xJZHg6IHN0YXJ0Q29sSWR4LFxuICAgICAgICAgICAgICAgIGVuZENvbElkeDogZW5kQ29sSWR4LFxuICAgICAgICAgICAgICAgIGR1bW15T2Zmc2V0czogW3N0YXJ0Q2VsbE9mZnNldCwgZW5kQ2VsbE9mZnNldF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGV4cGFuZFJvd3ModHIsIHNjaGVtYSwgbWFwLCBfYSwgY2VsbHNPZmZzZXRzKSB7XG4gICAgdmFyIGFkZGVkUm93Q291bnQgPSBfYS5hZGRlZFJvd0NvdW50LCBhZGRlZENvbHVtbkNvdW50ID0gX2EuYWRkZWRDb2x1bW5Db3VudCwgc3RhcnRDb2xJZHggPSBfYS5zdGFydENvbElkeCwgZW5kQ29sSWR4ID0gX2EuZW5kQ29sSWR4O1xuICAgIHZhciBtYXBTdGFydCA9IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7XG4gICAgdmFyIHRhYmxlRW5kUG9zID0gbWFwLnRhYmxlRW5kT2Zmc2V0IC0gMjtcbiAgICB2YXIgcm93cyA9IGNyZWF0ZVRhYmxlQm9keVJvd3MoYWRkZWRSb3dDb3VudCwgbWFwLnRvdGFsQ29sdW1uQ291bnQgKyBhZGRlZENvbHVtbkNvdW50LCBzY2hlbWEpO1xuICAgIHZhciBzdGFydE9mZnNldCA9IHRhYmxlRW5kUG9zO1xuICAgIHRyLmluc2VydCh0ci5tYXBwaW5nLnNsaWNlKG1hcFN0YXJ0KS5tYXAoc3RhcnRPZmZzZXQpLCByb3dzKTtcbiAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgYWRkZWRSb3dDb3VudDsgcm93SW5kZXggKz0gMSkge1xuICAgICAgICB2YXIgc3RhcnRDZWxsT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBnZXREdW1teUNlbGxTaXplKHN0YXJ0Q29sSWR4KSArIDE7XG4gICAgICAgIHZhciBlbmRDZWxsT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBnZXREdW1teUNlbGxTaXplKGVuZENvbElkeCArIDEpICsgMTtcbiAgICAgICAgdmFyIG5leHRDZWxsT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBnZXREdW1teUNlbGxTaXplKG1hcC50b3RhbENvbHVtbkNvdW50ICsgYWRkZWRDb2x1bW5Db3VudCkgKyBUUl9OT0RFU19TSVpFO1xuICAgICAgICBjZWxsc09mZnNldHMucHVzaCh7XG4gICAgICAgICAgICByb3dJZHg6IHJvd0luZGV4ICsgbWFwLnRvdGFsUm93Q291bnQsXG4gICAgICAgICAgICBzdGFydENvbElkeDogc3RhcnRDb2xJZHgsXG4gICAgICAgICAgICBlbmRDb2xJZHg6IGVuZENvbElkeCxcbiAgICAgICAgICAgIGR1bW15T2Zmc2V0czogW3N0YXJ0Q2VsbE9mZnNldCwgZW5kQ2VsbE9mZnNldF0sXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydE9mZnNldCA9IG5leHRDZWxsT2Zmc2V0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VDZWxscyh0ciwgcGFzdGluZ1Jvd3MsIGNlbGxzT2Zmc2V0cywgbWFwKSB7XG4gICAgdmFyIG1hcFN0YXJ0ID0gdHIubWFwcGluZy5tYXBzLmxlbmd0aDtcbiAgICBjZWxsc09mZnNldHMuZm9yRWFjaChmdW5jdGlvbiAob2Zmc2V0cywgaW5kZXgpIHtcbiAgICAgICAgdmFyIHJvd0lkeCA9IG9mZnNldHMucm93SWR4LCBzdGFydENvbElkeCA9IG9mZnNldHMuc3RhcnRDb2xJZHgsIGVuZENvbElkeCA9IG9mZnNldHMuZW5kQ29sSWR4LCBkdW1teU9mZnNldHMgPSBvZmZzZXRzLmR1bW15T2Zmc2V0cztcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcFN0YXJ0KTtcbiAgICAgICAgdmFyIGNlbGxzID0gbmV3IFNsaWNlKHBhc3RpbmdSb3dzW2luZGV4XSwgMCwgMCk7XG4gICAgICAgIHZhciBmcm9tID0gZHVtbXlPZmZzZXRzID8gZHVtbXlPZmZzZXRzWzBdIDogbWFwLmdldENlbGxTdGFydE9mZnNldChyb3dJZHgsIHN0YXJ0Q29sSWR4KTtcbiAgICAgICAgdmFyIHRvID0gZHVtbXlPZmZzZXRzID8gZHVtbXlPZmZzZXRzWzFdIDogbWFwLmdldENlbGxFbmRPZmZzZXQocm93SWR4LCBlbmRDb2xJZHgpO1xuICAgICAgICB0ci5yZXBsYWNlKG1hcHBpbmcubWFwKGZyb20pLCBtYXBwaW5nLm1hcCh0byksIGNlbGxzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhc3RlVG9UYWJsZSh2aWV3LCBzbGljZSkge1xuICAgIHZhciBfYSA9IHZpZXcuc3RhdGUsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgc2NoZW1hID0gX2Euc2NoZW1hLCB0ciA9IF9hLnRyO1xuICAgIHZhciBfYiA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9iLmFuY2hvciwgaGVhZCA9IF9iLmhlYWQ7XG4gICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7XG4gICAgICAgIHZhciB0YWJsZUNvbnRlbnQgPSBnZXRUYWJsZUNvbnRlbnRGcm9tU2xpY2Uoc2xpY2UpO1xuICAgICAgICBpZiAoIXRhYmxlQ29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgdmFyIGN1clNlbGVjdGlvbkluZm8gPSBtYXAuZ2V0UmVjdE9mZnNldHMoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgdmFyIHBhc3RpbmdDZWxscyA9IGNyZWF0ZVBhc3RpbmdDZWxscyh0YWJsZUNvbnRlbnQsIGN1clNlbGVjdGlvbkluZm8sIHNjaGVtYSk7XG4gICAgICAgIHZhciBwYXN0aW5nSW5mbyA9IGdldFBhc3RpbmdSYW5nZUluZm8obWFwLCBjdXJTZWxlY3Rpb25JbmZvLCBwYXN0aW5nQ2VsbHMpO1xuICAgICAgICB2YXIgY2VsbHNPZmZzZXRzID0gW107XG4gICAgICAgIC8vIEBUT0RPOiB1bm1lcmdlIHRoZSBzcGFuIGFuZCBwYXN0ZSB0aGUgY2VsbFxuICAgICAgICBpZiAoY2FuTWVyZ2UobWFwLCBwYXN0aW5nSW5mbykpIHtcbiAgICAgICAgICAgIGFkZFJlcGxhY2VkT2Zmc2V0cyhwYXN0aW5nSW5mbywgY2VsbHNPZmZzZXRzKTtcbiAgICAgICAgICAgIGlmIChwYXN0aW5nSW5mby5hZGRlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kQ29sdW1ucyh0ciwgc2NoZW1hLCBtYXAsIHBhc3RpbmdJbmZvLCBjZWxsc09mZnNldHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhc3RpbmdJbmZvLmFkZGVkUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICBleHBhbmRSb3dzKHRyLCBzY2hlbWEsIG1hcCwgcGFzdGluZ0luZm8sIGNlbGxzT2Zmc2V0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBsYWNlQ2VsbHModHIsIHBhc3RpbmdDZWxscywgY2VsbHNPZmZzZXRzLCBtYXApO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb24odmlldywgY2VsbHNPZmZzZXRzLCBtYXAuZ2V0Q2VsbEluZm8oMCwgMCkub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKHZpZXcsIGNlbGxzT2Zmc2V0cywgcG9zKSB7XG4gICAgdmFyIF9hID0gdmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgZG9jID0gX2EuZG9jO1xuICAgIC8vIGdldCBjaGFuZ2VkIGNlbGwgb2Zmc2V0c1xuICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoZG9jLnJlc29sdmUocG9zKSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgdmFyIF9iID0gY2VsbHNPZmZzZXRzWzBdLCBzdGFydFJvd0lkeCA9IF9iLnJvd0lkeCwgc3RhcnRDb2xJZHggPSBfYi5zdGFydENvbElkeDtcbiAgICB2YXIgX2MgPSBsYXN0JDEoY2VsbHNPZmZzZXRzKSwgZW5kUm93SWR4ID0gX2Mucm93SWR4LCBlbmRDb2xJZHggPSBfYy5lbmRDb2xJZHg7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gbWFwLmdldENlbGxJbmZvKHN0YXJ0Um93SWR4LCBzdGFydENvbElkeCkub2Zmc2V0O1xuICAgIHZhciBlbmRPZmZzZXQgPSBtYXAuZ2V0Q2VsbEluZm8oZW5kUm93SWR4LCBlbmRDb2xJZHgpLm9mZnNldDtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihuZXcgQ2VsbFNlbGVjdGlvbihkb2MucmVzb2x2ZShzdGFydE9mZnNldCksIGRvYy5yZXNvbHZlKGVuZE9mZnNldCkpKSk7XG59XG5mdW5jdGlvbiBjYW5NZXJnZShtYXAsIHBhc3RpbmdJbmZvKSB7XG4gICAgdmFyIHJhbmdlcyA9IG1hcC5nZXRTcGFubmVkT2Zmc2V0cyhwYXN0aW5nSW5mbyk7XG4gICAgdmFyIF9hID0gZ2V0Um93QW5kQ29sdW1uQ291bnQocmFuZ2VzKSwgcm93Q291bnQgPSBfYS5yb3dDb3VudCwgY29sdW1uQ291bnQgPSBfYS5jb2x1bW5Db3VudDtcbiAgICB2YXIgX2IgPSBnZXRSb3dBbmRDb2x1bW5Db3VudChwYXN0aW5nSW5mbyksIHBhc3RpbmdSb3dDb3VudCA9IF9iLnJvd0NvdW50LCBwYXN0aW5nQ29sdW1uQ291bnQgPSBfYi5jb2x1bW5Db3VudDtcbiAgICByZXR1cm4gcm93Q291bnQgPT09IHBhc3RpbmdSb3dDb3VudCAmJiBjb2x1bW5Db3VudCA9PT0gcGFzdGluZ0NvbHVtbkNvdW50O1xufVxuXG52YXIgRG9jID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKERvYywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb2MoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvYy5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvYy5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdibG9jaysnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBEb2M7XG59KE5vZGUkMikpO1xuXG52YXIgUGFyYWdyYXBoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFBhcmFncmFwaCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJhZ3JhcGgoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFncmFwaC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdwYXJhZ3JhcGgnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFncmFwaC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdpbmxpbmUqJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7fSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbeyB0YWc6ICdwJyB9XSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydwJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBQYXJhZ3JhcGg7XG59KE5vZGUkMikpO1xuXG52YXIgcmVTb2Z0VGFiTGVuID0gL1xcc3sxLDR9JC87XG52YXIgVGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHQucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGV4dCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdyb3VwOiAnaW5saW5lJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUZXh0LnByb3RvdHlwZS5hZGRTcGFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyO1xuICAgICAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgICAgICAgICAgaWYgKHJhbmdlICYmICFpc0luTGlzdE5vZGUoJGZyb20pICYmICFpc0luVGFibGVOb2RlKCRmcm9tKSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLmluc2VydFRleHQoJyAgICAnLCAkZnJvbS5wb3MsICR0by5wb3MpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLnJlbW92ZVNwYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHI7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG8sIGZyb20gPSBzZWxlY3Rpb24uZnJvbTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcbiAgICAgICAgICAgIGlmIChyYW5nZSAmJiAhaXNJbkxpc3ROb2RlKCRmcm9tKSAmJiAhaXNJblRhYmxlTm9kZSgkZnJvbSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUJlZm9yZSA9ICRmcm9tLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVCZWZvcmUgJiYgbm9kZUJlZm9yZS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBub2RlQmVmb3JlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkU3BhY2VUZXh0ID0gdGV4dC5yZXBsYWNlKHJlU29mdFRhYkxlbiwgJycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BhY2VzID0gdGV4dC5sZW5ndGggLSByZW1vdmVkU3BhY2VUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuZGVsZXRlKGZyb20gLSBzcGFjZXMsIGZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGV4dC5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFRhYjogdGhpcy5hZGRTcGFjZXMoKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiB0aGlzLnJlbW92ZVNwYWNlcygpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRleHQ7XG59KE5vZGUkMikpO1xuXG52YXIgSGVhZGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShIZWFkaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRpbmcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlYWRpbmcucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnaGVhZGluZyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVhZGluZy5wcm90b3R5cGUsIFwibGV2ZWxzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlYWRpbmcucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlRE9NID0gdGhpcy5sZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogXCJoXCIgKyBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoeyBsZXZlbDogbGV2ZWwgfSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgbGV2ZWw6IHsgZGVmYXVsdDogMSB9LCBoZWFkaW5nVHlwZTogeyBkZWZhdWx0OiAnYXR4JyB9LCByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgY29udGVudDogJ2lubGluZSonLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGRlZmluaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBwYXJzZURPTSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiaFwiICsgYXR0cnMubGV2ZWwsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBIZWFkaW5nLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBzdGF0ZS5zY2hlbWEubm9kZXNbcGF5bG9hZC5sZXZlbCA/ICdoZWFkaW5nJyA6ICdwYXJhZ3JhcGgnXTtcbiAgICAgICAgICAgIHJldHVybiBzZXRCbG9ja1R5cGUobm9kZVR5cGUsIHBheWxvYWQpKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICByZXR1cm4gSGVhZGluZztcbn0oTm9kZSQyKSk7XG5cbnZhciBDb2RlQmxvY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ29kZUJsb2NrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvZGVCbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZUJsb2NrLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NvZGVCbG9jayc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZUJsb2NrLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3RleHQqJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IGxhbmd1YWdlOiB7IGRlZmF1bHQ6IG51bGwgfSwgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIGNvZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVmaW5pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgbWFya3M6ICcnLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ3ByZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gZG9tLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgbGFuZ3VhZ2U6IChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGQuZ2V0QXR0cmlidXRlKCdkYXRhLWxhbmd1YWdlJykpIHx8IG51bGwgfSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMucmF3SFRNTCB8fCAncHJlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnY29kZScsIF9fYXNzaWduJDEoeyAnZGF0YS1sYW5ndWFnZSc6IGF0dHJzLmxhbmd1YWdlIH0sIGdldEN1c3RvbUF0dHJzKGF0dHJzKSksIDBdLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29kZUJsb2NrLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHsgcmV0dXJuIHNldEJsb2NrVHlwZShzdGF0ZS5zY2hlbWEubm9kZXMuY29kZUJsb2NrKShzdGF0ZSwgZGlzcGF0Y2gpOyB9OyB9O1xuICAgIH07XG4gICAgQ29kZUJsb2NrLnByb3RvdHlwZS5tb3ZlQ3Vyc29yID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHRyID0gc3RhdGUudHIsIGRvYyA9IHN0YXRlLmRvYywgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICAgICAgdmFyICRmcm9tID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBfdGhpcy5jb250ZXh0LnZpZXc7XG4gICAgICAgICAgICBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXJlY3Rpb24pICYmICRmcm9tLm5vZGUoKS50eXBlLm5hbWUgPT09ICdjb2RlQmxvY2snKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gJGZyb20ucGFyZW50LnRleHRDb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZGlyZWN0aW9uID09PSAndXAnID8gJGZyb20uc3RhcnQoKSA6ICRmcm9tLmVuZCgpO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGRpcmVjdGlvbiA9PT0gJ3VwJ1xuICAgICAgICAgICAgICAgICAgICA/IFtvZmZzZXQsIGxpbmVzWzBdLmxlbmd0aCArIG9mZnNldF1cbiAgICAgICAgICAgICAgICAgICAgOiBbb2Zmc2V0IC0gbGFzdCQxKGxpbmVzKS5sZW5ndGgsIG9mZnNldF07XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGRvYy5yZXNvbHZlKGRpcmVjdGlvbiA9PT0gJ3VwJyA/ICRmcm9tLmJlZm9yZSgpIDogJGZyb20uYWZ0ZXIoKSk7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBkaXJlY3Rpb24gPT09ICd1cCcgPyBwb3Mubm9kZUJlZm9yZSA6IHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKGJldHdlZW4kMSgkZnJvbS5wb3MsIHJhbmdlWzBdLCByYW5nZVsxXSkgJiYgIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1RyID0gYWRkUGFyYWdyYXBoKHRyLCBwb3MsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdUcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb2RlQmxvY2sucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2RlQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ1NoaWZ0LU1vZC1wJzogY29kZUNvbW1hbmQsXG4gICAgICAgICAgICAnU2hpZnQtTW9kLVAnOiBjb2RlQ29tbWFuZCxcbiAgICAgICAgICAgIEFycm93VXA6IHRoaXMubW92ZUN1cnNvcigndXAnKSxcbiAgICAgICAgICAgIEFycm93RG93bjogdGhpcy5tb3ZlQ3Vyc29yKCdkb3duJyksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZUJsb2NrO1xufShOb2RlJDIpKTtcblxudmFyIEJ1bGxldExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQnVsbGV0TGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWxsZXRMaXN0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWxsZXRMaXN0LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2J1bGxldExpc3QnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1bGxldExpc3QucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnbGlzdEl0ZW0rJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW2NyZWF0ZURPTUluZm9QYXJzZWRSYXdIVE1MKCd1bCcpXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyd1bCcsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCdWxsZXRMaXN0LnByb3RvdHlwZS5jaGFuZ2VMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkgeyByZXR1cm4gY2hhbmdlTGlzdChzdGF0ZS5zY2hlbWEubm9kZXMuYnVsbGV0TGlzdCkoc3RhdGUsIGRpc3BhdGNoKTsgfTtcbiAgICB9O1xuICAgIEJ1bGxldExpc3QucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnVsbGV0TGlzdDogdGhpcy5jaGFuZ2VMaXN0LFxuICAgICAgICAgICAgdGFza0xpc3Q6IHRvZ2dsZVRhc2ssXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBCdWxsZXRMaXN0LnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVsbGV0TGlzdENvbW1hbmQgPSB0aGlzLmNoYW5nZUxpc3QoKTtcbiAgICAgICAgdmFyIF9hID0gZ2V0V3dDb21tYW5kcygpLCBpbmRlbnQgPSBfYS5pbmRlbnQsIG91dGRlbnQgPSBfYS5vdXRkZW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC11JzogYnVsbGV0TGlzdENvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLVUnOiBidWxsZXRMaXN0Q29tbWFuZCxcbiAgICAgICAgICAgIFRhYjogaW5kZW50KCksXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogb3V0ZGVudCgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEJ1bGxldExpc3Q7XG59KE5vZGUkMikpO1xuXG52YXIgT3JkZXJlZExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoT3JkZXJlZExpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3JkZXJlZExpc3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9yZGVyZWRMaXN0LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ29yZGVyZWRMaXN0JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcmRlcmVkTGlzdC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdsaXN0SXRlbSsnLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgb3JkZXI6IHsgZGVmYXVsdDogMSB9LCByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAnb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBkb20uZ2V0QXR0cmlidXRlKCdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgb3JkZXI6IGRvbS5oYXNBdHRyaWJ1dGUoJ3N0YXJ0JykgPyBOdW1iZXIoc3RhcnQpIDogMSB9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5yYXdIVE1MIHx8ICdvbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2Fzc2lnbiQxKHsgc3RhcnQ6IGF0dHJzLm9yZGVyID09PSAxID8gbnVsbCA6IGF0dHJzLm9yZGVyIH0sIGdldEN1c3RvbUF0dHJzKGF0dHJzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT3JkZXJlZExpc3QucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkgeyByZXR1cm4gY2hhbmdlTGlzdChzdGF0ZS5zY2hlbWEubm9kZXMub3JkZXJlZExpc3QpKHN0YXRlLCBkaXNwYXRjaCk7IH07IH07XG4gICAgfTtcbiAgICBPcmRlcmVkTGlzdC5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9yZGVyZWRMaXN0Q29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICB2YXIgX2EgPSBnZXRXd0NvbW1hbmRzKCksIGluZGVudCA9IF9hLmluZGVudCwgb3V0ZGVudCA9IF9hLm91dGRlbnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLW8nOiBvcmRlcmVkTGlzdENvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLU8nOiBvcmRlcmVkTGlzdENvbW1hbmQsXG4gICAgICAgICAgICBUYWI6IGluZGVudCgpLFxuICAgICAgICAgICAgJ1NoaWZ0LVRhYic6IG91dGRlbnQoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBPcmRlcmVkTGlzdDtcbn0oTm9kZSQyKSk7XG5cbnZhciBMaXN0SXRlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShMaXN0SXRlbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXN0SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlzdEl0ZW0ucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGlzdEl0ZW0nO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RJdGVtLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3BhcmFncmFwaCBibG9jayonLFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2s6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlZmluaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ2xpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoeyB0YXNrOiBkb20uaGFzQXR0cmlidXRlKCdkYXRhLXRhc2snKSwgY2hlY2tlZDogZG9tLmhhc0F0dHJpYnV0ZSgnZGF0YS10YXNrLWNoZWNrZWQnKSB9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXNrID0gYXR0cnMudGFzaywgY2hlY2tlZCA9IGF0dHJzLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFzaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthdHRycy5yYXdIVE1MIHx8ICdsaScsIDBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gWyd0YXNrLWxpc3QtaXRlbSddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdjaGVja2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLnJhd0hUTUwgfHwgJ2xpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fYXNzaWduJDEoeyBjbGFzczogY2xhc3NOYW1lcy5qb2luKCcgJyksICdkYXRhLXRhc2snOiB0YXNrIH0sIChjaGVja2VkICYmIHsgJ2RhdGEtdGFzay1jaGVja2VkJzogY2hlY2tlZCB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLmxpZnRUb1ByZXZMaXN0SXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHIsIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgZW1wdHkgPSBzZWxlY3Rpb24uZW1wdHk7XG4gICAgICAgICAgICB2YXIgbGlzdEl0ZW0gPSBzY2hlbWEubm9kZXMubGlzdEl0ZW07XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gJGZyb20ucGFyZW50O1xuICAgICAgICAgICAgdmFyIGxpc3RJdGVtUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XG4gICAgICAgICAgICBpZiAoZW1wdHkgJiYgIXBhcmVudC5jaGlsZENvdW50ICYmIGxpc3RJdGVtUGFyZW50LnR5cGUgPT09IGxpc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0byBwcmV2aW91cyBzaWJsaW5nIGxpc3QgaXRlbSB3aGVuIHRoZSBjdXJyZW50IGxpc3QgaXRlbSBpcyBub3QgdG9wIGxpc3QgaXRlbVxuICAgICAgICAgICAgICAgIGlmICgkZnJvbS5pbmRleCgtMikgPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgc3VidHJhY3QgJzEnIGZvciBjb25zaWRlcmluZyB0YWcgbGVuZ3RoKDxsaT4pXG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSgkZnJvbS5zdGFydCgtMSkgLSAxLCAkZnJvbS5lbmQoLTEpKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGdyYW5kUGFyZW50TGlzdEl0ZW0gPSAkZnJvbS5ub2RlKC0zKTtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRvIHBhcmVudCBsaXN0IGl0ZW0gd2hlbiB0aGUgY3VycmVudCBsaXN0IGl0ZW0gaXMgdG9wIGxpc3QgaXRlbVxuICAgICAgICAgICAgICAgIGlmIChncmFuZFBhcmVudExpc3RJdGVtLnR5cGUgPT09IGxpc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBzdWJ0cmFjdCAnMScgZm9yIGNvbnNpZGVyaW5nIHRhZyBsZW5ndGgoPHVsPilcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKCRmcm9tLnN0YXJ0KC0yKSAtIDEsICRmcm9tLmVuZCgtMSkpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExpc3RJdGVtLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3BsaXQgPSBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRMaXN0SXRlbShzdGF0ZS5zY2hlbWEubm9kZXMubGlzdEl0ZW0pKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBCYWNrc3BhY2U6IHRoaXMubGlmdFRvUHJldkxpc3RJdGVtKCksXG4gICAgICAgICAgICBFbnRlcjogc3BsaXQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTGlzdEl0ZW07XG59KE5vZGUkMikpO1xuXG52YXIgQmxvY2tRdW90ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShCbG9ja1F1b3RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrUXVvdGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2NrUXVvdGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnYmxvY2tRdW90ZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmxvY2tRdW90ZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdibG9jaysnLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbY3JlYXRlRE9NSW5mb1BhcnNlZFJhd0hUTUwoJ2Jsb2NrcXVvdGUnKV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnYmxvY2txdW90ZScsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCbG9ja1F1b3RlLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHsgcmV0dXJuIHdyYXBJbihzdGF0ZS5zY2hlbWEubm9kZXMuYmxvY2tRdW90ZSkoc3RhdGUsIGRpc3BhdGNoKTsgfTsgfTtcbiAgICB9O1xuICAgIEJsb2NrUXVvdGUucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBibG9ja1F1dG9lQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ0FsdC1xJzogYmxvY2tRdXRvZUNvbW1hbmQsXG4gICAgICAgICAgICAnQWx0LVEnOiBibG9ja1F1dG9lQ29tbWFuZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja1F1b3RlO1xufShOb2RlJDIpKTtcblxudmFyIGNlbGxPZmZzZXRGbk1hcCA9IHtcbiAgICBsZWZ0OiBnZXRMZWZ0Q2VsbE9mZnNldCxcbiAgICByaWdodDogZ2V0UmlnaHRDZWxsT2Zmc2V0LFxuICAgIHVwOiBnZXRVcENlbGxPZmZzZXQsXG4gICAgZG93bjogZ2V0RG93bkNlbGxPZmZzZXQsXG59O1xuZnVuY3Rpb24gaXNJbkZpcnN0TGlzdEl0ZW0ocG9zLCBkb2MsIF9hKSB7XG4gICAgdmFyIHBhcmFEZXB0aCA9IF9hWzBdLCBsaXN0RGVwdGggPSBfYVsxXTtcbiAgICB2YXIgbGlzdEl0ZW1Ob2RlID0gZG9jLnJlc29sdmUocG9zLmJlZm9yZShwYXJhRGVwdGggLSAxKSk7XG4gICAgcmV0dXJuIGxpc3REZXB0aCA9PT0gcGFyYURlcHRoICYmICFsaXN0SXRlbU5vZGUubm9kZUJlZm9yZTtcbn1cbmZ1bmN0aW9uIGlzSW5MYXN0TGlzdEl0ZW0ocG9zKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBkZXB0aCA9IHBvcy5kZXB0aDtcbiAgICB2YXIgcGFyZW50Tm9kZTtcbiAgICB3aGlsZSAoZGVwdGgpIHtcbiAgICAgICAgcGFyZW50Tm9kZSA9IHBvcy5ub2RlKGRlcHRoKTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUudHlwZS5uYW1lID09PSAndGFibGVCb2R5Q2VsbCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnROb2RlLnR5cGUubmFtZSA9PT0gJ2xpc3RJdGVtJykge1xuICAgICAgICAgICAgdmFyIGdyYW5kUGFyZW50ID0gcG9zLm5vZGUoZGVwdGggLSAxKTtcbiAgICAgICAgICAgIHZhciBsYXN0TGlzdEl0ZW0gPSBncmFuZFBhcmVudC5sYXN0Q2hpbGQgPT09IHBhcmVudE5vZGU7XG4gICAgICAgICAgICB2YXIgaGFzQ2hpbGRyZW4gPSAoKF9hID0gcGFyZW50Tm9kZS5sYXN0Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlLm5hbWUpICE9PSAncGFyYWdyYXBoJztcbiAgICAgICAgICAgIGlmICghbGFzdExpc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFoYXNDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYW5Nb3ZlVG9CZWZvcmVDZWxsKGRpcmVjdGlvbiwgX2EsIGZyb20sIGRvYywgaW5MaXN0KSB7XG4gICAgdmFyIHBhcmFEZXB0aCA9IF9hWzBdLCBsaXN0RGVwdGggPSBfYVsxXSwgY3VyRGVwdGggPSBfYVsyXTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImxlZnRcIiAvKiBMRUZUICovIHx8IGRpcmVjdGlvbiA9PT0gXCJ1cFwiIC8qIFVQICovKSB7XG4gICAgICAgIGlmIChpbkxpc3QgJiYgIWlzSW5GaXJzdExpc3RJdGVtKGZyb20sIGRvYywgW3BhcmFEZXB0aCwgbGlzdERlcHRoXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZnJvbS5iZWZvcmUoY3VyRGVwdGgpO1xuICAgICAgICB2YXIgbm9kZUJlZm9yZSA9IGRvYy5yZXNvbHZlKGVuZE9mZnNldCkubm9kZUJlZm9yZTtcbiAgICAgICAgaWYgKG5vZGVCZWZvcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNhbk1vdmVUb0FmdGVyQ2VsbChkaXJlY3Rpb24sIGN1ckRlcHRoLCBmcm9tLCBkb2MsIGluTGlzdCkge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwicmlnaHRcIiAvKiBSSUdIVCAqLyB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiIC8qIERPV04gKi8pIHtcbiAgICAgICAgaWYgKGluTGlzdCAmJiAhaXNJbkxhc3RMaXN0SXRlbShmcm9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmRPZmZzZXQgPSBmcm9tLmFmdGVyKGN1ckRlcHRoKTtcbiAgICAgICAgdmFyIG5vZGVBZnRlciA9IGRvYy5yZXNvbHZlKGVuZE9mZnNldCkubm9kZUFmdGVyO1xuICAgICAgICBpZiAobm9kZUFmdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjYW5Nb3ZlQmV0d2VlbkNlbGxzKGRpcmVjdGlvbiwgX2EsIGZyb20sIGRvYykge1xuICAgIHZhciBjZWxsRGVwdGggPSBfYVswXSwgcGFyYURlcHRoID0gX2FbMV07XG4gICAgdmFyIGxpc3REZXB0aCA9IGNlbGxEZXB0aCArIDM7IC8vIDMgaXMgcG9zaXRpb24gb2YgPHVsPjxsaT48cD5cbiAgICB2YXIgaW5MaXN0ID0gcGFyYURlcHRoID49IGxpc3REZXB0aDtcbiAgICB2YXIgY3VyRGVwdGggPSBpbkxpc3QgPyBjZWxsRGVwdGggKyAxIDogcGFyYURlcHRoO1xuICAgIHZhciBtb3ZlQmVmb3JlQ2VsbCA9IGNhbk1vdmVUb0JlZm9yZUNlbGwoZGlyZWN0aW9uLCBbcGFyYURlcHRoLCBsaXN0RGVwdGgsIGN1ckRlcHRoXSwgZnJvbSwgZG9jLCBpbkxpc3QpO1xuICAgIHZhciBtb3ZlQWZ0ZXJDZWxsID0gY2FuTW92ZVRvQWZ0ZXJDZWxsKGRpcmVjdGlvbiwgY3VyRGVwdGgsIGZyb20sIGRvYywgaW5MaXN0KTtcbiAgICByZXR1cm4gbW92ZUJlZm9yZUNlbGwgJiYgbW92ZUFmdGVyQ2VsbDtcbn1cbmZ1bmN0aW9uIGNhbkJlT3V0T2ZUYWJsZShkaXJlY3Rpb24sIG1hcCwgX2EpIHtcbiAgICB2YXIgcm93SWR4ID0gX2FbMF0sIGNvbElkeCA9IF9hWzFdO1xuICAgIHZhciByb3dzcGFuSW5mbyA9IG1hcC5nZXRSb3dzcGFuU3RhcnRJbmZvKHJvd0lkeCwgY29sSWR4KTtcbiAgICB2YXIgaW5GaXJzdFJvdyA9IGRpcmVjdGlvbiA9PT0gXCJ1cFwiIC8qIFVQICovICYmIHJvd0lkeCA9PT0gMDtcbiAgICB2YXIgaW5MYXN0Um93ID0gZGlyZWN0aW9uID09PSBcImRvd25cIiAvKiBET1dOICovICYmXG4gICAgICAgICgocm93c3BhbkluZm8gPT09IG51bGwgfHwgcm93c3BhbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvd3NwYW5JbmZvLmNvdW50KSA+IDEgPyByb3dJZHggKyByb3dzcGFuSW5mby5jb3VudCAtIDEgOiByb3dJZHgpID09PSBtYXAudG90YWxSb3dDb3VudCAtIDE7XG4gICAgcmV0dXJuIGluRmlyc3RSb3cgfHwgaW5MYXN0Um93O1xufVxuZnVuY3Rpb24gYWRkUGFyYWdyYXBoQmVmb3JlVGFibGUodHIsIG1hcCwgc2NoZW1hKSB7XG4gICAgdmFyIHRhYmxlU3RhcnRQb3MgPSB0ci5kb2MucmVzb2x2ZShtYXAudGFibGVTdGFydE9mZnNldCAtIDEpO1xuICAgIGlmICghdGFibGVTdGFydFBvcy5ub2RlQmVmb3JlKSB7XG4gICAgICAgIHJldHVybiBhZGRQYXJhZ3JhcGgodHIsIHRhYmxlU3RhcnRQb3MsIHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodGFibGVTdGFydFBvcywgLTEpKTtcbn1cbmZ1bmN0aW9uIGFkZFBhcmFncmFwaEFmdGVyVGFibGUodHIsIG1hcCwgc2NoZW1hLCBmb3JjZWRBZGR0aW9uKSB7XG4gICAgaWYgKGZvcmNlZEFkZHRpb24gPT09IHZvaWQgMCkgeyBmb3JjZWRBZGR0aW9uID0gZmFsc2U7IH1cbiAgICB2YXIgdGFibGVFbmRQb3MgPSB0ci5kb2MucmVzb2x2ZShtYXAudGFibGVFbmRPZmZzZXQpO1xuICAgIGlmIChmb3JjZWRBZGR0aW9uIHx8ICF0YWJsZUVuZFBvcy5ub2RlQWZ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGFkZFBhcmFncmFwaCh0ciwgdGFibGVFbmRQb3MsIHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodGFibGVFbmRQb3MsIDEpKTtcbn1cbmZ1bmN0aW9uIGdldFJpZ2h0Q2VsbE9mZnNldChfYSwgbWFwKSB7XG4gICAgdmFyIHJvd0lkeCA9IF9hWzBdLCBjb2xJZHggPSBfYVsxXTtcbiAgICB2YXIgdG90YWxSb3dDb3VudCA9IG1hcC50b3RhbFJvd0NvdW50LCB0b3RhbENvbHVtbkNvdW50ID0gbWFwLnRvdGFsQ29sdW1uQ291bnQ7XG4gICAgdmFyIGxhc3RDZWxsSW5Sb3cgPSBjb2xJZHggPT09IHRvdGFsQ29sdW1uQ291bnQgLSAxO1xuICAgIHZhciBsYXN0Q2VsbEluVGFibGUgPSByb3dJZHggPT09IHRvdGFsUm93Q291bnQgLSAxICYmIGxhc3RDZWxsSW5Sb3c7XG4gICAgaWYgKCFsYXN0Q2VsbEluVGFibGUpIHtcbiAgICAgICAgdmFyIG5leHRDb2xJZHggPSBjb2xJZHggKyAxO1xuICAgICAgICB2YXIgY29sc3BhbkluZm8gPSBtYXAuZ2V0Q29sc3BhblN0YXJ0SW5mbyhyb3dJZHgsIGNvbElkeCk7XG4gICAgICAgIGlmICgoY29sc3BhbkluZm8gPT09IG51bGwgfHwgY29sc3BhbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbHNwYW5JbmZvLmNvdW50KSA+IDEpIHtcbiAgICAgICAgICAgIG5leHRDb2xJZHggKz0gY29sc3BhbkluZm8uY291bnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Q2VsbEluUm93IHx8IG5leHRDb2xJZHggPT09IHRvdGFsQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHJvd0lkeCArPSAxO1xuICAgICAgICAgICAgbmV4dENvbElkeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHgsIG5leHRDb2xJZHgpLm9mZnNldDtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0TGVmdENlbGxPZmZzZXQoX2EsIG1hcCkge1xuICAgIHZhciByb3dJZHggPSBfYVswXSwgY29sSWR4ID0gX2FbMV07XG4gICAgdmFyIHRvdGFsQ29sdW1uQ291bnQgPSBtYXAudG90YWxDb2x1bW5Db3VudDtcbiAgICB2YXIgZmlyc3RDZWxsSW5Sb3cgPSBjb2xJZHggPT09IDA7XG4gICAgdmFyIGZpcnN0Q2VsbEluVGFibGUgPSByb3dJZHggPT09IDAgJiYgZmlyc3RDZWxsSW5Sb3c7XG4gICAgaWYgKCFmaXJzdENlbGxJblRhYmxlKSB7XG4gICAgICAgIGNvbElkeCAtPSAxO1xuICAgICAgICBpZiAoZmlyc3RDZWxsSW5Sb3cpIHtcbiAgICAgICAgICAgIHJvd0lkeCAtPSAxO1xuICAgICAgICAgICAgY29sSWR4ID0gdG90YWxDb2x1bW5Db3VudCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9iID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgY29sSWR4KSwgb2Zmc2V0ID0gX2Iub2Zmc2V0LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgbm9kZVNpemUgLSAyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFVwQ2VsbE9mZnNldChfYSwgbWFwKSB7XG4gICAgdmFyIHJvd0lkeCA9IF9hWzBdLCBjb2xJZHggPSBfYVsxXTtcbiAgICBpZiAocm93SWR4ID4gMCkge1xuICAgICAgICB2YXIgX2IgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4IC0gMSwgY29sSWR4KSwgb2Zmc2V0ID0gX2Iub2Zmc2V0LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgbm9kZVNpemUgLSAyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERvd25DZWxsT2Zmc2V0KF9hLCBtYXApIHtcbiAgICB2YXIgcm93SWR4ID0gX2FbMF0sIGNvbElkeCA9IF9hWzFdO1xuICAgIHZhciB0b3RhbFJvd0NvdW50ID0gbWFwLnRvdGFsUm93Q291bnQ7XG4gICAgaWYgKHJvd0lkeCA8IHRvdGFsUm93Q291bnQgLSAxKSB7XG4gICAgICAgIHZhciBuZXh0Um93SWR4ID0gcm93SWR4ICsgMTtcbiAgICAgICAgdmFyIHJvd3NwYW5JbmZvID0gbWFwLmdldFJvd3NwYW5TdGFydEluZm8ocm93SWR4LCBjb2xJZHgpO1xuICAgICAgICBpZiAoKHJvd3NwYW5JbmZvID09PSBudWxsIHx8IHJvd3NwYW5JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3dzcGFuSW5mby5jb3VudCkgPiAxKSB7XG4gICAgICAgICAgICBuZXh0Um93SWR4ICs9IHJvd3NwYW5JbmZvLmNvdW50IC0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gbWFwLmdldENlbGxJbmZvKG5leHRSb3dJZHgsIGNvbElkeCkub2Zmc2V0O1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtb3ZlVG9DZWxsKGRpcmVjdGlvbiwgdHIsIGNlbGxJbmRleCwgbWFwKSB7XG4gICAgdmFyIGNlbGxPZmZzZXRGbiA9IGNlbGxPZmZzZXRGbk1hcFtkaXJlY3Rpb25dO1xuICAgIHZhciBvZmZzZXQgPSBjZWxsT2Zmc2V0Rm4oY2VsbEluZGV4LCBtYXApO1xuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgdmFyIGRpciA9IGRpcmVjdGlvbiA9PT0gXCJyaWdodFwiIC8qIFJJR0hUICovIHx8IGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgLyogRE9XTiAqLyA/IDEgOiAtMTtcbiAgICAgICAgcmV0dXJuIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShvZmZzZXQpLCBkaXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjYW5TZWxlY3RUYWJsZU5vZGUoZGlyZWN0aW9uLCBtYXAsIF9hKSB7XG4gICAgdmFyIHJvd0lkeCA9IF9hWzBdLCBjb2xJZHggPSBfYVsxXTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInVwXCIgLyogVVAgKi8gfHwgZGlyZWN0aW9uID09PSBcImRvd25cIiAvKiBET1dOICovKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRhYmxlU3RhcnRPZmZzZXQgPSBtYXAudGFibGVTdGFydE9mZnNldCwgdGFibGVFbmRPZmZzZXQgPSBtYXAudGFibGVFbmRPZmZzZXQ7XG4gICAgdmFyIF9iID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgY29sSWR4KSwgb2Zmc2V0ID0gX2Iub2Zmc2V0LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgIHZhciBwb3MgPSBkaXJlY3Rpb24gPT09IFwibGVmdFwiIC8qIExFRlQgKi8gPyB0YWJsZVN0YXJ0T2Zmc2V0IDogdGFibGVFbmRPZmZzZXQ7XG4gICAgdmFyIGN1clBvcyA9IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgLyogTEVGVCAqLyA/IG9mZnNldCAtIDIgOiBvZmZzZXQgKyBub2RlU2l6ZSArIDM7XG4gICAgcmV0dXJuIHBvcyA9PT0gY3VyUG9zO1xufVxuZnVuY3Rpb24gc2VsZWN0Tm9kZSh0ciwgcG9zLCBkZXB0aCkge1xuICAgIHZhciB0YWJsZVBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcy5iZWZvcmUoZGVwdGggLSAzKSk7XG4gICAgcmV0dXJuIHRyLnNldFNlbGVjdGlvbihuZXcgTm9kZVNlbGVjdGlvbih0YWJsZVBvcykpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRSb3dJbmZvKGRpcmVjdGlvbiwgbWFwLCBzZWxlY3Rpb25JbmZvKSB7XG4gICAgdmFyIHRhcmdldFJvd0lkeDtcbiAgICB2YXIgaW5zZXJ0Q29sSWR4O1xuICAgIHZhciBub2RlU2l6ZTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInVwXCIgLyogVVAgKi8pIHtcbiAgICAgICAgdGFyZ2V0Um93SWR4ID0gc2VsZWN0aW9uSW5mby5zdGFydFJvd0lkeDtcbiAgICAgICAgaW5zZXJ0Q29sSWR4ID0gMDtcbiAgICAgICAgbm9kZVNpemUgPSAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFJvd0lkeCA9IHNlbGVjdGlvbkluZm8uZW5kUm93SWR4O1xuICAgICAgICBpbnNlcnRDb2xJZHggPSBtYXAudG90YWxDb2x1bW5Db3VudCAtIDE7XG4gICAgICAgIG5vZGVTaXplID0gbWFwLmdldENlbGxJbmZvKHRhcmdldFJvd0lkeCwgaW5zZXJ0Q29sSWR4KS5ub2RlU2l6ZSArIDE7XG4gICAgfVxuICAgIHJldHVybiB7IHRhcmdldFJvd0lkeDogdGFyZ2V0Um93SWR4LCBpbnNlcnRDb2xJZHg6IGluc2VydENvbElkeCwgbm9kZVNpemU6IG5vZGVTaXplIH07XG59XG5mdW5jdGlvbiBnZXRSb3dSYW5nZXMobWFwLCByb3dJZHgsIHRvdGFsQ29sdW1uQ291bnQpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCAwKS5vZmZzZXQ7XG4gICAgdmFyIF9hID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgdG90YWxDb2x1bW5Db3VudCAtIDEpLCBvZmZzZXQgPSBfYS5vZmZzZXQsIG5vZGVTaXplID0gX2Eubm9kZVNpemU7XG4gICAgcmV0dXJuIHsgZnJvbTogc3RhcnRPZmZzZXQsIHRvOiBvZmZzZXQgKyBub2RlU2l6ZSB9O1xufVxudmFyIFRhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGUucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAndGFibGVIZWFkezF9IHRhYmxlQm9keXsxfScsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtjcmVhdGVET01JbmZvUGFyc2VkUmF3SFRNTCgndGFibGUnKV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndGFibGUnLCBnZXRDdXN0b21BdHRycyhhdHRycyksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGFibGUucHJvdG90eXBlLmFkZFRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkID09PSB2b2lkIDApIHsgcGF5bG9hZCA9IHsgcm93Q291bnQ6IDIsIGNvbHVtbkNvdW50OiAxLCBkYXRhOiBbXSB9OyB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhciByb3dDb3VudCA9IHBheWxvYWQucm93Q291bnQsIGNvbHVtbkNvdW50ID0gcGF5bG9hZC5jb2x1bW5Db3VudCwgZGF0YSA9IHBheWxvYWQuZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBzZWxlY3Rpb24uZnJvbSwgdG8gPSBzZWxlY3Rpb24udG8sICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICAgICAgICAgIHZhciBjb2xsYXBzZWQgPSBmcm9tID09PSB0bztcbiAgICAgICAgICAgICAgICBpZiAoY29sbGFwc2VkICYmICFpc0luVGFibGVOb2RlKCRmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBzY2hlbWEubm9kZXMsIHRhYmxlSGVhZCA9IF9hLnRhYmxlSGVhZCwgdGFibGVCb2R5ID0gX2EudGFibGVCb2R5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhlYWREYXRhID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnNsaWNlKDAsIGNvbHVtbkNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRib2R5RGF0YSA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5zbGljZShjb2x1bW5Db3VudCwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVIZWFkUm93ID0gY3JlYXRlVGFibGVIZWFkUm93KGNvbHVtbkNvdW50LCBzY2hlbWEsIHRoZWFkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZUJvZHlSb3dzID0gY3JlYXRlVGFibGVCb2R5Um93cyhyb3dDb3VudCAtIDEsIGNvbHVtbkNvdW50LCBzY2hlbWEsIHRib2R5RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IHNjaGVtYS5ub2Rlcy50YWJsZS5jcmVhdGUobnVsbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVIZWFkLmNyZWF0ZShudWxsLCB0YWJsZUhlYWRSb3cpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVCb2R5LmNyZWF0ZShudWxsLCB0YWJsZUJvZHlSb3dzKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHRhYmxlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLnJlbW92ZVRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoc2VsZWN0aW9uLiRhbmNob3IpO1xuICAgICAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWJsZVN0YXJ0T2Zmc2V0ID0gbWFwLnRhYmxlU3RhcnRPZmZzZXQsIHRhYmxlRW5kT2Zmc2V0ID0gbWFwLnRhYmxlRW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IHRhYmxlU3RhcnRPZmZzZXQgLSAxO1xuICAgICAgICAgICAgICAgIHZhciBjdXJzb3JQb3MgPSBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLmRlbGV0ZShzdGFydE9mZnNldCwgdGFibGVFbmRPZmZzZXQpLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGN1cnNvclBvcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmFkZENvbHVtbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHIsIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9hLmFuY2hvciwgaGVhZCA9IF9hLmhlYWQ7XG4gICAgICAgICAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkluZm8gPSBtYXAuZ2V0UmVjdE9mZnNldHMoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q29sSWR4ID0gZGlyZWN0aW9uID09PSBcImxlZnRcIiAvKiBMRUZUICovID8gc2VsZWN0aW9uSW5mby5zdGFydENvbElkeCA6IHNlbGVjdGlvbkluZm8uZW5kQ29sSWR4ICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uQ291bnQgPSBnZXRSb3dBbmRDb2x1bW5Db3VudChzZWxlY3Rpb25JbmZvKS5jb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxSb3dDb3VudCA9IG1hcC50b3RhbFJvd0NvdW50O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0lkeCA9IDA7IHJvd0lkeCA8IHRvdGFsUm93Q291bnQ7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IGNyZWF0ZUR1bW15Q2VsbHMoY29sdW1uQ291bnQsIHJvd0lkeCwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgdHIuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKG1hcC5wb3NBdChyb3dJZHgsIHRhcmdldENvbElkeCkpLCBjZWxscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5yZW1vdmVDb2x1bW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSwgYW5jaG9yID0gX2EuYW5jaG9yLCBoZWFkID0gX2EuaGVhZDtcbiAgICAgICAgICAgIGlmIChhbmNob3IgJiYgaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyhhbmNob3IsIGhlYWQpO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbENvbHVtbkNvdW50ID0gbWFwLnRvdGFsQ29sdW1uQ291bnQsIHRvdGFsUm93Q291bnQgPSBtYXAudG90YWxSb3dDb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uQ291bnQgPSBnZXRSb3dBbmRDb2x1bW5Db3VudChzZWxlY3Rpb25JbmZvKS5jb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRBbGxDb2x1bW4gPSBjb2x1bW5Db3VudCA9PT0gdG90YWxDb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRBbGxDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb2xJZHggPSBzZWxlY3Rpb25JbmZvLnN0YXJ0Q29sSWR4LCBlbmRDb2xJZHggPSBzZWxlY3Rpb25JbmZvLmVuZENvbElkeDtcbiAgICAgICAgICAgICAgICB2YXIgbWFwU3RhcnQgPSB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0lkeCA9IDA7IHJvd0lkeCA8IHRvdGFsUm93Q291bnQ7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbElkeCA9IGVuZENvbElkeDsgY29sSWR4ID49IHN0YXJ0Q29sSWR4OyBjb2xJZHggLT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgY29sSWR4KSwgb2Zmc2V0ID0gX2Iub2Zmc2V0LCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb20gPSB0ci5tYXBwaW5nLnNsaWNlKG1hcFN0YXJ0KS5tYXAob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0byA9IGZyb20gKyBub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmFkZFJvdyA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9hLmFuY2hvciwgaGVhZCA9IF9hLmhlYWQ7XG4gICAgICAgICAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsQ29sdW1uQ291bnQgPSBtYXAudG90YWxDb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyhhbmNob3IsIGhlYWQpO1xuICAgICAgICAgICAgICAgIHZhciByb3dDb3VudCA9IGdldFJvd0FuZENvbHVtbkNvdW50KHNlbGVjdGlvbkluZm8pLnJvd0NvdW50O1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGdldFRhcmdldFJvd0luZm8oZGlyZWN0aW9uLCBtYXAsIHNlbGVjdGlvbkluZm8pLCB0YXJnZXRSb3dJZHggPSBfYi50YXJnZXRSb3dJZHgsIGluc2VydENvbElkeCA9IF9iLmluc2VydENvbElkeCwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRUaGVhZCA9IHRhcmdldFJvd0lkeCA9PT0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkVGhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyb20gPSB0ci5tYXBwaW5nLm1hcChtYXAucG9zQXQodGFyZ2V0Um93SWR4LCBpbnNlcnRDb2xJZHgpKSArIG5vZGVTaXplO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sSWR4ID0gMDsgY29sSWR4IDwgdG90YWxDb2x1bW5Db3VudDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzID0gY2VsbHMuY29uY2F0KGNyZWF0ZUR1bW15Q2VsbHMoMSwgdGFyZ2V0Um93SWR4LCBzY2hlbWEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChzY2hlbWEubm9kZXMudGFibGVSb3cuY3JlYXRlKG51bGwsIGNlbGxzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuaW5zZXJ0KGZyb20sIHJvd3MpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLnJlbW92ZVJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLCBhbmNob3IgPSBfYS5hbmNob3IsIGhlYWQgPSBfYS5oZWFkO1xuICAgICAgICAgICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbFJvd0NvdW50ID0gbWFwLnRvdGFsUm93Q291bnQsIHRvdGFsQ29sdW1uQ291bnQgPSBtYXAudG90YWxDb2x1bW5Db3VudDtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyhhbmNob3IsIGhlYWQpO1xuICAgICAgICAgICAgICAgIHZhciByb3dDb3VudCA9IGdldFJvd0FuZENvbHVtbkNvdW50KHNlbGVjdGlvbkluZm8pLnJvd0NvdW50O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFJvd0lkeCA9IHNlbGVjdGlvbkluZm8uc3RhcnRSb3dJZHgsIGVuZFJvd0lkeCA9IHNlbGVjdGlvbkluZm8uZW5kUm93SWR4O1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZFRoZWFkID0gc3RhcnRSb3dJZHggPT09IDA7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkQWxsVGJvZHlSb3cgPSByb3dDb3VudCA9PT0gdG90YWxSb3dDb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkQWxsVGJvZHlSb3cgfHwgc2VsZWN0ZWRUaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0lkeCA9IGVuZFJvd0lkeDsgcm93SWR4ID49IHN0YXJ0Um93SWR4OyByb3dJZHggLT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBnZXRSb3dSYW5nZXMobWFwLCByb3dJZHgsIHRvdGFsQ29sdW1uQ291bnQpLCBmcm9tID0gX2IuZnJvbSwgdG8gPSBfYi50bztcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRhYmxlIHJvd1xuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGUoZnJvbSAtIDEsIHRvICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5hbGlnbkNvbHVtbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZCA9PT0gdm9pZCAwKSB7IHBheWxvYWQgPSB7IGFsaWduOiAnY2VudGVyJyB9OyB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhciBhbGlnbiA9IHBheWxvYWQuYWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLCBhbmNob3IgPSBfYS5hbmNob3IsIGhlYWQgPSBfYS5oZWFkO1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgJiYgaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbFJvd0NvdW50ID0gbWFwLnRvdGFsUm93Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25JbmZvID0gbWFwLmdldFJlY3RPZmZzZXRzKGFuY2hvciwgaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydENvbElkeCA9IHNlbGVjdGlvbkluZm8uc3RhcnRDb2xJZHgsIGVuZENvbElkeCA9IHNlbGVjdGlvbkluZm8uZW5kQ29sSWR4O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByb3dJZHggPSAwOyByb3dJZHggPCB0b3RhbFJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sSWR4ID0gc3RhcnRDb2xJZHg7IGNvbElkeCA8PSBlbmRDb2xJZHg7IGNvbElkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXAuZXh0ZW5kZWRSb3dzcGFuKHJvd0lkeCwgY29sSWR4KSAmJiAhbWFwLmV4dGVuZGVkQ29sc3Bhbihyb3dJZHgsIGNvbElkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gbWFwLmdldE5vZGVBbmRQb3Mocm93SWR4LCBjb2xJZHgpLCBub2RlID0gX2Iubm9kZSwgcG9zID0gX2IucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBzZXRBdHRycyhub2RlLCB7IGFsaWduOiBhbGlnbiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIG51bGwsIGF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5tb3ZlVG9DZWxsID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50ciwgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSwgYW5jaG9yID0gX2EuYW5jaG9yLCBoZWFkID0gX2EuaGVhZDtcbiAgICAgICAgICAgIGlmIChhbmNob3IgJiYgaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbEluZGV4ID0gbWFwLmdldENlbGxJbmRleChhbmNob3IpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdUciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVPdXRPZlRhYmxlKGRpcmVjdGlvbiwgbWFwLCBjZWxsSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gY29udGVudCBiZWZvcmUgb3IgYWZ0ZXIgdGhlIHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbiBlbXB0eSBsaW5lKCdwYXJhZ3JhcGgnKSBpcyBjcmVhdGVkIGJ5IHByZXNzaW5nIHRoZSBhcnJvdyBrZXlzLlxuICAgICAgICAgICAgICAgICAgICBuZXdUciA9IGFkZFBhcmFncmFwaEFmdGVyVGFibGUodHIsIG1hcCwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RyID0gbW92ZVRvQ2VsbChkaXJlY3Rpb24sIHRyLCBjZWxsSW5kZXgsIG1hcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdUcikge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChuZXdUcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5tb3ZlSW5DZWxsID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50ciwgZG9jID0gc3RhdGUuZG9jLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb207XG4gICAgICAgICAgICB2YXIgdmlldyA9IF90aGlzLmNvbnRleHQudmlldztcbiAgICAgICAgICAgIGlmICghdmlldy5lbmRPZlRleHRibG9jayhkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNlbGwgPSBmaW5kTm9kZUJ5KCRmcm9tLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ3RhYmxlSGVhZENlbGwnIHx8IHR5cGUubmFtZSA9PT0gJ3RhYmxlQm9keUNlbGwnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhID0gZmluZE5vZGVCeSgkZnJvbSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ3BhcmFncmFwaCc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxEZXB0aCA9IGNlbGwuZGVwdGg7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmEgJiYgY2FuTW92ZUJldHdlZW5DZWxscyhkaXJlY3Rpb24sIFtjZWxsRGVwdGgsIHBhcmEuZGVwdGhdLCAkZnJvbSwgZG9jKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKS5hbmNob3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxJbmRleCA9IG1hcC5nZXRDZWxsSW5kZXgoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1RyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuU2VsZWN0VGFibGVOb2RlKGRpcmVjdGlvbiwgbWFwLCBjZWxsSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBjdXJzb3IgcG9zaXRpb24gaXMgYXQgdGhlIGVuZCBvZiB0aGUgY2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0YWJsZSBpcyBzZWxlY3RlZCB3aGVuIHRoZSBsZWZ0IC8gcmlnaHQgYXJyb3cga2V5cyBhcmUgcHJlc3NlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RyID0gc2VsZWN0Tm9kZSh0ciwgJGZyb20sIGNlbGxEZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2FuQmVPdXRPZlRhYmxlKGRpcmVjdGlvbiwgbWFwLCBjZWxsSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGNvbnRlbnQgYmVmb3JlIG9yIGFmdGVyIHRoZSB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIGVtcHR5IGxpbmUoJ3BhcmFncmFwaCcpIGlzIGNyZWF0ZWQgYnkgcHJlc3NpbmcgdGhlIGFycm93IGtleXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBcInVwXCIgLyogVVAgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUciA9IGFkZFBhcmFncmFwaEJlZm9yZVRhYmxlKHRyLCBtYXAsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwiZG93blwiIC8qIERPV04gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUciA9IGFkZFBhcmFncmFwaEFmdGVyVGFibGUodHIsIG1hcCwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RyID0gbW92ZVRvQ2VsbChkaXJlY3Rpb24sIHRyLCBjZWxsSW5kZXgsIG1hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChuZXdUcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5kZWxldGVDZWxscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5zY2hlbWEsIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9hLmFuY2hvciwgaGVhZCA9IF9hLmhlYWQ7XG4gICAgICAgICAgICB2YXIgdGV4dFNlbGVjdGlvbiA9IHNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAoYW5jaG9yICYmIGhlYWQgJiYgIXRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gbWFwLmdldFJlY3RPZmZzZXRzKGFuY2hvciwgaGVhZCksIHN0YXJ0Um93SWR4ID0gX2Iuc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4ID0gX2Iuc3RhcnRDb2xJZHgsIGVuZFJvd0lkeCA9IF9iLmVuZFJvd0lkeCwgZW5kQ29sSWR4ID0gX2IuZW5kQ29sSWR4O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvd0lkeCA9IHN0YXJ0Um93SWR4OyByb3dJZHggPD0gZW5kUm93SWR4OyByb3dJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2xJZHggPSBzdGFydENvbElkeDsgY29sSWR4IDw9IGVuZENvbElkeDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWFwLmV4dGVuZGVkUm93c3Bhbihyb3dJZHgsIGNvbElkeCkgJiYgIW1hcC5leHRlbmRlZENvbHNwYW4ocm93SWR4LCBjb2xJZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gbWFwLmdldE5vZGVBbmRQb3Mocm93SWR4LCBjb2xJZHgpLCBub2RlID0gX2Mubm9kZSwgcG9zID0gX2MucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IGNyZWF0ZUR1bW15Q2VsbHMoMSwgcm93SWR4LCBzY2hlbWEsIG5vZGUuYXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHRyLm1hcHBpbmcubWFwKHBvcyksIHRyLm1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUpLCBjZWxscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmV4aXRUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHIsIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbTtcbiAgICAgICAgICAgIHZhciBjZWxsID0gZmluZE5vZGVCeSgkZnJvbSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICd0YWJsZUhlYWRDZWxsJyB8fCB0eXBlLm5hbWUgPT09ICd0YWJsZUJvZHlDZWxsJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYSA9IGZpbmROb2RlQnkoJGZyb20sIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3IgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLmFuY2hvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChhZGRQYXJhZ3JhcGhBZnRlclRhYmxlKHRyLCBtYXAsIHNjaGVtYSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRUYWJsZTogdGhpcy5hZGRUYWJsZSgpLFxuICAgICAgICAgICAgcmVtb3ZlVGFibGU6IHRoaXMucmVtb3ZlVGFibGUoKSxcbiAgICAgICAgICAgIGFkZENvbHVtblRvTGVmdDogdGhpcy5hZGRDb2x1bW4oXCJsZWZ0XCIgLyogTEVGVCAqLyksXG4gICAgICAgICAgICBhZGRDb2x1bW5Ub1JpZ2h0OiB0aGlzLmFkZENvbHVtbihcInJpZ2h0XCIgLyogUklHSFQgKi8pLFxuICAgICAgICAgICAgcmVtb3ZlQ29sdW1uOiB0aGlzLnJlbW92ZUNvbHVtbigpLFxuICAgICAgICAgICAgYWRkUm93VG9VcDogdGhpcy5hZGRSb3coXCJ1cFwiIC8qIFVQICovKSxcbiAgICAgICAgICAgIGFkZFJvd1RvRG93bjogdGhpcy5hZGRSb3coXCJkb3duXCIgLyogRE9XTiAqLyksXG4gICAgICAgICAgICByZW1vdmVSb3c6IHRoaXMucmVtb3ZlUm93KCksXG4gICAgICAgICAgICBhbGlnbkNvbHVtbjogdGhpcy5hbGlnbkNvbHVtbigpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWxldGVDZWxsQ29udGVudCA9IHRoaXMuZGVsZXRlQ2VsbHMoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFRhYjogdGhpcy5tb3ZlVG9DZWxsKFwicmlnaHRcIiAvKiBSSUdIVCAqLyksXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogdGhpcy5tb3ZlVG9DZWxsKFwibGVmdFwiIC8qIExFRlQgKi8pLFxuICAgICAgICAgICAgQXJyb3dVcDogdGhpcy5tb3ZlSW5DZWxsKFwidXBcIiAvKiBVUCAqLyksXG4gICAgICAgICAgICBBcnJvd0Rvd246IHRoaXMubW92ZUluQ2VsbChcImRvd25cIiAvKiBET1dOICovKSxcbiAgICAgICAgICAgIEFycm93TGVmdDogdGhpcy5tb3ZlSW5DZWxsKFwibGVmdFwiIC8qIExFRlQgKi8pLFxuICAgICAgICAgICAgQXJyb3dSaWdodDogdGhpcy5tb3ZlSW5DZWxsKFwicmlnaHRcIiAvKiBSSUdIVCAqLyksXG4gICAgICAgICAgICBCYWNrc3BhY2U6IGRlbGV0ZUNlbGxDb250ZW50LFxuICAgICAgICAgICAgJ01vZC1CYWNrc3BhY2UnOiBkZWxldGVDZWxsQ29udGVudCxcbiAgICAgICAgICAgIERlbGV0ZTogZGVsZXRlQ2VsbENvbnRlbnQsXG4gICAgICAgICAgICAnTW9kLURlbGV0ZSc6IGRlbGV0ZUNlbGxDb250ZW50LFxuICAgICAgICAgICAgJ01vZC1FbnRlcic6IHRoaXMuZXhpdFRhYmxlKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGU7XG59KE5vZGUkMikpO1xuXG52YXIgVGFibGVIZWFkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlSGVhZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUhlYWQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlSGVhZC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZUhlYWQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlSGVhZC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0YWJsZVJvd3sxfScsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtjcmVhdGVET01JbmZvUGFyc2VkUmF3SFRNTCgndGhlYWQnKV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndGhlYWQnLCBnZXRDdXN0b21BdHRycyhhdHRycyksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRhYmxlSGVhZDtcbn0oTm9kZSQyKSk7XG5cbnZhciBUYWJsZUJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFibGVCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQm9keSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVCb2R5LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RhYmxlQm9keSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVCb2R5LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3RhYmxlUm93KycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAndGJvZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKCd0cicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gcm93c1swXS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndGJvZHknLCBnZXRDdXN0b21BdHRycyhhdHRycyksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRhYmxlQm9keTtcbn0oTm9kZSQyKSk7XG5cbnZhciBUYWJsZVJvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZVJvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZVJvdygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVSb3cucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFibGVSb3cnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlUm93LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJyh0YWJsZUhlYWRDZWxsIHwgdGFibGVCb2R5Q2VsbCkqJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICd0cicsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gZG9tLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7fSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyd0cicsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGFibGVSb3c7XG59KE5vZGUkMikpO1xuXG52YXIgVGFibGVIZWFkQ2VsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZUhlYWRDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlSGVhZENlbGwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlSGVhZENlbGwucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFibGVIZWFkQ2VsbCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVIZWFkQ2VsbC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdwYXJhZ3JhcGgrJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IGFsaWduOiB7IGRlZmF1bHQ6IG51bGwgfSwgY2xhc3NOYW1lOiB7IGRlZmF1bHQ6IG51bGwgfSwgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0sIGNvbHNwYW46IHsgZGVmYXVsdDogbnVsbCB9LCBleHRlbmRlZDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIGlzb2xhdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW2NyZWF0ZVBhcnNlZENlbGxET00oJ3RoJyldLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsQXR0cnMgPSBjcmVhdGVDZWxsQXR0cnMoYXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyd0aCcsIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgY2VsbEF0dHJzKSwgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGFibGVIZWFkQ2VsbDtcbn0oTm9kZSQyKSk7XG5cbnZhciBUYWJsZUJvZHlDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlQm9keUNlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVCb2R5Q2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVCb2R5Q2VsbC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZUJvZHlDZWxsJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUJvZHlDZWxsLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJyhwYXJhZ3JhcGggfCBidWxsZXRMaXN0IHwgb3JkZXJlZExpc3QpKycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ246IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgY29sc3BhbjogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIHJvd3NwYW46IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZDogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc29sYXRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtjcmVhdGVQYXJzZWRDZWxsRE9NKCd0ZCcpXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbEF0dHJzID0gY3JlYXRlQ2VsbEF0dHJzKGF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndGQnLCBjZWxsQXR0cnMsIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRhYmxlQm9keUNlbGw7XG59KE5vZGUkMikpO1xuXG52YXIgSW1hZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoSW1hZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW1hZ2UoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEltYWdlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2ltYWdlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbWFnZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IGltYWdlVXJsOiB7IGRlZmF1bHQ6ICcnIH0sIGFsdFRleHQ6IHsgZGVmYXVsdDogbnVsbCB9LCByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdpbmxpbmUnLFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ2ltZ1tzcmNdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhbml0aXplZERPTSA9IHNhbml0aXplSFRNTChkb20sIHsgUkVUVVJOX0RPTV9GUkFHTUVOVDogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VVcmwgPSBzYW5pdGl6ZWRET00uZ2V0QXR0cmlidXRlKCdzcmMnKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IHNhbml0aXplZERPTS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWx0VGV4dCA9IHNhbml0aXplZERPTS5nZXRBdHRyaWJ1dGUoJ2FsdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgaW1hZ2VVcmw6IGltYWdlVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRUZXh0OiBhbHRUZXh0IH0sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLnJhd0hUTUwgfHwgJ2ltZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoeyBzcmM6IGVzY2FwZVhtbCQxKGF0dHJzLmltYWdlVXJsKSB9LCAoYXR0cnMuYWx0VGV4dCAmJiB7IGFsdDogYXR0cnMuYWx0VGV4dCB9KSksIGdldEN1c3RvbUF0dHJzKGF0dHJzKSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBJbWFnZS5wcm90b3R5cGUuYWRkSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IF9hLnNjaGVtYSwgdHIgPSBfYS50cjtcbiAgICAgICAgICAgIHZhciBfYiA9IHBheWxvYWQsIGltYWdlVXJsID0gX2IuaW1hZ2VVcmwsIGFsdFRleHQgPSBfYi5hbHRUZXh0O1xuICAgICAgICAgICAgaWYgKCFpbWFnZVVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlID0gc2NoZW1hLm5vZGVzLmltYWdlLmNyZWF0ZUFuZEZpbGwoX19hc3NpZ24kMSh7IGltYWdlVXJsOiBpbWFnZVVybCB9LCAoYWx0VGV4dCAmJiB7IGFsdFRleHQ6IGFsdFRleHQgfSkpKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKG5vZGUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBJbWFnZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRJbWFnZTogdGhpcy5hZGRJbWFnZSgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEltYWdlO1xufShOb2RlJDIpKTtcblxudmFyIFJPT1RfQkxPQ0tfREVQVEggPSAxO1xudmFyIFRoZW1hdGljQnJlYWsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGhlbWF0aWNCcmVhaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaGVtYXRpY0JyZWFrKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaGVtYXRpY0JyZWFrLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RoZW1hdGljQnJlYWsnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRoZW1hdGljQnJlYWsucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW3sgdGFnOiAnaHInIH1dLFxuICAgICAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgW2F0dHJzLnJhd0hUTUwgfHwgJ2hyJ11dO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGhlbWF0aWNCcmVhay5wcm90b3R5cGUuaHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBzdGF0ZS5zZWxlY3Rpb24sICRmcm9tID0gX2IuJGZyb20sICR0byA9IF9iLiR0bztcbiAgICAgICAgICAgIGlmICgkZnJvbSA9PT0gJHRvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IHN0YXRlLmRvYztcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBzdGF0ZS5zY2hlbWEubm9kZXMsIHRoZW1hdGljQnJlYWsgPSBfYy50aGVtYXRpY0JyZWFrLCBwYXJhZ3JhcGggPSBfYy5wYXJhZ3JhcGg7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gW3RoZW1hdGljQnJlYWsuY3JlYXRlKCldO1xuICAgICAgICAgICAgICAgIHZhciByb290QmxvY2sgPSAkZnJvbS5ub2RlKFJPT1RfQkxPQ0tfREVQVEgpO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0QmxvY2sgPSBkb2MuY2hpbGQoZG9jLmNoaWxkQ291bnQgLSAxKSA9PT0gcm9vdEJsb2NrO1xuICAgICAgICAgICAgICAgIHZhciBibG9ja0VuZCA9IGRvYy5yZXNvbHZlKCRmcm9tLmFmdGVyKFJPT1RfQkxPQ0tfREVQVEgpKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEhyID0gKChfYSA9ICRmcm9tLm5vZGVBZnRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUubmFtZSkgPT09IF90aGlzLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RCbG9jayB8fCBuZXh0SHIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChwYXJhZ3JhcGguY3JlYXRlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnQoYmxvY2tFbmQucG9zLCBub2Rlcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBUaGVtYXRpY0JyZWFrLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgaHI6IHRoaXMuaHIoKSB9O1xuICAgIH07XG4gICAgVGhlbWF0aWNCcmVhay5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhyQ29tbWFuZCA9IHRoaXMuaHIoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1sJzogaHJDb21tYW5kLFxuICAgICAgICAgICAgJ01vZC1MJzogaHJDb21tYW5kLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRoZW1hdGljQnJlYWs7XG59KE5vZGUkMikpO1xuXG52YXIgU3Ryb25nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFN0cm9uZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJvbmcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cm9uZy5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdzdHJvbmcnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cm9uZy5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VET00gPSBbJ2InLCAnc3Ryb25nJ10ubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogcGFyc2VET00sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthdHRycy5yYXdIVE1MIHx8ICdzdHJvbmcnLCBnZXRDdXN0b21BdHRycyhhdHRycyldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3Ryb25nLnByb3RvdHlwZS5ib2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkgeyByZXR1cm4gdG9nZ2xlTWFyayQxKHN0YXRlLnNjaGVtYS5tYXJrcy5zdHJvbmcpKHN0YXRlLCBkaXNwYXRjaCk7IH07IH07XG4gICAgfTtcbiAgICBTdHJvbmcucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBib2xkOiB0aGlzLmJvbGQoKSB9O1xuICAgIH07XG4gICAgU3Ryb25nLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9sZENvbW1hbmQgPSB0aGlzLmJvbGQoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1iJzogYm9sZENvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLUInOiBib2xkQ29tbWFuZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJvbmc7XG59KE1hcmspKTtcblxudmFyIEVtcGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoRW1waCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbXBoKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbXBoLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2VtcGgnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtcGgucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlRE9NID0gWydpJywgJ2VtJ10ubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogcGFyc2VET00sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthdHRycy5yYXdIVE1MIHx8ICdlbScsIGdldEN1c3RvbUF0dHJzKGF0dHJzKV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFbXBoLnByb3RvdHlwZS5pdGFsaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7IHJldHVybiB0b2dnbGVNYXJrJDEoc3RhdGUuc2NoZW1hLm1hcmtzLmVtcGgpKHN0YXRlLCBkaXNwYXRjaCk7IH07IH07XG4gICAgfTtcbiAgICBFbXBoLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgaXRhbGljOiB0aGlzLml0YWxpYygpIH07XG4gICAgfTtcbiAgICBFbXBoLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRhbGljQ29tbWFuZCA9IHRoaXMuaXRhbGljKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtaSc6IGl0YWxpY0NvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLUknOiBpdGFsaWNDb21tYW5kLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEVtcGg7XG59KE1hcmspKTtcblxudmFyIFN0cmlrZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShTdHJpa2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RyaWtlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpa2UucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3RyaWtlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpa2UucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlRE9NID0gWydzJywgJ2RlbCddLm1hcChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHt9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IHBhcnNlRE9NLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXR0cnMucmF3SFRNTCB8fCAnZGVsJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0cmlrZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7IHJldHVybiB0b2dnbGVNYXJrJDEoc3RhdGUuc2NoZW1hLm1hcmtzLnN0cmlrZSkoc3RhdGUsIGRpc3BhdGNoKTsgfTsgfTtcbiAgICB9O1xuICAgIFN0cmlrZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0cmlrZUNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2Qtcyc6IHN0cmlrZUNvbW1hbmQsXG4gICAgICAgICAgICAnTW9kLVMnOiBzdHJpa2VDb21tYW5kLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmlrZTtcbn0oTWFyaykpO1xuXG52YXIgTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShMaW5rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmsobGlua0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGlua0F0dHJpYnV0ZXMgPSBsaW5rQXR0cmlidXRlcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGluay5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdsaW5rJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5rLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgbGlua1VybDogeyBkZWZhdWx0OiAnJyB9LCB0aXRsZTogeyBkZWZhdWx0OiBudWxsIH0sIHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ2FbaHJlZl0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVkRE9NID0gc2FuaXRpemVIVE1MKGRvbSwgeyBSRVRVUk5fRE9NX0ZSQUdNRU5UOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBocmVmID0gc2FuaXRpemVkRE9NLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IHNhbml0aXplZERPTS5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBzYW5pdGl6ZWRET00uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoeyBsaW5rVXJsOiBocmVmLCB0aXRsZTogdGl0bGUgfSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMucmF3SFRNTCB8fCAnYScsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoeyBocmVmOiBlc2NhcGVYbWwkMShhdHRycy5saW5rVXJsKSB9LCBfdGhpcy5saW5rQXR0cmlidXRlcyksIGdldEN1c3RvbUF0dHJzKGF0dHJzKSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMaW5rLnByb3RvdHlwZS5hZGRMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHBheWxvYWQsIGxpbmtVcmwgPSBfYS5saW5rVXJsLCBfYiA9IF9hLmxpbmtUZXh0LCBsaW5rVGV4dCA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgdHIgPSBzdGF0ZS50ciwgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgdmFyIGVtcHR5ID0gc2VsZWN0aW9uLmVtcHR5LCBmcm9tID0gc2VsZWN0aW9uLmZyb20sIHRvID0gc2VsZWN0aW9uLnRvO1xuICAgICAgICAgICAgaWYgKGZyb20gJiYgdG8gJiYgbGlua1VybCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IHsgbGlua1VybDogbGlua1VybCB9O1xuICAgICAgICAgICAgICAgIHZhciBtYXJrID0gc2NoZW1hLm1hcmsoJ2xpbmsnLCBhdHRycyk7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5ICYmIGxpbmtUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIGxpbmtUZXh0LCBtYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgdHIucmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBMaW5rLnByb3RvdHlwZS50b2dnbGVMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2dnbGVNYXJrJDEoc3RhdGUuc2NoZW1hLm1hcmtzLmxpbmssIHBheWxvYWQpKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBMaW5rLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZExpbms6IHRoaXMuYWRkTGluaygpLFxuICAgICAgICAgICAgdG9nZ2xlTGluazogdGhpcy50b2dnbGVMaW5rKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTGluaztcbn0oTWFyaykpO1xuXG52YXIgQ29kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnY29kZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ2NvZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7fSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2F0dHJzLnJhd0hUTUwgfHwgJ2NvZGUnLCBnZXRDdXN0b21BdHRycyhhdHRycyldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29kZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7IHJldHVybiB0b2dnbGVNYXJrJDEoc3RhdGUuc2NoZW1hLm1hcmtzLmNvZGUpKHN0YXRlLCBkaXNwYXRjaCk7IH07IH07XG4gICAgfTtcbiAgICBDb2RlLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29kZUNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdTaGlmdC1Nb2QtYyc6IGNvZGVDb21tYW5kLFxuICAgICAgICAgICAgJ1NoaWZ0LU1vZC1DJzogY29kZUNvbW1hbmQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZTtcbn0oTWFyaykpO1xuXG52YXIgQ3VzdG9tQmxvY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ3VzdG9tQmxvY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tQmxvY2soKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUJsb2NrLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2N1c3RvbUJsb2NrJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21CbG9jay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0ZXh0KicsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhdG9tOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVmaW5pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAnZGl2W2RhdGEtY3VzdG9tLWluZm9dJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLWN1c3RvbS1pbmZvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5mbzogaW5mbyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIHsgJ2RhdGEtY3VzdG9tLWluZm8nOiBhdHRycy5pbmZvIHx8IG51bGwgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDdXN0b21CbG9jay5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIChwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQuaW5mbylcbiAgICAgICAgICAgICAgICA/IHNldEJsb2NrVHlwZShzdGF0ZS5zY2hlbWEubm9kZXMuY3VzdG9tQmxvY2ssIHBheWxvYWQpKHN0YXRlLCBkaXNwYXRjaClcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgcmV0dXJuIEN1c3RvbUJsb2NrO1xufShOb2RlJDIpKTtcblxudmFyIEZyb250TWF0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEZyb250TWF0dGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyb250TWF0dGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGcm9udE1hdHRlci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdmcm9udE1hdHRlcic7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJvbnRNYXR0ZXIucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAndGV4dConLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGNvZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVmaW5pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAnZnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdkaXZbZGF0YS1mcm9udC1tYXR0ZXJdJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIHsgJ2RhdGEtZnJvbnQtbWF0dGVyJzogJ3RydWUnIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRnJvbnRNYXR0ZXIucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICAgICAgdmFyICRmcm9tID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICAgICAgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soJ2Rvd24nKSAmJiAkZnJvbS5ub2RlKCkudHlwZS5uYW1lID09PSAnZnJvbnRNYXR0ZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXRDb2RlKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBGcm9udE1hdHRlci5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEVudGVyOiB0aGlzLmNvbW1hbmRzKCkoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBGcm9udE1hdHRlcjtcbn0oTm9kZSQyKSk7XG5cbnZhciBIVE1MQ29tbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShIVE1MQ29tbWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIVE1MQ29tbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTENvbW1lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnaHRtbENvbW1lbnQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxDb21tZW50LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3RleHQqJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBjb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlZmluaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbeyBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJywgdGFnOiAnZGl2W2RhdGEtaHRtbC1jb21tZW50XScgfV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgeyAnZGF0YS1odG1sLWNvbW1lbnQnOiAndHJ1ZScgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBIVE1MQ29tbWVudC5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBzdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgICAgICAgICBpZiAodmlldy5lbmRPZlRleHRibG9jaygnZG93bicpICYmICRmcm9tLm5vZGUoKS50eXBlLm5hbWUgPT09ICdodG1sQ29tbWVudCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpdENvZGUoc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIEhUTUxDb21tZW50LnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRW50ZXI6IHRoaXMuY29tbWFuZHMoKSgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEhUTUxDb21tZW50O1xufShOb2RlJDIpKTtcblxuZnVuY3Rpb24gY3JlYXRlU3BlY3MobGlua0F0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFNwZWNNYW5hZ2VyKFtcbiAgICAgICAgbmV3IERvYygpLFxuICAgICAgICBuZXcgUGFyYWdyYXBoKCksXG4gICAgICAgIG5ldyBUZXh0KCksXG4gICAgICAgIG5ldyBIZWFkaW5nKCksXG4gICAgICAgIG5ldyBDb2RlQmxvY2soKSxcbiAgICAgICAgbmV3IEJ1bGxldExpc3QoKSxcbiAgICAgICAgbmV3IE9yZGVyZWRMaXN0KCksXG4gICAgICAgIG5ldyBMaXN0SXRlbSgpLFxuICAgICAgICBuZXcgQmxvY2tRdW90ZSgpLFxuICAgICAgICBuZXcgVGFibGUoKSxcbiAgICAgICAgbmV3IFRhYmxlSGVhZCgpLFxuICAgICAgICBuZXcgVGFibGVCb2R5KCksXG4gICAgICAgIG5ldyBUYWJsZVJvdygpLFxuICAgICAgICBuZXcgVGFibGVIZWFkQ2VsbCgpLFxuICAgICAgICBuZXcgVGFibGVCb2R5Q2VsbCgpLFxuICAgICAgICBuZXcgSW1hZ2UoKSxcbiAgICAgICAgbmV3IFRoZW1hdGljQnJlYWsoKSxcbiAgICAgICAgbmV3IFN0cm9uZygpLFxuICAgICAgICBuZXcgRW1waCgpLFxuICAgICAgICBuZXcgU3RyaWtlKCksXG4gICAgICAgIG5ldyBMaW5rKGxpbmtBdHRyaWJ1dGVzKSxcbiAgICAgICAgbmV3IENvZGUoKSxcbiAgICAgICAgbmV3IEN1c3RvbUJsb2NrKCksXG4gICAgICAgIG5ldyBGcm9udE1hdHRlcigpLFxuICAgICAgICBuZXcgV2lkZ2V0KCksXG4gICAgICAgIG5ldyBIVE1MQ29tbWVudCgpLFxuICAgIF0pO1xufVxuXG52YXIgQ09OVEVOVFNfQ0xBU1NfTkFNRSA9IGNscygnY29udGVudHMnKTtcbnZhciBXeXNpd3lnRWRpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFd5c2l3eWdFZGl0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3lzaXd5Z0VkaXRvcihldmVudEVtaXR0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZXZlbnRFbWl0dGVyKSB8fCB0aGlzO1xuICAgICAgICB2YXIgdG9ET01BZGFwdG9yID0gb3B0aW9ucy50b0RPTUFkYXB0b3IsIF9hID0gb3B0aW9ucy5odG1sU2NoZW1hTWFwLCBodG1sU2NoZW1hTWFwID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9iID0gb3B0aW9ucy5saW5rQXR0cmlidXRlcywgbGlua0F0dHJpYnV0ZXMgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYiwgX2MgPSBvcHRpb25zLnVzZUNvbW1hbmRTaG9ydGN1dCwgdXNlQ29tbWFuZFNob3J0Y3V0ID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgX2QgPSBvcHRpb25zLnd3UGx1Z2lucywgd3dQbHVnaW5zID0gX2QgPT09IHZvaWQgMCA/IFtdIDogX2QsIF9lID0gb3B0aW9ucy53d05vZGVWaWV3cywgd3dOb2RlVmlld3MgPSBfZSA9PT0gdm9pZCAwID8ge30gOiBfZTtcbiAgICAgICAgX3RoaXMuZWRpdG9yVHlwZSA9ICd3eXNpd3lnJztcbiAgICAgICAgX3RoaXMuZWwuY2xhc3NMaXN0LmFkZCgnd3ctbW9kZScpO1xuICAgICAgICBfdGhpcy50b0RPTUFkYXB0b3IgPSB0b0RPTUFkYXB0b3I7XG4gICAgICAgIF90aGlzLmxpbmtBdHRyaWJ1dGVzID0gbGlua0F0dHJpYnV0ZXM7XG4gICAgICAgIF90aGlzLmV4dHJhUGx1Z2lucyA9IHd3UGx1Z2lucztcbiAgICAgICAgX3RoaXMucGx1Z2luTm9kZVZpZXdzID0gd3dOb2RlVmlld3M7XG4gICAgICAgIF90aGlzLnNwZWNzID0gX3RoaXMuY3JlYXRlU3BlY3MoKTtcbiAgICAgICAgX3RoaXMuc2NoZW1hID0gX3RoaXMuY3JlYXRlU2NoZW1hKGh0bWxTY2hlbWFNYXApO1xuICAgICAgICBfdGhpcy5jb250ZXh0ID0gX3RoaXMuY3JlYXRlQ29udGV4dCgpO1xuICAgICAgICBfdGhpcy5rZXltYXBzID0gX3RoaXMuY3JlYXRlS2V5bWFwcyh1c2VDb21tYW5kU2hvcnRjdXQpO1xuICAgICAgICBfdGhpcy52aWV3ID0gX3RoaXMuY3JlYXRlVmlldygpO1xuICAgICAgICBfdGhpcy5jb21tYW5kcyA9IF90aGlzLmNyZWF0ZUNvbW1hbmRzKCk7XG4gICAgICAgIF90aGlzLnNwZWNzLnNldENvbnRleHQoX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBfdGhpcy5jb250ZXh0KSwgeyB2aWV3OiBfdGhpcy52aWV3IH0pKTtcbiAgICAgICAgX3RoaXMuaW5pdEV2ZW50KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuY3JlYXRlU3BlY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTcGVjcyh0aGlzLmxpbmtBdHRyaWJ1dGVzKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiB0aGlzLmV2ZW50RW1pdHRlcixcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVNjaGVtYSA9IGZ1bmN0aW9uIChodG1sU2NoZW1hTWFwKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICAgICAgICAgIG5vZGVzOiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHRoaXMuc3BlY3Mubm9kZXMpLCBodG1sU2NoZW1hTWFwLm5vZGVzKSxcbiAgICAgICAgICAgIG1hcmtzOiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHRoaXMuc3BlY3MubWFya3MpLCBodG1sU2NoZW1hTWFwLm1hcmtzKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVQbHVnaW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheSQxKFtcbiAgICAgICAgICAgIHRhYmxlU2VsZWN0aW9uKCksXG4gICAgICAgICAgICB0YWJsZUNvbnRleHRNZW51KHRoaXMuZXZlbnRFbWl0dGVyKSxcbiAgICAgICAgICAgIHRhc2soKSxcbiAgICAgICAgICAgIHRvb2xiYXJTdGF0ZUhpZ2hsaWdodCh0aGlzLmV2ZW50RW1pdHRlcilcbiAgICAgICAgXSwgdGhpcy5jcmVhdGVQbHVnaW5Qcm9wcygpKS5jb25jYXQodGhpcy5kZWZhdWx0UGx1Z2lucyk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVQbHVnaW5Ob2RlVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlciwgcGx1Z2luTm9kZVZpZXdzID0gX2EucGx1Z2luTm9kZVZpZXdzO1xuICAgICAgICB2YXIgcGx1Z2luTm9kZVZpZXdNYXAgPSB7fTtcbiAgICAgICAgaWYgKHBsdWdpbk5vZGVWaWV3cykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocGx1Z2luTm9kZVZpZXdzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW5Ob2RlVmlld01hcFtrZXldID0gZnVuY3Rpb24gKG5vZGUsIHZpZXcsIGdldFBvcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luTm9kZVZpZXdzW2tleV0obm9kZSwgdmlldywgZ2V0UG9zLCBldmVudEVtaXR0ZXIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGx1Z2luTm9kZVZpZXdNYXA7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB0b0RPTUFkYXB0b3IgPSBfYS50b0RPTUFkYXB0b3IsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JWaWV3KHRoaXMuZWwsIHtcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmNyZWF0ZVN0YXRlKCksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IENPTlRFTlRTX0NMQVNTX05BTUUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9kZVZpZXdzOiBfX2Fzc2lnbiQxKHsgY3VzdG9tQmxvY2s6IGZ1bmN0aW9uIChub2RlLCB2aWV3LCBnZXRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21CbG9ja1ZpZXcobm9kZSwgdmlldywgZ2V0UG9zLCB0b0RPTUFkYXB0b3IpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGZ1bmN0aW9uIChub2RlLCB2aWV3LCBnZXRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbWFnZVZpZXcobm9kZSwgdmlldywgZ2V0UG9zLCBldmVudEVtaXR0ZXIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29kZUJsb2NrOiBmdW5jdGlvbiAobm9kZSwgdmlldywgZ2V0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29kZUJsb2NrVmlldyhub2RlLCB2aWV3LCBnZXRQb3MsIGV2ZW50RW1pdHRlcik7XG4gICAgICAgICAgICAgICAgfSwgd2lkZ2V0OiB3aWRnZXROb2RlVmlldyB9LCB0aGlzLmNyZWF0ZVBsdWdpbk5vZGVWaWV3cygpKSxcbiAgICAgICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IGZ1bmN0aW9uICh0cikge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IF90aGlzLnZpZXcuc3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGU7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdENoYW5nZUV2ZW50KHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdzZXRGb2N1c2VkTm9kZScsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5ub2RlKDEpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2Zvcm1QYXN0ZWRIVE1MOiBjaGFuZ2VQYXN0ZWRIVE1MLFxuICAgICAgICAgICAgdHJhbnNmb3JtUGFzdGVkOiBmdW5jdGlvbiAoc2xpY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlUGFzdGVkU2xpY2Uoc2xpY2UsIF90aGlzLnNjaGVtYSwgaXNJblRhYmxlTm9kZShfdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZVBhc3RlOiBmdW5jdGlvbiAodmlldywgXywgc2xpY2UpIHsgcmV0dXJuIHBhc3RlVG9UYWJsZSh2aWV3LCBzbGljZSk7IH0sXG4gICAgICAgICAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgna2V5ZG93bicsIF90aGlzLmVkaXRvclR5cGUsIGV2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgcGFzdGU6IGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcGJvYXJkRGF0YSA9IGV2LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IGNsaXBib2FyZERhdGEgPT09IG51bGwgfHwgY2xpcGJvYXJkRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xpcGJvYXJkRGF0YS5pdGVtcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpblJ0Zkl0ZW0gPSB0b0FycmF5XzEoaXRlbXMpLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ua2luZCA9PT0gJ3N0cmluZycgJiYgaXRlbS50eXBlID09PSAndGV4dC9ydGYnOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGNvbnRhaW5zIHJ0ZiwgaXQncyBtb3N0IGxpa2VseSBjb3B5IHBhc3RlIGZyb20gb2ZmaWNlIC0+IG5vIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5SdGZJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlQmxvYiA9IHBhc3RlSW1hZ2VPbmx5KGl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRJbWFnZUJsb2JIb29rKF90aGlzLmV2ZW50RW1pdHRlciwgaW1hZ2VCbG9iLCBldi50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAga2V5dXA6IGZ1bmN0aW9uIChfLCBldikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgna2V5dXAnLCBfdGhpcy5lZGl0b3JUeXBlLCBldik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNjcm9sbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnc2Nyb2xsJywgJ2VkaXRvcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVDb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlY3MuY29tbWFuZHModGhpcy52aWV3LCBnZXRXd0NvbW1hbmRzKCkpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuZ2V0SFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKHRoaXMudmlldy5kb20uaW5uZXJIVE1MKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmdldE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYztcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbiwgZnJvbSA9IF9hLmZyb20sIHRvID0gX2EudG87XG4gICAgICAgIHJldHVybiBbZnJvbSwgdG9dO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuZ2V0U2NoZW1hID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlLnNjaGVtYTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLnJlcGxhY2VTZWxlY3Rpb24gPSBmdW5jdGlvbiAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHNjaGVtYSA9IF9hLnNjaGVtYSwgdHIgPSBfYS50cjtcbiAgICAgICAgdmFyIGxpbmVUZXh0cyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgcGFyYXMgPSBsaW5lVGV4dHMubWFwKGZ1bmN0aW9uIChsaW5lVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhcmFncmFwaChzY2hlbWEsIGNyZWF0ZU5vZGVzV2l0aFdpZGdldChsaW5lVGV4dCwgc2NoZW1hKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2xpY2UgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShwYXJhcyksIDEsIDEpO1xuICAgICAgICB2YXIgbmV3VHIgPSBpc051bWJlcl8xKHN0YXJ0KSAmJiBpc051bWJlcl8xKGVuZClcbiAgICAgICAgICAgID8gdHIucmVwbGFjZVJhbmdlKHN0YXJ0LCBlbmQsIHNsaWNlKVxuICAgICAgICAgICAgOiB0ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKG5ld1RyKTtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuZGVsZXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHRyID0gdGhpcy52aWV3LnN0YXRlLnRyO1xuICAgICAgICB2YXIgbmV3VHIgPSBpc051bWJlcl8xKHN0YXJ0KSAmJiBpc051bWJlcl8xKGVuZCkgPyB0ci5kZWxldGVSYW5nZShzdGFydCwgZW5kKSA6IHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2gobmV3VHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5nZXRTZWxlY3RlZFRleHQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIGRvYyA9IF9hLmRvYywgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgZnJvbSA9IHNlbGVjdGlvbi5mcm9tLCB0byA9IHNlbGVjdGlvbi50bztcbiAgICAgICAgaWYgKGlzTnVtYmVyXzEoc3RhcnQpICYmIGlzTnVtYmVyXzEoZW5kKSkge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXJ0O1xuICAgICAgICAgICAgdG8gPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bywgJ1xcbicpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuc2V0TW9kZWwgPSBmdW5jdGlvbiAobmV3RG9jLCBjdXJzb3JUb0VuZCkge1xuICAgICAgICBpZiAoY3Vyc29yVG9FbmQgPT09IHZvaWQgMCkgeyBjdXJzb3JUb0VuZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgdHIgPSBfYS50ciwgZG9jID0gX2EuZG9jO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIucmVwbGFjZVdpdGgoMCwgZG9jLmNvbnRlbnQuc2l6ZSwgbmV3RG9jKSk7XG4gICAgICAgIGlmIChjdXJzb3JUb0VuZCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9FbmQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBzdGFydDsgfVxuICAgICAgICB2YXIgdHIgPSB0aGlzLnZpZXcuc3RhdGUudHI7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuYWRkV2lkZ2V0ID0gZnVuY3Rpb24gKG5vZGUsIHN0eWxlLCBwb3MpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LCBkaXNwYXRjaCA9IF9hLmRpc3BhdGNoLCBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRNZXRhKCd3aWRnZXQnLCB7IHBvczogcG9zICE9PSBudWxsICYmIHBvcyAhPT0gdm9pZCAwID8gcG9zIDogc3RhdGUuc2VsZWN0aW9uLnRvLCBub2RlOiBub2RlLCBzdHlsZTogc3R5bGUgfSkpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUucmVwbGFjZVdpdGhXaWRnZXQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGV4dCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHRyID0gX2EudHIsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgdmFyIG5vZGVzID0gY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KHRleHQsIHNjaGVtYSk7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5yZXBsYWNlV2l0aChzdGFydCwgZW5kLCBub2RlcykpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuZ2V0UmFuZ2VJbmZvT2ZOb2RlID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIGRvYyA9IF9hLmRvYywgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgJHBvcyA9IHBvcyA/IGRvYy5yZXNvbHZlKHBvcykgOiBzZWxlY3Rpb24uJGZyb207XG4gICAgICAgIHZhciBtYXJrcyA9ICRwb3MubWFya3MoKTtcbiAgICAgICAgdmFyIG5vZGUgPSAkcG9zLm5vZGUoKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gJHBvcy5zdGFydCgpO1xuICAgICAgICB2YXIgZW5kID0gJHBvcy5lbmQoKTtcbiAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGUubmFtZTtcbiAgICAgICAgaWYgKG1hcmtzLmxlbmd0aCB8fCB0eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgdmFyIG1hcmtfMSA9IG1hcmtzW21hcmtzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIG1heWJlSGFzTWFya18xID0gZnVuY3Rpb24gKG5vZGVNYXJrcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlTWFya3MubGVuZ3RoID8gaW5jbHVkZXMobm9kZU1hcmtzLCBtYXJrXzEpIDogdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0eXBlID0gbWFya18xID8gbWFya18xLnR5cGUubmFtZSA6ICd0ZXh0JztcbiAgICAgICAgICAgIG5vZGUuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHZhciBpc1RleHQgPSBjaGlsZC5pc1RleHQsIG5vZGVTaXplID0gY2hpbGQubm9kZVNpemUsIG5vZGVNYXJrcyA9IGNoaWxkLm1hcmtzO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9ICRwb3MucG9zIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPD0gc3RhcnRPZmZzZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICsgbm9kZVNpemUgPj0gc3RhcnRPZmZzZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVIYXNNYXJrXzEobm9kZU1hcmtzKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIG5vZGVTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBbc3RhcnQsIGVuZF0sIHR5cGU6IHR5cGUgfTtcbiAgICB9O1xuICAgIHJldHVybiBXeXNpd3lnRWRpdG9yO1xufShFZGl0b3JCYXNlKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBleGlzdGluZyBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZF8xO1xudmFyIGlzTnVsbCA9IGlzTnVsbF8xO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGV4aXN0aW5nIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBub3QgbnVsbCBhbmQgbm90IHVuZGVmaW5lZCwgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSBwYXJhbSAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBleGlzdHk/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBpc0V4aXN0eSBmcm9tICd0dWktY29kZS1zbmlwcGV0L3R5cGUvaXNFeGlzdHknKTtcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGlzRXhpc3R5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC90eXBlL2lzRXhpc3R5Jyk7XG4gKlxuICogaXNFeGlzdHkoJycpOyAvL3RydWVcbiAqIGlzRXhpc3R5KDApOyAvL3RydWVcbiAqIGlzRXhpc3R5KFtdKTsgLy90cnVlXG4gKiBpc0V4aXN0eSh7fSk7IC8vdHJ1ZVxuICogaXNFeGlzdHkobnVsbCk7IC8vZmFsc2VcbiAqIGlzRXhpc3R5KHVuZGVmaW5lZCk7IC8vZmFsc2VcbiovXG5mdW5jdGlvbiBpc0V4aXN0eSQxKHBhcmFtKSB7XG4gIHJldHVybiAhaXNVbmRlZmluZWQocGFyYW0pICYmICFpc051bGwocGFyYW0pO1xufVxuXG52YXIgaXNFeGlzdHlfMSA9IGlzRXhpc3R5JDE7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB0cnV0aHkgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzRXhpc3R5ID0gaXNFeGlzdHlfMTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB0cnV0aHkgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG5vdCBudWxsIG9yIG5vdCB1bmRlZmluZWQgb3Igbm90IGZhbHNlLCByZXR1cm5zIHRydWUuXG4gKiAoSXQgcmVnYXJkcyAwIGFzIHRydWUpXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyB0cnV0aHk/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNUcnV0aHkkMShvYmopIHtcbiAgcmV0dXJuIGlzRXhpc3R5KG9iaikgJiYgb2JqICE9PSBmYWxzZTtcbn1cblxudmFyIGlzVHJ1dGh5XzEgPSBpc1RydXRoeSQxO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZmFsc3kgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzVHJ1dGh5ID0gaXNUcnV0aHlfMTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBmYWxzeSBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgZmFsc2UsIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIGZhbHN5P1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzRmFsc3kob2JqKSB7XG4gIHJldHVybiAhaXNUcnV0aHkob2JqKTtcbn1cblxudmFyIGlzRmFsc3lfMSA9IGlzRmFsc3k7XG5cbnZhciBldmVudFR5cGVMaXN0ID0gW1xuICAgICdhZnRlclByZXZpZXdSZW5kZXInLFxuICAgICd1cGRhdGVQcmV2aWV3JyxcbiAgICAnY2hhbmdlTW9kZScsXG4gICAgJ25lZWRDaGFuZ2VNb2RlJyxcbiAgICAnY29tbWFuZCcsXG4gICAgJ2NoYW5nZVByZXZpZXdTdHlsZScsXG4gICAgJ2NoYW5nZVByZXZpZXdUYWJQcmV2aWV3JyxcbiAgICAnY2hhbmdlUHJldmlld1RhYldyaXRlJyxcbiAgICAnc2Nyb2xsJyxcbiAgICAnY29udGV4dG1lbnUnLFxuICAgICdzaG93JyxcbiAgICAnaGlkZScsXG4gICAgJ2NoYW5nZUxhbmd1YWdlJyxcbiAgICAnY2hhbmdlVG9vbGJhclN0YXRlJyxcbiAgICAndG9nZ2xlU2Nyb2xsU3luYycsXG4gICAgJ21peGluVGFibGVPZmZzZXRNYXBQcm90b3R5cGUnLFxuICAgICdzZXRGb2N1c2VkTm9kZScsXG4gICAgJ3JlbW92ZVBvcHVwV2lkZ2V0JyxcbiAgICAncXVlcnknLFxuICAgIC8vIHByb3ZpZGUgZXZlbnQgZm9yIHVzZXJcbiAgICAnb3BlblBvcHVwJyxcbiAgICAnY2xvc2VQb3B1cCcsXG4gICAgJ2FkZEltYWdlQmxvYkhvb2snLFxuICAgICdiZWZvcmVQcmV2aWV3UmVuZGVyJyxcbiAgICAnYmVmb3JlQ29udmVydFd5c2l3eWdUb01hcmtkb3duJyxcbiAgICAnbG9hZCcsXG4gICAgJ2xvYWRVSScsXG4gICAgJ2NoYW5nZScsXG4gICAgJ2NhcmV0Q2hhbmdlJyxcbiAgICAnZGVzdHJveScsXG4gICAgJ2ZvY3VzJyxcbiAgICAnYmx1cicsXG4gICAgJ2tleWRvd24nLFxuICAgICdrZXl1cCcsXG5dO1xuLyoqXG4gKiBDbGFzcyBFdmVudEVtaXR0ZXJcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEV2ZW50RW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IE1hcCQxKCk7XG4gICAgICAgIHRoaXMuZXZlbnRUeXBlcyA9IGV2ZW50VHlwZUxpc3QucmVkdWNlKGZ1bmN0aW9uICh0eXBlcywgdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgdHlwZXMpLCB7IHR5cGU6IHR5cGUgfSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdGhpcy5ob2xkID0gZmFsc2U7XG4gICAgICAgIGV2ZW50VHlwZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBfdGhpcy5hZGRFdmVudFR5cGUoZXZlbnRUeXBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RlbiBldmVudCBhbmQgYmluZCBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciB0eXBlSW5mbyA9IHRoaXMuZ2V0VHlwZUluZm8odHlwZSk7XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5ldmVudHMuZ2V0KHR5cGVJbmZvLnR5cGUpIHx8IFtdO1xuICAgICAgICBpZiAoIXRoaXMuaGFzRXZlbnRUeXBlKHR5cGVJbmZvLnR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBldmVudCB0eXBlIFwiICsgdHlwZUluZm8udHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVJbmZvLm5hbWVzcGFjZSkge1xuICAgICAgICAgICAgaGFuZGxlci5uYW1lc3BhY2UgPSB0eXBlSW5mby5uYW1lc3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmV2ZW50cy5zZXQodHlwZUluZm8udHlwZSwgZXZlbnRIYW5kbGVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0IGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lIHRvIGVtaXRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGVJbmZvID0gdGhpcy5nZXRUeXBlSW5mbyh0eXBlKTtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmV2ZW50cy5nZXQodHlwZUluZm8udHlwZSk7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlmICghdGhpcy5ob2xkICYmIGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZF8xKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0IGdpdmVuIGV2ZW50IGFuZCByZXR1cm4gcmVzdWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lIHRvIGVtaXRcbiAgICAgKiBAcGFyYW0ge2FueX0gc291cmNlIFNvdXJjZSB0byBjaGFuZ2VcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdFJlZHVjZSA9IGZ1bmN0aW9uICh0eXBlLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmV2ZW50cy5nZXQodHlwZSk7XG4gICAgICAgIGlmICghdGhpcy5ob2xkICYmIGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheSQxKFtzb3VyY2VdLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZhbHN5XzEocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBldmVudCB0eXBlIGFuZCBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7e3R5cGU6IHN0cmluZywgbmFtZXNwYWNlOiBzdHJpbmd9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRUeXBlSW5mbyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBzcGxpdGVkID0gdHlwZS5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogc3BsaXRlZFswXSxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogc3BsaXRlZFsxXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgZXZlbnQgdHlwZSBleGlzdHMgb3Igbm90XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmhhc0V2ZW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiAhaXNVbmRlZmluZWRfMSh0aGlzLmV2ZW50VHlwZXNbdGhpcy5nZXRUeXBlSW5mbyh0eXBlKS50eXBlXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgZXZlbnQgdHlwZSB3aGVuIGdpdmVuIGV2ZW50IG5vdCBleGlzdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0V2ZW50VHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgYWxyZWFkeSBoYXZlIGV2ZW50IHR5cGUgXCIgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50VHlwZXNbdHlwZV0gPSB0eXBlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGhhbmRsZXIgZnJvbSBnaXZlbiBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRUeXBlSW5mbyhldmVudFR5cGUpLCB0eXBlID0gX2EudHlwZSwgbmFtZXNwYWNlID0gX2EubmFtZXNwYWNlO1xuICAgICAgICBpZiAodHlwZSAmJiBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhIYW5kbGVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgJiYgIW5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0eXBlICYmIG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoXywgZXZ0VHlwZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhUeXBlSW5mbyhldnRUeXBlLCBuYW1lc3BhY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSAmJiBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aFR5cGVJbmZvKHR5cGUsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBldmVudCBoYW5kbGVyIHdpdGggZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aEhhbmRsZXIgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVySW5kZXggPSBldmVudEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpID49IDApIHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXJzLnNwbGljZShoYW5kbGVySW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnQgaGFuZGxlciB3aXRoIGV2ZW50IHR5cGUgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIEV2ZW50IG5hbWVzcGFjZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudEhhbmRsZXJXaXRoVHlwZUluZm8gPSBmdW5jdGlvbiAodHlwZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBoYW5kbGVyc1RvU3Vydml2ZSA9IFtdO1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRIYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNUb1N1cnZpdmUucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMuc2V0KHR5cGUsIGhhbmRsZXJzVG9TdXJ2aXZlKTtcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHM7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmhvbGRFdmVudEludm9rZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLmhvbGQgPSB0cnVlO1xuICAgICAgICBmbigpO1xuICAgICAgICB0aGlzLmhvbGQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCkpO1xuXG52YXIgQ29tbWFuZE1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tbWFuZE1hbmFnZXIoZXZlbnRFbWl0dGVyLCBtZENvbW1hbmRzLCB3d0NvbW1hbmRzLCBnZXRFZGl0b3JUeXBlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLm1kQ29tbWFuZHMgPSBtZENvbW1hbmRzO1xuICAgICAgICB0aGlzLnd3Q29tbWFuZHMgPSB3d0NvbW1hbmRzO1xuICAgICAgICB0aGlzLmdldEVkaXRvclR5cGUgPSBnZXRFZGl0b3JUeXBlO1xuICAgICAgICB0aGlzLmluaXRFdmVudCgpO1xuICAgIH1cbiAgICBDb21tYW5kTWFuYWdlci5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NvbW1hbmQnLCBmdW5jdGlvbiAoY29tbWFuZCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgX3RoaXMuZXhlYyhjb21tYW5kLCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21tYW5kTWFuYWdlci5wcm90b3R5cGUuYWRkQ29tbWFuZCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBjb21tYW5kKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnbWFya2Rvd24nKSB7XG4gICAgICAgICAgICB0aGlzLm1kQ29tbWFuZHNbbmFtZV0gPSBjb21tYW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53d0NvbW1hbmRzW25hbWVdID0gY29tbWFuZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZUNvbW1hbmQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ21hcmtkb3duJykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWRDb21tYW5kc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnd3Q29tbWFuZHNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKG5hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmdldEVkaXRvclR5cGUoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtYXJrZG93bicpIHtcbiAgICAgICAgICAgIHRoaXMubWRDb21tYW5kc1tuYW1lXShwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3dDb21tYW5kc1tuYW1lXShwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbW1hbmRNYW5hZ2VyO1xufSgpKTtcblxuZnVuY3Rpb24gZ2V0VGV4dFdpdGhvdXRUcmFpbGluZ05ld2xpbmUodGV4dCkge1xuICAgIHJldHVybiB0ZXh0W3RleHQubGVuZ3RoIC0gMV0gPT09ICdcXG4nID8gdGV4dC5zbGljZSgwLCB0ZXh0Lmxlbmd0aCAtIDEpIDogdGV4dDtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tSFRNTElubGluZU5vZGUoX2EsIG5vZGUpIHtcbiAgICB2YXIgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgIHZhciBodG1sID0gbm9kZS5saXRlcmFsO1xuICAgIHZhciBtYXRjaGVkID0gaHRtbC5tYXRjaChyZUhUTUxUYWcpO1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHZhciBvcGVuVGFnTmFtZSA9IG1hdGNoZWRbMV0sIGNsb3NlVGFnTmFtZSA9IG1hdGNoZWRbM107XG4gICAgICAgIHZhciB0eXBlTmFtZSA9IChvcGVuVGFnTmFtZSB8fCBjbG9zZVRhZ05hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdodG1sSW5saW5lJyAmJiAhIShzY2hlbWEubWFya3NbdHlwZU5hbWVdIHx8IHNjaGVtYS5ub2Rlc1t0eXBlTmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lubGluZU5vZGUoX2EpIHtcbiAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgcmV0dXJuIGluY2x1ZGVzKFsndGV4dCcsICdzdHJvbmcnLCAnZW1waCcsICdzdHJpa2UnLCAnaW1hZ2UnLCAnbGluaycsICdjb2RlJ10sIHR5cGUpO1xufVxuZnVuY3Rpb24gaXNTb2Z0YnJlYWsobWROb2RlKSB7XG4gICAgcmV0dXJuIChtZE5vZGUgPT09IG51bGwgfHwgbWROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZE5vZGUudHlwZSkgPT09ICdzb2Z0YnJlYWsnO1xufVxuZnVuY3Rpb24gaXNMaXN0Tm9kZShfYSkge1xuICAgIHZhciB0eXBlID0gX2EudHlwZSwgbGl0ZXJhbCA9IF9hLmxpdGVyYWw7XG4gICAgdmFyIG1hdGNoZWQgPSB0eXBlID09PSAnaHRtbElubGluZScgJiYgbGl0ZXJhbC5tYXRjaChyZUhUTUxUYWcpO1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHZhciBvcGVuVGFnTmFtZSA9IG1hdGNoZWRbMV0sIGNsb3NlVGFnTmFtZSA9IG1hdGNoZWRbM107XG4gICAgICAgIHZhciB0YWdOYW1lID0gb3BlblRhZ05hbWUgfHwgY2xvc2VUYWdOYW1lO1xuICAgICAgICBpZiAodGFnTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKFsndWwnLCAnb2wnLCAnbGknXSwgdGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRMaXN0SXRlbUF0dHJzKF9hKSB7XG4gICAgdmFyIGxpdGVyYWwgPSBfYS5saXRlcmFsO1xuICAgIHZhciB0YXNrID0gL2RhdGEtdGFzay8udGVzdChsaXRlcmFsKTtcbiAgICB2YXIgY2hlY2tlZCA9IC9kYXRhLXRhc2stY2hlY2tlZC8udGVzdChsaXRlcmFsKTtcbiAgICByZXR1cm4geyB0YXNrOiB0YXNrLCBjaGVja2VkOiBjaGVja2VkIH07XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVkQXR0cmlidXRlVmFsdWUocmF3SFRNTCkge1xuICAgIHZhciBhdHRyTmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhdHRyTmFtZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcHBlci5pbm5lckhUTUwgPSBzYW5pdGl6ZUhUTUwocmF3SFRNTCk7XG4gICAgdmFyIGVsID0gd3JhcHBlci5maXJzdENoaWxkO1xuICAgIHJldHVybiBhdHRyTmFtZXMubWFwKGZ1bmN0aW9uIChhdHRyTmFtZSkgeyByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSB8fCAnJzsgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb252ZXJ0b3JzKGNvbnZlcnRvcnMpIHtcbiAgICB2YXIgY29udmVydG9yTWFwID0ge307XG4gICAgT2JqZWN0LmtleXMoY29udmVydG9ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0YWdOYW1lcyA9IGtleS5zcGxpdCgnLCAnKTtcbiAgICAgICAgdGFnTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb252ZXJ0b3JNYXBbbmFtZV0gPSBjb252ZXJ0b3JzW2tleV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb252ZXJ0b3JNYXA7XG59XG52YXIgY29udmVydG9ycyA9IHtcbiAgICAnYiwgc3Ryb25nJzogZnVuY3Rpb24gKHN0YXRlLCBfLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICB2YXIgc3Ryb25nID0gc3RhdGUuc2NoZW1hLm1hcmtzLnN0cm9uZztcbiAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhzdHJvbmcuY3JlYXRlKHsgcmF3SFRNTDogb3BlblRhZ05hbWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKHN0cm9uZyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgICdpLCBlbSc6IGZ1bmN0aW9uIChzdGF0ZSwgXywgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIGVtcGggPSBzdGF0ZS5zY2hlbWEubWFya3MuZW1waDtcbiAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhlbXBoLmNyZWF0ZSh7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhlbXBoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgJ3MsIGRlbCc6IGZ1bmN0aW9uIChzdGF0ZSwgXywgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIHN0cmlrZSA9IHN0YXRlLnNjaGVtYS5tYXJrcy5zdHJpa2U7XG4gICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsoc3RyaWtlLmNyZWF0ZSh7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhzdHJpa2UpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAoc3RhdGUsIF8sIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RhdGUuc2NoZW1hLm1hcmtzLmNvZGU7XG4gICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsoY29kZS5jcmVhdGUoeyByYXdIVE1MOiBvcGVuVGFnTmFtZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsoY29kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGE6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIHRhZyA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgdmFyIGxpbmsgPSBzdGF0ZS5zY2hlbWEubWFya3MubGluaztcbiAgICAgICAgaWYgKG9wZW5UYWdOYW1lKSB7XG4gICAgICAgICAgICB2YXIgbGlua1VybCA9IGdldE1hdGNoZWRBdHRyaWJ1dGVWYWx1ZSh0YWcsICdocmVmJylbMF07XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhsaW5rLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgbGlua1VybDogbGlua1VybCxcbiAgICAgICAgICAgICAgICByYXdIVE1MOiBvcGVuVGFnTmFtZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhsaW5rKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW1nOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHZhciB0YWcgPSBub2RlLmxpdGVyYWw7XG4gICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0TWF0Y2hlZEF0dHJpYnV0ZVZhbHVlKHRhZywgJ3NyYycsICdhbHQnKSwgaW1hZ2VVcmwgPSBfYVswXSwgYWx0VGV4dCA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIGltYWdlID0gc3RhdGUuc2NoZW1hLm5vZGVzLmltYWdlO1xuICAgICAgICAgICAgc3RhdGUuYWRkTm9kZShpbWFnZSwgX19hc3NpZ24kMSh7IHJhd0hUTUw6IG9wZW5UYWdOYW1lLCBpbWFnZVVybDogaW1hZ2VVcmwgfSwgKGFsdFRleHQgJiYgeyBhbHRUZXh0OiBhbHRUZXh0IH0pKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhyOiBmdW5jdGlvbiAoc3RhdGUsIF8sIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHN0YXRlLmFkZE5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnRoZW1hdGljQnJlYWssIHsgcmF3SFRNTDogb3BlblRhZ05hbWUgfSk7XG4gICAgfSxcbiAgICBicjogZnVuY3Rpb24gKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIHZhciBwYXJhZ3JhcGggPSBzdGF0ZS5zY2hlbWEubm9kZXMucGFyYWdyYXBoO1xuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQsIHByZXYgPSBub2RlLnByZXYsIG5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgIGlmICgocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LnR5cGUpID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgLy8gc2hvdWxkIG9wZW4gYSBwYXJhZ3JhcGggbm9kZSB3aGVuIGxpbmUgdGV4dCBoYXMgb25seSA8YnI+IHRhZ1xuICAgICAgICAgICAgLy8gZXgpIGZpcnN0IGxpbmVcXG5cXG48YnI+XFxuZm91cnRoIGxpbmVcbiAgICAgICAgICAgIGlmIChpc1NvZnRicmVhayhwcmV2KSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzaG91bGQgY2xvc2UgYSBwYXJhZ3JhcGggbm9kZSB3aGVuIGxpbmUgdGV4dCBoYXMgb25seSA8YnI+IHRhZ1xuICAgICAgICAgICAgLy8gZXgpIGZpcnN0IGxpbmVcXG5cXG48YnI+XFxuZm91cnRoIGxpbmVcbiAgICAgICAgICAgIGlmIChpc1NvZnRicmVhayhuZXh0KSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBjbG9zZSBhIHBhcmFncmFwaCBub2RlIGFuZCBvcGVuIGEgcGFyYWdyYXBoIG5vZGUgdG8gc2VwYXJhdGUgYmV0d2VlbiBibG9ja3NcbiAgICAgICAgICAgICAgICAvLyB3aGVuIDxicj4gdGFnIGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHBhcmFncmFwaFxuICAgICAgICAgICAgICAgIC8vIGV4KSBmaXJzdCA8YnI+bGluZVxcbnRoaXJkIGxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQudHlwZSkgPT09ICd0YWJsZUNlbGwnKSB7XG4gICAgICAgICAgICBpZiAocHJldiAmJiAoaXNJbmxpbmVOb2RlKHByZXYpIHx8IGlzQ3VzdG9tSFRNTElubGluZU5vZGUoc3RhdGUsIHByZXYpKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgKGlzSW5saW5lTm9kZShuZXh0KSB8fCBpc0N1c3RvbUhUTUxJbmxpbmVOb2RlKHN0YXRlLCBuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmU6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gbm9kZS5saXRlcmFsO1xuICAgICAgICB2YXIgbGl0ZXJhbCA9IChfYiA9IChfYSA9IGNvbnRhaW5lci5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRleHRDb250ZW50O1xuICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMuY29kZUJsb2NrLCB7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0pO1xuICAgICAgICBzdGF0ZS5hZGRUZXh0KGdldFRleHRXaXRob3V0VHJhaWxpbmdOZXdsaW5lKGxpdGVyYWwpKTtcbiAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgfSxcbiAgICAndWwsIG9sJzogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICAvLyBpbiB0aGUgdGFibGUgY2VsbCwgJzx1bD4nLCAnPG9sPicgaXMgcGFyc2VkIGFzICdodG1sSW5saW5lJyBub2RlXG4gICAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSAndGFibGVDZWxsJykge1xuICAgICAgICAgICAgdmFyIF9hID0gc3RhdGUuc2NoZW1hLm5vZGVzLCBidWxsZXRMaXN0ID0gX2EuYnVsbGV0TGlzdCwgb3JkZXJlZExpc3QgPSBfYS5vcmRlcmVkTGlzdCwgcGFyYWdyYXBoID0gX2EucGFyYWdyYXBoO1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBvcGVuVGFnTmFtZSA9PT0gJ3VsJyA/IGJ1bGxldExpc3QgOiBvcmRlcmVkTGlzdDtcbiAgICAgICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnByZXYgJiYgIWlzTGlzdE5vZGUobm9kZS5wcmV2KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUobGlzdCwgeyByYXdIVE1MOiBvcGVuVGFnTmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5leHQgJiYgIWlzTGlzdE5vZGUobm9kZS5uZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbGk6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBpbiB0aGUgdGFibGUgY2VsbCwgJzxsaT4nIGlzIHBhcnNlZCBhcyAnaHRtbElubGluZScgbm9kZVxuICAgICAgICBpZiAoKChfYSA9IG5vZGUucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09ICd0YWJsZUNlbGwnKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBzdGF0ZS5zY2hlbWEubm9kZXMsIGxpc3RJdGVtID0gX2IubGlzdEl0ZW0sIHBhcmFncmFwaCA9IF9iLnBhcmFncmFwaDtcbiAgICAgICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IGdldExpc3RJdGVtQXR0cnMobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucHJldiAmJiAhaXNMaXN0Tm9kZShub2RlLnByZXYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShsaXN0SXRlbSwgX19hc3NpZ24kMSh7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0sIGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmV4dCAmJiAhaXNMaXN0Tm9kZShub2RlLm5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucHJldiAmJiAhaXNMaXN0Tm9kZShub2RlLnByZXYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xudmFyIGh0bWxUb1d3Q29udmVydG9ycyA9IGNyZWF0ZUNvbnZlcnRvcnMoY29udmVydG9ycyk7XG5cbmZ1bmN0aW9uIGlzQlJUYWcobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdodG1sSW5saW5lJyAmJiByZUJSLnRlc3Qobm9kZS5saXRlcmFsKTtcbn1cbmZ1bmN0aW9uIGFkZFJhd0hUTUxBdHRyaWJ1dGVUb0RPTShwYXJlbnQpIHtcbiAgICB0b0FycmF5XzEocGFyZW50LmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChpc0VsZW1Ob2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgdmFyIG9wZW5UYWdOYW1lID0gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcsIG9wZW5UYWdOYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgYWRkUmF3SFRNTEF0dHJpYnV0ZVRvRE9NKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxudmFyIHRvV3dDb252ZXJ0b3JzID0ge1xuICAgIHRleHQ6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgICBzdGF0ZS5hZGRUZXh0KG5vZGUubGl0ZXJhbCB8fCAnJyk7XG4gICAgfSxcbiAgICBwYXJhZ3JhcGg6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIHBhcmFncmFwaCA9IHN0YXRlLnNjaGVtYS5ub2Rlcy5wYXJhZ3JhcGg7XG4gICAgICAgICAgICAvLyBUaGUgYFxcblxcbmAgZW50ZXJlZCBpbiBtYXJrZG93biBzZXBhcmF0ZXMgdGhlIHBhcmFncmFwaC5cbiAgICAgICAgICAgIC8vIFdoZW4gY2hhbmdpbmcgdG8gd3lzaXd5ZywgYSBuZXdsaW5lIGlzIGFkZGVkIGJldHdlZW4gdGhlIHR3byBwYXJhZ3JhcGhzLlxuICAgICAgICAgICAgaWYgKCgoX2IgPSBub2RlLnByZXYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50eXBlKSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgsIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCwgY3VzdG9tQXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhlYWRpbmc6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IG5vZGUsIGxldmVsID0gX2IubGV2ZWwsIGhlYWRpbmdUeXBlID0gX2IuaGVhZGluZ1R5cGU7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMuaGVhZGluZywgX19hc3NpZ24kMSh7IGxldmVsOiBsZXZlbCwgaGVhZGluZ1R5cGU6IGhlYWRpbmdUeXBlIH0sIGN1c3RvbUF0dHJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29kZUJsb2NrOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBjb2RlQmxvY2sgPSBzdGF0ZS5zY2hlbWEubm9kZXMuY29kZUJsb2NrO1xuICAgICAgICB2YXIgX2EgPSBub2RlLCBpbmZvID0gX2EuaW5mbywgbGl0ZXJhbCA9IF9hLmxpdGVyYWw7XG4gICAgICAgIHN0YXRlLm9wZW5Ob2RlKGNvZGVCbG9jaywgX19hc3NpZ24kMSh7IGxhbmd1YWdlOiBpbmZvIH0sIGN1c3RvbUF0dHJzKSk7XG4gICAgICAgIHN0YXRlLmFkZFRleHQoZ2V0VGV4dFdpdGhvdXRUcmFpbGluZ05ld2xpbmUobGl0ZXJhbCB8fCAnJykpO1xuICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICB9LFxuICAgIGxpc3Q6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IHN0YXRlLnNjaGVtYS5ub2RlcywgYnVsbGV0TGlzdCA9IF9iLmJ1bGxldExpc3QsIG9yZGVyZWRMaXN0ID0gX2Iub3JkZXJlZExpc3Q7XG4gICAgICAgICAgICB2YXIgX2MgPSBub2RlLmxpc3REYXRhLCB0eXBlID0gX2MudHlwZSwgc3RhcnQgPSBfYy5zdGFydDtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnYnVsbGV0Jykge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKGJ1bGxldExpc3QsIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKG9yZGVyZWRMaXN0LCBfX2Fzc2lnbiQxKHsgb3JkZXI6IHN0YXJ0IH0sIGN1c3RvbUF0dHJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaXRlbTogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBsaXN0SXRlbSA9IHN0YXRlLnNjaGVtYS5ub2Rlcy5saXN0SXRlbTtcbiAgICAgICAgdmFyIF9iID0gbm9kZS5saXN0RGF0YSwgdGFzayA9IF9iLnRhc2ssIGNoZWNrZWQgPSBfYi5jaGVja2VkO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCAodGFzayAmJiB7IHRhc2s6IHRhc2sgfSkpLCAoY2hlY2tlZCAmJiB7IGNoZWNrZWQ6IGNoZWNrZWQgfSkpLCBjdXN0b21BdHRycyk7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShsaXN0SXRlbSwgYXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJsb2NrUXVvdGU6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy5ibG9ja1F1b3RlLCBjdXN0b21BdHRycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW1hZ2U6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBza2lwQ2hpbGRyZW4gPSBfYS5za2lwQ2hpbGRyZW47XG4gICAgICAgIHZhciBpbWFnZSA9IHN0YXRlLnNjaGVtYS5ub2Rlcy5pbWFnZTtcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgZGVzdGluYXRpb24gPSBfYi5kZXN0aW5hdGlvbiwgZmlyc3RDaGlsZCA9IF9iLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChlbnRlcmluZyAmJiBza2lwQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHNraXBDaGlsZHJlbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmFkZE5vZGUoaW1hZ2UsIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7IGltYWdlVXJsOiBkZXN0aW5hdGlvbiB9LCAoZmlyc3RDaGlsZCAmJiB7IGFsdFRleHQ6IGZpcnN0Q2hpbGQubGl0ZXJhbCB9KSksIGN1c3RvbUF0dHJzKSk7XG4gICAgfSxcbiAgICB0aGVtYXRpY0JyZWFrOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF8sIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHN0YXRlLmFkZE5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnRoZW1hdGljQnJlYWssIGN1c3RvbUF0dHJzKTtcbiAgICB9LFxuICAgIHN0cm9uZzogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBzdHJvbmcgPSBzdGF0ZS5zY2hlbWEubWFya3Muc3Ryb25nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5NYXJrKHN0cm9uZy5jcmVhdGUoY3VzdG9tQXR0cnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhzdHJvbmcpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlbXBoOiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIGVtcGggPSBzdGF0ZS5zY2hlbWEubWFya3MuZW1waDtcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhlbXBoLmNyZWF0ZShjdXN0b21BdHRycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKGVtcGgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIGxpbmsgPSBzdGF0ZS5zY2hlbWEubWFya3MubGluaztcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgZGVzdGluYXRpb24gPSBfYi5kZXN0aW5hdGlvbiwgdGl0bGUgPSBfYi50aXRsZTtcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBfX2Fzc2lnbiQxKHsgbGlua1VybDogZGVzdGluYXRpb24sIHRpdGxlOiB0aXRsZSB9LCBjdXN0b21BdHRycyk7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhsaW5rLmNyZWF0ZShhdHRycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKGxpbmspO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzb2Z0YnJlYWs6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gbm9kZS5wcmV2LCBuZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgIWlzQlJUYWcocHJldikpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmICFpc0JSVGFnKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnBhcmFncmFwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIEdGTSBzcGVjaWZpY2F0aW9ucyBub2RlXG4gICAgdGFibGU6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy50YWJsZSwgY3VzdG9tQXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlSGVhZDogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnRhYmxlSGVhZCwgY3VzdG9tQXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlQm9keTogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnRhYmxlQm9keSwgY3VzdG9tQXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlUm93OiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMudGFibGVSb3csIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0YWJsZUNlbGw6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmICghbm9kZS5pZ25vcmVkKSB7XG4gICAgICAgICAgICB2YXIgaGFzUGFyYU5vZGUgPSBmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZSAmJiAoaXNJbmxpbmVOb2RlKGNoaWxkTm9kZSkgfHwgaXNDdXN0b21IVE1MSW5saW5lTm9kZShzdGF0ZSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gc3RhdGUuc2NoZW1hLm5vZGVzLCB0YWJsZUhlYWRDZWxsID0gX2IudGFibGVIZWFkQ2VsbCwgdGFibGVCb2R5Q2VsbCA9IF9iLnRhYmxlQm9keUNlbGwsIHBhcmFncmFwaCA9IF9iLnBhcmFncmFwaDtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGVQYXJ0ID0gbm9kZS5wYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGFibGVQYXJ0LnR5cGUgPT09ICd0YWJsZUhlYWQnID8gdGFibGVIZWFkQ2VsbCA6IHRhYmxlQm9keUNlbGw7XG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gdGFibGVQYXJ0LnBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgYWxpZ24gPSAodGFibGUuY29sdW1uc1tub2RlLnN0YXJ0SWR4XSB8fCB7fSkuYWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX19hc3NpZ24kMSh7fSwgbm9kZS5hdHRycyk7XG4gICAgICAgICAgICAgICAgaWYgKGFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLmFsaWduID0gYWxpZ247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKGNlbGwsIGF0dHJzKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUGFyYU5vZGUobm9kZS5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYXNQYXJhTm9kZShub2RlLmxhc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzdHJpa2U6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgc3RyaWtlID0gc3RhdGUuc2NoZW1hLm1hcmtzLnN0cmlrZTtcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhzdHJpa2UuY3JlYXRlKGN1c3RvbUF0dHJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsoc3RyaWtlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29kZTogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgY29kZSA9IHN0YXRlLnNjaGVtYS5tYXJrcy5jb2RlO1xuICAgICAgICBzdGF0ZS5vcGVuTWFyayhjb2RlLmNyZWF0ZShjdXN0b21BdHRycykpO1xuICAgICAgICBzdGF0ZS5hZGRUZXh0KGdldFRleHRXaXRob3V0VHJhaWxpbmdOZXdsaW5lKG5vZGUubGl0ZXJhbCB8fCAnJykpO1xuICAgICAgICBzdGF0ZS5jbG9zZU1hcmsoY29kZSk7XG4gICAgfSxcbiAgICBjdXN0b21CbG9jazogZnVuY3Rpb24gKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIHZhciBfYSA9IHN0YXRlLnNjaGVtYS5ub2RlcywgY3VzdG9tQmxvY2sgPSBfYS5jdXN0b21CbG9jaywgcGFyYWdyYXBoID0gX2EucGFyYWdyYXBoO1xuICAgICAgICB2YXIgX2IgPSBub2RlLCBpbmZvID0gX2IuaW5mbywgbGl0ZXJhbCA9IF9iLmxpdGVyYWw7XG4gICAgICAgIHN0YXRlLm9wZW5Ob2RlKGN1c3RvbUJsb2NrLCB7IGluZm86IGluZm8gfSk7XG4gICAgICAgIHN0YXRlLmFkZFRleHQoZ2V0VGV4dFdpdGhvdXRUcmFpbGluZ05ld2xpbmUobGl0ZXJhbCB8fCAnJykpO1xuICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgLy8gYWRkIGVtcHR5IGxpbmUgdG8gZWRpdCB0aGUgY29udGVudCBpbiBuZXh0IGxpbmVcbiAgICAgICAgaWYgKCFub2RlLm5leHQpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHBhcmFncmFwaCk7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZnJvbnRNYXR0ZXI6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMuZnJvbnRNYXR0ZXIpO1xuICAgICAgICBzdGF0ZS5hZGRUZXh0KG5vZGUubGl0ZXJhbCk7XG4gICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgIH0sXG4gICAgaHRtbElubGluZTogZnVuY3Rpb24gKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIHZhciBodG1sID0gbm9kZS5saXRlcmFsO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGh0bWwubWF0Y2gocmVIVE1MVGFnKTtcbiAgICAgICAgdmFyIG9wZW5UYWdOYW1lID0gbWF0Y2hlZFsxXSwgY2xvc2VUYWdOYW1lID0gbWF0Y2hlZFszXTtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gKG9wZW5UYWdOYW1lIHx8IGNsb3NlVGFnTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIG1hcmtUeXBlID0gc3RhdGUuc2NoZW1hLm1hcmtzW3R5cGVOYW1lXTtcbiAgICAgICAgdmFyIHNhbml0aXplZEhUTUwgPSBzYW5pdGl6ZUhUTUwoaHRtbCk7XG4gICAgICAgIC8vIGZvciB1c2VyIGRlZmluZWQgaHRtbCBzY2hlbWFcbiAgICAgICAgaWYgKG1hcmtUeXBlID09PSBudWxsIHx8IG1hcmtUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrVHlwZS5zcGVjLmF0dHJzLmh0bWxJbmxpbmUpIHtcbiAgICAgICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBodG1sQXR0cnMgPSBnZXRIVE1MQXR0cnNCeUhUTUxTdHJpbmcoc2FuaXRpemVkSFRNTCk7XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsobWFya1R5cGUuY3JlYXRlKHsgaHRtbEF0dHJzOiBodG1sQXR0cnMgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKG1hcmtUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBodG1sVG9Xd0NvbnZlcnRvciA9IGh0bWxUb1d3Q29udmVydG9yc1t0eXBlTmFtZV07XG4gICAgICAgICAgICBpZiAoaHRtbFRvV3dDb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICBodG1sVG9Xd0NvbnZlcnRvcihzdGF0ZSwgbm9kZSwgb3BlblRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBodG1sQmxvY2s6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgICB2YXIgaHRtbCA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgaXNIVE1MQ29tbWVudCA9IHJlSFRNTENvbW1lbnQudGVzdChodG1sKTtcbiAgICAgICAgaWYgKGlzSFRNTENvbW1lbnQpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy5odG1sQ29tbWVudCk7XG4gICAgICAgICAgICBzdGF0ZS5hZGRUZXh0KG5vZGUubGl0ZXJhbCk7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gaHRtbC5tYXRjaChyZUhUTUxUYWcpO1xuICAgICAgICAgICAgdmFyIG9wZW5UYWdOYW1lID0gbWF0Y2hlZFsxXSwgY2xvc2VUYWdOYW1lID0gbWF0Y2hlZFszXTtcbiAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IChvcGVuVGFnTmFtZSB8fCBjbG9zZVRhZ05hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBzdGF0ZS5zY2hlbWEubm9kZXNbdHlwZU5hbWVdO1xuICAgICAgICAgICAgdmFyIHNhbml0aXplZEhUTUwgPSBzYW5pdGl6ZUhUTUwoaHRtbCk7XG4gICAgICAgICAgICAvLyBmb3IgdXNlciBkZWZpbmVkIGh0bWwgc2NoZW1hXG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IG51bGwgfHwgbm9kZVR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVUeXBlLnNwZWMuYXR0cnMuaHRtbEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWxBdHRycyA9IGdldEhUTUxBdHRyc0J5SFRNTFN0cmluZyhzYW5pdGl6ZWRIVE1MKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5IVE1MID0gZ2V0Q2hpbGRyZW5IVE1MKG5vZGUsIHR5cGVOYW1lKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hZGROb2RlKG5vZGVUeXBlLCB7IGh0bWxBdHRyczogaHRtbEF0dHJzLCBjaGlsZHJlbkhUTUw6IGNoaWxkcmVuSFRNTCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBzYW5pdGl6ZWRIVE1MO1xuICAgICAgICAgICAgICAgIGFkZFJhd0hUTUxBdHRyaWJ1dGVUb0RPTShjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmNvbnZlcnRCeURPTVBhcnNlcihjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjdXN0b21JbmxpbmU6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmcsIHNraXBDaGlsZHJlbiA9IF9hLnNraXBDaGlsZHJlbjtcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgaW5mbyA9IF9iLmluZm8sIGZpcnN0Q2hpbGQgPSBfYi5maXJzdENoaWxkO1xuICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICBpZiAoaW5mby5pbmRleE9mKCd3aWRnZXQnKSAhPT0gLTEgJiYgZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gZ2V0V2lkZ2V0Q29udGVudChub2RlKTtcbiAgICAgICAgICAgIHNraXBDaGlsZHJlbigpO1xuICAgICAgICAgICAgc3RhdGUuYWRkTm9kZShzY2hlbWEubm9kZXMud2lkZ2V0LCB7IGluZm86IGluZm8gfSwgW1xuICAgICAgICAgICAgICAgIHNjaGVtYS50ZXh0KGNyZWF0ZVdpZGdldENvbnRlbnQoaW5mbywgY29udGVudCkpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9ICckJCc7XG4gICAgICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IGZpcnN0Q2hpbGQgPyBpbmZvICsgXCIgXCIgOiBpbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuYWRkVGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlV3dDb252ZXJ0b3JzKGN1c3RvbUNvbnZlcnRvcnMpIHtcbiAgICB2YXIgY3VzdG9tQ29udmVydG9yVHlwZXMgPSBPYmplY3Qua2V5cyhjdXN0b21Db252ZXJ0b3JzKTtcbiAgICB2YXIgY29udmVydG9ycyA9IF9fYXNzaWduJDEoe30sIHRvV3dDb252ZXJ0b3JzKTtcbiAgICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgICBnZm06IHRydWUsXG4gICAgICAgIG5vZGVJZDogdHJ1ZSxcbiAgICAgICAgY29udmVydG9yczogY3VzdG9tQ29udmVydG9ycyxcbiAgICB9KTtcbiAgICB2YXIgb3JnQ29udmVydG9ycyA9IHJlbmRlcmVyLmdldENvbnZlcnRvcnMoKTtcbiAgICBjdXN0b21Db252ZXJ0b3JUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciB3d0NvbnZlcnRvciA9IHRvV3dDb252ZXJ0b3JzW3R5cGVdO1xuICAgICAgICBpZiAod3dDb252ZXJ0b3IgJiYgIWluY2x1ZGVzKFsnaHRtbEJsb2NrJywgJ2h0bWxJbmxpbmUnXSwgdHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnZlcnRvcnNbdHlwZV0gPSBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9yaWdpbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yZ0NvbnZlcnRvcnNbdHlwZV0obm9kZSwgY29udGV4dCwgb3JnQ29udmVydG9ycyk7IH07XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IGN1c3RvbUNvbnZlcnRvcnNbdHlwZV0obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gQXJyYXkuaXNBcnJheSh0b2tlbnMpID8gdG9rZW5zWzBdIDogdG9rZW5zLCBodG1sQXR0cnMgPSBfYS5hdHRyaWJ1dGVzLCBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcztcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSB7IGh0bWxBdHRyczogaHRtbEF0dHJzLCBjbGFzc05hbWVzOiBjbGFzc05hbWVzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHd3Q29udmVydG9yKHN0YXRlLCBub2RlLCBjb250ZXh0LCBhdHRycyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnZlcnRvcnM7XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFya1RleHQoYSwgYikge1xuICAgIGlmIChhLmlzVGV4dCAmJiBiLmlzVGV4dCAmJiBNYXJrJDEuc2FtZVNldChhLm1hcmtzLCBiLm1hcmtzKSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vIHR5cGUgaXMgbm90IGRlZmluZWQgZm9yIFwid2l0aFRleHRcIiBpbiBwcm9zZW1pcnJvci1tb2RlbFxuICAgICAgICByZXR1cm4gYS53aXRoVGV4dChhLnRleHQgKyBiLnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG52YXIgVG9Xd0NvbnZlcnRvclN0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvV3dDb252ZXJ0b3JTdGF0ZShzY2hlbWEsIGNvbnZlcnRvcnMpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuY29udmVydG9ycyA9IGNvbnZlcnRvcnM7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbeyB0eXBlOiB0aGlzLnNjaGVtYS50b3BOb2RlVHlwZSwgYXR0cnM6IG51bGwsIGNvbnRlbnQ6IFtdIH1dO1xuICAgICAgICB0aGlzLm1hcmtzID0gTWFyayQxLm5vbmU7XG4gICAgfVxuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUudG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGFzdCQxKHRoaXMuc3RhY2spO1xuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnRvcCgpLmNvbnRlbnQucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5hZGRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMudG9wKCkuY29udGVudDtcbiAgICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IGxhc3QkMShub2Rlcyk7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc2NoZW1hLnRleHQodGV4dCwgdGhpcy5tYXJrcyk7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkID0gbGFzdE5vZGUgJiYgbWVyZ2VNYXJrVGV4dChsYXN0Tm9kZSwgbm9kZSk7XG4gICAgICAgICAgICBpZiAobWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0gPSBtZXJnZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLm9wZW5NYXJrID0gZnVuY3Rpb24gKG1hcmspIHtcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmsuYWRkVG9TZXQodGhpcy5tYXJrcyk7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmNsb3NlTWFyayA9IGZ1bmN0aW9uIChtYXJrKSB7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5tYXJrcyk7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbiAodHlwZSwgYXR0cnMsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0eXBlLmNyZWF0ZUFuZEZpbGwoYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLm9wZW5Ob2RlID0gZnVuY3Rpb24gKHR5cGUsIGF0dHJzKSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh7IHR5cGU6IHR5cGUsIGF0dHJzOiBhdHRycywgY29udGVudDogW10gfSk7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmNsb3NlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtzID0gTWFyayQxLm5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGFjay5wb3AoKSwgdHlwZSA9IF9hLnR5cGUsIGF0dHJzID0gX2EuYXR0cnMsIGNvbnRlbnQgPSBfYS5jb250ZW50O1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlKHR5cGUsIGF0dHJzLCBjb250ZW50KTtcbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydEJ5RE9NUGFyc2VyID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRvYyA9IERPTVBhcnNlci5mcm9tU2NoZW1hKHRoaXMuc2NoZW1hKS5wYXJzZShyb290KTtcbiAgICAgICAgZG9jLmNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX3RoaXMucHVzaChub2RlKTsgfSk7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmNsb3NlVW5tYXRjaGVkSFRNTElubGluZSA9IGZ1bmN0aW9uIChub2RlLCBlbnRlcmluZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZW50ZXJpbmcgJiYgbm9kZS50eXBlICE9PSAnaHRtbElubGluZScpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZW5ndGhfMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUluZm8gPSB0aGlzLnN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmICgoX2EgPSBub2RlSW5mby5hdHRycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJhd0hUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVJbmZvLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBwb3AgdXNlbGVzcyB1bm1hdGNoZWQgaHRtbCBpbmxpbmUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAobWROb2RlLCBpbmZvRm9yUG9zU3luYykge1xuICAgICAgICB2YXIgd2Fsa2VyID0gbWROb2RlLndhbGtlcigpO1xuICAgICAgICB2YXIgZXZlbnQgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgICAgIHZhciBjb252ZXJ0b3IgPSB0aGlzXzEuY29udmVydG9yc1tub2RlLnR5cGVdO1xuICAgICAgICAgICAgdmFyIHNraXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZW50ZXJpbmc6IGVudGVyaW5nLFxuICAgICAgICAgICAgICAgICAgICBsZWFmOiAhaXNDb250YWluZXIkMihub2RlKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q2hpbGRyZW5UZXh0OiBnZXRDaGlsZHJlblRleHQkMSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogeyBnZm06IHRydWUsIG5vZGVJZDogZmFsc2UsIHRhZ0ZpbHRlcjogZmFsc2UsIHNvZnRicmVhazogJ1xcbicgfSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXNfMS5jbG9zZVVubWF0Y2hlZEhUTUxJbmxpbmUobm9kZSwgZW50ZXJpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnZlcnRvcih0aGlzXzEsIG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICgoaW5mb0ZvclBvc1N5bmMgPT09IG51bGwgfHwgaW5mb0ZvclBvc1N5bmMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm9Gb3JQb3NTeW5jLm5vZGUpID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzXzEuc3RhY2sucmVkdWNlKGZ1bmN0aW9uIChub2RlU2l6ZSwgc3RhY2tJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVNpemUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrSXRlbS5jb250ZW50LnJlZHVjZShmdW5jdGlvbiAoY29udGVudFNpemUsIHBtTm9kZSkgeyByZXR1cm4gY29udGVudFNpemUgKyBwbU5vZGUubm9kZVNpemU7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGluZm9Gb3JQb3NTeW5jLnNldE1hcHBlZFBvcyhwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLnJlc3VtZUF0KG5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQgPSB3YWxrZXIubmV4dCgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGV2ZW50KSB7XG4gICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydE5vZGUgPSBmdW5jdGlvbiAobWROb2RlLCBpbmZvRm9yUG9zU3luYykge1xuICAgICAgICB0aGlzLmNvbnZlcnQobWROb2RlLCBpbmZvRm9yUG9zU3luYyk7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gVG9Xd0NvbnZlcnRvclN0YXRlO1xufSgpKTtcblxuZnVuY3Rpb24gY29udmVydFRvUmF3SFRNTEhhdmluZ0lubGluZXMoc3RhdGUsIG5vZGUsIF9hKSB7XG4gICAgdmFyIG9wZW5UYWcgPSBfYVswXSwgY2xvc2VUYWcgPSBfYVsxXTtcbiAgICBzdGF0ZS53cml0ZShvcGVuVGFnKTtcbiAgICBzdGF0ZS5jb252ZXJ0SW5saW5lKG5vZGUpO1xuICAgIHN0YXRlLndyaXRlKGNsb3NlVGFnKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1Jhd0hUTUxIYXZpbmdCbG9ja3Moc3RhdGUsIF9hLCBfYikge1xuICAgIHZhciBub2RlID0gX2Eubm9kZSwgcGFyZW50ID0gX2EucGFyZW50O1xuICAgIHZhciBvcGVuVGFnID0gX2JbMF0sIGNsb3NlVGFnID0gX2JbMV07XG4gICAgc3RhdGUuc3RvcE5ld2xpbmUgPSB0cnVlO1xuICAgIHN0YXRlLndyaXRlKG9wZW5UYWcpO1xuICAgIHN0YXRlLmNvbnZlcnROb2RlKG5vZGUpO1xuICAgIHN0YXRlLndyaXRlKGNsb3NlVGFnKTtcbiAgICBpZiAoKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC50eXBlLm5hbWUpID09PSAnZG9jJykge1xuICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgICAgICBzdGF0ZS5zdG9wTmV3bGluZSA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlSGVhZERlbGltKHRleHRDb250ZW50LCBjb2x1bW5BbGlnbikge1xuICAgIHZhciB0ZXh0TGVuID0gdGV4dENvbnRlbnQubGVuZ3RoO1xuICAgIHZhciBsZWZ0RGVsaW0gPSAnJztcbiAgICB2YXIgcmlnaHREZWxpbSA9ICcnO1xuICAgIGlmIChjb2x1bW5BbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGxlZnREZWxpbSA9ICc6JztcbiAgICAgICAgdGV4dExlbiAtPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2x1bW5BbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICByaWdodERlbGltID0gJzonO1xuICAgICAgICB0ZXh0TGVuIC09IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbHVtbkFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICBsZWZ0RGVsaW0gPSAnOic7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSAnOic7XG4gICAgICAgIHRleHRMZW4gLT0gMjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIgKyBsZWZ0RGVsaW0gKyByZXBlYXQkMSgnLScsIE1hdGgubWF4KHRleHRMZW4sIDMpKSArIHJpZ2h0RGVsaW07XG59XG52YXIgbm9kZVR5cGVXcml0ZXJzID0ge1xuICAgIHRleHQ6IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciB0ZXh0ID0gKF9iID0gbm9kZS50ZXh0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgICAgICAgaWYgKChub2RlLm1hcmtzIHx8IFtdKS5zb21lKGZ1bmN0aW9uIChtYXJrKSB7IHJldHVybiBtYXJrLnR5cGUubmFtZSA9PT0gJ2xpbmsnOyB9KSkge1xuICAgICAgICAgICAgc3RhdGUudGV4dChlc2NhcGVUZXh0Rm9yTGluayh0ZXh0KSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUudGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcGFyYWdyYXBoOiBmdW5jdGlvbiAoc3RhdGUsIF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZSwgcGFyZW50ID0gX2EucGFyZW50LCBfYiA9IF9hLmluZGV4LCBpbmRleCA9IF9iID09PSB2b2lkIDAgPyAwIDogX2I7XG4gICAgICAgIGlmIChzdGF0ZS5zdG9wTmV3bGluZSkge1xuICAgICAgICAgICAgc3RhdGUuY29udmVydElubGluZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmaXJzdENoaWxkTm9kZSA9IGluZGV4ID09PSAwO1xuICAgICAgICAgICAgdmFyIHByZXZOb2RlID0gIWZpcnN0Q2hpbGROb2RlICYmIHBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgICAgdmFyIHByZXZFbXB0eU5vZGUgPSBwcmV2Tm9kZSAmJiBwcmV2Tm9kZS5jaGlsZENvdW50ID09PSAwO1xuICAgICAgICAgICAgdmFyIG5leHROb2RlID0gaW5kZXggPCBwYXJlbnQuY2hpbGRDb3VudCAtIDEgJiYgcGFyZW50LmNoaWxkKGluZGV4ICsgMSk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhcmFOb2RlID0gbmV4dE5vZGUgJiYgbmV4dE5vZGUudHlwZS5uYW1lID09PSAncGFyYWdyYXBoJztcbiAgICAgICAgICAgIHZhciBlbXB0eU5vZGUgPSBub2RlLmNoaWxkQ291bnQgPT09IDA7XG4gICAgICAgICAgICBpZiAoZW1wdHlOb2RlICYmIHByZXZFbXB0eU5vZGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS53cml0ZSgnPGJyPlxcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW1wdHlOb2RlICYmICFwcmV2RW1wdHlOb2RlICYmICFmaXJzdENoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICgocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LnR5cGUubmFtZSkgPT09ICdsaXN0SXRlbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZEZWxpbSA9IHN0YXRlLmdldERlbGltKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNldERlbGltKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUud3JpdGUoJzxicj4nKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2V0RGVsaW0ocHJldkRlbGltKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUud3JpdGUoJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY29udmVydElubGluZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFBhcmFOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlKCdcXG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBoZWFkaW5nOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBkZWxpbSA9IF9iLmRlbGltO1xuICAgICAgICB2YXIgaGVhZGluZ1R5cGUgPSBub2RlLmF0dHJzLmhlYWRpbmdUeXBlO1xuICAgICAgICBpZiAoaGVhZGluZ1R5cGUgPT09ICdhdHgnKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZShkZWxpbSArIFwiIFwiKTtcbiAgICAgICAgICAgIHN0YXRlLmNvbnZlcnRJbmxpbmUobm9kZSk7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY29udmVydElubGluZShub2RlKTtcbiAgICAgICAgICAgIHN0YXRlLmVuc3VyZU5ld0xpbmUoKTtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKGRlbGltKTtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZGVsaW0gPSBfYi5kZWxpbSwgdGV4dCA9IF9iLnRleHQ7XG4gICAgICAgIHZhciBfYyA9IGRlbGltLCBvcGVuRGVsaW0gPSBfY1swXSwgY2xvc2VEZWxpbSA9IF9jWzFdO1xuICAgICAgICBzdGF0ZS53cml0ZShvcGVuRGVsaW0pO1xuICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgICAgIHN0YXRlLnRleHQodGV4dCwgZmFsc2UpO1xuICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgICAgIHN0YXRlLndyaXRlKGNsb3NlRGVsaW0pO1xuICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgIH0sXG4gICAgYmxvY2tRdW90ZTogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlLCBwYXJlbnQgPSBfYS5wYXJlbnQ7XG4gICAgICAgIHZhciBkZWxpbSA9IF9iLmRlbGltO1xuICAgICAgICBpZiAoKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC50eXBlLm5hbWUpID09PSBub2RlLnR5cGUubmFtZSkge1xuICAgICAgICAgICAgc3RhdGUuZmx1c2hDbG9zZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cmFwQmxvY2soZGVsaW0sIG51bGwsIG5vZGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlLmNvbnZlcnROb2RlKG5vZGUpOyB9KTtcbiAgICB9LFxuICAgIGJ1bGxldExpc3Q6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGRlbGltID0gX2IuZGVsaW07XG4gICAgICAgIC8vIHNvZnQtdGFiKDQpXG4gICAgICAgIHN0YXRlLmNvbnZlcnRMaXN0KG5vZGUsIHJlcGVhdCQxKCcgJywgNCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGltICsgXCIgXCI7IH0pO1xuICAgIH0sXG4gICAgb3JkZXJlZExpc3Q6IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgc3RhcnQgPSBub2RlLmF0dHJzLm9yZGVyIHx8IDE7XG4gICAgICAgIC8vIHNvZnQtdGFiKDQpXG4gICAgICAgIHN0YXRlLmNvbnZlcnRMaXN0KG5vZGUsIHJlcGVhdCQxKCcgJywgNCksIGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgdmFyIG9yZGVyZWROdW0gPSBTdHJpbmcoc3RhcnQgKyBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gb3JkZXJlZE51bSArIFwiLiBcIjtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBsaXN0SXRlbTogZnVuY3Rpb24gKHN0YXRlLCBfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBfYiA9IG5vZGUuYXR0cnMsIHRhc2sgPSBfYi50YXNrLCBjaGVja2VkID0gX2IuY2hlY2tlZDtcbiAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKFwiW1wiICsgKGNoZWNrZWQgPyAneCcgOiAnICcpICsgXCJdIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5jb252ZXJ0Tm9kZShub2RlKTtcbiAgICB9LFxuICAgIGltYWdlOiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hKSB7XG4gICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICBzdGF0ZS53cml0ZShcIiFbXCIgKyAoYXR0cnMgPT09IG51bGwgfHwgYXR0cnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF0dHJzLmFsdFRleHQpICsgXCJdKFwiICsgKGF0dHJzID09PSBudWxsIHx8IGF0dHJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdHRycy5pbWFnZVVybCkgKyBcIilcIik7XG4gICAgfSxcbiAgICB0aGVtYXRpY0JyZWFrOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBkZWxpbSA9IF9iLmRlbGltO1xuICAgICAgICBzdGF0ZS53cml0ZShkZWxpbSk7XG4gICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgfSxcbiAgICB0YWJsZTogZnVuY3Rpb24gKHN0YXRlLCBfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHN0YXRlLmNvbnZlcnROb2RlKG5vZGUpO1xuICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgIH0sXG4gICAgdGFibGVIZWFkOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBkZWxpbSA9IF9iLmRlbGltO1xuICAgICAgICB2YXIgcm93ID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBzdGF0ZS5jb252ZXJ0Tm9kZShub2RlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRlbGltICE9PSBudWxsICYmIGRlbGltICE9PSB2b2lkIDAgPyBkZWxpbSA6ICcnO1xuICAgICAgICBpZiAoIWRlbGltICYmIHJvdykge1xuICAgICAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gX2EudGV4dENvbnRlbnQsIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWREZWxpbSA9IGNyZWF0ZVRhYmxlSGVhZERlbGltKHRleHRDb250ZW50LCBhdHRycy5hbGlnbik7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwifCBcIiArIGhlYWREZWxpbSArIFwiIFwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUocmVzdWx0ICsgXCJ8XCIpO1xuICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgfSxcbiAgICB0YWJsZUJvZHk6IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICBzdGF0ZS5jb252ZXJ0Tm9kZShub2RlKTtcbiAgICB9LFxuICAgIHRhYmxlUm93OiBmdW5jdGlvbiAoc3RhdGUsIF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgc3RhdGUuY29udmVydE5vZGUobm9kZSk7XG4gICAgICAgIHN0YXRlLndyaXRlKCd8Jyk7XG4gICAgICAgIHN0YXRlLmVuc3VyZU5ld0xpbmUoKTtcbiAgICB9LFxuICAgIHRhYmxlSGVhZENlbGw6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIF9jID0gX2IuZGVsaW0sIGRlbGltID0gX2MgPT09IHZvaWQgMCA/ICd8ICcgOiBfYztcbiAgICAgICAgc3RhdGUud3JpdGUoZGVsaW0pO1xuICAgICAgICBzdGF0ZS5jb252ZXJ0VGFibGVDZWxsKG5vZGUpO1xuICAgICAgICBzdGF0ZS53cml0ZSgnICcpO1xuICAgIH0sXG4gICAgdGFibGVCb2R5Q2VsbDogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgX2MgPSBfYi5kZWxpbSwgZGVsaW0gPSBfYyA9PT0gdm9pZCAwID8gJ3wgJyA6IF9jO1xuICAgICAgICBzdGF0ZS53cml0ZShkZWxpbSk7XG4gICAgICAgIHN0YXRlLmNvbnZlcnRUYWJsZUNlbGwobm9kZSk7XG4gICAgICAgIHN0YXRlLndyaXRlKCcgJyk7XG4gICAgfSxcbiAgICBjdXN0b21CbG9jazogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZGVsaW0gPSBfYi5kZWxpbSwgdGV4dCA9IF9iLnRleHQ7XG4gICAgICAgIHZhciBfYyA9IGRlbGltLCBvcGVuRGVsaW0gPSBfY1swXSwgY2xvc2VEZWxpbSA9IF9jWzFdO1xuICAgICAgICBzdGF0ZS53cml0ZShvcGVuRGVsaW0pO1xuICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgICAgIHN0YXRlLnRleHQodGV4dCwgZmFsc2UpO1xuICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgICAgIHN0YXRlLndyaXRlKGNsb3NlRGVsaW0pO1xuICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgIH0sXG4gICAgZnJvbnRNYXR0ZXI6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIHRleHQgPSBfYi50ZXh0O1xuICAgICAgICBzdGF0ZS50ZXh0KHRleHQsIGZhbHNlKTtcbiAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICB9LFxuICAgIHdpZGdldDogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSkge1xuICAgICAgICB2YXIgdGV4dCA9IF9hLnRleHQ7XG4gICAgICAgIHN0YXRlLndyaXRlKHRleHQpO1xuICAgIH0sXG4gICAgaHRtbDogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgdGV4dCA9IF9iLnRleHQ7XG4gICAgICAgIHN0YXRlLndyaXRlKHRleHQpO1xuICAgICAgICBpZiAobm9kZS5hdHRycy5odG1sQmxvY2spIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGh0bWxDb21tZW50OiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciB0ZXh0ID0gX2IudGV4dDtcbiAgICAgICAgc3RhdGUud3JpdGUodGV4dCk7XG4gICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB3cml0ZSh0eXBlLCBfYSkge1xuICAgIHZhciBzdGF0ZSA9IF9hLnN0YXRlLCBub2RlSW5mbyA9IF9hLm5vZGVJbmZvLCBwYXJhbXMgPSBfYS5wYXJhbXM7XG4gICAgdmFyIHJhd0hUTUwgPSBwYXJhbXMucmF3SFRNTDtcbiAgICBpZiAocmF3SFRNTCkge1xuICAgICAgICBpZiAoaW5BcnJheV8xKHR5cGUsIFsnaGVhZGluZycsICdjb2RlQmxvY2snXSkgPiAtMSkge1xuICAgICAgICAgICAgY29udmVydFRvUmF3SFRNTEhhdmluZ0lubGluZXMoc3RhdGUsIG5vZGVJbmZvLm5vZGUsIHJhd0hUTUwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluQXJyYXlfMSh0eXBlLCBbJ2ltYWdlJywgJ3RoZW1hdGljQnJlYWsnXSkgPiAtMSkge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUocmF3SFRNTCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb252ZXJ0VG9SYXdIVE1MSGF2aW5nQmxvY2tzKHN0YXRlLCBub2RlSW5mbywgcmF3SFRNTCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlV3JpdGVyc1t0eXBlXShzdGF0ZSwgbm9kZUluZm8sIHBhcmFtcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRCYWNrdGlja3Mobm9kZSwgc2lkZSkge1xuICAgIHZhciB0ZXh0ID0gbm9kZS50ZXh0O1xuICAgIHZhciB0aWNrcyA9IC9gKy9nO1xuICAgIHZhciBsZW4gPSAwO1xuICAgIGlmIChub2RlLmlzVGV4dCAmJiB0ZXh0KSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gdGlja3MuZXhlYyh0ZXh0KTtcbiAgICAgICAgd2hpbGUgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGxlbiwgbWF0Y2hlZFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgbWF0Y2hlZCA9IHRpY2tzLmV4ZWModGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGxlbiA+IDAgJiYgc2lkZSA+IDAgPyAnIGAnIDogJ2AnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVzdWx0ICs9ICdgJztcbiAgICB9XG4gICAgaWYgKGxlbiA+IDAgJiYgc2lkZSA8IDApIHtcbiAgICAgICAgcmVzdWx0ICs9ICcgJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFBhaXJSYXdIVE1MKHJhd0hUTUwpIHtcbiAgICByZXR1cm4gcmF3SFRNTCA/IFtcIjxcIiArIHJhd0hUTUwgKyBcIj5cIiwgXCI8L1wiICsgcmF3SFRNTCArIFwiPlwiXSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRPcGVuUmF3SFRNTChyYXdIVE1MKSB7XG4gICAgcmV0dXJuIHJhd0hUTUwgPyBcIjxcIiArIHJhd0hUTUwgKyBcIj5cIiA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRDbG9zZVJhd0hUTUwocmF3SFRNTCkge1xuICAgIHJldHVybiByYXdIVE1MID8gXCI8L1wiICsgcmF3SFRNTCArIFwiPlwiIDogbnVsbDtcbn1cbnZhciB0b01kQ29udmVydG9ycyA9IHtcbiAgICBoZWFkaW5nOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJzO1xuICAgICAgICB2YXIgbGV2ZWwgPSBhdHRycy5sZXZlbDtcbiAgICAgICAgdmFyIGRlbGltID0gcmVwZWF0JDEoJyMnLCBsZXZlbCk7XG4gICAgICAgIGlmIChhdHRycy5oZWFkaW5nVHlwZSA9PT0gJ3NldGV4dCcpIHtcbiAgICAgICAgICAgIGRlbGltID0gbGV2ZWwgPT09IDEgPyAnPT09JyA6ICctLS0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogZGVsaW0sXG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChhdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgYXR0cnMgPSBfYi5hdHRycywgdGV4dENvbnRlbnQgPSBfYi50ZXh0Q29udGVudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiBbXCJgYGBcIiArIChhdHRycy5sYW5ndWFnZSB8fCAnJyksICdgYGAnXSxcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKGF0dHJzLnJhd0hUTUwpLFxuICAgICAgICAgICAgdGV4dDogdGV4dENvbnRlbnQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBibG9ja1F1b3RlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06ICc+ICcsXG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYnVsbGV0TGlzdDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBpblRhYmxlID0gX2IuaW5UYWJsZTtcbiAgICAgICAgdmFyIHJhd0hUTUwgPSBub2RlLmF0dHJzLnJhd0hUTUw7XG4gICAgICAgIGlmIChpblRhYmxlKSB7XG4gICAgICAgICAgICByYXdIVE1MID0gcmF3SFRNTCB8fCAndWwnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogJyonLFxuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwocmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvcmRlcmVkTGlzdDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBpblRhYmxlID0gX2IuaW5UYWJsZTtcbiAgICAgICAgdmFyIHJhd0hUTUwgPSBub2RlLmF0dHJzLnJhd0hUTUw7XG4gICAgICAgIGlmIChpblRhYmxlKSB7XG4gICAgICAgICAgICByYXdIVE1MID0gcmF3SFRNTCB8fCAnb2wnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChyYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGxpc3RJdGVtOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGluVGFibGUgPSBfYi5pblRhYmxlO1xuICAgICAgICB2YXIgX2MgPSBub2RlLmF0dHJzLCB0YXNrID0gX2MudGFzaywgY2hlY2tlZCA9IF9jLmNoZWNrZWQ7XG4gICAgICAgIHZhciByYXdIVE1MID0gbm9kZS5hdHRycy5yYXdIVE1MO1xuICAgICAgICBpZiAoaW5UYWJsZSkge1xuICAgICAgICAgICAgcmF3SFRNTCA9IHJhd0hUTUwgfHwgJ2xpJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGFzayA/IFwiIGNsYXNzPVxcXCJ0YXNrLWxpc3QtaXRlbVwiICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQnIDogJycpICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgdmFyIGRhdGFzZXQgPSB0YXNrID8gXCIgZGF0YS10YXNrXCIgKyAoY2hlY2tlZCA/IFwiIGRhdGEtdGFzay1jaGVja2VkXCIgOiAnJykgOiAnJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IHJhd0hUTUwgPyBbXCI8XCIgKyByYXdIVE1MICsgY2xhc3NOYW1lICsgZGF0YXNldCArIFwiPlwiLCBcIjwvXCIgKyByYXdIVE1MICsgXCI+XCJdIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlSGVhZDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZUJvZHk6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVSb3c6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVIZWFkQ2VsbDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZUJvZHlDZWxsOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGltYWdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJzO1xuICAgICAgICB2YXIgcmF3SFRNTCA9IGF0dHJzLnJhd0hUTUwsIGFsdFRleHQgPSBhdHRycy5hbHRUZXh0O1xuICAgICAgICB2YXIgaW1hZ2VVcmwgPSBhdHRycy5pbWFnZVVybC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpO1xuICAgICAgICB2YXIgYWx0QXR0ciA9IGFsdFRleHQgPyBcIiBhbHQ9XFxcIlwiICsgZXNjYXBlWG1sJDEoYWx0VGV4dCkgKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogcmF3SFRNTCA/IFwiPFwiICsgcmF3SFRNTCArIFwiIHNyYz1cXFwiXCIgKyBlc2NhcGVYbWwkMShpbWFnZVVybCkgKyBcIlxcXCJcIiArIGFsdEF0dHIgKyBcIj5cIiA6IG51bGwsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGFsdFRleHQ6IGVzY2FwZVRleHRGb3JMaW5rKGFsdFRleHQgfHwgJycpLFxuICAgICAgICAgICAgICAgIGltYWdlVXJsOiBpbWFnZVVybCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0aGVtYXRpY0JyZWFrOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06ICcqKionLFxuICAgICAgICAgICAgcmF3SFRNTDogZ2V0T3BlblJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGN1c3RvbUJsb2NrOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgX2IgPSBub2RlLCBhdHRycyA9IF9iLmF0dHJzLCB0ZXh0Q29udGVudCA9IF9iLnRleHRDb250ZW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06IFtcIiQkXCIgKyBhdHRycy5pbmZvLCAnJCQnXSxcbiAgICAgICAgICAgIHRleHQ6IHRleHRDb250ZW50LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZnJvbnRNYXR0ZXI6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBub2RlLnRleHRDb250ZW50LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgd2lkZ2V0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogbm9kZS50ZXh0Q29udGVudCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHN0cm9uZzogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9iLmVudGVyaW5nO1xuICAgICAgICB2YXIgcmF3SFRNTCA9IG5vZGUuYXR0cnMucmF3SFRNTDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiAnKionLFxuICAgICAgICAgICAgcmF3SFRNTDogZW50ZXJpbmcgPyBnZXRPcGVuUmF3SFRNTChyYXdIVE1MKSA6IGdldENsb3NlUmF3SFRNTChyYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGVtcGg6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYi5lbnRlcmluZztcbiAgICAgICAgdmFyIHJhd0hUTUwgPSBub2RlLmF0dHJzLnJhd0hUTUw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogJyonLFxuICAgICAgICAgICAgcmF3SFRNTDogZW50ZXJpbmcgPyBnZXRPcGVuUmF3SFRNTChyYXdIVE1MKSA6IGdldENsb3NlUmF3SFRNTChyYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHN0cmlrZTogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9iLmVudGVyaW5nO1xuICAgICAgICB2YXIgcmF3SFRNTCA9IG5vZGUuYXR0cnMucmF3SFRNTDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiAnfn4nLFxuICAgICAgICAgICAgcmF3SFRNTDogZW50ZXJpbmcgPyBnZXRPcGVuUmF3SFRNTChyYXdIVE1MKSA6IGdldENsb3NlUmF3SFRNTChyYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYi5lbnRlcmluZztcbiAgICAgICAgdmFyIGF0dHJzID0gbm9kZS5hdHRycztcbiAgICAgICAgdmFyIHRpdGxlID0gYXR0cnMudGl0bGUsIHJhd0hUTUwgPSBhdHRycy5yYXdIVE1MO1xuICAgICAgICB2YXIgbGlua1VybCA9IGF0dHJzLmxpbmtVcmwucmVwbGFjZSgvJmFtcDsvZywgJyYnKTtcbiAgICAgICAgdmFyIHRpdGxlQXR0ciA9IHRpdGxlID8gXCIgdGl0bGU9XFxcIlwiICsgZXNjYXBlWG1sJDEodGl0bGUpICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRlbGltOiAnWycsXG4gICAgICAgICAgICAgICAgcmF3SFRNTDogcmF3SFRNTCA/IFwiPFwiICsgcmF3SFRNTCArIFwiIGhyZWY9XFxcIlwiICsgZXNjYXBlWG1sJDEobGlua1VybCkgKyBcIlxcXCJcIiArIHRpdGxlQXR0ciArIFwiPlwiIDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiBcIl0oXCIgKyBsaW5rVXJsICsgKHRpdGxlID8gXCIgXCIgKyBxdW90ZShlc2NhcGVUZXh0Rm9yTGluayh0aXRsZSkpIDogJycpICsgXCIpXCIsXG4gICAgICAgICAgICByYXdIVE1MOiBnZXRDbG9zZVJhd0hUTUwocmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZSwgcGFyZW50ID0gX2EucGFyZW50LCBfYyA9IF9hLmluZGV4LCBpbmRleCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2M7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9iLmVudGVyaW5nO1xuICAgICAgICB2YXIgZGVsaW0gPSBlbnRlcmluZ1xuICAgICAgICAgICAgPyBhZGRCYWNrdGlja3MocGFyZW50LmNoaWxkKGluZGV4KSwgLTEpXG4gICAgICAgICAgICA6IGFkZEJhY2t0aWNrcyhwYXJlbnQuY2hpbGQoaW5kZXggLSAxKSwgMSk7XG4gICAgICAgIHZhciByYXdIVE1MID0gZW50ZXJpbmdcbiAgICAgICAgICAgID8gZ2V0T3BlblJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKVxuICAgICAgICAgICAgOiBnZXRDbG9zZVJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiBkZWxpbSxcbiAgICAgICAgICAgIHJhd0hUTUw6IHJhd0hUTUwsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBodG1sQ29tbWVudDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IG5vZGUudGV4dENvbnRlbnQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICAvLyBodG1sIGlubGluZSBub2RlLCBodG1sIGJsb2NrIG5vZGVcbiAgICBodG1sOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2IuZW50ZXJpbmc7XG4gICAgICAgIHZhciB0YWdOYW1lID0gbm9kZS50eXBlLm5hbWU7XG4gICAgICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cnMuaHRtbEF0dHJzO1xuICAgICAgICB2YXIgb3BlblRhZyA9IFwiPFwiICsgdGFnTmFtZTtcbiAgICAgICAgdmFyIGNsb3NlVGFnID0gXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgYnJva2VuIGNvbnZlcnRpbmcgd2hlbiBhdHRyaWJ1dGVzIGhhcyBkb3VibGUgcXVvdGUgc3RyaW5nXG4gICAgICAgICAgICBvcGVuVGFnICs9IFwiIFwiICsgYXR0ck5hbWUgKyBcIj1cXFwiXCIgKyBhdHRyc1thdHRyTmFtZV0ucmVwbGFjZSgvXCIvZywgXCInXCIpICsgXCJcXFwiXCI7XG4gICAgICAgIH0pO1xuICAgICAgICBvcGVuVGFnICs9ICc+JztcbiAgICAgICAgaWYgKG5vZGUuYXR0cnMuaHRtbElubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByYXdIVE1MOiBlbnRlcmluZyA/IG9wZW5UYWcgOiBjbG9zZVRhZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCIgKyBvcGVuVGFnICsgbm9kZS5hdHRycy5jaGlsZHJlbkhUTUwgKyBjbG9zZVRhZyxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbnZhciBtYXJrVHlwZU9wdGlvbnMgPSB7XG4gICAgc3Ryb25nOiB7XG4gICAgICAgIG1peGFibGU6IHRydWUsXG4gICAgICAgIHJlbW92ZWRFbmNsb3NpbmdXaGl0ZXNwYWNlOiB0cnVlLFxuICAgIH0sXG4gICAgZW1waDoge1xuICAgICAgICBtaXhhYmxlOiB0cnVlLFxuICAgICAgICByZW1vdmVkRW5jbG9zaW5nV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICB9LFxuICAgIHN0cmlrZToge1xuICAgICAgICBtaXhhYmxlOiB0cnVlLFxuICAgICAgICByZW1vdmVkRW5jbG9zaW5nV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICB9LFxuICAgIGNvZGU6IHtcbiAgICAgICAgZXNjYXBlOiBmYWxzZSxcbiAgICB9LFxuICAgIGxpbms6IG51bGwsXG4gICAgaHRtbDogbnVsbCxcbn07XG5mdW5jdGlvbiBjcmVhdGVOb2RlVHlwZUNvbnZlcnRvcnMoY29udmVydG9ycykge1xuICAgIHZhciBub2RlVHlwZUNvbnZlcnRvcnMgPSB7fTtcbiAgICB2YXIgbm9kZVR5cGVzID0gT2JqZWN0LmtleXMobm9kZVR5cGVXcml0ZXJzKTtcbiAgICBub2RlVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBub2RlVHlwZUNvbnZlcnRvcnNbdHlwZV0gPSBmdW5jdGlvbiAoc3RhdGUsIG5vZGVJbmZvKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVyID0gbm9kZVR5cGVXcml0ZXJzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKHdyaXRlcikge1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0b3IgPSBjb252ZXJ0b3JzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBjb252ZXJ0b3JcbiAgICAgICAgICAgICAgICAgICAgPyBjb252ZXJ0b3Iobm9kZUluZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluVGFibGU6IHN0YXRlLmluVGFibGUsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICAgICAgd3JpdGUodHlwZSwgeyBzdGF0ZTogc3RhdGUsIG5vZGVJbmZvOiBub2RlSW5mbywgcGFyYW1zOiBwYXJhbXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVUeXBlQ29udmVydG9ycztcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1hcmtUeXBlQ29udmVydG9ycyhjb252ZXJ0b3JzKSB7XG4gICAgdmFyIG1hcmtUeXBlQ29udmVydG9ycyA9IHt9O1xuICAgIHZhciBtYXJrVHlwZXMgPSBPYmplY3Qua2V5cyhtYXJrVHlwZU9wdGlvbnMpO1xuICAgIG1hcmtUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIG1hcmtUeXBlQ29udmVydG9yc1t0eXBlXSA9IGZ1bmN0aW9uIChub2RlSW5mbywgZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBtYXJrT3B0aW9uID0gbWFya1R5cGVPcHRpb25zW3R5cGVdO1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRvciA9IGNvbnZlcnRvcnNbdHlwZV07XG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgdHdvIHdheXMgdG8gY2FsbCB0aGUgbWFyayB0eXBlIGNvbnZlcnRlclxuICAgICAgICAgICAgLy8gaW4gdGhlIGB0b01kQ29udmVydG9yU3RhdGVgIG1vZHVsZS5cbiAgICAgICAgICAgIC8vIFdoZW4gY2FsbGluZyB0aGUgY29udmVydGVyIHdpdGhvdXQgdXNpbmcgYGRlbGltYCBhbmQgYHJhd0hUTUxgIHZhbHVlcyxcbiAgICAgICAgICAgIC8vIHRoZSBjb252ZXJ0ZXIgaXMgY2FsbGVkIHdpdGhvdXQgcGFyYW1ldGVycy5cbiAgICAgICAgICAgIHZhciBydW5Db252ZXJ0b3IgPSBjb252ZXJ0b3IgJiYgbm9kZUluZm8gJiYgIWlzVW5kZWZpbmVkXzEoZW50ZXJpbmcpO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHJ1bkNvbnZlcnRvciA/IGNvbnZlcnRvcihub2RlSW5mbywgeyBlbnRlcmluZzogZW50ZXJpbmcgfSkgOiB7fTtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHBhcmFtcyksIG1hcmtPcHRpb24pO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBtYXJrVHlwZUNvbnZlcnRvcnM7XG59XG4vLyBTdGVwIDE6IENyZWF0ZSB0aGUgY29udmVydGVyIGJ5IG92ZXJyaWRpbmcgdGhlIGN1c3RvbSBjb252ZXJ0ZXJcbi8vICAgICAgICAgdG8gdGhlIG9yaWdpbmFsIGNvbnZlcnRlciBkZWZpbmVkIGluIHRoZSBgdG9NZENvbnZlcnRvcnNgIG1vZHVsZS5cbi8vICAgICAgICAgSWYgdGhlIG5vZGUgdHlwZSBpcyBkZWZpbmVkIGluIHRoZSBvcmlnaW5hbCBjb252ZXJ0ZXIsXG4vLyAgICAgICAgIHRoZSBgb3JpZ2luKClgIGZ1bmN0aW9uIGlzIGV4cG9ydGVkIHRvIHRoZSBwYXJhbXRlciBvZiB0aGUgY29udmVydGVyLlxuLy8gU3RlcCAyOiBDcmVhdGUgYSBjb252ZXJ0ZXIgZm9yIHRoZSBub2RlIHR5cGUgb2YgUHJvc2VNaXJyb3IgYnkgY29tYmluaW5nIHRoZSBjb252ZXJ0ZXJcbi8vICAgICAgICAgY3JlYXRlZCBpbiBTdGVwIDEgd2l0aCB0aGUgd3JpdGVycyBkZWZpbmVkIGluIHRoZWB0b01kTm9kZVR5cGVXcml0ZXJzYCBtb2R1bGUuXG4vLyAgICAgICAgIEVhY2ggd3JpdGVyIGNvbnZlcnRzIHRoZSBQcm9zZU1pcnJvcidzIG5vZGUgdG8gYSBzdHJpbmcgd2l0aCB0aGUgdmFsdWUgcmV0dXJuZWRcbi8vICAgICAgICAgYnkgdGhlIGNvbnZlcnRlciwgYW5kIHRoZW4gc3RvcmVzIHRoZSBzdGF0ZSBpbiB0aGVgdG9NZENvbnZlcnRlclN0YXRlYCBjbGFzcy5cbi8vIFN0ZXAgMzogQ3JlYXRlIGEgY29udmVydGVyIGZvciB0aGUgbWFyayB0eXBlIG9mIFByb3NlTWlycm9yIGJ5IGNvbWJpbmluZyB0aGUgY29udmVydGVyXG4vLyAgICAgICAgIGNyZWF0ZWQgaW4gU3RlcCAxIHdpdGggYG1hcmtUeXBlT3B0aW9uc2AuXG4vLyBTdGVwIDQ6IFRoZSBjcmVhdGVkIG5vZGUgdHlwZSBjb252ZXJ0ZXIgYW5kIG1hcmsgdHlwZSBjb252ZXJ0ZXIgYXJlIGluamVjdGVkXG4vLyAgICAgICAgIHdoZW4gY3JlYXRpbmcgYW4gaW5zdGFuY2Ugb2YgdGhlYHRvTWRDb252ZXJ0ZXJTdGF0ZWAgY2xhc3MuXG5mdW5jdGlvbiBjcmVhdGVNZENvbnZlcnRvcnMoY3VzdG9tQ29udmVydG9ycykge1xuICAgIHZhciBjdXN0b21Db252ZXJ0b3JUeXBlcyA9IE9iamVjdC5rZXlzKGN1c3RvbUNvbnZlcnRvcnMpO1xuICAgIGN1c3RvbUNvbnZlcnRvclR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGJhc2VDb252ZXJ0b3IgPSB0b01kQ29udmVydG9yc1t0eXBlXTtcbiAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGN1c3RvbUNvbnZlcnRvcnNbdHlwZV07XG4gICAgICAgIGlmIChiYXNlQ29udmVydG9yKSB7XG4gICAgICAgICAgICB0b01kQ29udmVydG9yc1t0eXBlXSA9IGZ1bmN0aW9uIChub2RlSW5mbywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQub3JpZ2luID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZUNvbnZlcnRvcihub2RlSW5mbywgY29udGV4dCk7IH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnZlcnRvcihub2RlSW5mbywgY29udGV4dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9NZENvbnZlcnRvcnNbdHlwZV0gPSBjdXN0b21Db252ZXJ0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGN1c3RvbUNvbnZlcnRvcnNbdHlwZV07XG4gICAgfSk7XG4gICAgdmFyIG5vZGVUeXBlQ29udmVydG9ycyA9IGNyZWF0ZU5vZGVUeXBlQ29udmVydG9ycyh0b01kQ29udmVydG9ycyk7XG4gICAgdmFyIG1hcmtUeXBlQ29udmVydG9ycyA9IGNyZWF0ZU1hcmtUeXBlQ29udmVydG9ycyh0b01kQ29udmVydG9ycyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGVDb252ZXJ0b3JzOiBub2RlVHlwZUNvbnZlcnRvcnMsXG4gICAgICAgIG1hcmtUeXBlQ29udmVydG9yczogbWFya1R5cGVDb252ZXJ0b3JzLFxuICAgIH07XG59XG5cbnZhciBUb01kQ29udmVydG9yU3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9NZENvbnZlcnRvclN0YXRlKF9hKSB7XG4gICAgICAgIHZhciBub2RlVHlwZUNvbnZlcnRvcnMgPSBfYS5ub2RlVHlwZUNvbnZlcnRvcnMsIG1hcmtUeXBlQ29udmVydG9ycyA9IF9hLm1hcmtUeXBlQ29udmVydG9ycztcbiAgICAgICAgdGhpcy5ub2RlVHlwZUNvbnZlcnRvcnMgPSBub2RlVHlwZUNvbnZlcnRvcnM7XG4gICAgICAgIHRoaXMubWFya1R5cGVDb252ZXJ0b3JzID0gbWFya1R5cGVDb252ZXJ0b3JzO1xuICAgICAgICB0aGlzLmRlbGltID0gJyc7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gJyc7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGlnaHRMaXN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RvcE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pblRhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuZ2V0TWFya0NvbnZlcnRvciA9IGZ1bmN0aW9uIChtYXJrKSB7XG4gICAgICAgIHZhciB0eXBlID0gbWFyay5hdHRycy5odG1sSW5saW5lID8gJ2h0bWwnIDogbWFyay50eXBlLm5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtUeXBlQ29udmVydG9yc1t0eXBlXTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuaXNJbkJsYW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gLyhefFxcbikkLy50ZXN0KHRoaXMucmVzdWx0KTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUubWFya1RleHQgPSBmdW5jdGlvbiAobWFyaywgZW50ZXJpbmcsIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRvciA9IHRoaXMuZ2V0TWFya0NvbnZlcnRvcihtYXJrKTtcbiAgICAgICAgaWYgKGNvbnZlcnRvcikge1xuICAgICAgICAgICAgdmFyIF9hID0gY29udmVydG9yKHsgbm9kZTogbWFyaywgcGFyZW50OiBwYXJlbnQsIGluZGV4OiBpbmRleCB9LCBlbnRlcmluZyksIGRlbGltID0gX2EuZGVsaW0sIHJhd0hUTUwgPSBfYS5yYXdIVE1MO1xuICAgICAgICAgICAgcmV0dXJuIHJhd0hUTUwgfHwgZGVsaW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5zZXREZWxpbSA9IGZ1bmN0aW9uIChkZWxpbSkge1xuICAgICAgICB0aGlzLmRlbGltID0gZGVsaW07XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmdldERlbGltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxpbTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuZmx1c2hDbG9zZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmICghdGhpcy5zdG9wTmV3bGluZSAmJiB0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5CbGFuaygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaXplID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWxpbU1pbiA9IHRoaXMuZGVsaW07XG4gICAgICAgICAgICAgICAgdmFyIHRyaW0gPSAvXFxzKyQvLmV4ZWMoZGVsaW1NaW4pO1xuICAgICAgICAgICAgICAgIGlmICh0cmltKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGltTWluID0gZGVsaW1NaW4uc2xpY2UoMCwgZGVsaW1NaW4ubGVuZ3RoIC0gdHJpbVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNpemU7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBkZWxpbU1pbiArIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS53cmFwQmxvY2sgPSBmdW5jdGlvbiAoZGVsaW0sIGZpcnN0RGVsaW0sIG5vZGUsIGZuKSB7XG4gICAgICAgIHZhciBvbGQgPSB0aGlzLmdldERlbGltKCk7XG4gICAgICAgIHRoaXMud3JpdGUoZmlyc3REZWxpbSB8fCBkZWxpbSk7XG4gICAgICAgIHRoaXMuc2V0RGVsaW0odGhpcy5nZXREZWxpbSgpICsgZGVsaW0pO1xuICAgICAgICBmbigpO1xuICAgICAgICB0aGlzLnNldERlbGltKG9sZCk7XG4gICAgICAgIHRoaXMuY2xvc2VCbG9jayhub2RlKTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuZW5zdXJlTmV3TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5CbGFuaygpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50ID09PSB2b2lkIDApIHsgY29udGVudCA9ICcnOyB9XG4gICAgICAgIHRoaXMuZmx1c2hDbG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5kZWxpbSAmJiB0aGlzLmlzSW5CbGFuaygpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSB0aGlzLmRlbGltO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmNsb3NlQmxvY2sgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IG5vZGU7XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAodGV4dCwgZXNjYXBlZCkge1xuICAgICAgICBpZiAoZXNjYXBlZCA9PT0gdm9pZCAwKSB7IGVzY2FwZWQgPSB0cnVlOyB9XG4gICAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBlc2NhcGVkID8gZXNjYXBlJDEobGluZXNbaV0pIDogbGluZXNbaV07XG4gICAgICAgICAgICBpZiAoaSAhPT0gbGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmNvbnZlcnRCbG9jayA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlLm5hbWU7XG4gICAgICAgIHZhciBjb252ZXJ0b3IgPSB0aGlzLm5vZGVUeXBlQ29udmVydG9yc1t0eXBlXTtcbiAgICAgICAgdmFyIG5vZGVJbmZvID0geyBub2RlOiBub2RlLCBwYXJlbnQ6IHBhcmVudCwgaW5kZXg6IGluZGV4IH07XG4gICAgICAgIGlmIChub2RlLmF0dHJzLmh0bWxCbG9jaykge1xuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZUNvbnZlcnRvcnMuaHRtbCh0aGlzLCBub2RlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udmVydG9yKSB7XG4gICAgICAgICAgICBjb252ZXJ0b3IodGhpcywgbm9kZUluZm8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmNvbnZlcnRJbmxpbmUgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhY3RpdmUgPSBbXTtcbiAgICAgICAgdmFyIHRyYWlsaW5nID0gJyc7XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IGZ1bmN0aW9uIChub2RlLCBfLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIG1hcmtzID0gbm9kZSA/IG5vZGUubWFya3MgOiBbXTtcbiAgICAgICAgICAgIHZhciBsZWFkaW5nID0gdHJhaWxpbmc7XG4gICAgICAgICAgICB0cmFpbGluZyA9ICcnO1xuICAgICAgICAgICAgLy8gSWYgd2hpdGVzcGFjZSBoYXMgdG8gYmUgZXhwZWxsZWQgZnJvbSB0aGUgbm9kZSwgYWRqdXN0XG4gICAgICAgICAgICAvLyBsZWFkaW5nIGFuZCB0cmFpbGluZyBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgIHZhciByZW1vdmVkV2hpdGVzcGFjZSA9IG5vZGUgJiZcbiAgICAgICAgICAgICAgICBub2RlLmlzVGV4dCAmJlxuICAgICAgICAgICAgICAgIG1hcmtzLnNvbWUoZnVuY3Rpb24gKG1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtDb252ZXJ0b3IgPSBfdGhpcy5nZXRNYXJrQ29udmVydG9yKG1hcmspO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IG1hcmtDb252ZXJ0b3IgJiYgbWFya0NvbnZlcnRvcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5mbyAmJiBpbmZvLnJlbW92ZWRFbmNsb3NpbmdXaGl0ZXNwYWNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlbW92ZWRXaGl0ZXNwYWNlICYmIG5vZGUgJiYgbm9kZS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gL14oXFxzKikoLio/KShcXHMqKSQvbS5leGVjKG5vZGUudGV4dCksIGxlYWQgPSBfYVsxXSwgbWFyayA9IF9hWzJdLCB0cmFpbCA9IF9hWzNdO1xuICAgICAgICAgICAgICAgIGxlYWRpbmcgKz0gbGVhZDtcbiAgICAgICAgICAgICAgICB0cmFpbGluZyA9IHRyYWlsO1xuICAgICAgICAgICAgICAgIGlmIChsZWFkIHx8IHRyYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdHlwZSBpcyBub3QgZGVmaW5lZCBmb3IgXCJ3aXRoVGV4dFwiIGluIHByb3NlbWlycm9yLW1vZGVsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBtYXJrID8gbm9kZS53aXRoVGV4dChtYXJrKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBhY3RpdmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGFzdE1hcmsgPSBtYXJrcy5sZW5ndGggJiYgbGFzdCQxKG1hcmtzKTtcbiAgICAgICAgICAgIHZhciBtYXJrQ29udmVydG9yID0gbGFzdE1hcmsgJiYgX3RoaXMuZ2V0TWFya0NvbnZlcnRvcihsYXN0TWFyayk7XG4gICAgICAgICAgICB2YXIgbWFya1R5cGUgPSBtYXJrQ29udmVydG9yICYmIG1hcmtDb252ZXJ0b3IoKTtcbiAgICAgICAgICAgIHZhciBub0VzY2FwZSA9IG1hcmtUeXBlICYmIG1hcmtUeXBlLmVzY2FwZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbGVuID0gbWFya3MubGVuZ3RoIC0gKG5vRXNjYXBlID8gMSA6IDApO1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHJlb3JkZXIgJ21peGFibGUnIG1hcmtzLCBzdWNoIGFzIGVtIGFuZCBzdHJvbmcsIHdoaWNoXG4gICAgICAgICAgICAvLyBpbiBNYXJrZG93biBtYXkgYmUgb3BlbmVkIGFuZCBjbG9zZWQgaW4gZGlmZmVyZW50IG9yZGVyLCBzb1xuICAgICAgICAgICAgLy8gdGhhdCBvcmRlciBvZiB0aGUgbWFya3MgZm9yIHRoZSB0b2tlbiBtYXRjaGVzIHRoZSBvcmRlciBpblxuICAgICAgICAgICAgLy8gYWN0aXZlLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrID0gbWFya3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlICYmICFtYXJrVHlwZS5taXhhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFjdGl2ZS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBhY3RpdmVbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSAmJiAhbWFya1R5cGUubWl4YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmsuZXEob3RoZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCBqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG1hcmspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobWFya3Muc2xpY2UoaiwgaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobWFya3Muc2xpY2UoaSArIDEsIGxlbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCBpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG1hcmtzLnNsaWNlKGkgKyAxLCBqKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtYXJrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG1hcmtzLnNsaWNlKGosIGxlbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBwcmVmaXggb2YgdGhlIG1hcmsgc2V0IHRoYXQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgdmFyIGtlZXAgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBNYXRoLm1pbihhY3RpdmUubGVuZ3RoLCBsZW4pICYmIG1hcmtzW2tlZXBdLmVxKGFjdGl2ZVtrZWVwXSkpIHtcbiAgICAgICAgICAgICAgICBrZWVwICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbG9zZSB0aGUgbWFya3MgdGhhdCBuZWVkIHRvIGJlIGNsb3NlZFxuICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZWRNYXJrID0gYWN0aXZlLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVkTWFyaykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXh0KF90aGlzLm1hcmtUZXh0KGFjdGl2ZWRNYXJrLCBmYWxzZSwgcGFyZW50LCBpbmRleCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdXRwdXQgYW55IHByZXZpb3VzbHkgZXhwZWxsZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvdXRzaWRlIHRoZSBtYXJrc1xuICAgICAgICAgICAgaWYgKGxlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50ZXh0KGxlYWRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3BlbiB0aGUgbWFya3MgdGhhdCBuZWVkIHRvIGJlIG9wZW5lZFxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoYWN0aXZlLmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFyayA9IG1hcmtzW2FjdGl2ZS5sZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaChtYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGV4dChfdGhpcy5tYXJrVGV4dChtYXJrLCB0cnVlLCBwYXJlbnQsIGluZGV4KSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGhlIG5vZGUuIFNwZWNpYWwgY2FzZSBjb2RlIG1hcmtzLCBzaW5jZSB0aGVpciBjb250ZW50XG4gICAgICAgICAgICAgICAgLy8gbWF5IG5vdCBiZSBlc2NhcGVkLlxuICAgICAgICAgICAgICAgIGlmIChub0VzY2FwZSAmJiBub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXh0KF90aGlzLm1hcmtUZXh0KGxhc3RNYXJrLCB0cnVlLCBwYXJlbnQsIGluZGV4KSArXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRleHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFya1RleHQobGFzdE1hcmssIGZhbHNlLCBwYXJlbnQsIGluZGV4ICsgMSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnZlcnRCbG9jayhub2RlLCBwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHBhcmVudC5mb3JFYWNoKHByb2dyZXNzKTtcbiAgICAgICAgcHJvZ3Jlc3MobnVsbCwgbnVsbCwgcGFyZW50LmNoaWxkQ291bnQpO1xuICAgIH07XG4gICAgLy8gUmVuZGVyIGEgbm9kZSdzIGNvbnRlbnQgYXMgYSBsaXN0LiBgZGVsaW1gIHNob3VsZCBiZSB0aGUgZXh0cmFcbiAgICAvLyBpbmRlbnRhdGlvbiBhZGRlZCB0byBhbGwgbGluZXMgZXhjZXB0IHRoZSBmaXJzdCBpbiBhbiBpdGVtLFxuICAgIC8vIGBmaXJzdERlbGltRm5gIGlzIGEgZnVuY3Rpb24gZ29pbmcgZnJvbSBhbiBpdGVtIGluZGV4IHRvIGFcbiAgICAvLyBkZWxpbWl0ZXIgZm9yIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBpdGVtLlxuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydExpc3QgPSBmdW5jdGlvbiAobm9kZSwgZGVsaW0sIGZpcnN0RGVsaW1Gbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCAmJiB0aGlzLmNsb3NlZC50eXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDbG9zZSgzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnRpZ2h0TGlzdCkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaENsb3NlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aWdodCA9IChfYSA9IG5vZGUuYXR0cnMudGlnaHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgICAgIHZhciBwcmV2VGlnaHQgPSB0aGlzLnRpZ2h0TGlzdDtcbiAgICAgICAgdGhpcy50aWdodExpc3QgPSB0aWdodDtcbiAgICAgICAgbm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgXywgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCAmJiB0aWdodCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZsdXNoQ2xvc2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy53cmFwQmxvY2soZGVsaW0sIGZpcnN0RGVsaW1GbihpbmRleCksIG5vZGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbnZlcnRCbG9jayhjaGlsZCwgbm9kZSwgaW5kZXgpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGlnaHRMaXN0ID0gcHJldlRpZ2h0O1xuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jb252ZXJ0VGFibGVDZWxsID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdG9wTmV3bGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5UYWJsZSA9IHRydWU7XG4gICAgICAgIG5vZGUuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIF8sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZXMoWydidWxsZXRMaXN0JywgJ29yZGVyZWRMaXN0J10sIGNoaWxkLnR5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb252ZXJ0QmxvY2soY2hpbGQsIG5vZGUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnZlcnRJbmxpbmUoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IG5vZGUuY2hpbGRDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5vZGUuY2hpbGQoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZC50eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy53cml0ZSgnPGJyPicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdG9wTmV3bGluZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluVGFibGUgPSBmYWxzZTtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydE5vZGUgPSBmdW5jdGlvbiAocGFyZW50LCBpbmZvRm9yUG9zU3luYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSwgXywgaW5kZXgpIHtcbiAgICAgICAgICAgIF90aGlzLmNvbnZlcnRCbG9jayhub2RlLCBwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICgoaW5mb0ZvclBvc1N5bmMgPT09IG51bGwgfHwgaW5mb0ZvclBvc1N5bmMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm9Gb3JQb3NTeW5jLm5vZGUpID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVUZXh0cyA9IF90aGlzLnJlc3VsdC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgaW5mb0ZvclBvc1N5bmMuc2V0TWFwcGVkUG9zKFtsaW5lVGV4dHMubGVuZ3RoLCBsYXN0JDEobGluZVRleHRzKS5sZW5ndGggKyAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gVG9NZENvbnZlcnRvclN0YXRlO1xufSgpKTtcblxudmFyIENvbnZlcnRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252ZXJ0b3Ioc2NoZW1hLCB0b01kQ29udmVydG9ycywgdG9IVE1MQ29udmVydG9ycywgZXZlbnRFbWl0dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2V0TWFwcGVkUG9zID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgX3RoaXMubWFwcGVkUG9zV2hlbkNvbnZlcnRpbmcgPSBwb3M7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5mb2N1c2VkTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWFwcGVkUG9zV2hlbkNvbnZlcnRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLnRvV3dDb252ZXJ0b3JzID0gY3JlYXRlV3dDb252ZXJ0b3JzKHRvSFRNTENvbnZlcnRvcnMpO1xuICAgICAgICB0aGlzLnRvTWRDb252ZXJ0b3JzID0gY3JlYXRlTWRDb252ZXJ0b3JzKHRvTWRDb252ZXJ0b3JzIHx8IHt9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdzZXRGb2N1c2VkTm9kZScsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAoX3RoaXMuZm9jdXNlZE5vZGUgPSBub2RlKTsgfSk7XG4gICAgfVxuICAgIENvbnZlcnRvci5wcm90b3R5cGUuZ2V0TWFwcGVkUG9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBwZWRQb3NXaGVuQ29udmVydGluZztcbiAgICB9O1xuICAgIENvbnZlcnRvci5wcm90b3R5cGUuZ2V0SW5mb0ZvclBvc1N5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuZm9jdXNlZE5vZGUsIHNldE1hcHBlZFBvczogdGhpcy5zZXRNYXBwZWRQb3MgfTtcbiAgICB9O1xuICAgIENvbnZlcnRvci5wcm90b3R5cGUudG9XeXNpd3lnTW9kZWwgPSBmdW5jdGlvbiAobWROb2RlKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IG5ldyBUb1d3Q29udmVydG9yU3RhdGUodGhpcy5zY2hlbWEsIHRoaXMudG9Xd0NvbnZlcnRvcnMpO1xuICAgICAgICByZXR1cm4gc3RhdGUuY29udmVydE5vZGUobWROb2RlLCB0aGlzLmdldEluZm9Gb3JQb3NTeW5jKCkpO1xuICAgIH07XG4gICAgQ29udmVydG9yLnByb3RvdHlwZS50b01hcmtkb3duVGV4dCA9IGZ1bmN0aW9uICh3d05vZGUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gbmV3IFRvTWRDb252ZXJ0b3JTdGF0ZSh0aGlzLnRvTWRDb252ZXJ0b3JzKTtcbiAgICAgICAgdmFyIG1hcmtkb3duVGV4dCA9IHN0YXRlLmNvbnZlcnROb2RlKHd3Tm9kZSwgdGhpcy5nZXRJbmZvRm9yUG9zU3luYygpKTtcbiAgICAgICAgbWFya2Rvd25UZXh0ID0gdGhpcy5ldmVudEVtaXR0ZXIuZW1pdFJlZHVjZSgnYmVmb3JlQ29udmVydFd5c2l3eWdUb01hcmtkb3duJywgbWFya2Rvd25UZXh0KTtcbiAgICAgICAgcmV0dXJuIG1hcmtkb3duVGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBDb252ZXJ0b3I7XG59KCkpO1xuXG5mdW5jdGlvbiBleGVjUGx1Z2luKHBsdWdpbkluZm8pIHtcbiAgICB2YXIgcGx1Z2luID0gcGx1Z2luSW5mby5wbHVnaW4sIGV2ZW50RW1pdHRlciA9IHBsdWdpbkluZm8uZXZlbnRFbWl0dGVyLCB1c2FnZVN0YXRpc3RpY3MgPSBwbHVnaW5JbmZvLnVzYWdlU3RhdGlzdGljcywgaW5zdGFuY2UgPSBwbHVnaW5JbmZvLmluc3RhbmNlO1xuICAgIHZhciBwbVN0YXRlID0geyBQbHVnaW46IFBsdWdpbiwgUGx1Z2luS2V5OiBQbHVnaW5LZXksIFNlbGVjdGlvbjogU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uOiBUZXh0U2VsZWN0aW9uIH07XG4gICAgdmFyIHBtVmlldyA9IHsgRGVjb3JhdGlvbjogRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldDogRGVjb3JhdGlvblNldCB9O1xuICAgIHZhciBwbU1vZGVsID0geyBGcmFnbWVudDogRnJhZ21lbnQgfTtcbiAgICB2YXIgcG1SdWxlcyA9IHsgSW5wdXRSdWxlOiBJbnB1dFJ1bGUsIGlucHV0UnVsZXM6IGlucHV0UnVsZXMsIHVuZG9JbnB1dFJ1bGU6IHVuZG9JbnB1dFJ1bGUgfTtcbiAgICB2YXIgcG1LZXltYXAgPSB7IGtleW1hcDoga2V5bWFwIH07XG4gICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgIGV2ZW50RW1pdHRlcjogZXZlbnRFbWl0dGVyLFxuICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHVzYWdlU3RhdGlzdGljcyxcbiAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICBwbVN0YXRlOiBwbVN0YXRlLFxuICAgICAgICBwbVZpZXc6IHBtVmlldyxcbiAgICAgICAgcG1Nb2RlbDogcG1Nb2RlbCxcbiAgICAgICAgcG1SdWxlczogcG1SdWxlcyxcbiAgICAgICAgcG1LZXltYXA6IHBtS2V5bWFwLFxuICAgICAgICBpMThuOiBpMThuLFxuICAgIH07XG4gICAgaWYgKGlzQXJyYXlfMShwbHVnaW4pKSB7XG4gICAgICAgIHZhciBwbHVnaW5GbiA9IHBsdWdpblswXSwgX2EgPSBwbHVnaW5bMV0sIG9wdGlvbnMgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYTtcbiAgICAgICAgcmV0dXJuIHBsdWdpbkZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcGx1Z2luKGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZ2V0UGx1Z2luSW5mbyhwbHVnaW5zSW5mbykge1xuICAgIHZhciBwbHVnaW5zID0gcGx1Z2luc0luZm8ucGx1Z2lucywgZXZlbnRFbWl0dGVyID0gcGx1Z2luc0luZm8uZXZlbnRFbWl0dGVyLCB1c2FnZVN0YXRpc3RpY3MgPSBwbHVnaW5zSW5mby51c2FnZVN0YXRpc3RpY3MsIGluc3RhbmNlID0gcGx1Z2luc0luZm8uaW5zdGFuY2U7XG4gICAgZXZlbnRFbWl0dGVyLmxpc3RlbignbWl4aW5UYWJsZU9mZnNldE1hcFByb3RvdHlwZScsIG1peGluVGFibGVPZmZzZXRNYXBQcm90b3R5cGUpO1xuICAgIHJldHVybiAocGx1Z2lucyAhPT0gbnVsbCAmJiBwbHVnaW5zICE9PSB2b2lkIDAgPyBwbHVnaW5zIDogW10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbHVnaW4pIHtcbiAgICAgICAgdmFyIHBsdWdpbkluZm9SZXN1bHQgPSBleGVjUGx1Z2luKHtcbiAgICAgICAgICAgIHBsdWdpbjogcGx1Z2luLFxuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiBldmVudEVtaXR0ZXIsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHVzYWdlU3RhdGlzdGljcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcGx1Z2luSW5mb1Jlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRlZCBwbHVnaW4gaXMgZW1wdHkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmtkb3duUGFyc2VycyA9IHBsdWdpbkluZm9SZXN1bHQubWFya2Rvd25QYXJzZXJzLCB0b0hUTUxSZW5kZXJlcnMgPSBwbHVnaW5JbmZvUmVzdWx0LnRvSFRNTFJlbmRlcmVycywgdG9NYXJrZG93blJlbmRlcmVycyA9IHBsdWdpbkluZm9SZXN1bHQudG9NYXJrZG93blJlbmRlcmVycywgbWFya2Rvd25QbHVnaW5zID0gcGx1Z2luSW5mb1Jlc3VsdC5tYXJrZG93blBsdWdpbnMsIHd5c2l3eWdQbHVnaW5zID0gcGx1Z2luSW5mb1Jlc3VsdC53eXNpd3lnUGx1Z2lucywgd3lzaXd5Z05vZGVWaWV3cyA9IHBsdWdpbkluZm9SZXN1bHQud3lzaXd5Z05vZGVWaWV3cywgbWFya2Rvd25Db21tYW5kcyA9IHBsdWdpbkluZm9SZXN1bHQubWFya2Rvd25Db21tYW5kcywgd3lzaXd5Z0NvbW1hbmRzID0gcGx1Z2luSW5mb1Jlc3VsdC53eXNpd3lnQ29tbWFuZHMsIHRvb2xiYXJJdGVtcyA9IHBsdWdpbkluZm9SZXN1bHQudG9vbGJhckl0ZW1zO1xuICAgICAgICBpZiAodG9IVE1MUmVuZGVyZXJzKSB7XG4gICAgICAgICAgICBhY2MudG9IVE1MUmVuZGVyZXJzID0gZGVlcE1lcmdlZENvcHkoYWNjLnRvSFRNTFJlbmRlcmVycywgdG9IVE1MUmVuZGVyZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9NYXJrZG93blJlbmRlcmVycykge1xuICAgICAgICAgICAgYWNjLnRvTWFya2Rvd25SZW5kZXJlcnMgPSBkZWVwTWVyZ2VkQ29weShhY2MudG9NYXJrZG93blJlbmRlcmVycywgdG9NYXJrZG93blJlbmRlcmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtkb3duUGx1Z2lucykge1xuICAgICAgICAgICAgYWNjLm1kUGx1Z2lucyA9IGFjYy5tZFBsdWdpbnMuY29uY2F0KG1hcmtkb3duUGx1Z2lucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHd5c2l3eWdQbHVnaW5zKSB7XG4gICAgICAgICAgICBhY2Mud3dQbHVnaW5zID0gYWNjLnd3UGx1Z2lucy5jb25jYXQod3lzaXd5Z1BsdWdpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3eXNpd3lnTm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBhY2Mud3dOb2RlVmlld3MgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGFjYy53d05vZGVWaWV3cyksIHd5c2l3eWdOb2RlVmlld3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZG93bkNvbW1hbmRzKSB7XG4gICAgICAgICAgICBhY2MubWRDb21tYW5kcyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgYWNjLm1kQ29tbWFuZHMpLCBtYXJrZG93bkNvbW1hbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3lzaXd5Z0NvbW1hbmRzKSB7XG4gICAgICAgICAgICBhY2Mud3dDb21tYW5kcyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgYWNjLnd3Q29tbWFuZHMpLCB3eXNpd3lnQ29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b29sYmFySXRlbXMpIHtcbiAgICAgICAgICAgIGFjYy50b29sYmFySXRlbXMgPSBhY2MudG9vbGJhckl0ZW1zLmNvbmNhdCh0b29sYmFySXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZG93blBhcnNlcnMpIHtcbiAgICAgICAgICAgIGFjYy5tYXJrZG93blBhcnNlcnMgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGFjYy5tYXJrZG93blBhcnNlcnMpLCBtYXJrZG93blBhcnNlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge1xuICAgICAgICB0b0hUTUxSZW5kZXJlcnM6IHt9LFxuICAgICAgICB0b01hcmtkb3duUmVuZGVyZXJzOiB7fSxcbiAgICAgICAgbWRQbHVnaW5zOiBbXSxcbiAgICAgICAgd3dQbHVnaW5zOiBbXSxcbiAgICAgICAgd3dOb2RlVmlld3M6IHt9LFxuICAgICAgICBtZENvbW1hbmRzOiB7fSxcbiAgICAgICAgd3dDb21tYW5kczoge30sXG4gICAgICAgIHRvb2xiYXJJdGVtczogW10sXG4gICAgICAgIG1hcmtkb3duUGFyc2Vyczoge30sXG4gICAgfSk7XG59XG5cbnZhciBUQVNLX0FUVFJfTkFNRSA9ICdkYXRhLXRhc2snO1xudmFyIERJU0FCTEVEX1RBU0tfQVRUUl9OQU1FID0gJ2RhdGEtdGFzay1kaXNhYmxlZCc7XG52YXIgVEFTS19DSEVDS0VEX0NMQVNTX05BTUUgPSAnY2hlY2tlZCc7XG5mdW5jdGlvbiByZWdpc3RlckhUTUxUYWdUb1doaXRlbGlzdChjb252ZXJ0b3JNYXApIHtcbiAgICBbJ2h0bWxCbG9jaycsICdodG1sSW5saW5lJ10uZm9yRWFjaChmdW5jdGlvbiAoaHRtbFR5cGUpIHtcbiAgICAgICAgaWYgKGNvbnZlcnRvck1hcFtodG1sVHlwZV0pIHtcbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRhZyB3aGl0ZSBsaXN0IGZvciBwcmV2ZW50aW5nIHRvIHJlbW92ZSB0aGUgaHRtbCBpbiBzYW5pdGl6ZXJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnZlcnRvck1hcFtodG1sVHlwZV0pLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHJlZ2lzdGVyVGFnV2hpdGVsaXN0SWZQb3NzaWJsZSh0eXBlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQ2xhc3MgVG9hc3RVSUVkaXRvclZpZXdlclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9uIG9iamVjdFxuICogICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuZWwgLSBjb250YWluZXIgZWxlbWVudFxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbml0aWFsVmFsdWVdIEVkaXRvcidzIGluaXRpYWwgdmFsdWVcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXZlbnRzXSAtIEV2ZW50c1xuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMubG9hZF0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZWRpdG9yIGZ1bGx5IGxvYWRcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmNoYW5nZV0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gY29udGVudCBjaGFuZ2VkXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5jYXJldENoYW5nZV0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZm9ybWF0IGNoYW5nZSBieSBjdXJzb3IgcG9zaXRpb25cbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmZvY3VzXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgZ2V0IGZvY3VzXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5ibHVyXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgbG9vc2UgZm9jdXNcbiAqICAgICBAcGFyYW0ge0FycmF5LjxmdW5jdGlvbnxBcnJheT59IFtvcHRpb25zLnBsdWdpbnNdIC0gQXJyYXkgb2YgcGx1Z2lucy4gQSBwbHVnaW4gY2FuIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5IGluIHRoZSBmb3JtIG9mIFtmdW5jdGlvbiwgb3B0aW9uc10uXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuZGVkQXV0b2xpbmtzXSAtIFVzaW5nIGV4dGVuZGVkIEF1dG9saW5rcyBzcGVjaWZpZWQgaW4gR0ZNIHNwZWNcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGlua0F0dHJpYnV0ZXNdIC0gQXR0cmlidXRlcyBvZiBhbmNob3IgZWxlbWVudCB0aGF0IHNob3VsZCBiZSByZWwsIHRhcmdldCwgaHJlZmxhbmcsIHR5cGVcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY3VzdG9tSFRNTFJlbmRlcmVyPW51bGxdIC0gT2JqZWN0IGNvbnRhaW5pbmcgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9ucyBjb3JyZXNwb25kIHRvIGNoYW5nZSBtYXJrZG93biBub2RlIHRvIHByZXZpZXcgSFRNTCBvciB3eXNpd3lnIG5vZGVcbiAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb249ZmFsc2VdIC0gd2hldGhlciB1c2UgdGhlIHNwZWNpZmljYXRpb24gb2YgbGluayByZWZlcmVuY2UgZGVmaW5pdGlvblxuICogICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmN1c3RvbUhUTUxTYW5pdGl6ZXI9bnVsbF0gLSBjdXN0b20gSFRNTCBzYW5pdGl6ZXJcbiAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZyb250TWF0dGVyPWZhbHNlXSAtIHdoZXRoZXIgdXNlIHRoZSBmcm9udCBtYXR0ZXJcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGhlbWVdIC0gVGhlIHRoZW1lIHRvIHN0eWxlIHRoZSB2aWV3ZXIgd2l0aC4gVGhlIGRlZmF1bHQgaXMgaW5jbHVkZWQgaW4gdG9hc3R1aS1lZGl0b3IuY3NzLlxuICovXG52YXIgVG9hc3RVSUVkaXRvclZpZXdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2FzdFVJRWRpdG9yVmlld2VyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kXzEoe1xuICAgICAgICAgICAgbGlua0F0dHJpYnV0ZXM6IG51bGwsXG4gICAgICAgICAgICBleHRlbmRlZEF1dG9saW5rczogZmFsc2UsXG4gICAgICAgICAgICBjdXN0b21IVE1MUmVuZGVyZXI6IG51bGwsXG4gICAgICAgICAgICByZWZlcmVuY2VEZWZpbml0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGN1c3RvbUhUTUxTYW5pdGl6ZXI6IG51bGwsXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZmFsc2UsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHRydWUsXG4gICAgICAgICAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB2YXIgbGlua0F0dHJpYnV0ZXMgPSBzYW5pdGl6ZUxpbmtBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmxpbmtBdHRyaWJ1dGVzKTtcbiAgICAgICAgdmFyIF9hID0gZ2V0UGx1Z2luSW5mbyh7XG4gICAgICAgICAgICBwbHVnaW5zOiB0aGlzLm9wdGlvbnMucGx1Z2lucyxcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlcjogdGhpcy5ldmVudEVtaXR0ZXIsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHRoaXMub3B0aW9ucy51c2FnZVN0YXRpc3RpY3MsXG4gICAgICAgICAgICBpbnN0YW5jZTogdGhpcyxcbiAgICAgICAgfSkgfHwge30sIHRvSFRNTFJlbmRlcmVycyA9IF9hLnRvSFRNTFJlbmRlcmVycywgbWFya2Rvd25QYXJzZXJzID0gX2EubWFya2Rvd25QYXJzZXJzO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLm9wdGlvbnMsIGN1c3RvbUhUTUxSZW5kZXJlciA9IF9iLmN1c3RvbUhUTUxSZW5kZXJlciwgZXh0ZW5kZWRBdXRvbGlua3MgPSBfYi5leHRlbmRlZEF1dG9saW5rcywgcmVmZXJlbmNlRGVmaW5pdGlvbiA9IF9iLnJlZmVyZW5jZURlZmluaXRpb24sIGZyb250TWF0dGVyID0gX2IuZnJvbnRNYXR0ZXIsIGN1c3RvbUhUTUxTYW5pdGl6ZXIgPSBfYi5jdXN0b21IVE1MU2FuaXRpemVyO1xuICAgICAgICB2YXIgcmVuZGVyZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgbGlua0F0dHJpYnV0ZXM6IGxpbmtBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFJlbmRlcmVyOiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHRvSFRNTFJlbmRlcmVycyksIGN1c3RvbUhUTUxSZW5kZXJlciksXG4gICAgICAgICAgICBleHRlbmRlZEF1dG9saW5rczogZXh0ZW5kZWRBdXRvbGlua3MsXG4gICAgICAgICAgICByZWZlcmVuY2VEZWZpbml0aW9uOiByZWZlcmVuY2VEZWZpbml0aW9uLFxuICAgICAgICAgICAgZnJvbnRNYXR0ZXI6IGZyb250TWF0dGVyLFxuICAgICAgICAgICAgc2FuaXRpemVyOiBjdXN0b21IVE1MU2FuaXRpemVyIHx8IHNhbml0aXplSFRNTCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVnaXN0ZXJIVE1MVGFnVG9XaGl0ZWxpc3QocmVuZGVyZXJPcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlcik7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgICAgICBmb3JFYWNoT3duUHJvcGVydGllc18xKHRoaXMub3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uIChmbiwga2V5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub24oa2V5LCBmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2MgPSB0aGlzLm9wdGlvbnMsIGVsID0gX2MuZWwsIGluaXRpYWxWYWx1ZSA9IF9jLmluaXRpYWxWYWx1ZSwgdGhlbWUgPSBfYy50aGVtZTtcbiAgICAgICAgdmFyIGV4aXN0aW5nSFRNTCA9IGVsLmlubmVySFRNTDtcbiAgICAgICAgaWYgKHRoZW1lICE9PSAnbGlnaHQnKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyh0aGVtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLnRvYXN0TWFyayA9IG5ldyBUb2FzdE1hcmsoJycsIHtcbiAgICAgICAgICAgIGRpc2FsbG93ZWRIdG1sQmxvY2tUYWdzOiBbJ2JyJywgJ2ltZyddLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGV4dGVuZGVkQXV0b2xpbmtzLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogcmVmZXJlbmNlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGRpc2FsbG93RGVlcEhlYWRpbmc6IHRydWUsXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIsXG4gICAgICAgICAgICBjdXN0b21QYXJzZXI6IG1hcmtkb3duUGFyc2VycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJldmlldyA9IG5ldyBNYXJrZG93blByZXZpZXcodGhpcy5ldmVudEVtaXR0ZXIsIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgcmVuZGVyZXJPcHRpb25zKSwgeyBpc1ZpZXdlcjogdHJ1ZSB9KSk7XG4gICAgICAgIG9uXzEodGhpcy5wcmV2aWV3LnByZXZpZXdDb250ZW50LCAnbW91c2Vkb3duJywgdGhpcy50b2dnbGVUYXNrLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1hcmtkb3duKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhpc3RpbmdIVE1MKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcuc2V0SFRNTChleGlzdGluZ0hUTUwpO1xuICAgICAgICB9XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMucHJldmlldy5wcmV2aWV3Q29udGVudCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2xvYWQnLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRhc2sgYnkgZGV0ZWN0aW5nIG1vdXNlZG93biBldmVudC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2IC0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLnRvZ2dsZVRhc2sgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBldi50YXJnZXQ7XG4gICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgJzpiZWZvcmUnKTtcbiAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShESVNBQkxFRF9UQVNLX0FUVFJfTkFNRSkgJiZcbiAgICAgICAgICAgIGVsZW1lbnQuaGFzQXR0cmlidXRlKFRBU0tfQVRUUl9OQU1FKSAmJlxuICAgICAgICAgICAgaXNQb3NpdGlvbkluQm94KHN0eWxlLCBldi5vZmZzZXRYLCBldi5vZmZzZXRZKSkge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZWxlbWVudCwgVEFTS19DSEVDS0VEX0NMQVNTX05BTUUpO1xuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogJ3ZpZXdlcicsXG4gICAgICAgICAgICAgICAgZGF0ZTogZXYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGNvbnRlbnQgZm9yIHByZXZpZXdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya2Rvd24gTWFya2Rvd24gdGV4dFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLnNldE1hcmtkb3duID0gZnVuY3Rpb24gKG1hcmtkb3duKSB7XG4gICAgICAgIHZhciBsaW5lVGV4dHMgPSB0aGlzLnRvYXN0TWFyay5nZXRMaW5lVGV4dHMoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpbmVUZXh0cy5sZW5ndGg7XG4gICAgICAgIHZhciBsYXN0TGluZSA9IGxhc3QkMShsaW5lVGV4dHMpO1xuICAgICAgICB2YXIgZW5kU291cmNlcG9zID0gW2xlbmd0aCwgbGFzdExpbmUubGVuZ3RoICsgMV07XG4gICAgICAgIHZhciBlZGl0UmVzdWx0ID0gdGhpcy50b2FzdE1hcmsuZWRpdE1hcmtkb3duKFsxLCAxXSwgZW5kU291cmNlcG9zLCBtYXJrZG93biB8fCAnJyk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3VwZGF0ZVByZXZpZXcnLCBlZGl0UmVzdWx0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJpbmQgZXZlbnRIYW5kbGVyIHRvIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4odHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmJpbmQgZXZlbnRIYW5kbGVyIGZyb20gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIodHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgaG9vayB0byBUVUlFZGl0b3IgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuYWRkSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcih0eXBlKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKHR5cGUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIFZpZXdlciBwcmV2aWV3IGZyb20gZG9jdW1lbnRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmZfMSh0aGlzLnByZXZpZXcuZWwsICdtb3VzZWRvd24nLCB0aGlzLnRvZ2dsZVRhc2suYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucHJldmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuaXNWaWV3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZhbHNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuaXNNYXJrZG93bk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBmYWxzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLmlzV3lzaXd5Z01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBUb2FzdFVJRWRpdG9yVmlld2VyO1xufSgpKTtcblxuZnVuY3Rpb24gaXNQbU5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSQzO1xufVxuZnVuY3Rpb24gaXNDb250YWluZXIodHlwZSkge1xuICAgIHZhciBjb250YWluZXJUeXBlcyA9IFtcbiAgICAgICAgJ2RvY3VtZW50JyxcbiAgICAgICAgJ2Jsb2NrUXVvdGUnLFxuICAgICAgICAnYnVsbGV0TGlzdCcsXG4gICAgICAgICdvcmRlcmVkTGlzdCcsXG4gICAgICAgICdsaXN0SXRlbScsXG4gICAgICAgICdwYXJhZ3JhcGgnLFxuICAgICAgICAnaGVhZGluZycsXG4gICAgICAgICdlbXBoJyxcbiAgICAgICAgJ3N0cm9uZycsXG4gICAgICAgICdzdHJpa2UnLFxuICAgICAgICAnbGluaycsXG4gICAgICAgICdpbWFnZScsXG4gICAgICAgICd0YWJsZScsXG4gICAgICAgICd0YWJsZUhlYWQnLFxuICAgICAgICAndGFibGVCb2R5JyxcbiAgICAgICAgJ3RhYmxlUm93JyxcbiAgICAgICAgJ3RhYmxlSGVhZENlbGwnLFxuICAgICAgICAndGFibGVCb2R5Q2VsbCcsXG4gICAgXTtcbiAgICByZXR1cm4gaW5jbHVkZXMoY29udGFpbmVyVHlwZXMsIHR5cGUpO1xufVxuZnVuY3Rpb24gY3JlYXRlTWRMaWtlTm9kZShub2RlKSB7XG4gICAgdmFyIGF0dHJzID0gbm9kZS5hdHRycywgdHlwZSA9IG5vZGUudHlwZTtcbiAgICB2YXIgbm9kZVR5cGUgPSB0eXBlLm5hbWU7XG4gICAgdmFyIG1kTGlrZU5vZGUgPSB7XG4gICAgICAgIHR5cGU6IG5vZGVUeXBlLFxuICAgICAgICB3eXNpd3lnTm9kZTogdHJ1ZSxcbiAgICAgICAgbGl0ZXJhbDogIWlzQ29udGFpbmVyKG5vZGVUeXBlKSAmJiBpc1BtTm9kZShub2RlKSA/IG5vZGUudGV4dENvbnRlbnQgOiBudWxsLFxuICAgIH07XG4gICAgdmFyIG5vZGVUeXBlTWFwID0ge1xuICAgICAgICBoZWFkaW5nOiB7IGxldmVsOiBhdHRycy5sZXZlbCB9LFxuICAgICAgICBsaW5rOiB7IGRlc3RpbmF0aW9uOiBhdHRycy5saW5rVXJsLCB0aXRsZTogYXR0cnMudGl0bGUgfSxcbiAgICAgICAgaW1hZ2U6IHsgZGVzdGluYXRpb246IGF0dHJzLmltYWdlVXJsIH0sXG4gICAgICAgIGNvZGVCbG9jazogeyBpbmZvOiBhdHRycy5sYW5ndWFnZSB9LFxuICAgICAgICBidWxsZXRMaXN0OiB7IHR5cGU6ICdsaXN0JywgbGlzdERhdGE6IHsgdHlwZTogJ2J1bGxldCcgfSB9LFxuICAgICAgICBvcmRlcmVkTGlzdDogeyB0eXBlOiAnbGlzdCcsIGxpc3REYXRhOiB7IHR5cGU6ICdvcmRlcmVkJywgc3RhcnQ6IGF0dHJzLm9yZGVyIH0gfSxcbiAgICAgICAgbGlzdEl0ZW06IHsgdHlwZTogJ2l0ZW0nLCBsaXN0RGF0YTogeyB0YXNrOiBhdHRycy50YXNrLCBjaGVja2VkOiBhdHRycy5jaGVja2VkIH0gfSxcbiAgICAgICAgdGFibGVIZWFkQ2VsbDogeyB0eXBlOiAndGFibGVDZWxsJywgY2VsbFR5cGU6ICdoZWFkJywgYWxpZ246IGF0dHJzLmFsaWduIH0sXG4gICAgICAgIHRhYmxlQm9keUNlbGw6IHsgdHlwZTogJ3RhYmxlQ2VsbCcsIGNlbGxUeXBlOiAnYm9keScsIGFsaWduOiBhdHRycy5hbGlnbiB9LFxuICAgICAgICBjdXN0b21CbG9jazogeyBpbmZvOiBhdHRycy5pbmZvIH0sXG4gICAgfTtcbiAgICB2YXIgbm9kZUluZm8gPSBub2RlVHlwZU1hcFtub2RlVHlwZV07XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIG1kTGlrZU5vZGUpLCBub2RlSW5mbyk7XG4gICAgLy8gaHRtbCBibG9jaywgaW5saW5lIG5vZGVcbiAgICB2YXIgX2EgPSBub2RlLmF0dHJzLCBodG1sQXR0cnMgPSBfYS5odG1sQXR0cnMsIGNoaWxkcmVuSFRNTCA9IF9hLmNoaWxkcmVuSFRNTDtcbiAgICBpZiAoaHRtbEF0dHJzKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGF0dHJpYnV0ZXMpLCB7IGF0dHJzOiBodG1sQXR0cnMsIGNoaWxkcmVuSFRNTDogY2hpbGRyZW5IVE1MIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn1cblxudmFyIHRva2VuVG9ET01Ob2RlID0ge1xuICAgIG9wZW5UYWc6IGZ1bmN0aW9uICh0b2tlbiwgc3RhY2spIHtcbiAgICAgICAgdmFyIF9hID0gdG9rZW4sIHRhZ05hbWUgPSBfYS50YWdOYW1lLCBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcywgYXR0cmlidXRlcyA9IF9hLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGF0dHJzID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhdHRycyksIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHNldEF0dHJpYnV0ZXMoYXR0cnMsIGVsKTtcbiAgICAgICAgc3RhY2sucHVzaChlbCk7XG4gICAgfSxcbiAgICBjbG9zZVRhZzogZnVuY3Rpb24gKF8sIHN0YWNrKSB7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxhc3QkMShzdGFjaykuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBodG1sOiBmdW5jdGlvbiAodG9rZW4sIHN0YWNrKSB7XG4gICAgICAgIGxhc3QkMShzdGFjaykuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCB0b2tlbi5jb250ZW50KTtcbiAgICB9LFxuICAgIHRleHQ6IGZ1bmN0aW9uICh0b2tlbiwgc3RhY2spIHtcbiAgICAgICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodG9rZW4uY29udGVudCk7XG4gICAgICAgIGxhc3QkMShzdGFjaykuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgIH0sXG59O1xudmFyIFd3VG9ET01BZGFwdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFd3VG9ET01BZGFwdG9yKGxpbmtBdHRyaWJ1dGVzLCBjdXN0b21SZW5kZXJlcikge1xuICAgICAgICB2YXIgY29udmVydG9ycyA9IGdldEhUTUxSZW5kZXJDb252ZXJ0b3JzKGxpbmtBdHRyaWJ1dGVzLCBjdXN0b21SZW5kZXJlcik7XG4gICAgICAgIHZhciBjdXN0b21IVE1MQ29udmVydG9yID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBjdXN0b21SZW5kZXJlci5odG1sQmxvY2spLCBjdXN0b21SZW5kZXJlci5odG1sSW5saW5lKTtcbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgaHRtbCBibG9jaywgaW5saW5lIGNvbnZlcnRvciB0byBvdGhlciBjdXN0b20gY29udmVydG9yc1xuICAgICAgICB0aGlzLmN1c3RvbUNvbnZlcnRvcktleXMgPSBPYmplY3Qua2V5cyhjdXN0b21SZW5kZXJlcikuY29uY2F0KE9iamVjdC5rZXlzKGN1c3RvbUhUTUxDb252ZXJ0b3IpKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcih7XG4gICAgICAgICAgICBnZm06IHRydWUsXG4gICAgICAgICAgICBjb252ZXJ0b3JzOiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGNvbnZlcnRvcnMpLCBjdXN0b21IVE1MQ29udmVydG9yKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29udmVydG9ycyA9IHRoaXMucmVuZGVyZXIuZ2V0Q29udmVydG9ycygpO1xuICAgIH1cbiAgICBXd1RvRE9NQWRhcHRvci5wcm90b3R5cGUuZ2VuZXJhdGVUb2tlbnMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgbWRMaWtlTm9kZSA9IGNyZWF0ZU1kTGlrZU5vZGUobm9kZSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgZW50ZXJpbmc6IHRydWUsXG4gICAgICAgICAgICBsZWFmOiBpc1BtTm9kZShub2RlKSA/IG5vZGUuaXNMZWFmIDogZmFsc2UsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLnJlbmRlcmVyLmdldE9wdGlvbnMoKSxcbiAgICAgICAgICAgIGdldENoaWxkcmVuVGV4dDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKGlzUG1Ob2RlKG5vZGUpID8gbm9kZS50ZXh0Q29udGVudCA6ICcnKTsgfSxcbiAgICAgICAgICAgIHNraXBDaGlsZHJlbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb252ZXJ0b3IgPSB0aGlzLmNvbnZlcnRvcnNbbm9kZS50eXBlLm5hbWVdO1xuICAgICAgICB2YXIgY29udmVydGVkID0gY29udmVydG9yKG1kTGlrZU5vZGUsIGNvbnRleHQsIHRoaXMuY29udmVydG9ycyk7XG4gICAgICAgIHZhciB0b2tlbnMgPSBpc0FycmF5XzEoY29udmVydGVkKSA/IGNvbnZlcnRlZCA6IFtjb252ZXJ0ZWRdO1xuICAgICAgICBpZiAoaXNDb250YWluZXIobm9kZS50eXBlLm5hbWUpIHx8IG5vZGUuYXR0cnMuaHRtbElubGluZSkge1xuICAgICAgICAgICAgY29udGV4dC5lbnRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IGlzUG1Ob2RlKG5vZGUpID8gbm9kZS50ZXh0Q29udGVudCA6ICcnIH0pO1xuICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChjb252ZXJ0b3IobWRMaWtlTm9kZSwgY29udGV4dCwgdGhpcy5jb252ZXJ0b3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9O1xuICAgIFd3VG9ET01BZGFwdG9yLnByb3RvdHlwZS50b0RPTU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5nZW5lcmF0ZVRva2Vucyhub2RlKTtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIHRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW5Ub0RPTU5vZGVbdG9rZW4udHlwZV0odG9rZW4sIHN0YWNrKTsgfSk7XG4gICAgICAgIHJldHVybiBzdGFja1swXTtcbiAgICB9O1xuICAgIFd3VG9ET01BZGFwdG9yLnByb3RvdHlwZS5nZXRUb0RPTU5vZGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoaW5jbHVkZXModGhpcy5jdXN0b21Db252ZXJ0b3JLZXlzLCBuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9ET01Ob2RlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gV3dUb0RPTUFkYXB0b3I7XG59KCkpO1xuXG52YXIgQU5JTUFUSU9OX1RJTUUgPSAxMDA7XG52YXIgU0NST0xMX0JMT0NLSU5HX1JFU0VUX0RFTEFZID0gMTU7XG52YXIgY3VycmVudFRpbWVvdXRJZCA9IG51bGw7XG52YXIgcmVsZWFzZVRpbWVyID0gbnVsbDtcbmZ1bmN0aW9uIHJ1bihkZWx0YVNjcm9sbFRvcCwgX2EpIHtcbiAgICB2YXIgc3luY1Njcm9sbFRvcCA9IF9hLnN5bmNTY3JvbGxUb3AsIHJlbGVhc2VFdmVudEJsb2NrID0gX2EucmVsZWFzZUV2ZW50QmxvY2s7XG4gICAgaWYgKHJlbGVhc2VUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQocmVsZWFzZVRpbWVyKTtcbiAgICB9XG4gICAgc3luY1Njcm9sbFRvcChkZWx0YVNjcm9sbFRvcCk7XG4gICAgcmVsZWFzZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbGVhc2VFdmVudEJsb2NrKCk7XG4gICAgfSwgU0NST0xMX0JMT0NLSU5HX1JFU0VUX0RFTEFZKTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGUoY3VyU2Nyb2xsVG9wLCB0YXJnZXRTY3JvbGxUb3AsIHN5bmNDYWxsYmFja3MpIHtcbiAgICB2YXIgZGlmZiA9IHRhcmdldFNjcm9sbFRvcCAtIGN1clNjcm9sbFRvcDtcbiAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXBUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHByb2dyZXNzID0gKHN0ZXBUaW1lIC0gc3RhcnRUaW1lKSAvIEFOSU1BVElPTl9USU1FO1xuICAgICAgICB2YXIgZGVsdGFWYWx1ZTtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjdXJyZW50VGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3Jlc3MgPCAxKSB7XG4gICAgICAgICAgICBkZWx0YVZhbHVlID0gY3VyU2Nyb2xsVG9wICsgZGlmZiAqIE1hdGguY29zKCgoMSAtIHByb2dyZXNzKSAqIE1hdGguUEkpIC8gMik7XG4gICAgICAgICAgICBydW4oTWF0aC5jZWlsKGRlbHRhVmFsdWUpLCBzeW5jQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHN0ZXAsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcnVuKHRhcmdldFNjcm9sbFRvcCwgc3luY0NhbGxiYWNrcyk7XG4gICAgICAgICAgICBjdXJyZW50VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc3RlcCgpO1xufVxuXG52YXIgRURJVE9SX0JPVFRPTV9QQURESU5HID0gMTg7XG52YXIgU2Nyb2xsU3luYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxTeW5jKG1kRWRpdG9yLCBwcmV2aWV3LCBldmVudEVtaXR0ZXIpIHtcbiAgICAgICAgdGhpcy5sYXRlc3RFZGl0b3JTY3JvbGxUb3AgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFByZXZpZXdTY3JvbGxUb3AgPSBudWxsO1xuICAgICAgICB0aGlzLmJsb2NrZWRTY3JvbGwgPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgcHJldmlld1Jvb3QgPSBwcmV2aWV3LnByZXZpZXdDb250ZW50LCBwcmV2aWV3RWwgPSBwcmV2aWV3LmVsO1xuICAgICAgICB0aGlzLnByZXZpZXdSb290ID0gcHJldmlld1Jvb3Q7XG4gICAgICAgIHRoaXMucHJldmlld0VsID0gcHJldmlld0VsO1xuICAgICAgICB0aGlzLm1kRWRpdG9yID0gbWRFZGl0b3I7XG4gICAgICAgIHRoaXMuZWRpdG9yVmlldyA9IG1kRWRpdG9yLnZpZXc7XG4gICAgICAgIHRoaXMudG9hc3RNYXJrID0gbWRFZGl0b3IuZ2V0VG9hc3RNYXJrKCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gZXZlbnRFbWl0dGVyO1xuICAgICAgICB0aGlzLmFkZFNjcm9sbFN5bmNFdmVudCgpO1xuICAgIH1cbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5hZGRTY3JvbGxTeW5jRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignYWZ0ZXJQcmV2aWV3UmVuZGVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAgICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdhZnRlclByZXZpZXdSZW5kZXInIGV2ZW50IGhhcyBvY2N1cnJlZCxcbiAgICAgICAgICAgIC8vIGJyb3dzZXIgcmVuZGVyaW5nIGlzIG5vdCB5ZXQgY29tcGxldGUuXG4gICAgICAgICAgICAvLyBTbyB0aGUgc2l6ZSBvZiBlbGVtZW50cyBjYW4gbm90IGJlIGFjY3VyYXRlbHkgbWVhc3VyZWQuXG4gICAgICAgICAgICBfdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN5bmNQcmV2aWV3U2Nyb2xsVG9wKHRydWUpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3Rlbignc2Nyb2xsJywgZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2VkaXRvcicgJiYgX3RoaXMuYmxvY2tlZFNjcm9sbCAhPT0gJ2VkaXRvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3luY1ByZXZpZXdTY3JvbGxUb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3ByZXZpZXcnICYmIF90aGlzLmJsb2NrZWRTY3JvbGwgIT09ICdwcmV2aWV3Jykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zeW5jRWRpdG9yU2Nyb2xsVG9wKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbigndG9nZ2xlU2Nyb2xsU3luYycsIGZ1bmN0aW9uIChhY3RpdmUpIHtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5nZXRNZE5vZGVBdFBvcyA9IGZ1bmN0aW9uIChkb2MsIHBvc0luZm8pIHtcbiAgICAgICAgdmFyIGluZGV4SW5mbyA9IGRvYy5jb250ZW50LmZpbmRJbmRleChwb3NJbmZvLnBvcyk7XG4gICAgICAgIHZhciBsaW5lID0gaW5kZXhJbmZvLmluZGV4O1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShsaW5lICsgMSk7XG4gICAgfTtcbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5nZXRTY3JvbGxUb3BCeUNhcmV0UG9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5tZEVkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIGZpcnN0TWROb2RlID0gdGhpcy50b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShwb3NbMF1bMF0pO1xuICAgICAgICB2YXIgcHJldmlld0hlaWdodCA9IHRoaXMucHJldmlld0VsLmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGVsID0gZ2V0UGFyZW50Tm9kZU9iaih0aGlzLnByZXZpZXdSb290LCBmaXJzdE1kTm9kZSkuZWw7XG4gICAgICAgIHZhciB0b3RhbE9mZnNldFRvcCA9IGdldFRvdGFsT2Zmc2V0VG9wKGVsLCB0aGlzLnByZXZpZXdSb290KSB8fCBlbC5vZmZzZXRUb3A7XG4gICAgICAgIHZhciBub2RlSGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAvLyBtdWx0aXBseSAwLjUgZm9yIGNhbGN1bGF0aW5nIHRoZSBwb3NpdGlvbiBpbiB0aGUgbWlkZGxlIG9mIHByZXZpZXcgYXJlYVxuICAgICAgICB2YXIgdGFyZ2V0U2Nyb2xsVG9wID0gdG90YWxPZmZzZXRUb3AgKyBub2RlSGVpZ2h0IC0gcHJldmlld0hlaWdodCAqIDAuNTtcbiAgICAgICAgdGhpcy5sYXRlc3RFZGl0b3JTY3JvbGxUb3AgPSBudWxsO1xuICAgICAgICB2YXIgZGlmZiA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIHRoaXMucHJldmlld0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgcmV0dXJuIGRpZmYgPCBwcmV2aWV3SGVpZ2h0ID8gbnVsbCA6IHRhcmdldFNjcm9sbFRvcDtcbiAgICB9O1xuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLnN5bmNQcmV2aWV3U2Nyb2xsVG9wID0gZnVuY3Rpb24gKGVkaXRpbmcpIHtcbiAgICAgICAgaWYgKGVkaXRpbmcgPT09IHZvaWQgMCkgeyBlZGl0aW5nID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgZWRpdG9yVmlldyA9IF9hLmVkaXRvclZpZXcsIHByZXZpZXdFbCA9IF9hLnByZXZpZXdFbCwgcHJldmlld1Jvb3QgPSBfYS5wcmV2aWV3Um9vdDtcbiAgICAgICAgdmFyIF9iID0gZWRpdG9yVmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxlZnQgPSBfYi5sZWZ0LCB0b3AgPSBfYi50b3A7XG4gICAgICAgIHZhciBwb3NJbmZvID0gZWRpdG9yVmlldy5wb3NBdENvb3Jkcyh7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH0pO1xuICAgICAgICB2YXIgZG9jID0gZWRpdG9yVmlldy5zdGF0ZS5kb2M7XG4gICAgICAgIHZhciBmaXJzdE1kTm9kZSA9IHRoaXMuZ2V0TWROb2RlQXRQb3MoZG9jLCBwb3NJbmZvKTtcbiAgICAgICAgaWYgKCFmaXJzdE1kTm9kZSB8fCBpc0hUTUxOb2RlKGZpcnN0TWROb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJTY3JvbGxUb3AgPSBwcmV2aWV3RWwuc2Nyb2xsVG9wO1xuICAgICAgICB2YXIgX2MgPSBlZGl0b3JWaWV3LmRvbSwgc2Nyb2xsVG9wID0gX2Muc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQgPSBfYy5zY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCA9IF9jLmNsaWVudEhlaWdodCwgY2hpbGRyZW4gPSBfYy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGlzQm90dG9tUG9zID0gc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsVG9wIDw9IGNsaWVudEhlaWdodCArIEVESVRPUl9CT1RUT01fUEFERElORztcbiAgICAgICAgdmFyIHRhcmdldFNjcm9sbFRvcCA9IGlzQm90dG9tUG9zID8gcHJldmlld0VsLnNjcm9sbEhlaWdodCA6IDA7XG4gICAgICAgIGlmIChzY3JvbGxUb3AgJiYgIWlzQm90dG9tUG9zKSB7XG4gICAgICAgICAgICBpZiAoZWRpdGluZykge1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3BCeUVkaXRpbmcgPSB0aGlzLmdldFNjcm9sbFRvcEJ5Q2FyZXRQb3MoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjcm9sbFRvcEJ5RWRpdGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldFNjcm9sbFRvcCA9IHNjcm9sbFRvcEJ5RWRpdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IGdldFBhcmVudE5vZGVPYmoodGhpcy5wcmV2aWV3Um9vdCwgZmlyc3RNZE5vZGUpLCBlbCA9IF9kLmVsLCBtZE5vZGUgPSBfZC5tZE5vZGU7XG4gICAgICAgICAgICAgICAgdmFyIF9lID0gZ2V0RWRpdG9yUmFuZ2VIZWlnaHRJbmZvKGRvYywgbWROb2RlLCBjaGlsZHJlbiksIGhlaWdodCA9IF9lLmhlaWdodCwgcmVjdCA9IF9lLnJlY3Q7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsT2Zmc2V0VG9wID0gZ2V0VG90YWxPZmZzZXRUb3AoZWwsIHByZXZpZXdSb290KSB8fCBlbC5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVIZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gdG9wID4gcmVjdC50b3AgPyBNYXRoLm1pbigodG9wIC0gcmVjdC50b3ApIC8gaGVpZ2h0LCAxKSA6IDA7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2Nyb2xsVG9wID0gdG90YWxPZmZzZXRUb3AgKyBub2RlSGVpZ2h0ICogcmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRTY3JvbGxUb3AgPSB0aGlzLmdldFJlc29sdmVkU2Nyb2xsVG9wKCdlZGl0b3InLCBzY3JvbGxUb3AsIHRhcmdldFNjcm9sbFRvcCwgY3VyU2Nyb2xsVG9wKTtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0RWRpdG9yU2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRTY3JvbGxUb3AgIT09IGN1clNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy5ydW4oJ2VkaXRvcicsIHRhcmdldFNjcm9sbFRvcCwgY3VyU2Nyb2xsVG9wKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsU3luYy5wcm90b3R5cGUuc3luY0VkaXRvclNjcm9sbFRvcCA9IGZ1bmN0aW9uICh0YXJnZXROb2RlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHRvYXN0TWFyayA9IF9hLnRvYXN0TWFyaywgZWRpdG9yVmlldyA9IF9hLmVkaXRvclZpZXcsIHByZXZpZXdSb290ID0gX2EucHJldmlld1Jvb3QsIHByZXZpZXdFbCA9IF9hLnByZXZpZXdFbDtcbiAgICAgICAgdmFyIGRvbSA9IGVkaXRvclZpZXcuZG9tLCBzdGF0ZSA9IGVkaXRvclZpZXcuc3RhdGU7XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSBwcmV2aWV3RWwuc2Nyb2xsVG9wLCBjbGllbnRIZWlnaHQgPSBwcmV2aWV3RWwuY2xpZW50SGVpZ2h0LCBzY3JvbGxIZWlnaHQgPSBwcmV2aWV3RWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICB2YXIgaXNCb3R0b21Qb3MgPSBzY3JvbGxIZWlnaHQgLSBzY3JvbGxUb3AgPD0gY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgY3VyU2Nyb2xsVG9wID0gZG9tLnNjcm9sbFRvcDtcbiAgICAgICAgdmFyIHRhcmdldFNjcm9sbFRvcCA9IGlzQm90dG9tUG9zID8gZG9tLnNjcm9sbEhlaWdodCA6IDA7XG4gICAgICAgIGlmIChzY3JvbGxUb3AgJiYgdGFyZ2V0Tm9kZSAmJiAhaXNCb3R0b21Qb3MpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSBmaW5kQW5jZXN0b3JIYXZpbmdJZCh0YXJnZXROb2RlLCBwcmV2aWV3Um9vdCk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW5vZGVpZCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZG9tLmNoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIG1kTm9kZUlkID0gTnVtYmVyKHRhcmdldE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW5vZGVpZCcpKTtcbiAgICAgICAgICAgIHZhciBfYiA9IGdldFBhcmVudE5vZGVPYmoodGhpcy5wcmV2aWV3Um9vdCwgdG9hc3RNYXJrLmZpbmROb2RlQnlJZChtZE5vZGVJZCkpLCBtZE5vZGUgPSBfYi5tZE5vZGUsIGVsID0gX2IuZWw7XG4gICAgICAgICAgICB2YXIgbWROb2RlU3RhcnRMaW5lID0gZ2V0TWRTdGFydExpbmUobWROb2RlKTtcbiAgICAgICAgICAgIHRhcmdldFNjcm9sbFRvcCA9IGNoaWxkcmVuW21kTm9kZVN0YXJ0TGluZSAtIDFdLm9mZnNldFRvcDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBnZXRFZGl0b3JSYW5nZUhlaWdodEluZm8oc3RhdGUuZG9jLCBtZE5vZGUsIGNoaWxkcmVuKS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgX2MgPSBnZXRBbmRTYXZlT2Zmc2V0SW5mbyhlbCwgcHJldmlld1Jvb3QsIG1kTm9kZUlkKSwgbm9kZUhlaWdodCA9IF9jLm5vZGVIZWlnaHQsIG9mZnNldFRvcCA9IF9jLm9mZnNldFRvcDtcbiAgICAgICAgICAgIHRhcmdldFNjcm9sbFRvcCArPSBnZXRBZGRpdGlvbmFsUG9zKHNjcm9sbFRvcCwgb2Zmc2V0VG9wLCBub2RlSGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICAgICAgdGFyZ2V0U2Nyb2xsVG9wID0gdGhpcy5nZXRSZXNvbHZlZFNjcm9sbFRvcCgncHJldmlldycsIHNjcm9sbFRvcCwgdGFyZ2V0U2Nyb2xsVG9wLCBjdXJTY3JvbGxUb3ApO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RQcmV2aWV3U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXRTY3JvbGxUb3AgIT09IGN1clNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy5ydW4oJ3ByZXZpZXcnLCB0YXJnZXRTY3JvbGxUb3AsIGN1clNjcm9sbFRvcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLmdldFJlc29sdmVkU2Nyb2xsVG9wID0gZnVuY3Rpb24gKGZyb20sIHNjcm9sbFRvcCwgdGFyZ2V0U2Nyb2xsVG9wLCBjdXJTY3JvbGxUb3ApIHtcbiAgICAgICAgdmFyIGxhdGVzdFNjcm9sbFRvcCA9IGZyb20gPT09ICdlZGl0b3InID8gdGhpcy5sYXRlc3RFZGl0b3JTY3JvbGxUb3AgOiB0aGlzLmxhdGVzdFByZXZpZXdTY3JvbGxUb3A7XG4gICAgICAgIGlmIChsYXRlc3RTY3JvbGxUb3AgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRTY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhdGVzdFNjcm9sbFRvcCA8IHNjcm9sbFRvcFxuICAgICAgICAgICAgPyBNYXRoLm1heCh0YXJnZXRTY3JvbGxUb3AsIGN1clNjcm9sbFRvcClcbiAgICAgICAgICAgIDogTWF0aC5taW4odGFyZ2V0U2Nyb2xsVG9wLCBjdXJTY3JvbGxUb3ApO1xuICAgIH07XG4gICAgU2Nyb2xsU3luYy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZyb20sIHRhcmdldFNjcm9sbFRvcCwgY3VyU2Nyb2xsVG9wKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzY3JvbGxUYXJnZXQ7XG4gICAgICAgIGlmIChmcm9tID09PSAnZWRpdG9yJykge1xuICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gdGhpcy5wcmV2aWV3RWw7XG4gICAgICAgICAgICB0aGlzLmJsb2NrZWRTY3JvbGwgPSAncHJldmlldyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSB0aGlzLmVkaXRvclZpZXcuZG9tO1xuICAgICAgICAgICAgdGhpcy5ibG9ja2VkU2Nyb2xsID0gJ2VkaXRvcic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN5bmNDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBzeW5jU2Nyb2xsVG9wOiBmdW5jdGlvbiAoc2Nyb2xsVG9wKSB7IHJldHVybiAoc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCA9IHNjcm9sbFRvcCk7IH0sXG4gICAgICAgICAgICByZWxlYXNlRXZlbnRCbG9jazogZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLmJsb2NrZWRTY3JvbGwgPSBudWxsKTsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgYW5pbWF0ZShjdXJTY3JvbGxUb3AsIHRhcmdldFNjcm9sbFRvcCwgc3luY0NhbGxiYWNrcyk7XG4gICAgfTtcbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5jbGVhclRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIoJ3Njcm9sbCcpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIoJ2FmdGVyUHJldmlld1JlbmRlcicpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjcm9sbFN5bmM7XG59KCkpO1xuXG52YXIgcXVlcnlNYXAgPSB7XG4gICAgZ2V0UG9wdXBJbml0aWFsVmFsdWVzOiBmdW5jdGlvbiAoZWRpdG9yLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciBwb3B1cE5hbWUgPSBwYXlsb2FkLnBvcHVwTmFtZTtcbiAgICAgICAgcmV0dXJuIHBvcHVwTmFtZSA9PT0gJ2xpbmsnID8geyBsaW5rVGV4dDogZWRpdG9yLmdldFNlbGVjdGVkVGV4dCgpIH0gOiB7fTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGJ1aWxkUXVlcnkoZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV2ZW50RW1pdHRlci5saXN0ZW4oJ3F1ZXJ5JywgZnVuY3Rpb24gKHF1ZXJ5LCBwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBxdWVyeU1hcFtxdWVyeV0oZWRpdG9yLCBwYXlsb2FkKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBUb2FzdFVJRWRpdG9yQ29yZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uIG9iamVjdFxuICogICAgIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuZWwgLSBjb250YWluZXIgZWxlbWVudFxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5oZWlnaHQ9JzMwMHB4J10gLSBFZGl0b3IncyBoZWlnaHQgc3R5bGUgdmFsdWUuIEhlaWdodCBpcyBhcHBsaWVkIGFzIGJvcmRlci1ib3ggZXgpICczMDBweCcsICcxMDAlJywgJ2F1dG8nXG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1pbkhlaWdodD0nMjAwcHgnXSAtIEVkaXRvcidzIG1pbi1oZWlnaHQgc3R5bGUgdmFsdWUgaW4gcGl4ZWwgZXgpICczMDBweCdcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5pdGlhbFZhbHVlXSAtIEVkaXRvcidzIGluaXRpYWwgdmFsdWVcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJldmlld1N0eWxlXSAtIE1hcmtkb3duIGVkaXRvcidzIHByZXZpZXcgc3R5bGUgKHRhYiwgdmVydGljYWwpXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcmV2aWV3SGlnaGxpZ2h0ID0gdHJ1ZV0gLSBIaWdobGlnaHQgYSBwcmV2aWV3IGVsZW1lbnQgY29ycmVzcG9uZHMgdG8gdGhlIGN1cnNvciBwb3NpdGlvbiBpbiB0aGUgbWFya2Rvd24gZWRpdG9yXG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmluaXRpYWxFZGl0VHlwZV0gLSBJbml0aWFsIGVkaXRvciB0eXBlIChtYXJrZG93biwgd3lzaXd5ZylcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXZlbnRzXSAtIEV2ZW50c1xuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMubG9hZF0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZWRpdG9yIGZ1bGx5IGxvYWRcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmNoYW5nZV0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gY29udGVudCBjaGFuZ2VkXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5jYXJldENoYW5nZV0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZm9ybWF0IGNoYW5nZSBieSBjdXJzb3IgcG9zaXRpb25cbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmZvY3VzXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgZ2V0IGZvY3VzXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5ibHVyXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgbG9vc2UgZm9jdXNcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmtleWRvd25dIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIHRoZSBrZXkgaXMgcHJlc3NlZCBpbiBlZGl0b3JcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmtleXVwXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiB0aGUga2V5IGlzIHJlbGVhc2VkIGluIGVkaXRvclxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuYmVmb3JlUHJldmlld1JlbmRlcl0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIGJlZm9yZSByZW5kZXJpbmcgdGhlIG1hcmtkb3duIHByZXZpZXcgd2l0aCBodG1sIHN0cmluZ1xuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuYmVmb3JlQ29udmVydFd5c2l3eWdUb01hcmtkb3duXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgYmVmb3JlIGNvbnZlcnRpbmcgd3lzaXd5ZyB0byBtYXJrZG93biB3aXRoIG1hcmtkb3duIHRleHRcbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaG9va3NdIC0gSG9va3NcbiAqICAgICAgICAgQHBhcmFtIHthZGRJbWFnZUJsb2JIb29rfSBbb3B0aW9ucy5ob29rcy5hZGRJbWFnZUJsb2JIb29rXSAtIGhvb2sgZm9yIGltYWdlIHVwbG9hZFxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nZW4tVVMnXSAtIGxhbmd1YWdlXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VDb21tYW5kU2hvcnRjdXQ9dHJ1ZV0gLSB3aGV0aGVyIHVzZSBrZXlib2FyZCBzaG9ydGN1dHMgdG8gcGVyZm9ybSBjb21tYW5kc1xuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudXNhZ2VTdGF0aXN0aWNzPXRydWVdIC0gc2VuZCBob3N0bmFtZSB0byBnb29nbGUgYW5hbHl0aWNzXG4gKiAgICAgQHBhcmFtIHtBcnJheS48c3RyaW5nfHRvb2xiYXJJdGVtc1ZhbHVlPn0gW29wdGlvbnMudG9vbGJhckl0ZW1zXSAtIHRvb2xiYXIgaXRlbXMuXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5oaWRlTW9kZVN3aXRjaD1mYWxzZV0gLSBoaWRlIG1vZGUgc3dpdGNoIHRhYiBiYXJcbiAqICAgICBAcGFyYW0ge0FycmF5LjxmdW5jdGlvbnxBcnJheT59IFtvcHRpb25zLnBsdWdpbnNdIC0gQXJyYXkgb2YgcGx1Z2lucy4gQSBwbHVnaW4gY2FuIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5IGluIHRoZSBmb3JtIG9mIFtmdW5jdGlvbiwgb3B0aW9uc10uXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuZGVkQXV0b2xpbmtzXSAtIFVzaW5nIGV4dGVuZGVkIEF1dG9saW5rcyBzcGVjaWZpZWQgaW4gR0ZNIHNwZWNcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGxhY2Vob2xkZXJdIC0gVGhlIHBsYWNlaG9sZGVyIHRleHQgb2YgdGhlIGVkaXRhYmxlIGVsZW1lbnQuXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxpbmtBdHRyaWJ1dGVzXSAtIEF0dHJpYnV0ZXMgb2YgYW5jaG9yIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVsLCB0YXJnZXQsIGhyZWZsYW5nLCB0eXBlXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlcj1udWxsXSAtIE9iamVjdCBjb250YWluaW5nIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbnMgY29ycmVzcG9uZCB0byBjaGFuZ2UgbWFya2Rvd24gbm9kZSB0byBwcmV2aWV3IEhUTUwgb3Igd3lzaXd5ZyBub2RlXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmN1c3RvbU1hcmtkb3duUmVuZGVyZXI9bnVsbF0gLSBPYmplY3QgY29udGFpbmluZyBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb25zIGNvcnJlc3BvbmQgdG8gY2hhbmdlIHd5c2l3eWcgbm9kZSB0byBtYXJrZG93biB0ZXh0XG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uPWZhbHNlXSAtIHdoZXRoZXIgdXNlIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGxpbmsgcmVmZXJlbmNlIGRlZmluaXRpb25cbiAqICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5jdXN0b21IVE1MU2FuaXRpemVyPW51bGxdIC0gY3VzdG9tIEhUTUwgc2FuaXRpemVyXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wcmV2aWV3SGlnaGxpZ2h0PWZhbHNlXSAtIHdoZXRoZXIgaGlnaGxpZ2h0IHByZXZpZXcgYXJlYVxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZnJvbnRNYXR0ZXI9ZmFsc2VdIC0gd2hldGhlciB1c2UgdGhlIGZyb250IG1hdHRlclxuICogICAgIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IFtvcHRpb25zLndpZGdldFJ1bGVzPVtdXSAtIFRoZSBydWxlcyBmb3IgcmVwbGFjaW5nIHRoZSB0ZXh0IHdpdGggd2lkZ2V0IG5vZGVcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGhlbWVdIC0gVGhlIHRoZW1lIHRvIHN0eWxlIHRoZSBlZGl0b3Igd2l0aC4gVGhlIGRlZmF1bHQgaXMgaW5jbHVkZWQgaW4gdG9hc3R1aS1lZGl0b3IuY3NzLlxuICogICAgIEBwYXJhbSB7YXV0b2ZvY3VzfSBbb3B0aW9ucy5hdXRvZm9jdXM9dHJ1ZV0gLSBhdXRvbWF0aWNhbGx5IGZvY3VzIHRoZSBlZGl0b3Igb24gY3JlYXRpb24uXG4gKi9cbnZhciBUb2FzdFVJRWRpdG9yQ29yZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2FzdFVJRWRpdG9yQ29yZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5pdGlhbEhUTUwgPSBvcHRpb25zLmVsLmlubmVySFRNTDtcbiAgICAgICAgb3B0aW9ucy5lbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kXzEoe1xuICAgICAgICAgICAgcHJldmlld1N0eWxlOiAndGFiJyxcbiAgICAgICAgICAgIHByZXZpZXdIaWdobGlnaHQ6IHRydWUsXG4gICAgICAgICAgICBpbml0aWFsRWRpdFR5cGU6ICdtYXJrZG93bicsXG4gICAgICAgICAgICBoZWlnaHQ6ICczMDBweCcsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6ICcyMDBweCcsXG4gICAgICAgICAgICBsYW5ndWFnZTogJ2VuLVVTJyxcbiAgICAgICAgICAgIHVzZUNvbW1hbmRTaG9ydGN1dDogdHJ1ZSxcbiAgICAgICAgICAgIHVzYWdlU3RhdGlzdGljczogdHJ1ZSxcbiAgICAgICAgICAgIHRvb2xiYXJJdGVtczogW1xuICAgICAgICAgICAgICAgIFsnaGVhZGluZycsICdib2xkJywgJ2l0YWxpYycsICdzdHJpa2UnXSxcbiAgICAgICAgICAgICAgICBbJ2hyJywgJ3F1b3RlJ10sXG4gICAgICAgICAgICAgICAgWyd1bCcsICdvbCcsICd0YXNrJywgJ2luZGVudCcsICdvdXRkZW50J10sXG4gICAgICAgICAgICAgICAgWyd0YWJsZScsICdpbWFnZScsICdsaW5rJ10sXG4gICAgICAgICAgICAgICAgWydjb2RlJywgJ2NvZGVibG9jayddLFxuICAgICAgICAgICAgICAgIFsnc2Nyb2xsU3luYyddLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGhpZGVNb2RlU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzOiBudWxsLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFJlbmRlcmVyOiBudWxsLFxuICAgICAgICAgICAgY3VzdG9tTWFya2Rvd25SZW5kZXJlcjogbnVsbCxcbiAgICAgICAgICAgIHJlZmVyZW5jZURlZmluaXRpb246IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFNhbml0aXplcjogbnVsbCxcbiAgICAgICAgICAgIGZyb250TWF0dGVyOiBmYWxzZSxcbiAgICAgICAgICAgIHdpZGdldFJ1bGVzOiBbXSxcbiAgICAgICAgICAgIHRoZW1lOiAnbGlnaHQnLFxuICAgICAgICAgICAgYXV0b2ZvY3VzOiB0cnVlLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBjdXN0b21IVE1MUmVuZGVyZXIgPSBfYS5jdXN0b21IVE1MUmVuZGVyZXIsIGV4dGVuZGVkQXV0b2xpbmtzID0gX2EuZXh0ZW5kZWRBdXRvbGlua3MsIHJlZmVyZW5jZURlZmluaXRpb24gPSBfYS5yZWZlcmVuY2VEZWZpbml0aW9uLCBmcm9udE1hdHRlciA9IF9hLmZyb250TWF0dGVyLCBjdXN0b21NYXJrZG93blJlbmRlcmVyID0gX2EuY3VzdG9tTWFya2Rvd25SZW5kZXJlciwgdXNlQ29tbWFuZFNob3J0Y3V0ID0gX2EudXNlQ29tbWFuZFNob3J0Y3V0LCBpbml0aWFsRWRpdFR5cGUgPSBfYS5pbml0aWFsRWRpdFR5cGUsIHdpZGdldFJ1bGVzID0gX2Eud2lkZ2V0UnVsZXMsIGN1c3RvbUhUTUxTYW5pdGl6ZXIgPSBfYS5jdXN0b21IVE1MU2FuaXRpemVyO1xuICAgICAgICB0aGlzLm1vZGUgPSBpbml0aWFsRWRpdFR5cGUgfHwgJ21hcmtkb3duJztcbiAgICAgICAgdGhpcy5tZFByZXZpZXdTdHlsZSA9IHRoaXMub3B0aW9ucy5wcmV2aWV3U3R5bGU7XG4gICAgICAgIHRoaXMuaTE4biA9IGkxOG47XG4gICAgICAgIHRoaXMuaTE4bi5zZXRDb2RlKHRoaXMub3B0aW9ucy5sYW5ndWFnZSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBzZXRXaWRnZXRSdWxlcyh3aWRnZXRSdWxlcyk7XG4gICAgICAgIHZhciBsaW5rQXR0cmlidXRlcyA9IHNhbml0aXplTGlua0F0dHJpYnV0ZSh0aGlzLm9wdGlvbnMubGlua0F0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLnBsdWdpbkluZm8gPSBnZXRQbHVnaW5JbmZvKHtcbiAgICAgICAgICAgIHBsdWdpbnM6IHRoaXMub3B0aW9ucy5wbHVnaW5zLFxuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiB0aGlzLmV2ZW50RW1pdHRlcixcbiAgICAgICAgICAgIHVzYWdlU3RhdGlzdGljczogdGhpcy5vcHRpb25zLnVzYWdlU3RhdGlzdGljcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5wbHVnaW5JbmZvLCB0b0hUTUxSZW5kZXJlcnMgPSBfYi50b0hUTUxSZW5kZXJlcnMsIHRvTWFya2Rvd25SZW5kZXJlcnMgPSBfYi50b01hcmtkb3duUmVuZGVyZXJzLCBtZFBsdWdpbnMgPSBfYi5tZFBsdWdpbnMsIHd3UGx1Z2lucyA9IF9iLnd3UGx1Z2lucywgd3dOb2RlVmlld3MgPSBfYi53d05vZGVWaWV3cywgbWRDb21tYW5kcyA9IF9iLm1kQ29tbWFuZHMsIHd3Q29tbWFuZHMgPSBfYi53d0NvbW1hbmRzLCBtYXJrZG93blBhcnNlcnMgPSBfYi5tYXJrZG93blBhcnNlcnM7XG4gICAgICAgIHZhciByZW5kZXJlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBsaW5rQXR0cmlidXRlczogbGlua0F0dHJpYnV0ZXMsXG4gICAgICAgICAgICBjdXN0b21IVE1MUmVuZGVyZXI6IGRlZXBNZXJnZWRDb3B5KHRvSFRNTFJlbmRlcmVycywgY3VzdG9tSFRNTFJlbmRlcmVyKSxcbiAgICAgICAgICAgIGV4dGVuZGVkQXV0b2xpbmtzOiBleHRlbmRlZEF1dG9saW5rcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZURlZmluaXRpb246IHJlZmVyZW5jZURlZmluaXRpb24sXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIsXG4gICAgICAgICAgICBzYW5pdGl6ZXI6IGN1c3RvbUhUTUxTYW5pdGl6ZXIgfHwgc2FuaXRpemVIVE1MLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgd3dUb0RPTUFkYXB0b3IgPSBuZXcgV3dUb0RPTUFkYXB0b3IobGlua0F0dHJpYnV0ZXMsIHJlbmRlcmVyT3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXIpO1xuICAgICAgICB2YXIgaHRtbFNjaGVtYU1hcCA9IGNyZWF0ZUhUTUxTY2hlbWFNYXAocmVuZGVyZXJPcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlciwgcmVuZGVyZXJPcHRpb25zLnNhbml0aXplciwgd3dUb0RPTUFkYXB0b3IpO1xuICAgICAgICB0aGlzLnRvYXN0TWFyayA9IG5ldyBUb2FzdE1hcmsoJycsIHtcbiAgICAgICAgICAgIGRpc2FsbG93ZWRIdG1sQmxvY2tUYWdzOiBbJ2JyJywgJ2ltZyddLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGV4dGVuZGVkQXV0b2xpbmtzLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogcmVmZXJlbmNlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGRpc2FsbG93RGVlcEhlYWRpbmc6IHRydWUsXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIsXG4gICAgICAgICAgICBjdXN0b21QYXJzZXI6IG1hcmtkb3duUGFyc2VycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWRFZGl0b3IgPSBuZXcgTWRFZGl0b3IodGhpcy5ldmVudEVtaXR0ZXIsIHtcbiAgICAgICAgICAgIHRvYXN0TWFyazogdGhpcy50b2FzdE1hcmssXG4gICAgICAgICAgICB1c2VDb21tYW5kU2hvcnRjdXQ6IHVzZUNvbW1hbmRTaG9ydGN1dCxcbiAgICAgICAgICAgIG1kUGx1Z2luczogbWRQbHVnaW5zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcmV2aWV3ID0gbmV3IE1hcmtkb3duUHJldmlldyh0aGlzLmV2ZW50RW1pdHRlciwgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCByZW5kZXJlck9wdGlvbnMpLCB7IGlzVmlld2VyOiBmYWxzZSwgaGlnaGxpZ2h0OiB0aGlzLm9wdGlvbnMucHJldmlld0hpZ2hsaWdodCB9KSk7XG4gICAgICAgIHRoaXMud3dFZGl0b3IgPSBuZXcgV3lzaXd5Z0VkaXRvcih0aGlzLmV2ZW50RW1pdHRlciwge1xuICAgICAgICAgICAgdG9ET01BZGFwdG9yOiB3d1RvRE9NQWRhcHRvcixcbiAgICAgICAgICAgIHVzZUNvbW1hbmRTaG9ydGN1dDogdXNlQ29tbWFuZFNob3J0Y3V0LFxuICAgICAgICAgICAgaHRtbFNjaGVtYU1hcDogaHRtbFNjaGVtYU1hcCxcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzOiBsaW5rQXR0cmlidXRlcyxcbiAgICAgICAgICAgIHd3UGx1Z2luczogd3dQbHVnaW5zLFxuICAgICAgICAgICAgd3dOb2RlVmlld3M6IHd3Tm9kZVZpZXdzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb252ZXJ0b3IgPSBuZXcgQ29udmVydG9yKHRoaXMud3dFZGl0b3IuZ2V0U2NoZW1hKCksIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgdG9NYXJrZG93blJlbmRlcmVycyksIGN1c3RvbU1hcmtkb3duUmVuZGVyZXIpLCBnZXRIVE1MUmVuZGVyQ29udmVydG9ycyhsaW5rQXR0cmlidXRlcywgcmVuZGVyZXJPcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlciksIHRoaXMuZXZlbnRFbWl0dGVyKTtcbiAgICAgICAgdGhpcy5zZXRNaW5IZWlnaHQodGhpcy5vcHRpb25zLm1pbkhlaWdodCk7XG4gICAgICAgIHRoaXMuc2V0SGVpZ2h0KHRoaXMub3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICB0aGlzLnNldE1hcmtkb3duKHRoaXMub3B0aW9ucy5pbml0aWFsVmFsdWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlcih0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRIVE1MKHRoaXMuaW5pdGlhbEhUTUwsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKHRoaXMuZXZlbnRFbWl0dGVyLCB0aGlzLm1kRWRpdG9yLmNvbW1hbmRzLCB0aGlzLnd3RWRpdG9yLmNvbW1hbmRzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tb2RlOyB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2FnZVN0YXRpc3RpY3MpIHtcbiAgICAgICAgICAgIHNlbmRIb3N0TmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsU3luYyA9IG5ldyBTY3JvbGxTeW5jKHRoaXMubWRFZGl0b3IsIHRoaXMucHJldmlldywgdGhpcy5ldmVudEVtaXR0ZXIpO1xuICAgICAgICB0aGlzLmFkZEluaXRFdmVudCgpO1xuICAgICAgICB0aGlzLmFkZEluaXRDb21tYW5kKG1kQ29tbWFuZHMsIHd3Q29tbWFuZHMpO1xuICAgICAgICBidWlsZFF1ZXJ5KHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvb2tzKSB7XG4gICAgICAgICAgICBmb3JFYWNoT3duUHJvcGVydGllc18xKHRoaXMub3B0aW9ucy5ob29rcywgZnVuY3Rpb24gKGZuLCBrZXkpIHsgcmV0dXJuIF90aGlzLmFkZEhvb2soa2V5LCBmbik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgICAgICBmb3JFYWNoT3duUHJvcGVydGllc18xKHRoaXMub3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uIChmbiwga2V5KSB7IHJldHVybiBfdGhpcy5vbihrZXksIGZuKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnbG9hZCcsIHRoaXMpO1xuICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb1N0YXJ0KHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpO1xuICAgIH1cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuYWRkSW5pdEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9uKCduZWVkQ2hhbmdlTW9kZScsIHRoaXMuY2hhbmdlTW9kZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5vbignbG9hZFVJJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmhlaWdodCAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICAgICAgLy8gNzVweCBlcXVhbHMgZGVmYXVsdCBlZGl0b3IgdWkgaGVpZ2h0IC0gdGhlIGVkaXRpbmcgYXJlYSBoZWlnaHRcbiAgICAgICAgICAgICAgICB2YXIgbWluSGVpZ2h0ID0gTWF0aC5taW4ocGFyc2VJbnQoX3RoaXMubWluSGVpZ2h0LCAxMCksIHBhcnNlSW50KF90aGlzLmhlaWdodCwgMTApIC0gNzUpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldE1pbkhlaWdodChtaW5IZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYWRkRGVmYXVsdEltYWdlQmxvYkhvb2sodGhpcy5ldmVudEVtaXR0ZXIpO1xuICAgIH07XG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmFkZEluaXRDb21tYW5kID0gZnVuY3Rpb24gKG1kQ29tbWFuZHMsIHd3Q29tbWFuZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFkZFBsdWdpbkNvbW1hbmRzID0gZnVuY3Rpb24gKHR5cGUsIGNvbW1hbmRNYXApIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbW1hbmRNYXApLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRDb21tYW5kKHR5cGUsIG5hbWUsIGNvbW1hbmRNYXBbbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCgnbWFya2Rvd24nLCAndG9nZ2xlU2Nyb2xsU3luYycsIGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndG9nZ2xlU2Nyb2xsU3luYycsIHBheWxvYWQuYWN0aXZlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgYWRkUGx1Z2luQ29tbWFuZHMoJ21hcmtkb3duJywgbWRDb21tYW5kcyk7XG4gICAgICAgIGFkZFBsdWdpbkNvbW1hbmRzKCd3eXNpd3lnJywgd3dDb21tYW5kcyk7XG4gICAgfTtcbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0Q3VycmVudE1vZGVFZGl0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc01hcmtkb3duTW9kZSgpID8gdGhpcy5tZEVkaXRvciA6IHRoaXMud3dFZGl0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBtZXRob2QgZm9yIEVkaXRvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbiBmb3IgaW5pdGlhbGl6ZSBUVUlFZGl0b3JcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUb2FzdFVJRWRpdG9yQ29yZSBvciBUb2FzdFVJRWRpdG9yVmlld2VyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUuZmFjdG9yeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnZpZXdlciA/IG5ldyBUb2FzdFVJRWRpdG9yVmlld2VyKG9wdGlvbnMpIDogbmV3IFRvYXN0VUlFZGl0b3JDb3JlKG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGxhbmd1YWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNvZGUgLSBjb2RlIGZvciBJMThOIGxhbmd1YWdlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBsYW5ndWFnZSBzZXRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5zZXRMYW5ndWFnZSA9IGZ1bmN0aW9uIChjb2RlLCBkYXRhKSB7XG4gICAgICAgIGkxOG4uc2V0TGFuZ3VhZ2UoY29kZSwgZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjaGFuZ2UgcHJldmlldyBzdHlsZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZSAtICd0YWInfCd2ZXJ0aWNhbCdcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuY2hhbmdlUHJldmlld1N0eWxlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLm1kUHJldmlld1N0eWxlICE9PSBzdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5tZFByZXZpZXdTdHlsZSA9IHN0eWxlO1xuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlUHJldmlld1N0eWxlJywgc3R5bGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBleGVjdXRlIGVkaXRvciBjb21tYW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBjb21tYW5kIG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3BheWxvYWRdIC0gcGF5bG9hZCBmb3IgY29tbWFuZFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKG5hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kTWFuYWdlci5leGVjKG5hbWUsIHBheWxvYWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBlZGl0b3IgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gY29tbWFuZCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tbWFuZCAtIGNvbW1hbmQgaGFuZGxlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5hZGRDb21tYW5kID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbW1hbmRIb2MgPSBmdW5jdGlvbiAocGF5bGFvZCkge1xuICAgICAgICAgICAgaWYgKHBheWxhb2QgPT09IHZvaWQgMCkgeyBwYXlsYW9kID0ge307IH1cbiAgICAgICAgICAgIHZhciB2aWV3ID0gKHR5cGUgPT09ICdtYXJrZG93bicgPyBfdGhpcy5tZEVkaXRvciA6IF90aGlzLnd3RWRpdG9yKS52aWV3O1xuICAgICAgICAgICAgY29tbWFuZChwYXlsYW9kLCB2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoLCB2aWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb21tYW5kTWFuYWdlci5hZGRDb21tYW5kKHR5cGUsIG5hbWUsIGNvbW1hbmRIb2MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQmluZCBldmVudEhhbmRsZXIgdG8gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4odHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmJpbmQgZXZlbnRIYW5kbGVyIGZyb20gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGhvb2sgdG8gVFVJRWRpdG9yIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5hZGRIb29rID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKHR5cGUpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4odHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgaG9vayBmcm9tIFRVSUVkaXRvciBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUucmVtb3ZlSG9vayA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcih0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBmb2N1cyB0byBjdXJyZW50IEVkaXRvclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLmZvY3VzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZm9jdXMgb2YgY3VycmVudCBFZGl0b3JcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLmJsdXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBjdXJzb3IgcG9zaXRpb24gdG8gZW5kXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZm9jdXNdIC0gYXV0b21hdGljYWxseSBmb2N1cyB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLm1vdmVDdXJzb3JUb0VuZCA9IGZ1bmN0aW9uIChmb2N1cykge1xuICAgICAgICBpZiAoZm9jdXMgPT09IHZvaWQgMCkgeyBmb2N1cyA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLm1vdmVDdXJzb3JUb0VuZChmb2N1cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgY3Vyc29yIHBvc2l0aW9uIHRvIHN0YXJ0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZm9jdXNdIC0gYXV0b21hdGljYWxseSBmb2N1cyB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLm1vdmVDdXJzb3JUb1N0YXJ0ID0gZnVuY3Rpb24gKGZvY3VzKSB7XG4gICAgICAgIGlmIChmb2N1cyA9PT0gdm9pZCAwKSB7IGZvY3VzID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkubW92ZUN1cnNvclRvU3RhcnQoZm9jdXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG1hcmtkb3duIHN5bnRheCB0ZXh0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZG93biAtIG1hcmtkb3duIHN5bnRheCB0ZXh0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2N1cnNvclRvRW5kPXRydWVdIC0gbW92ZSBjdXJzb3IgdG8gY29udGVudHMgZW5kXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNldE1hcmtkb3duID0gZnVuY3Rpb24gKG1hcmtkb3duLCBjdXJzb3JUb0VuZCkge1xuICAgICAgICBpZiAobWFya2Rvd24gPT09IHZvaWQgMCkgeyBtYXJrZG93biA9ICcnOyB9XG4gICAgICAgIGlmIChjdXJzb3JUb0VuZCA9PT0gdm9pZCAwKSB7IGN1cnNvclRvRW5kID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLm1kRWRpdG9yLnNldE1hcmtkb3duKG1hcmtkb3duLCBjdXJzb3JUb0VuZCk7XG4gICAgICAgIGlmICh0aGlzLmlzV3lzaXd5Z01vZGUoKSkge1xuICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRoaXMudG9hc3RNYXJrLmdldFJvb3ROb2RlKCk7XG4gICAgICAgICAgICB2YXIgd3dOb2RlID0gdGhpcy5jb252ZXJ0b3IudG9XeXNpd3lnTW9kZWwobWROb2RlKTtcbiAgICAgICAgICAgIHRoaXMud3dFZGl0b3Iuc2V0TW9kZWwod3dOb2RlLCBjdXJzb3JUb0VuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBodG1sIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIC0gaHRtbCBzeW50YXggdGV4dFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2N1cnNvclRvRW5kPXRydWVdIC0gbW92ZSBjdXJzb3IgdG8gY29udGVudHMgZW5kXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNldEhUTUwgPSBmdW5jdGlvbiAoaHRtbCwgY3Vyc29yVG9FbmQpIHtcbiAgICAgICAgaWYgKGh0bWwgPT09IHZvaWQgMCkgeyBodG1sID0gJyc7IH1cbiAgICAgICAgaWYgKGN1cnNvclRvRW5kID09PSB2b2lkIDApIHsgY3Vyc29yVG9FbmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgLy8gdGhlIGBicmAgdGFnIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIGVtcHR5IGJsb2NrIHRvIHNlcGFyYXRlIGJldHdlZW4gYmxvY2tzXG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSByZXBsYWNlQlJXaXRoRW1wdHlCbG9jayhodG1sKTtcbiAgICAgICAgdmFyIHd3Tm9kZSA9IERPTVBhcnNlci5mcm9tU2NoZW1hKHRoaXMud3dFZGl0b3Iuc2NoZW1hKS5wYXJzZShjb250YWluZXIpO1xuICAgICAgICBpZiAodGhpcy5pc01hcmtkb3duTW9kZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1kRWRpdG9yLnNldE1hcmtkb3duKHRoaXMuY29udmVydG9yLnRvTWFya2Rvd25UZXh0KHd3Tm9kZSksIGN1cnNvclRvRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3dFZGl0b3Iuc2V0TW9kZWwod3dOb2RlLCBjdXJzb3JUb0VuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBjb250ZW50IHRvIG1hcmtkb3duXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbWFya2Rvd24gdGV4dFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRNYXJrZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXJrZG93bk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWRFZGl0b3IuZ2V0TWFya2Rvd24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0b3IudG9NYXJrZG93blRleHQodGhpcy53d0VkaXRvci5nZXRNb2RlbCgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBjb250ZW50IHRvIGh0bWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBodG1sIHN0cmluZ1xuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5ob2xkRXZlbnRJbnZva2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzTWFya2Rvd25Nb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWROb2RlID0gX3RoaXMudG9hc3RNYXJrLmdldFJvb3ROb2RlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHd3Tm9kZSA9IF90aGlzLmNvbnZlcnRvci50b1d5c2l3eWdNb2RlbChtZE5vZGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLnd3RWRpdG9yLnNldE1vZGVsKHd3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaHRtbCA9IHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKHRoaXMud3dFZGl0b3Iudmlldy5kb20uaW5uZXJIVE1MKTtcbiAgICAgICAgaWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHZhciByZVBsYWNlaG9sZGVyID0gbmV3IFJlZ0V4cChcIjxzcGFuIGNsYXNzPVxcXCJwbGFjZWhvbGRlcltePl0rPlwiICsgdGhpcy5wbGFjZWhvbGRlciArIFwiPC9zcGFuPlwiLCAnaScpO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShyZVBsYWNlaG9sZGVyLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgdGV4dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCBjb250ZW50XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmluc2VydFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkucmVwbGFjZVNlbGVjdGlvbih0ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gc3RhcnQgLSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBlbmQgLSBlbmQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLnNldFNlbGVjdGlvbihzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2Ugc2VsZWN0aW9uIHJhbmdlIHdpdGggZ2l2ZW4gdGV4dCBjb250ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW3N0YXJ0XSAtIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtlbmRdIC0gZW5kIHBvc2l0aW9uXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnJlcGxhY2VTZWxlY3Rpb24gPSBmdW5jdGlvbiAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkucmVwbGFjZVNlbGVjdGlvbih0ZXh0LCBzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgY29udGVudCBvZiBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW3N0YXJ0XSAtIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtlbmRdIC0gZW5kIHBvc2l0aW9uXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmRlbGV0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5kZWxldGVTZWxlY3Rpb24oc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgc2VsZWN0ZWQgdGV4dCBjb250ZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtzdGFydF0gLSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbZW5kXSAtIGVuZCBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gc2VsZWN0ZWQgdGV4dCBjb250ZW50XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldFNlbGVjdGVkVGV4dCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuZ2V0U2VsZWN0ZWRUZXh0KHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHJhbmdlIG9mIHRoZSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtwb3NdIC0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcltdPnxBcnJheS48bnVtYmVyPn0gLSBub2RlIFtzdGFydCwgZW5kXSByYW5nZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTWFya2Rvd24gbW9kZVxuICAgICAqIGNvbnN0IHJhbmdlSW5mbyA9IGVkaXRvci5nZXRSYW5nZUluZm9PZk5vZGUoKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHJhbmdlSW5mbyk7IC8vIHsgcmFuZ2U6IFtbc3RhcnRMaW5lT2Zmc2V0LCBzdGFydEN1cm9yT2Zmc2V0XSwgW2VuZExpbmVPZmZzZXQsIGVuZEN1cm9yT2Zmc2V0XV0sIHR5cGU6ICdlbXBoJyB9XG4gICAgICpcbiAgICAgKiAvLyBXWVNJV1lHIG1vZGVcbiAgICAgKiBjb25zdCByYW5nZUluZm8gPSBlZGl0b3IuZ2V0UmFuZ2VJbmZvT2ZOb2RlKCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhyYW5nZUluZm8pOyAvLyB7IHJhbmdlOiBbc3RhcnRDdXJzb3JPZmZzZXQsIGVuZEN1cnNvck9mZnNldF0sIHR5cGU6ICdlbXBoJyB9XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldFJhbmdlSW5mb09mTm9kZSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5nZXRSYW5nZUluZm9PZk5vZGUocG9zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCB3aWRnZXQgdG8gc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gd2lkZ2V0IG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3R5bGUgLSBBZGRpbmcgc3R5bGUgXCJ0b3BcIiBvciBcImJvdHRvbVwiXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtwb3NdIC0gcG9zaXRpb25cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuYWRkV2lkZ2V0ID0gZnVuY3Rpb24gKG5vZGUsIHN0eWxlLCBwb3MpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLmFkZFdpZGdldChub2RlLCBzdHlsZSwgcG9zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2Ugbm9kZSB3aXRoIHdpZGdldCB0byByYW5nZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBzdGFydCAtIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IGVuZCAtIGVuZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gd2lkZ2V0IHRleHQgY29udGVudFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5yZXBsYWNlV2l0aFdpZGdldCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0ZXh0KSB7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5yZXBsYWNlV2l0aFdpZGdldChzdGFydCwgZW5kLCB0ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBlZGl0b3IgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAtIGVkaXRvciBoZWlnaHQgaW4gcGl4ZWxcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLm9wdGlvbnMuZWw7XG4gICAgICAgIGlmIChpc1N0cmluZ18xKGhlaWdodCkpIHtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzXzEoZWwsICdhdXRvLWhlaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfMShlbCwgJ2F1dG8taGVpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldE1pbkhlaWdodCh0aGlzLmdldE1pbkhlaWdodCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjc3NfMShlbCwgeyBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgZWRpdG9yIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGVkaXRvciBoZWlnaHQgaW4gcGl4ZWxcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgbWluaW11bSBoZWlnaHQgdG8gZWRpdG9yIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWluSGVpZ2h0IC0gbWluIGNvbnRlbnQgaGVpZ2h0IGluIHBpeGVsXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNldE1pbkhlaWdodCA9IGZ1bmN0aW9uIChtaW5IZWlnaHQpIHtcbiAgICAgICAgaWYgKG1pbkhlaWdodCAhPT0gdGhpcy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCB8fCB0aGlzLm9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGhlaWdodCAhPT0gJ2F1dG8nICYmIHRoaXMub3B0aW9ucy5lbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgY2xzKCdtYWluJykpKSB7XG4gICAgICAgICAgICAgICAgLy8gNzVweCBlcXVhbHMgZGVmYXVsdCBlZGl0b3IgdWkgaGVpZ2h0IC0gdGhlIGVkaXRpbmcgYXJlYSBoZWlnaHRcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQgPSBNYXRoLm1pbihwYXJzZUludChtaW5IZWlnaHQsIDEwKSwgcGFyc2VJbnQoaGVpZ2h0LCAxMCkgLSA3NSkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluSGVpZ2h0TnVtID0gcGFyc2VJbnQobWluSGVpZ2h0LCAxMCk7XG4gICAgICAgICAgICB0aGlzLm1pbkhlaWdodCA9IG1pbkhlaWdodDtcbiAgICAgICAgICAgIHRoaXMud3dFZGl0b3Iuc2V0TWluSGVpZ2h0KG1pbkhlaWdodE51bSk7XG4gICAgICAgICAgICB0aGlzLm1kRWRpdG9yLnNldE1pbkhlaWdodChtaW5IZWlnaHROdW0pO1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3LnNldE1pbkhlaWdodChtaW5IZWlnaHROdW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgbWluaW11bSBoZWlnaHQgb2YgZWRpdG9yIGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBtaW4gaGVpZ2h0IGluIHBpeGVsXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldE1pbkhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluSGVpZ2h0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgY3VycmVudCBlZGl0b3IgbW9kZSBpcyBNYXJrZG93blxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5pc01hcmtkb3duTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gJ21hcmtkb3duJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIGN1cnJlbnQgZWRpdG9yIG1vZGUgaXMgV1lTSVdZR1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5pc1d5c2l3eWdNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSAnd3lzaXd5Zyc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuaXNWaWV3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IE1hcmtkb3duIGVkaXRvcidzIHByZXZpZXcgc3R5bGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRDdXJyZW50UHJldmlld1N0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZFByZXZpZXdTdHlsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoYW5nZSBlZGl0b3IncyBtb2RlIHRvIGdpdmVuIG1vZGUgc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBFZGl0b3IgbW9kZSBuYW1lIG9mIHdhbnQgdG8gY2hhbmdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbd2l0aG91dEZvY3VzXSAtIENoYW5nZSBtb2RlIHdpdGhvdXQgZm9jdXNcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuY2hhbmdlTW9kZSA9IGZ1bmN0aW9uIChtb2RlLCB3aXRob3V0Rm9jdXMpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gbW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIGlmICh0aGlzLmlzV3lzaXd5Z01vZGUoKSkge1xuICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRoaXMudG9hc3RNYXJrLmdldFJvb3ROb2RlKCk7XG4gICAgICAgICAgICB2YXIgd3dOb2RlID0gdGhpcy5jb252ZXJ0b3IudG9XeXNpd3lnTW9kZWwobWROb2RlKTtcbiAgICAgICAgICAgIHRoaXMud3dFZGl0b3Iuc2V0TW9kZWwod3dOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB3d05vZGUgPSB0aGlzLnd3RWRpdG9yLmdldE1vZGVsKCk7XG4gICAgICAgICAgICB0aGlzLm1kRWRpdG9yLnNldE1hcmtkb3duKHRoaXMuY29udmVydG9yLnRvTWFya2Rvd25UZXh0KHd3Tm9kZSksICF3aXRob3V0Rm9jdXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3JlbW92ZVBvcHVwV2lkZ2V0Jyk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZU1vZGUnLCBtb2RlKTtcbiAgICAgICAgaWYgKCF3aXRob3V0Rm9jdXMpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmNvbnZlcnRvci5nZXRNYXBwZWRQb3MoKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzV3lzaXd5Z01vZGUoKSAmJiBpc051bWJlcl8xKHBvcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnd3RWRpdG9yLnNldFNlbGVjdGlvbihwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwb3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZEVkaXRvci5zZXRTZWxlY3Rpb24ocG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBUVUlFZGl0b3IgZnJvbSBkb2N1bWVudFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnd3RWRpdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tZEVkaXRvci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucHJldmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3luYy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZ2V0RXZlbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoXywgdHlwZSkgeyByZXR1cm4gX3RoaXMub2ZmKHR5cGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhpZGUgVFVJRWRpdG9yXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2hpZGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNob3cgVFVJRWRpdG9yXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Nob3cnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmUgb24gc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3IgY29udGFpbmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHNjcm9sbFRvcCB2YWx1ZSBvZiBlZGl0b3IgY29udGFpbmVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuc2V0U2Nyb2xsVG9wKHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBzY3JvbGwgcG9zaXRpb24gdmFsdWUgb2YgZWRpdG9yIGNvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHNjcm9sbFRvcCB2YWx1ZSBvZiBlZGl0b3IgY29udGFpbmVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5nZXRTY3JvbGxUb3AoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0IFRVSUVkaXRvclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53d0VkaXRvci5zZXRNb2RlbChbXSk7XG4gICAgICAgIHRoaXMubWRFZGl0b3Iuc2V0TWFya2Rvd24oJycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgc2VsZWN0aW9uIHJhbmdlXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXJbXT58QXJyYXkuPG51bWJlcj59IFJldHVybnMgdGhlIHJhbmdlIG9mIHRoZSBzZWxlY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBlZGl0b3IgbW9kZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTWFya2Rvd24gbW9kZVxuICAgICAqIGNvbnN0IG1kU2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cobWRTZWxlY3Rpb24pOyAvLyBbW3N0YXJ0TGluZU9mZnNldCwgc3RhcnRDdXJvck9mZnNldF0sIFtlbmRMaW5lT2Zmc2V0LCBlbmRDdXJvck9mZnNldF1dXG4gICAgICpcbiAgICAgKiAvLyBXWVNJV1lHIG1vZGVcbiAgICAgKiBjb25zdCB3d1NlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHd3U2VsZWN0aW9uKTsgLy8gW3N0YXJ0Q3Vyc29yT2Zmc2V0LCBlbmRDdXJzb3JPZmZzZXRdXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5nZXRTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGxhY2Vob2xkZXIgb24gYWxsIGVkaXRvcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGxhY2Vob2xkZXIgLSBwbGFjZWhvbGRlciB0byBzZXRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuc2V0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgICB0aGlzLm1kRWRpdG9yLnNldFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgdGhpcy53d0VkaXRvci5zZXRQbGFjZWhvbGRlcihwbGFjZWhvbGRlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgbWFya2Rvd24gZWRpdG9yLCBwcmV2aWV3LCB3eXNpd3lnIGVkaXRvciBET00gZWxlbWVudHNcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0RWRpdG9yRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZEVkaXRvcjogdGhpcy5tZEVkaXRvci5nZXRFbGVtZW50KCksXG4gICAgICAgICAgICBtZFByZXZpZXc6IHRoaXMucHJldmlldy5nZXRFbGVtZW50KCksXG4gICAgICAgICAgICB3d0VkaXRvcjogdGhpcy53d0VkaXRvci5nZXRFbGVtZW50KCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHBvc2l0aW9uIHRvIG1hdGNoIGVkaXRvciBtb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHN0YXJ0IC0gc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gZW5kIC0gZW5kIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBFZGl0b3IgbW9kZSBuYW1lIG9mIHdhbnQgdG8gbWF0Y2ggY29udmVydGVkIHBvc2l0aW9uIHRvXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmNvbnZlcnRQb3NUb01hdGNoRWRpdG9yTW9kZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBtb2RlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBzdGFydDsgfVxuICAgICAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSB7IG1vZGUgPSB0aGlzLm1vZGU7IH1cbiAgICAgICAgdmFyIGRvYyA9IHRoaXMubWRFZGl0b3Iudmlldy5zdGF0ZS5kb2M7XG4gICAgICAgIHZhciBpc0Zyb21BcnJheSA9IEFycmF5LmlzQXJyYXkoc3RhcnQpO1xuICAgICAgICB2YXIgaXNUb0FycmF5ID0gQXJyYXkuaXNBcnJheShlbmQpO1xuICAgICAgICB2YXIgY29udmVydGVkRnJvbSA9IHN0YXJ0O1xuICAgICAgICB2YXIgY29udmVydGVkVG8gPSBlbmQ7XG4gICAgICAgIGlmIChpc0Zyb21BcnJheSAhPT0gaXNUb0FycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGVzIG9mIGFyZ3VtZW50cyBtdXN0IGJlIHNhbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZSA9PT0gJ21hcmtkb3duJyAmJiAhaXNGcm9tQXJyYXkgJiYgIWlzVG9BcnJheSkge1xuICAgICAgICAgICAgX2EgPSBnZXRFZGl0b3JUb01kUG9zKGRvYywgc3RhcnQsIGVuZCksIGNvbnZlcnRlZEZyb20gPSBfYVswXSwgY29udmVydGVkVG8gPSBfYVsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnd3lzaXd5ZycgJiYgaXNGcm9tQXJyYXkgJiYgaXNUb0FycmF5KSB7XG4gICAgICAgICAgICBfYiA9IGdldE1kVG9FZGl0b3JQb3MoZG9jLCBzdGFydCwgZW5kKSwgY29udmVydGVkRnJvbSA9IF9iWzBdLCBjb252ZXJ0ZWRUbyA9IF9iWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY29udmVydGVkRnJvbSwgY29udmVydGVkVG9dO1xuICAgIH07XG4gICAgcmV0dXJuIFRvYXN0VUlFZGl0b3JDb3JlO1xufSgpKTtcblxuLy8gQFRPRE86IGNoYW5nZSBzeW50YXggd2l0aCBvdXIgY29udmVudGlvblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmZ1bmN0aW9uIGh0bWwkMSAobikge1xuICBmb3IgKFxuICAgIHZhciBsLFxuICAgICAgZSxcbiAgICAgIHMgPSBhcmd1bWVudHMsXG4gICAgICB0ID0gMSxcbiAgICAgIHIgPSAnJyxcbiAgICAgIHUgPSAnJyxcbiAgICAgIGEgPSBbMF0sXG4gICAgICBjID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdCA9PT0gMSAmJiAobiB8fCAociA9IHIucmVwbGFjZSgvXlxccypcXG5cXHMqfFxccypcXG5cXHMqJC9nLCAnJykpKVxuICAgICAgICAgID8gYS5wdXNoKG4gPyBzW25dIDogcilcbiAgICAgICAgICA6IHQgPT09IDMgJiYgKG4gfHwgcilcbiAgICAgICAgICA/ICgoYVsxXSA9IG4gPyBzW25dIDogciksICh0ID0gMikpXG4gICAgICAgICAgOiB0ID09PSAyICYmIHIgPT09ICcuLi4nICYmIG5cbiAgICAgICAgICA/IChhWzJdID0gYXNzaWduKGFbMl0gfHwge30sIHNbbl0pKVxuICAgICAgICAgIDogdCA9PT0gMiAmJiByICYmICFuXG4gICAgICAgICAgPyAoKGFbMl0gPSBhWzJdIHx8IHt9KVtyXSA9ICEwKVxuICAgICAgICAgIDogdCA+PSA1ICYmXG4gICAgICAgICAgICAodCA9PT0gNVxuICAgICAgICAgICAgICA/ICgoKGFbMl0gPSBhWzJdIHx8IHt9KVtlXSA9IG4gPyAociA/IHIgKyBzW25dIDogc1tuXSkgOiByKSwgKHQgPSA2KSlcbiAgICAgICAgICAgICAgOiAobiB8fCByKSAmJiAoYVsyXVtlXSArPSBuID8gciArIHNbbl0gOiByKSksXG4gICAgICAgICAgKHIgPSAnJyk7XG4gICAgICB9LFxuICAgICAgaCA9IDA7XG4gICAgaCA8IG4ubGVuZ3RoO1xuICAgIGgrK1xuICApIHtcbiAgICBoICYmICh0ID09PSAxICYmIGMoKSwgYyhoKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuW2hdLmxlbmd0aDsgaSsrKVxuICAgICAgKGwgPSBuW2hdW2ldKSxcbiAgICAgICAgdCA9PT0gMVxuICAgICAgICAgID8gbCA9PT0gJzwnXG4gICAgICAgICAgICA/IChjKCksIChhID0gW2EsICcnLCBudWxsXSksICh0ID0gMykpXG4gICAgICAgICAgICA6IChyICs9IGwpXG4gICAgICAgICAgOiB0ID09PSA0XG4gICAgICAgICAgPyByID09PSAnLS0nICYmIGwgPT09ICc+J1xuICAgICAgICAgICAgPyAoKHQgPSAxKSwgKHIgPSAnJykpXG4gICAgICAgICAgICA6IChyID0gbCArIHJbMF0pXG4gICAgICAgICAgOiB1XG4gICAgICAgICAgPyBsID09PSB1XG4gICAgICAgICAgICA/ICh1ID0gJycpXG4gICAgICAgICAgICA6IChyICs9IGwpXG4gICAgICAgICAgOiBsID09PSAnXCInIHx8IGwgPT09IFwiJ1wiXG4gICAgICAgICAgPyAodSA9IGwpXG4gICAgICAgICAgOiBsID09PSAnPidcbiAgICAgICAgICA/IChjKCksICh0ID0gMSkpXG4gICAgICAgICAgOiB0ICYmXG4gICAgICAgICAgICAobCA9PT0gJz0nXG4gICAgICAgICAgICAgID8gKCh0ID0gNSksIChlID0gciksIChyID0gJycpKVxuICAgICAgICAgICAgICA6IGwgPT09ICcvJyAmJiAodCA8IDUgfHwgbltoXVtpICsgMV0gPT09ICc+JylcbiAgICAgICAgICAgICAgPyAoYygpLFxuICAgICAgICAgICAgICAgIHQgPT09IDMgJiYgKGEgPSBhWzBdKSxcbiAgICAgICAgICAgICAgICAodCA9IGEpLFxuICAgICAgICAgICAgICAgIChhID0gYVswXSkucHVzaCh0aGlzLmFwcGx5KG51bGwsIHQuc2xpY2UoMSkpKSxcbiAgICAgICAgICAgICAgICAodCA9IDApKVxuICAgICAgICAgICAgICA6IGwgPT09ICcgJyB8fCBsID09PSAnXFx0JyB8fCBsID09PSAnXFxuJyB8fCBsID09PSAnXFxyJ1xuICAgICAgICAgICAgICA/IChjKCksICh0ID0gMikpXG4gICAgICAgICAgICAgIDogKHIgKz0gbCkpLFxuICAgICAgICB0ID09PSAzICYmIHIgPT09ICchLS0nICYmICgodCA9IDQpLCAoYSA9IGFbMF0pKTtcbiAgfVxuICByZXR1cm4gYygpLCBhLmxlbmd0aCA+IDIgPyBhLnNsaWNlKDEpIDogYVsxXTtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgc3RyaW5nIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBib29sZWFuIG9yIG5vdC5cbiAqICBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBib29sZWFuLCByZXR1cm4gdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIGJvb2xlYW4/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nIHx8IG9iaiBpbnN0YW5jZW9mIEJvb2xlYW47XG59XG5cbnZhciBpc0Jvb2xlYW5fMSA9IGlzQm9vbGVhbjtcblxudmFyIFZOb2RlV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZOb2RlV2Fsa2VyKGN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5yb290ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgfVxuICAgIFZOb2RlV2Fsa2VyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBjdXIgPSBfYS5jdXJyZW50O1xuICAgICAgICBpZiAoIWN1cikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBpZiAoY3VyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIgPT09IHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLm5leHQ7XG4gICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdm5vZGU6IGN1ciwgZW50ZXJpbmc6IGVudGVyaW5nIH07XG4gICAgfTtcbiAgICByZXR1cm4gVk5vZGVXYWxrZXI7XG59KCkpO1xudmFyIFZOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMub2xkID0gbnVsbDtcbiAgICAgICAgdGhpcy5maXJzdENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5za2lwID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIGlmIChwcm9wcy5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVmID0gcHJvcHMucmVmO1xuICAgICAgICAgICAgZGVsZXRlIHByb3BzLnJlZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMua2V5KSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IHByb3BzLmtleTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wcy5rZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVk5vZGUucHJvdG90eXBlLndhbGtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWTm9kZVdhbGtlcih0aGlzKTtcbiAgICB9O1xuICAgIFZOb2RlLnJlbW92YWxOb2RlcyA9IFtdO1xuICAgIHJldHVybiBWTm9kZTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKCdURVhUX05PREUnLCB7IG5vZGVWYWx1ZTogdGV4dCB9LCBbXSk7XG59XG5mdW5jdGlvbiBleGNsdWRlVW5uZWNlc3NhcnlDaGlsZChjaGlsZCwgZmxhdHRlZCkge1xuICAgIHZhciB2bm9kZSA9IGNoaWxkO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgIGlmIChpc0Jvb2xlYW5fMShjaGlsZCkgfHwgY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICB2bm9kZSA9IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RyaW5nXzEoY2hpbGQpIHx8IGlzTnVtYmVyXzEoY2hpbGQpKSB7XG4gICAgICAgIHZub2RlID0gY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNoaWxkKSk7XG4gICAgfVxuICAgIGlmICh2bm9kZSkge1xuICAgICAgICBmbGF0dGVkLnB1c2godm5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjaGlsZHJlbltfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGZsYXR0ZWQgPSBbXTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24gKHZub2RlKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZVVubmVjZXNzYXJ5Q2hpbGQodm5vZGUsIGZsYXR0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGNsdWRlVW5uZWNlc3NhcnlDaGlsZChjaGlsZCwgZmxhdHRlZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFZOb2RlKHR5cGUsIHByb3BzIHx8IHt9LCBmbGF0dGVkKTtcbn1cbi8vIEB0cy1pZ25vcmVcbnZhciBodG1sID0gaHRtbCQxLmJpbmQoaCk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBvYmplY3Qgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBvYmplY3Qgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIG9iamVjdCwgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBvYmplY3Q/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0O1xuXG4vLyBAVE9ETzogY2xlYXJmeSB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciBDU1NEZWNsYXJhdGlvblxuZnVuY3Rpb24gY3JlYXRlTm9kZSh2bm9kZSkge1xuICAgIHZhciBub2RlO1xuICAgIGlmICh2bm9kZS50eXBlID09PSAnVEVYVF9OT0RFJykge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodm5vZGUucHJvcHMubm9kZVZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHZub2RlLnR5cGUpO1xuICAgICAgICBzZXRQcm9wcyhub2RlLCB7fSwgdm5vZGUucHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIHBhcmVudE5vZGUpIHtcbiAgICBpZiAodm5vZGUubm9kZSkge1xuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHZub2RlLm5vZGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5maXJzdENoaWxkLCBwYXJlbnROb2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbm5lckRpZmYobm9kZSwgcHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICBPYmplY3Qua2V5cyhwcmV2UHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgIGlmICgvXm9uLy50ZXN0KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgaWYgKCFuZXh0UHJvcHNbcHJvcE5hbWVdIHx8IHByZXZQcm9wc1twcm9wTmFtZV0gIT09IG5leHRQcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gcHJvcE5hbWUuc2xpY2UoMikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBwcmV2UHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9wTmFtZSAhPT0gJ2NoaWxkcmVuJyAmJiAhbmV4dFByb3BzW3Byb3BOYW1lXSAmJiAhaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgc2V0UHJvcHMobm9kZSwgcHJldlByb3BzLCBuZXh0UHJvcHMsIGZ1bmN0aW9uIChwcm9wTmFtZSkgeyByZXR1cm4gIXNoYWxsb3dFcXVhbChwcmV2UHJvcHNbcHJvcE5hbWVdLCBuZXh0UHJvcHNbcHJvcE5hbWVdKTsgfSk7XG59XG52YXIgcmVOb25EaW1lbnNpb24gPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmQvaTtcbmZ1bmN0aW9uIHNldFByb3BzKG5vZGUsIHByZXZQcm9wcywgcHJvcHMsIGNvbmRpdGlvbikge1xuICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbiB8fCBjb25kaXRpb24ocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoL15vbi8udGVzdChwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gcHJvcE5hbWUuc2xpY2UoMikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcE5hbWUgPT09ICdub2RlVmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ3N0eWxlJyAmJiBpc09iamVjdF8xKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBzZXRTdHlsZVByb3BzKG5vZGUsIHByZXZQcm9wc1twcm9wTmFtZV0sIHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wTmFtZSAhPT0gJ2NoaWxkcmVuJykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKHByb3BOYW1lLCBwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0U3R5bGVQcm9wcyhub2RlLCBwcmV2U3R5bGVQcm9wcywgc3R5bGVQcm9wcykge1xuICAgIGlmIChwcmV2U3R5bGVQcm9wcykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcmV2U3R5bGVQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVQcm9wKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBub2RlLnN0eWxlW3N0eWxlUHJvcF0gPSAnJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHN0eWxlUHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlUHJvcCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVByb3BzW3N0eWxlUHJvcF07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbm9kZS5zdHlsZVtzdHlsZVByb3BdID1cbiAgICAgICAgICAgIGlzTnVtYmVyXzEodmFsdWUpICYmICFyZU5vbkRpbWVuc2lvbi50ZXN0KHN0eWxlUHJvcCkgPyB2YWx1ZSArIFwicHhcIiA6IHZhbHVlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjb21taXQodm5vZGUpIHtcbiAgICBWTm9kZS5yZW1vdmFsTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAocmVtb3ZhbE5vZGUpIHsgcmV0dXJuIGRpZmYocmVtb3ZhbE5vZGUpOyB9KTtcbiAgICBpZiAodm5vZGUpIHtcbiAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG4gICAgICAgIHZhciB3YWxrZXIgPSB2bm9kZS53YWxrZXIoKTtcbiAgICAgICAgd2hpbGUgKChuZXh0ID0gd2Fsa2VyLndhbGsoKSkpIHtcbiAgICAgICAgICAgIHZub2RlID0gbmV4dC52bm9kZTtcbiAgICAgICAgICAgIGlmIChuZXh0LmVudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgZGlmZih2bm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uXzEodm5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcCA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAvLyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgICAgICAgICAgICAgaWYgKCF2bm9kZS5vbGQgJiYgY29tcC5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAubW91bnRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodm5vZGUub2xkICYmIGNvbXAudXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY29tcC5wcmV2UHJvcHMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbXAudXBkYXRlZChwcmV2UHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUodm5vZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gdm5vZGUucGFyZW50O1xuICAgIHdoaWxlICghcGFyZW50Lm5vZGUpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudC5ub2RlO1xufVxuZnVuY3Rpb24gZGlmZih2bm9kZSkge1xuICAgIGlmICghdm5vZGUgfHwgIXZub2RlLnBhcmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2bm9kZS5ub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZSh2bm9kZSk7XG4gICAgICAgIGlmICh2bm9kZS5lZmZlY3QgPT09ICdBJykge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh2bm9kZS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2bm9kZS5lZmZlY3QgPT09ICdVJykge1xuICAgICAgICAgICAgaW5uZXJEaWZmKHZub2RlLm5vZGUsIHZub2RlLm9sZC5wcm9wcywgdm5vZGUucHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2bm9kZS5lZmZlY3QgPT09ICdEJykge1xuICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHdhbGtlciA9IHZub2RlLndhbGtlcigpO1xuICAgICAgICB3aGlsZSAoKG5leHQgPSB3YWxrZXIud2FsaygpKSkge1xuICAgICAgICAgICAgdm5vZGUgPSBuZXh0LnZub2RlO1xuICAgICAgICAgICAgaWYgKCFuZXh0LmVudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMSh2bm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcCA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlmZWN5Y2xlIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcC5iZWZvcmVEZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wLmJlZm9yZURlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKHZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZSh2bm9kZSwgcGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFwcGx5IHJlZlxuICAgIGlmICh2bm9kZS5yZWYpIHtcbiAgICAgICAgaWYgKHZub2RlLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgdm5vZGUucmVmKHZub2RlLmNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodm5vZGUubm9kZSkge1xuICAgICAgICAgICAgdm5vZGUucmVmKHZub2RlLm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoQ29tcCwgdm5vZGUpIHtcbiAgICB2YXIgcHJvcHMgPSB2bm9kZS5wcm9wcywgY29tcG9uZW50ID0gdm5vZGUuY29tcG9uZW50O1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgY29tcG9uZW50LnByZXZQcm9wcyA9IGNvbXBvbmVudC5wcm9wcztcbiAgICAgICAgY29tcG9uZW50LnByb3BzID0gdm5vZGUucHJvcHM7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29tcChwcm9wcyk7XG59XG5mdW5jdGlvbiBidWlsZFZOb2RlKHZub2RlKSB7XG4gICAgdmFyIHJvb3QgPSB2bm9kZTtcbiAgICB3aGlsZSAodm5vZGUgJiYgIXZub2RlLnNraXApIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMSh2bm9kZS50eXBlKSkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50KHZub2RlLnR5cGUsIHZub2RlKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnZub2RlID0gdm5vZGU7XG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIHZub2RlLnByb3BzLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4gPSBbaW5zdGFuY2UucmVuZGVyKCldO1xuICAgICAgICAgICAgYnVpbGRDaGlsZHJlblZOb2RlKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdm5vZGUubm9kZSkge1xuICAgICAgICAgICAgICAgIHZub2RlLm5vZGUgPSBjcmVhdGVOb2RlKHZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1aWxkQ2hpbGRyZW5WTm9kZSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHZub2RlID0gdm5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICh2bm9kZSAmJiB2bm9kZS5wYXJlbnQgJiYgIXZub2RlLm5leHQpIHtcbiAgICAgICAgICAgICAgICB2bm9kZSA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm5vZGUgPSB2bm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTYW1lVHlwZShvbGQsIHZub2RlKSB7XG4gICAgcmV0dXJuIG9sZCAmJiB2bm9kZSAmJiB2bm9kZS50eXBlID09PSBvbGQudHlwZSAmJiAoIXZub2RlLmtleSB8fCB2bm9kZS5rZXkgPT09IG9sZC5rZXkpO1xufVxuLy8gQFRPRE86IGFkZCBrZXkgZGlmZiBhbGdvcml0aG1cbmZ1bmN0aW9uIGJ1aWxkQ2hpbGRyZW5WTm9kZShwYXJlbnQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgdmFyIG9sZCA9IHBhcmVudC5vbGQgPyBwYXJlbnQub2xkLmZpcnN0Q2hpbGQgOiBudWxsO1xuICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICh2bm9kZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHNhbWVUeXBlID0gaXNTYW1lVHlwZShvbGQsIHZub2RlKTtcbiAgICAgICAgaWYgKHNhbWVUeXBlKSB7XG4gICAgICAgICAgICB2bm9kZS5vbGQgPSBvbGQ7XG4gICAgICAgICAgICB2bm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB2bm9kZS5ub2RlID0gb2xkLm5vZGU7XG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnQgPSBvbGQuY29tcG9uZW50O1xuICAgICAgICAgICAgdm5vZGUuZWZmZWN0ID0gJ1UnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZSAmJiAhc2FtZVR5cGUpIHtcbiAgICAgICAgICAgIHZub2RlLm9sZCA9IG51bGw7XG4gICAgICAgICAgICB2bm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB2bm9kZS5ub2RlID0gbnVsbDtcbiAgICAgICAgICAgIHZub2RlLmVmZmVjdCA9ICdBJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkICYmICFzYW1lVHlwZSkge1xuICAgICAgICAgICAgVk5vZGUucmVtb3ZhbE5vZGVzLnB1c2gob2xkKTtcbiAgICAgICAgICAgIG9sZC5lZmZlY3QgPSAnRCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZCkge1xuICAgICAgICAgICAgb2xkID0gb2xkLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBwYXJlbnQuZmlyc3RDaGlsZCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZub2RlKSB7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gdm5vZGU7XG4gICAgfSk7XG4gICAgdmFyIGxhc3RDaGlsZCA9IGxhc3QkMShjaGlsZHJlbik7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKG9sZCkge1xuICAgICAgICAgICAgVk5vZGUucmVtb3ZhbE5vZGVzLnB1c2gob2xkKTtcbiAgICAgICAgICAgIG9sZC5lZmZlY3QgPSAnRCc7XG4gICAgICAgICAgICBvbGQgPSBvbGQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAob2xkICYmIGxhc3RDaGlsZCkge1xuICAgICAgICBpZiAob2xkICYmIGxhc3RDaGlsZC5vbGQgIT09IG9sZCkge1xuICAgICAgICAgICAgVk5vZGUucmVtb3ZhbE5vZGVzLnB1c2gob2xkKTtcbiAgICAgICAgICAgIG9sZC5lZmZlY3QgPSAnRCc7XG4gICAgICAgICAgICBvbGQgPSBvbGQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVzdHJveSh2bm9kZSkge1xuICAgIHZub2RlLmVmZmVjdCA9ICdEJztcbiAgICBWTm9kZS5yZW1vdmFsTm9kZXMgPSBbdm5vZGVdO1xuICAgIGNvbW1pdCgpO1xuICAgIFZOb2RlLnJlbW92YWxOb2RlcyA9IFtdO1xufVxuZnVuY3Rpb24gcmVyZW5kZXIoY29tcCkge1xuICAgIHZhciByb290ID0gY29tcC52bm9kZTtcbiAgICByb290LmVmZmVjdCA9ICdVJztcbiAgICByb290Lm9sZCA9IHJvb3Q7XG4gICAgLy8gc2tpcCBmb3IgdW5uZWNlc3NhcnkgcmVjb25jaWxpYXRpb25cbiAgICBpZiAocm9vdC5uZXh0KSB7XG4gICAgICAgIHJvb3QubmV4dC5za2lwID0gdHJ1ZTtcbiAgICB9XG4gICAgVk5vZGUucmVtb3ZhbE5vZGVzID0gW107XG4gICAgYnVpbGRWTm9kZShyb290KTtcbiAgICBjb21taXQocm9vdCk7XG4gICAgaWYgKHJvb3QubmV4dCkge1xuICAgICAgICByb290Lm5leHQuc2tpcCA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcihjb250YWluZXIsIHZub2RlKSB7XG4gICAgdmFyIHJvb3QgPSBuZXcgVk5vZGUoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSwge30sIFt2bm9kZV0pO1xuICAgIHJvb3Qubm9kZSA9IGNvbnRhaW5lcjtcbiAgICBWTm9kZS5yZW1vdmFsTm9kZXMgPSBbXTtcbiAgICBidWlsZFZOb2RlKHJvb3QpO1xuICAgIGNvbW1pdChyb290KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVzdHJveShyb290LmZpcnN0Q2hpbGQpOyB9O1xufVxuXG52YXIgQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcykge1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgfVxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCB0aGlzLnN0YXRlKSwgc3RhdGUpO1xuICAgICAgICBpZiAoIXNoYWxsb3dFcXVhbCh0aGlzLnN0YXRlLCBuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIHJlcmVuZGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcG9uZW50O1xufSgpKTtcblxudmFyIFN3aXRjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShTd2l0Y2gsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGhpZGU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN3aXRjaC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhpZGU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgU3dpdGNoLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgaGlkZTogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIFN3aXRjaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBlZGl0b3JUeXBlID0gX2EuZWRpdG9yVHlwZSwgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGggfHwgKHRlbXBsYXRlT2JqZWN0XzEkaCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IFwiLCBcIlxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJ0YWItaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcInRhYi1pdGVtXCIsIFwiXFxcIlxcbiAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IFwiLCBcIlxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJ0YWItaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgb25DbGljaz1cIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJ0YWItaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgb25DbGljaz1cIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBjbHMoJ21vZGUtc3dpdGNoJyksIHRoaXMuc3RhdGUuaGlkZSA/ICdub25lJyA6ICdibG9jaycsIGVkaXRvclR5cGUgPT09ICdtYXJrZG93bicgPyAnIGFjdGl2ZScgOiAnJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ25lZWRDaGFuZ2VNb2RlJywgJ21hcmtkb3duJyk7XG4gICAgICAgIH0sIGkxOG4uZ2V0KCdNYXJrZG93bicpLCBlZGl0b3JUeXBlID09PSAnd3lzaXd5ZycgPyAnIGFjdGl2ZScgOiAnJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ25lZWRDaGFuZ2VNb2RlJywgJ3d5c2l3eWcnKTtcbiAgICAgICAgfSwgaTE4bi5nZXQoJ1dZU0lXWUcnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoO1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJGg7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGZuIHVudGlsIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcyBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdWNlZCBmdW5jdGlvbiB3YXMgaW52b2tlZC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdC5uaG4uY29tPlxuICovXG5cbi8qKlxuICogQG1vZHVsZSB0cmlja3NcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgZm4gdW50aWwgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzIGhhcyBlbGFwc2VkXG4gKiBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdWNlZCBmdW5jdGlvbiB3YXMgaW52b2tlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXlcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQG1lbWJlcm9mIG1vZHVsZTp0cmlja3NcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBkZWJvdW5jZSBmcm9tICd0dWktY29kZS1zbmlwcGV0L3RyaWNrcy9kZWJvdW5jZSc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBkZWJvdW5jZSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvdHJpY2tzL2RlYm91bmNlJyk7XG4gKlxuICogZnVuY3Rpb24gc29tZU1ldGhvZFRvSW52b2tlRGVib3VuY2VkKCkge31cbiAqXG4gKiBjb25zdCBkZWJvdW5jZWQgPSBkZWJvdW5jZShzb21lTWV0aG9kVG9JbnZva2VEZWJvdW5jZWQsIDMwMCk7XG4gKlxuICogLy8gaW52b2tlIHJlcGVhdGVkbHlcbiAqIGRlYm91bmNlZCgpO1xuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpO1xuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTsgICAgLy8gbGFzdCBpbnZva2Ugb2YgZGVib3VuY2VkKClcbiAqXG4gKiAvLyBpbnZva2Ugc29tZU1ldGhvZFRvSW52b2tlRGVib3VuY2VkKCkgYWZ0ZXIgMzAwIG1pbGxpc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UkMShmbiwgZGVsYXkpIHtcbiAgdmFyIHRpbWVyLCBhcmdzO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGRlbGF5ID0gZGVsYXkgfHwgMDtcblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIGRlbGF5KTtcbiAgfVxuXG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbnZhciBkZWJvdW5jZV8xID0gZGVib3VuY2UkMTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgZm4gYXQgbW9zdCBvbmNlIHBlciBldmVyeSBpbnRlcnZhbCBtaWxsaXNlY29uZHMuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHQubmhuLmNvbT5cbiAqL1xuXG52YXIgZGVib3VuY2UgPSBkZWJvdW5jZV8xO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgZm4gYXQgbW9zdCBvbmNlIHBlciBldmVyeSBpbnRlcnZhbCBtaWxsaXNlY29uZHMuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIHRocm90dGxlIHNob3J0IHRpbWUgcmVwZWF0ZWRseSBpbnZva2luZyBmdW5jdGlvbnMuIChlLmcgTW91c2VNb3ZlLCBSZXNpemUgLi4uKVxuICogaWYgeW91IG5lZWQgcmV1c2UgdGhyb3R0bGVkIG1ldGhvZC4geW91IG11c3QgcmVtb3ZlIHNsdWdzIChlLmcuIGZsYWcgdmFyaWFibGUpIHJlbGF0ZWQgd2l0aCB0aHJvdHRsaW5nLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gZnVuY3Rpb24gdG8gdGhyb3R0bGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW50ZXJ2YWw9MF0gdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRocm90dGxlZCBmdW5jdGlvblxuICogQG1lbWJlcm9mIG1vZHVsZTp0cmlja3NcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCB0aHJvdHRsZSBmcm9tICd0dWktY29kZS1zbmlwcGV0L3RyaWNrcy90aHJvdHRsZSc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCB0aHJvdHRsZSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvdHJpY2tzL3Rocm90dGxlJyk7XG4gKlxuICogZnVuY3Rpb24gc29tZU1ldGhvZFRvSW52b2tlVGhyb3R0bGVkKCkge31cbiAqXG4gKiBjb25zdCB0aHJvdHRsZWQgPSB0aHJvdHRsZShzb21lTWV0aG9kVG9JbnZva2VUaHJvdHRsZWQsIDMwMCk7XG4gKlxuICogLy8gaW52b2tlIHJlcGVhdGVkbHlcbiAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKGxlYWRpbmcpXG4gKiB0aHJvdHRsZWQoKTtcbiAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKG5lYXIgMzAwIG1pbGxpc2Vjb25kcylcbiAqIHRocm90dGxlZCgpO1xuICogdGhyb3R0bGVkKCk7XG4gKiB0aHJvdHRsZWQoKTsgICAgLy8gaW52b2tlIChuZWFyIDYwMCBtaWxsaXNlY29uZHMpXG4gKiAvLyAuLi5cbiAqIC8vIGludm9rZSAodHJhaWxpbmcpXG4gKlxuICogLy8gaWYgeW91IG5lZWQgcmV1c2UgdGhyb3R0bGVkIG1ldGhvZC4gdGhlbiBpbnZva2UgcmVzZXQoKVxuICogdGhyb3R0bGVkLnJlc2V0KCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlJDEoZm4sIGludGVydmFsKSB7XG4gIHZhciBiYXNlO1xuICB2YXIgaXNMZWFkaW5nID0gdHJ1ZTtcbiAgdmFyIHRpY2sgPSBmdW5jdGlvbihfYXJncykge1xuICAgIGZuLmFwcGx5KG51bGwsIF9hcmdzKTtcbiAgICBiYXNlID0gbnVsbDtcbiAgfTtcbiAgdmFyIGRlYm91bmNlZCwgc3RhbXAsIGFyZ3M7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaW50ZXJ2YWwgPSBpbnRlcnZhbCB8fCAwO1xuXG4gIGRlYm91bmNlZCA9IGRlYm91bmNlKHRpY2ssIGludGVydmFsKTtcblxuICBmdW5jdGlvbiB0aHJvdHRsZWQoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgaWYgKGlzTGVhZGluZykge1xuICAgICAgdGljayhhcmdzKTtcbiAgICAgIGlzTGVhZGluZyA9IGZhbHNlO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhbXAgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cbiAgICBiYXNlID0gYmFzZSB8fCBzdGFtcDtcblxuICAgIC8vIHBhc3MgYXJyYXkgZGlyZWN0bHkgYmVjYXVzZSBgZGVib3VuY2UoKWAsIGB0aWNrKClgIGFyZSBhbHJlYWR5IHVzZVxuICAgIC8vIGBhcHBseSgpYCBtZXRob2QgdG8gaW52b2tlIGRldmVsb3BlcidzIGBmbmAgaGFuZGxlci5cbiAgICAvL1xuICAgIC8vIGFsc28sIHRoaXMgYGRlYm91bmNlZGAgbGluZSBpbnZva2VkIGV2ZXJ5IHRpbWUgZm9yIGltcGxlbWVudHNcbiAgICAvLyBgdHJhaWxpbmdgIGZlYXR1cmVzLlxuICAgIGRlYm91bmNlZChhcmdzKTtcblxuICAgIGlmICgoc3RhbXAgLSBiYXNlKSA+PSBpbnRlcnZhbCkge1xuICAgICAgdGljayhhcmdzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldCgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWpzZG9jXG4gICAgaXNMZWFkaW5nID0gdHJ1ZTtcbiAgICBiYXNlID0gbnVsbDtcbiAgfVxuXG4gIHRocm90dGxlZC5yZXNldCA9IHJlc2V0O1xuXG4gIHJldHVybiB0aHJvdHRsZWQ7XG59XG5cbnZhciB0aHJvdHRsZV8xID0gdGhyb3R0bGUkMTtcblxuLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBzaGltcyB0aGF0IHByb3ZpZGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBFUzYgY29sbGVjdGlvbnMuXHJcbiAqXHJcbiAqIFRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJcclxuICogbW9kdWxlcyBhcyB0aGV5IGNvdmVyIG9ubHkgYSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MsIHZhbGlkLWpzZG9jICovXHJcbnZhciBNYXBTaGltID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBNYXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5kZXggaW4gcHJvdmlkZWQgYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhcnJcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRJbmRleChhcnIsIGtleSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAtMTtcclxuICAgICAgICBhcnIuc29tZShmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeVswXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfXy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9fZW50cmllc19fW2luZGV4XTtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzFdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfX1tpbmRleF1bMV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18ucHVzaChba2V5LCB2YWx1ZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLl9fZW50cmllc19fO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleChlbnRyaWVzLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+Z2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbY3R4PW51bGxdXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChjdHggPT09IHZvaWQgMCkgeyBjdHggPSBudWxsOyB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9fZW50cmllc19fOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVudHJ5WzFdLCBlbnRyeVswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgfSgpKTtcclxufSkoKTtcblxuLyoqXHJcbiAqIERldGVjdHMgd2hldGhlciB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgYXJlIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gKi9cclxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ID09PSBkb2N1bWVudDtcblxuLy8gUmV0dXJucyBnbG9iYWwgb2JqZWN0IG9mIGEgY3VycmVudCBlbnZpcm9ubWVudC5cclxudmFyIGdsb2JhbCQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBBIHNoaW0gZm9yIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggZmFsbHMgYmFjayB0byB0aGUgc2V0VGltZW91dCBpZlxyXG4gKiBmaXJzdCBvbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gUmVxdWVzdHMnIGlkZW50aWZpZXIuXHJcbiAqL1xyXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHVzZSBhIGJvdW5kZWQgZnVuY3Rpb24gYmVjYXVzZSBJRSBzb21ldGltZXMgdGhyb3dzXHJcbiAgICAgICAgLy8gYW4gXCJJbnZhbGlkIGNhbGxpbmcgb2JqZWN0XCIgZXJyb3IgaWYgckFGIGlzIGludm9rZWQgd2l0aG91dCB0aGUgZ2xvYmFsXHJcbiAgICAgICAgLy8gb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZS5cclxuICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZ2xvYmFsJDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhEYXRlLm5vdygpKTsgfSwgMTAwMCAvIDYwKTsgfTtcclxufSkoKTtcblxuLy8gRGVmaW5lcyBtaW5pbXVtIHRpbWVvdXQgYmVmb3JlIGFkZGluZyBhIHRyYWlsaW5nIGNhbGwuXHJcbnZhciB0cmFpbGluZ1RpbWVvdXQgPSAyO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggZW5zdXJlcyB0aGF0IHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmVcclxuICogaW52b2tlZCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXkgcGVyaW9kLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGRlbGF5IHBlcmlvZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gRGVsYXkgYWZ0ZXIgd2hpY2ggdG8gaW52b2tlIGNhbGxiYWNrLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAqL1xyXG5mdW5jdGlvbiB0aHJvdHRsZSAoY2FsbGJhY2ssIGRlbGF5KSB7XHJcbiAgICB2YXIgbGVhZGluZ0NhbGwgPSBmYWxzZSwgdHJhaWxpbmdDYWxsID0gZmFsc2UsIGxhc3RDYWxsVGltZSA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBzY2hlZHVsZXMgbmV3IGludm9jYXRpb24gaWZcclxuICAgICAqIHRoZSBcInByb3h5XCIgd2FzIGNhbGxlZCBkdXJpbmcgY3VycmVudCByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXNvbHZlUGVuZGluZygpIHtcclxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICBwcm94eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LiBJdCB3aWxsIGZ1cnRoZXIgcG9zdHBvbmVcclxuICAgICAqIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGRlbGVnYXRpbmcgaXQgdG8gdGhlXHJcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShyZXNvbHZlUGVuZGluZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHJveHkoKSB7XHJcbiAgICAgICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFJlamVjdCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgY2FsbHMuXHJcbiAgICAgICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgXCJ0cmFuc2l0aW9uc1wiIHdoaWNoIG5ldmVyIGFjdHVhbGx5IHN0YXJ0XHJcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHNvIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgd2UgbWlnaHQgbWlzcyBvbmUgaWYgY2hhbmdlXHJcbiAgICAgICAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWVTdGFtcDtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm94eTtcclxufVxuXG4vLyBNaW5pbXVtIGRlbGF5IGJlZm9yZSBpbnZva2luZyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy5cclxudmFyIFJFRlJFU0hfREVMQVkgPSAyMDtcclxuLy8gQSBsaXN0IG9mIHN1YnN0cmluZ3Mgb2YgQ1NTIHByb3BlcnRpZXMgdXNlZCB0byBmaW5kIHRyYW5zaXRpb24gZXZlbnRzIHRoYXRcclxuLy8gbWlnaHQgYWZmZWN0IGRpbWVuc2lvbnMgb2Ygb2JzZXJ2ZWQgZWxlbWVudHMuXHJcbnZhciB0cmFuc2l0aW9uS2V5cyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdzaXplJywgJ3dlaWdodCddO1xyXG4vLyBDaGVjayBpZiBNdXRhdGlvbk9ic2VydmVyIGlzIGF2YWlsYWJsZS5cclxudmFyIG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gY29udHJvbGxlciBjbGFzcyB3aGljaCBoYW5kbGVzIHVwZGF0ZXMgb2YgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2VzLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVsbHMgdGhhdCBjb250cm9sbGVyIGhhcyBzdWJzY3JpYmVkIGZvciBNdXRhdGlvbiBFdmVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge011dGF0aW9uT2JzZXJ2ZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmVyU1BJPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmVyc18gPSBbXTtcclxuICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZF8gPSB0aGlzLm9uVHJhbnNpdGlvbkVuZF8uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSwgUkVGUkVTSF9ERUxBWSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb2JzZXJ2ZXIgdG8gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmFkZE9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgaWYgKCF+dGhpcy5vYnNlcnZlcnNfLmluZGV4T2Yob2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzXy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGxpc3RlbmVycyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBhZGRlZCB5ZXQuXHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc187XHJcbiAgICAgICAgdmFyIGluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBvYnNlcnZlciBpZiBpdCdzIHByZXNlbnQgaW4gcmVnaXN0cnkuXHJcbiAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyIGhhcyBubyBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGlmICghb2JzZXJ2ZXJzLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuIEl0IHdpbGwgY29udGludWUgcnVubmluZyB1cGRhdGVzIGluc29mYXJcclxuICAgICAqIGl0IGRldGVjdHMgY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaGFuZ2VzRGV0ZWN0ZWQgPSB0aGlzLnVwZGF0ZU9ic2VydmVyc18oKTtcclxuICAgICAgICAvLyBDb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaWYgY2hhbmdlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXMgdGhlcmUgbWlnaHRcclxuICAgICAgICAvLyBiZSBmdXR1cmUgb25lcyBjYXVzZWQgYnkgQ1NTIHRyYW5zaXRpb25zLlxyXG4gICAgICAgIGlmIChjaGFuZ2VzRGV0ZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBldmVyeSBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0IGFuZCBub3RpZmllcyB0aGVtIG9mIHF1ZXVlZFxyXG4gICAgICogZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IG9ic2VydmVyIGhhcyBkZXRlY3RlZCBjaGFuZ2VzIGluXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgaXQncyBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENvbGxlY3Qgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHZhciBhY3RpdmVPYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZ2F0aGVyQWN0aXZlKCksIG9ic2VydmVyLmhhc0FjdGl2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIERlbGl2ZXIgbm90aWZpY2F0aW9ucyBpbiBhIHNlcGFyYXRlIGN5Y2xlIGluIG9yZGVyIHRvIGF2b2lkIGFueVxyXG4gICAgICAgIC8vIGNvbGxpc2lvbnMgYmV0d2VlbiBvYnNlcnZlcnMsIGUuZy4gd2hlbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2ZcclxuICAgICAgICAvLyBSZXNpemVPYnNlcnZlciBhcmUgdHJhY2tpbmcgdGhlIHNhbWUgZWxlbWVudCBhbmQgdGhlIGNhbGxiYWNrIG9mIG9uZVxyXG4gICAgICAgIC8vIG9mIHRoZW0gY2hhbmdlcyBjb250ZW50IGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIHRhcmdldC4gU29tZXRpbWVzXHJcbiAgICAgICAgLy8gdGhpcyBtYXkgcmVzdWx0IGluIG5vdGlmaWNhdGlvbnMgYmVpbmcgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2Ygb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGFjdGl2ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gb2JzZXJ2ZXIuYnJvYWRjYXN0QWN0aXZlKCk7IH0pO1xyXG4gICAgICAgIHJldHVybiBhY3RpdmVPYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkLlxyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8IHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN1YnNjcmlwdGlvbiB0byB0aGUgXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgZm9yXHJcbiAgICAgICAgLy8gZGVsYXllZCB0cmFuc2l0aW9ucy4gVGhpcyB3YXkgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGF0IGxlYXN0IHRoZVxyXG4gICAgICAgIC8vIGZpbmFsIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5vYnNlcnZlKGRvY3VtZW50LCB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuZGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCAhdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7VHJhbnNpdGlvbkV2ZW50fSBldmVudFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUub25UcmFuc2l0aW9uRW5kXyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcbiAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgdHJhbnNpdGlvbiBtYXkgYWZmZWN0IGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICB2YXIgaXNSZWZsb3dQcm9wZXJ0eSA9IHRyYW5zaXRpb25LZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+cHJvcGVydHlOYW1lLmluZGV4T2Yoa2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNSZWZsb3dQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoZSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZV8gPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlXztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIHJlZmVyZW5jZSB0byB0aGUgY29udHJvbGxlcidzIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5pbnN0YW5jZV8gPSBudWxsO1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcclxufSgpKTtcblxuLyoqXHJcbiAqIERlZmluZXMgbm9uLXdyaXRhYmxlL2VudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgcHJvdmlkZWQgdGFyZ2V0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCBmb3Igd2hpY2ggdG8gZGVmaW5lIHByb3BlcnRpZXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFByb3BlcnRpZXMgdG8gYmUgZGVmaW5lZC5cclxuICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0IG9iamVjdC5cclxuICovXHJcbnZhciBkZWZpbmVDb25maWd1cmFibGUgPSAoZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwcm9wcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufSk7XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBnbG9iYWwgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqL1xyXG52YXIgZ2V0V2luZG93T2YgPSAoZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgLy8gQXNzdW1lIHRoYXQgdGhlIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgTm9kZSwgd2hpY2ggbWVhbnMgdGhhdCBpdFxyXG4gICAgLy8gaGFzIHRoZSBcIm93bmVyRG9jdW1lbnRcIiBwcm9wZXJ0eSBmcm9tIHdoaWNoIHdlIGNhbiByZXRyaWV2ZSBhXHJcbiAgICAvLyBjb3JyZXNwb25kaW5nIGdsb2JhbCBvYmplY3QuXHJcbiAgICB2YXIgb3duZXJHbG9iYWwgPSB0YXJnZXQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGxvY2FsIGdsb2JhbCBvYmplY3QgaWYgaXQncyBub3QgcG9zc2libGUgZXh0cmFjdCBvbmUgZnJvbVxyXG4gICAgLy8gcHJvdmlkZWQgZWxlbWVudC5cclxuICAgIHJldHVybiBvd25lckdsb2JhbCB8fCBnbG9iYWwkMTtcclxufSk7XG5cbi8vIFBsYWNlaG9sZGVyIG9mIGFuIGVtcHR5IGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG52YXIgZW1wdHlSZWN0ID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBwcm92aWRlZCBzdHJpbmcgdG8gYSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBib3JkZXJzIHNpemUgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwb3NpdGlvbnMgLSBCb3JkZXJzIHBvc2l0aW9ucyAodG9wLCByaWdodCwgLi4uKVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHBvc2l0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChzaXplLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1snYm9yZGVyLScgKyBwb3NpdGlvbiArICctd2lkdGgnXTtcclxuICAgICAgICByZXR1cm4gc2l6ZSArIHRvRmxvYXQodmFsdWUpO1xyXG4gICAgfSwgMCk7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHBhZGRpbmdzIHNpemVzIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQYWRkaW5ncyBib3guXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYWRkaW5ncyhzdHlsZXMpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xyXG4gICAgdmFyIHBhZGRpbmdzID0ge307XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBvc2l0aW9uc18xID0gcG9zaXRpb25zOyBfaSA8IHBvc2l0aW9uc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uc18xW19pXTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ3BhZGRpbmctJyArIHBvc2l0aW9uXTtcclxuICAgICAgICBwYWRkaW5nc1twb3NpdGlvbl0gPSB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYWRkaW5ncztcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBTVkcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHNcclxuICogICAgICB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIHZhciBiYm94ID0gdGFyZ2V0LmdldEJCb3goKTtcclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgSFRNTEVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY29udGVudCByZWN0YW5nbGUuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAvLyBDbGllbnQgd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBjYW4ndCBiZVxyXG4gICAgLy8gdXNlZCBleGNsdXNpdmVseSBhcyB0aGV5IHByb3ZpZGUgcm91bmRlZCB2YWx1ZXMuXHJcbiAgICB2YXIgY2xpZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7XHJcbiAgICAvLyBCeSB0aGlzIGNvbmRpdGlvbiB3ZSBjYW4gY2F0Y2ggYWxsIG5vbi1yZXBsYWNlZCBpbmxpbmUsIGhpZGRlbiBhbmRcclxuICAgIC8vIGRldGFjaGVkIGVsZW1lbnRzLiBUaG91Z2ggZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGxlc3NcclxuICAgIC8vIHRoYW4gMC41IHdpbGwgYmUgZGlzY2FyZGVkIGFzIHdlbGwuXHJcbiAgICAvL1xyXG4gICAgLy8gV2l0aG91dCBpdCB3ZSB3b3VsZCBuZWVkIHRvIGltcGxlbWVudCBzZXBhcmF0ZSBtZXRob2RzIGZvciBlYWNoIG9mXHJcbiAgICAvLyB0aG9zZSBjYXNlcyBhbmQgaXQncyBub3QgcG9zc2libGUgdG8gcGVyZm9ybSBhIHByZWNpc2UgYW5kIHBlcmZvcm1hbmNlXHJcbiAgICAvLyBlZmZlY3RpdmUgdGVzdCBmb3IgaGlkZGVuIGVsZW1lbnRzLiBFLmcuIGV2ZW4galF1ZXJ5J3MgJzp2aXNpYmxlJyBmaWx0ZXJcclxuICAgIC8vIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgbGVzcyB0aGFuIDAuNS5cclxuICAgIGlmICghY2xpZW50V2lkdGggJiYgIWNsaWVudEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICB2YXIgc3R5bGVzID0gZ2V0V2luZG93T2YodGFyZ2V0KS5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XHJcbiAgICB2YXIgcGFkZGluZ3MgPSBnZXRQYWRkaW5ncyhzdHlsZXMpO1xyXG4gICAgdmFyIGhvcml6UGFkID0gcGFkZGluZ3MubGVmdCArIHBhZGRpbmdzLnJpZ2h0O1xyXG4gICAgdmFyIHZlcnRQYWQgPSBwYWRkaW5ncy50b3AgKyBwYWRkaW5ncy5ib3R0b207XHJcbiAgICAvLyBDb21wdXRlZCBzdHlsZXMgb2Ygd2lkdGggJiBoZWlnaHQgYXJlIGJlaW5nIHVzZWQgYmVjYXVzZSB0aGV5IGFyZSB0aGVcclxuICAgIC8vIG9ubHkgZGltZW5zaW9ucyBhdmFpbGFibGUgdG8gSlMgdGhhdCBjb250YWluIG5vbi1yb3VuZGVkIHZhbHVlcy4gSXQgY291bGRcclxuICAgIC8vIGJlIHBvc3NpYmxlIHRvIHV0aWxpemUgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpZiBvbmx5IGl0J3MgZGF0YSB3YXNuJ3RcclxuICAgIC8vIGFmZmVjdGVkIGJ5IENTUyB0cmFuc2Zvcm1hdGlvbnMgbGV0IGFsb25lIHBhZGRpbmdzLCBib3JkZXJzIGFuZCBzY3JvbGwgYmFycy5cclxuICAgIHZhciB3aWR0aCA9IHRvRmxvYXQoc3R5bGVzLndpZHRoKSwgaGVpZ2h0ID0gdG9GbG9hdChzdHlsZXMuaGVpZ2h0KTtcclxuICAgIC8vIFdpZHRoICYgaGVpZ2h0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgd2hlbiB0aGUgJ2JvcmRlci1ib3gnIGJveFxyXG4gICAgLy8gbW9kZWwgaXMgYXBwbGllZCAoZXhjZXB0IGZvciBJRSkuXHJcbiAgICBpZiAoc3R5bGVzLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XHJcbiAgICAgICAgLy8gRm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGhhbmRsZSBJbnRlcm5ldCBFeHBsb3JlciB3aGljaFxyXG4gICAgICAgIC8vIGRvZXNuJ3QgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB0byBjb21wdXRlZCBDU1MgZGltZW5zaW9ucy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdlIGNhbiBzYXkgdGhhdCBpZiBDU1MgZGltZW5zaW9ucyArIHBhZGRpbmdzIGFyZSBlcXVhbCB0byB0aGUgXCJjbGllbnRcIlxyXG4gICAgICAgIC8vIHByb3BlcnRpZXMgdGhlbiBpdCdzIGVpdGhlciBJRSwgYW5kIHRodXMgd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdFxyXG4gICAgICAgIC8vIGFueXRoaW5nLCBvciBhbiBlbGVtZW50IG1lcmVseSBkb2Vzbid0IGhhdmUgcGFkZGluZ3MvYm9yZGVycyBzdHlsZXMuXHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgIT09IGNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ2xlZnQnLCAncmlnaHQnKSArIGhvcml6UGFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAhPT0gY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd0b3AnLCAnYm90dG9tJykgKyB2ZXJ0UGFkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEZvbGxvd2luZyBzdGVwcyBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCdzIHJvb3QgZWxlbWVudCBhcyBpdHNcclxuICAgIC8vIGNsaWVudFtXaWR0aC9IZWlnaHRdIHByb3BlcnRpZXMgcmVwcmVzZW50IHZpZXdwb3J0IGFyZWEgb2YgdGhlIHdpbmRvdy5cclxuICAgIC8vIEJlc2lkZXMsIGl0J3MgYXMgd2VsbCBub3QgbmVjZXNzYXJ5IGFzIHRoZSA8aHRtbD4gaXRzZWxmIG5laXRoZXIgaGFzXHJcbiAgICAvLyByZW5kZXJlZCBzY3JvbGwgYmFycyBub3IgaXQgY2FuIGJlIGNsaXBwZWQuXHJcbiAgICBpZiAoIWlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIChvbmx5IGluIEZpcmVmb3gsIGFjdHVhbGx5KSBDU1Mgd2lkdGggJiBoZWlnaHRcclxuICAgICAgICAvLyBpbmNsdWRlIHNjcm9sbCBiYXJzIHNpemUgd2hpY2ggY2FuIGJlIHJlbW92ZWQgYXQgdGhpcyBzdGVwIGFzIHNjcm9sbFxyXG4gICAgICAgIC8vIGJhcnMgYXJlIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiByb3VuZGVkIGRpbWVuc2lvbnMgKyBwYWRkaW5nc1xyXG4gICAgICAgIC8vIGFuZCBcImNsaWVudFwiIHByb3BlcnRpZXMsIHRob3VnaCB0aGF0IGlzIG5vdCBhbHdheXMgdHJ1ZSBpbiBDaHJvbWUuXHJcbiAgICAgICAgdmFyIHZlcnRTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpIC0gY2xpZW50V2lkdGg7XHJcbiAgICAgICAgdmFyIGhvcml6U2Nyb2xsYmFyID0gTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAtIGNsaWVudEhlaWdodDtcclxuICAgICAgICAvLyBDaHJvbWUgaGFzIGEgcmF0aGVyIHdlaXJkIHJvdW5kaW5nIG9mIFwiY2xpZW50XCIgcHJvcGVydGllcy5cclxuICAgICAgICAvLyBFLmcuIGZvciBhbiBlbGVtZW50IHdpdGggY29udGVudCB3aWR0aCBvZiAzMTQuMnB4IGl0IHNvbWV0aW1lcyBnaXZlc1xyXG4gICAgICAgIC8vIHRoZSBjbGllbnQgd2lkdGggb2YgMzE1cHggYW5kIGZvciB0aGUgd2lkdGggb2YgMzE0LjdweCBpdCBtYXkgZ2l2ZVxyXG4gICAgICAgIC8vIDMxNHB4LiBBbmQgaXQgZG9lc24ndCBoYXBwZW4gYWxsIHRoZSB0aW1lLiBTbyBqdXN0IGlnbm9yZSB0aGlzIGRlbHRhXHJcbiAgICAgICAgLy8gYXMgYSBub24tcmVsZXZhbnQuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHZlcnRTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IHZlcnRTY3JvbGxiYXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLmFicyhob3JpelNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IGhvcml6U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdChwYWRkaW5ncy5sZWZ0LCBwYWRkaW5ncy50b3AsIHdpZHRoLCBoZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBTVkdHcmFwaGljc0VsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbnZhciBpc1NWR0dyYXBoaWNzRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBTb21lIGJyb3dzZXJzLCBuYW1lbHkgSUUgYW5kIEVkZ2UsIGRvbid0IGhhdmUgdGhlIFNWR0dyYXBoaWNzRWxlbWVudFxyXG4gICAgLy8gaW50ZXJmYWNlLlxyXG4gICAgaWYgKHR5cGVvZiBTVkdHcmFwaGljc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHR3JhcGhpY3NFbGVtZW50OyB9O1xyXG4gICAgfVxyXG4gICAgLy8gSWYgaXQncyBzbywgdGhlbiBjaGVjayB0aGF0IGVsZW1lbnQgaXMgYXQgbGVhc3QgYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAvLyBTVkdFbGVtZW50IGFuZCB0aGF0IGl0IGhhcyB0aGUgXCJnZXRCQm94XCIgbWV0aG9kLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuICh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0VsZW1lbnQgJiZcclxuICAgICAgICB0eXBlb2YgdGFyZ2V0LmdldEJCb3ggPT09ICdmdW5jdGlvbicpOyB9O1xyXG59KSgpO1xyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhIGRvY3VtZW50IGVsZW1lbnQgKDxodG1sPikuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHRhcmdldCA9PT0gZ2V0V2luZG93T2YodGFyZ2V0KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYW4gYXBwcm9wcmlhdGUgY29udGVudCByZWN0YW5nbGUgZm9yIHByb3ZpZGVkIGh0bWwgb3Igc3ZnIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIGlmICghaXNCcm93c2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgIH1cclxuICAgIGlmIChpc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlY3RhbmdsZSB3aXRoIGFuIGludGVyZmFjZSBvZiB0aGUgRE9NUmVjdFJlYWRPbmx5LlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZG9tcmVjdHJlYWRvbmx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gT2JqZWN0IHdpdGggcmVjdGFuZ2xlJ3MgeC95IGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdFJlYWRPbmx5fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVhZE9ubHlSZWN0KF9hKSB7XHJcbiAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAvLyBJZiBET01SZWN0UmVhZE9ubHkgaXMgYXZhaWxhYmxlIHVzZSBpdCBhcyBhIHByb3RvdHlwZSBmb3IgdGhlIHJlY3RhbmdsZS5cclxuICAgIHZhciBDb25zdHIgPSB0eXBlb2YgRE9NUmVjdFJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJyA/IERPTVJlY3RSZWFkT25seSA6IE9iamVjdDtcclxuICAgIHZhciByZWN0ID0gT2JqZWN0LmNyZWF0ZShDb25zdHIucHJvdG90eXBlKTtcclxuICAgIC8vIFJlY3RhbmdsZSdzIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUuXHJcbiAgICBkZWZpbmVDb25maWd1cmFibGUocmVjdCwge1xyXG4gICAgICAgIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgdG9wOiB5LFxyXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXHJcbiAgICAgICAgYm90dG9tOiBoZWlnaHQgKyB5LFxyXG4gICAgICAgIGxlZnQ6IHhcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgRE9NUmVjdEluaXQgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zIGFuZCB0aGUgeC95IGNvb3JkaW5hdGVzLlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZGljdGRlZi1kb21yZWN0aW5pdFxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFJlY3RhbmdsZSdzIHdpZHRoLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gUmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWN0SW5pdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcbn1cblxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGF0aW9ucyBvZiB0aGUgY29udGVudCByZWN0YW5nbGUgb2ZcclxuICogcHJvdmlkZWQgRE9NIGVsZW1lbnQgYW5kIGZvciBrZWVwaW5nIHRyYWNrIG9mIGl0J3MgY2hhbmdlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb2FkY2FzdGVkIHdpZHRoIG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCBoZWlnaHQgb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7RE9NUmVjdEluaXR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBjb250ZW50IHJlY3RhbmdsZSBhbmQgdGVsbHMgd2hldGhlciBpdCdzIHdpZHRoIG9yIGhlaWdodCBwcm9wZXJ0aWVzXHJcbiAgICAgKiBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYnJvYWRjYXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBnZXRDb250ZW50UmVjdCh0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSByZWN0O1xyXG4gICAgICAgIHJldHVybiAocmVjdC53aWR0aCAhPT0gdGhpcy5icm9hZGNhc3RXaWR0aCB8fFxyXG4gICAgICAgICAgICByZWN0LmhlaWdodCAhPT0gdGhpcy5icm9hZGNhc3RIZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyAnYnJvYWRjYXN0V2lkdGgnIGFuZCAnYnJvYWRjYXN0SGVpZ2h0JyBwcm9wZXJ0aWVzIHdpdGggYSBkYXRhXHJcbiAgICAgKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgb2YgdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fSBMYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuYnJvYWRjYXN0UmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudFJlY3RfO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmF0aW9uO1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckVudHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0aGF0IGlzIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBEYXRhIG9mIHRoZSBlbGVtZW50J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRW50cnkodGFyZ2V0LCByZWN0SW5pdCkge1xyXG4gICAgICAgIHZhciBjb250ZW50UmVjdCA9IGNyZWF0ZVJlYWRPbmx5UmVjdChyZWN0SW5pdCk7XHJcbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGVcclxuICAgICAgICAvLyBhbmQgYXJlIGFsc28gbm90IGVudW1lcmFibGUgaW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFByb3BlcnR5IGFjY2Vzc29ycyBhcmUgbm90IGJlaW5nIHVzZWQgYXMgdGhleSdkIHJlcXVpcmUgdG8gZGVmaW5lIGFcclxuICAgICAgICAvLyBwcml2YXRlIFdlYWtNYXAgc3RvcmFnZSB3aGljaCBtYXkgY2F1c2UgbWVtb3J5IGxlYWtzIGluIGJyb3dzZXJzIHRoYXRcclxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IHRoaXMgdHlwZSBvZiBjb2xsZWN0aW9ucy5cclxuICAgICAgICBkZWZpbmVDb25maWd1cmFibGUodGhpcywgeyB0YXJnZXQ6IHRhcmdldCwgY29udGVudFJlY3Q6IGNvbnRlbnRSZWN0IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRW50cnk7XHJcbn0oKSk7XG5cbnZhciBSZXNpemVPYnNlcnZlclNQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkXHJcbiAgICAgKiAgICAgIHdoZW4gb25lIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2VzIGl0J3MgY29udGVudCBkaW1lbnNpb25zLlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBDb250cm9sbGVyIGluc3RhbmNlIHdoaWNoXHJcbiAgICAgKiAgICAgIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgdXBkYXRlcyBvZiBvYnNlcnZlci5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJ9IGNhbGxiYWNrQ3R4IC0gUmVmZXJlbmNlIHRvIHRoZSBwdWJsaWNcclxuICAgICAqICAgICAgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2Ugd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCBjYWxsYmFja0N0eCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgcmVzaXplIG9ic2VydmF0aW9ucyB0aGF0IGhhdmUgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBkaW1lbnNpb25zXHJcbiAgICAgICAgICogb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdHJ5IG9mIHRoZSBSZXNpemVPYnNlcnZhdGlvbiBpbnN0YW5jZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7TWFwPEVsZW1lbnQsIFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18gPSBuZXcgTWFwU2hpbSgpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIHByb3ZpZGVkIGFzIHBhcmFtZXRlciAxIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8gPSBjb250cm9sbGVyO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDdHhfID0gY2FsbGJhY2tDdHg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAob2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLnNldCh0YXJnZXQsIG5ldyBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLmFkZE9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIC8vIEZvcmNlIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVmcmVzaCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgbm90IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLnNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBvYnNlcnZpbmcgYWxsIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3RzIG9ic2VydmF0aW9uIGluc3RhbmNlcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IG9mIHdoaWNoIGhhcyBjaGFuZ2VkXHJcbiAgICAgKiBpdCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZ2F0aGVyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAob2JzZXJ2YXRpb24uaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyBpbml0aWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0IG9mIFJlc2l6ZU9ic2VydmVyRW50cnlcclxuICAgICAqIGluc3RhbmNlcyBjb2xsZWN0ZWQgZnJvbSBhY3RpdmUgcmVzaXplIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmJyb2FkY2FzdEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG9ic2VydmVyIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIGlmICghdGhpcy5oYXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbGxiYWNrQ3R4XztcclxuICAgICAgICAvLyBDcmVhdGUgUmVzaXplT2JzZXJ2ZXJFbnRyeSBpbnN0YW5jZSBmb3IgZXZlcnkgYWN0aXZlIG9ic2VydmF0aW9uLlxyXG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlckVudHJ5KG9ic2VydmF0aW9uLnRhcmdldCwgb2JzZXJ2YXRpb24uYnJvYWRjYXN0UmVjdCgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrXy5jYWxsKGN0eCwgZW50cmllcywgY3R4KTtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNvbGxlY3Rpb24gb2YgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmNsZWFyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5zcGxpY2UoMCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB3aGV0aGVyIG9ic2VydmVyIGhhcyBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuaGFzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTUEk7XHJcbn0oKSk7XG5cbi8vIFJlZ2lzdHJ5IG9mIGludGVybmFsIG9ic2VydmVycy4gSWYgV2Vha01hcCBpcyBub3QgYXZhaWxhYmxlIHVzZSBjdXJyZW50IHNoaW1cclxuLy8gZm9yIHRoZSBNYXAgY29sbGVjdGlvbiBhcyBpdCBoYXMgYWxsIHJlcXVpcmVkIG1ldGhvZHMgYW5kIGJlY2F1c2UgV2Vha01hcFxyXG4vLyBjYW4ndCBiZSBmdWxseSBwb2x5ZmlsbGVkIGFueXdheS5cclxudmFyIG9ic2VydmVycyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwU2hpbSgpO1xyXG4vKipcclxuICogUmVzaXplT2JzZXJ2ZXIgQVBJLiBFbmNhcHN1bGF0ZXMgdGhlIFJlc2l6ZU9ic2VydmVyIFNQSSBpbXBsZW1lbnRhdGlvblxyXG4gKiBleHBvc2luZyBvbmx5IHRob3NlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgc3BlYy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW5cclxuICAgICAqICAgICAgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcihjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNpemVPYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29udHJvbGxlciA9IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgdGhpcyk7XHJcbiAgICAgICAgb2JzZXJ2ZXJzLnNldCh0aGlzLCBvYnNlcnZlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbn0oKSk7XHJcbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBSZXNpemVPYnNlcnZlci5cclxuW1xyXG4gICAgJ29ic2VydmUnLFxyXG4gICAgJ3Vub2JzZXJ2ZScsXHJcbiAgICAnZGlzY29ubmVjdCdcclxuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gb2JzZXJ2ZXJzLmdldCh0aGlzKSlbbWV0aG9kXS5hcHBseShfYSwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbn0pO1xuXG52YXIgaW5kZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gRXhwb3J0IGV4aXN0aW5nIGltcGxlbWVudGF0aW9uIGlmIGF2YWlsYWJsZS5cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KSgpO1xuXG52YXIgSGVhZGluZ1BvcHVwQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShIZWFkaW5nUG9wdXBCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRpbmdQb3B1cEJvZHkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSGVhZGluZ1BvcHVwQm9keS5wcm90b3R5cGUuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIGVsID0gY2xvc2VzdChldi50YXJnZXQsICdsaScpO1xuICAgICAgICB0aGlzLnByb3BzLmV4ZWNDb21tYW5kKCdoZWFkaW5nJywge1xuICAgICAgICAgICAgbGV2ZWw6IE51bWJlcihlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGV2ZWwnKSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGVhZGluZ1BvcHVwQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8yJDggfHwgKHRlbXBsYXRlT2JqZWN0XzIkOCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDx1bFxcbiAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgIGFyaWEtcm9sZT1cXFwibWVudVxcXCJcXG4gICAgICAgIGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCJcXG4gICAgICA+XFxuICAgICAgICBcIiwgXCJcXG4gICAgICAgIDxsaSBkYXRhLXR5cGU9XFxcIlBhcmFncmFwaFxcXCIgYXJpYS1yb2xlPVxcXCJtZW51aXRlbVxcXCI+XFxuICAgICAgICAgIDxkaXY+XCIsIFwiPC9kaXY+XFxuICAgICAgICA8L2xpPlxcbiAgICAgIDwvdWw+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPHVsXFxuICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgYXJpYS1yb2xlPVxcXCJtZW51XFxcIlxcbiAgICAgICAgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIlxcbiAgICAgID5cXG4gICAgICAgIFwiLFxuICAgICAgICAgICAgXCJcXG4gICAgICAgIDxsaSBkYXRhLXR5cGU9XFxcIlBhcmFncmFwaFxcXCIgYXJpYS1yb2xlPVxcXCJtZW51aXRlbVxcXCI+XFxuICAgICAgICAgIDxkaXY+XCIsIFwiPC9kaXY+XFxuICAgICAgICA8L2xpPlxcbiAgICAgIDwvdWw+XFxuICAgIFwiXSkpLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmV4ZWNDb21tYW5kKGV2KTsgfSwgaTE4bi5nZXQoJ0hlYWRpbmdzJyksIFsxLCAyLCAzLCA0LCA1LCA2XS5tYXAoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGcgfHwgKHRlbXBsYXRlT2JqZWN0XzEkZyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICAgICAgPGxpIGRhdGEtbGV2ZWw9XFxcIlwiLCBcIlxcXCIgZGF0YS10eXBlPVxcXCJIZWFkaW5nXFxcIiBhcmlhLXJvbGU9XFxcIm1lbnVpdGVtXFxcIj5cXG4gICAgICAgICAgICAgICAgPFwiLCBcIj5cIiwgXCIgXCIsIFwiPC8kPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICAgICAgPGxpIGRhdGEtbGV2ZWw9XFxcIlwiLCBcIlxcXCIgZGF0YS10eXBlPVxcXCJIZWFkaW5nXFxcIiBhcmlhLXJvbGU9XFxcIm1lbnVpdGVtXFxcIj5cXG4gICAgICAgICAgICAgICAgPFwiLCBcIj5cIiwgXCIgXCIsIFwiPC8kPlxcbiAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICBcIl0pKSwgbGV2ZWwsIFwiaFwiICsgbGV2ZWwsIGkxOG4uZ2V0KCdIZWFkaW5nJyksIGxldmVsKTtcbiAgICAgICAgfSksIGkxOG4uZ2V0KCdQYXJhZ3JhcGgnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGVhZGluZ1BvcHVwQm9keTtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSRnLCB0ZW1wbGF0ZU9iamVjdF8yJDg7XG5cbnZhciBUYWJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFicygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJzLnByb3RvdHlwZS50b2dnbGVUYWIgPSBmdW5jdGlvbiAoZXYsIGFjdGl2ZVRhYikge1xuICAgICAgICB0aGlzLnByb3BzLm9uQ2xpY2soZXYsIGFjdGl2ZVRhYik7XG4gICAgfTtcbiAgICBUYWJzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzIkNyB8fCAodGVtcGxhdGVPYmplY3RfMiQ3ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBhcmlhLXJvbGU9XFxcInRhYnBhbmVsXFxcIj5cXG4gICAgICAgIFwiLCBcIlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgYXJpYS1yb2xlPVxcXCJ0YWJwYW5lbFxcXCI+XFxuICAgICAgICBcIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBjbHMoJ3RhYnMnKSwgdGhpcy5wcm9wcy50YWJzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdGV4dCA9IF9hLnRleHQ7XG4gICAgICAgICAgICB2YXIgaXNBY3RpdmUgPSBfdGhpcy5wcm9wcy5hY3RpdmVUYWIgPT09IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGYgfHwgKHRlbXBsYXRlT2JqZWN0XzEkZiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJ0YWItaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgICAgICBhcmlhLXJvbGU9XFxcInRhYlxcXCJcXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIHRhYmluZGV4PVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIFwiXSwgW1wiXFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcInRhYi1pdGVtXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgICAgIGFyaWEtcm9sZT1cXFwidGFiXFxcIlxcbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgYXJpYS1zZWxlY3RlZD1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgdGFiaW5kZXg9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgXCJdKSksIGlzQWN0aXZlID8gJyBhY3RpdmUnIDogJycsIGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMudG9nZ2xlVGFiKGV2LCBuYW1lKTsgfSwgaTE4bi5nZXQodGV4dCksIGlzQWN0aXZlID8gJ3RydWUnIDogJ2ZhbHNlJywgaXNBY3RpdmUgPyAnMCcgOiAnLTEnLCBpMThuLmdldCh0ZXh0KSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJzO1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJGYsIHRlbXBsYXRlT2JqZWN0XzIkNztcblxudmFyIFRZUEVfVUkgPSAndWknO1xudmFyIEltYWdlUG9wdXBCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEltYWdlUG9wdXBCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEltYWdlUG9wdXBCb2R5KHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbml0aWFsaXplID0gZnVuY3Rpb24gKGFjdGl2ZVRhYikge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVRhYiA9PT0gdm9pZCAwKSB7IGFjdGl2ZVRhYiA9ICdmaWxlJzsgfVxuICAgICAgICAgICAgdmFyIHVybEVsID0gX3RoaXMucmVmcy51cmw7XG4gICAgICAgICAgICB1cmxFbC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgX3RoaXMucmVmcy5hbHRUZXh0LnZhbHVlID0gJyc7XG4gICAgICAgICAgICBfdGhpcy5yZWZzLmZpbGUudmFsdWUgPSAnJztcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzXzEodXJsRWwsICd3cm9uZycpO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBhY3RpdmVUYWI6IGFjdGl2ZVRhYiwgZmlsZTogbnVsbCwgZmlsZU5hbWVFbENsYXNzTmFtZTogJycgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmV4ZWNDb21tYW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLmFjdGl2ZVRhYiA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdEFkZEltYWdlQmxvYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdEFkZEltYWdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnRvZ2dsZVRhYiA9IGZ1bmN0aW9uIChfLCBhY3RpdmVUYWIpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVUYWIgIT09IF90aGlzLnN0YXRlLmFjdGl2ZVRhYikge1xuICAgICAgICAgICAgICAgIF90aGlzLmluaXRpYWxpemUoYWN0aXZlVGFiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2hvd0ZpbGVTZWxlY3RCb3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWZzLmZpbGUuY2xpY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2hhbmdlRmlsZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGZpbGVzID0gZXYudGFyZ2V0LmZpbGVzO1xuICAgICAgICAgICAgaWYgKGZpbGVzID09PSBudWxsIHx8IGZpbGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGZpbGU6IGZpbGVzWzBdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHsgYWN0aXZlVGFiOiAnZmlsZScsIGZpbGU6IG51bGwsIGZpbGVOYW1lRWxDbGFzc05hbWU6ICcnIH07XG4gICAgICAgIF90aGlzLnRhYnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdmaWxlJywgdGV4dDogJ0ZpbGUnIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd1cmwnLCB0ZXh0OiAnVVJMJyB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEltYWdlUG9wdXBCb2R5LnByb3RvdHlwZS5lbWl0QWRkSW1hZ2VCbG9iID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmlsZXMgPSB0aGlzLnJlZnMuZmlsZS5maWxlcztcbiAgICAgICAgdmFyIGFsdFRleHRFbCA9IHRoaXMucmVmcy5hbHRUZXh0O1xuICAgICAgICB2YXIgZmlsZU5hbWVFbENsYXNzTmFtZSA9ICcgd3JvbmcnO1xuICAgICAgICBpZiAoZmlsZXMgPT09IG51bGwgfHwgZmlsZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZmlsZU5hbWVFbENsYXNzTmFtZSA9ICcnO1xuICAgICAgICAgICAgdmFyIGltYWdlRmlsZSA9IGZpbGVzLml0ZW0oMCk7XG4gICAgICAgICAgICB2YXIgaG9va0NhbGxiYWNrID0gZnVuY3Rpb24gKHVybCwgdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5leGVjQ29tbWFuZCgnYWRkSW1hZ2UnLCB7IGltYWdlVXJsOiB1cmwsIGFsdFRleHQ6IHRleHQgfHwgYWx0VGV4dEVsLnZhbHVlIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZXZlbnRFbWl0dGVyLmVtaXQoJ2FkZEltYWdlQmxvYkhvb2snLCBpbWFnZUZpbGUsIGhvb2tDYWxsYmFjaywgVFlQRV9VSSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVOYW1lRWxDbGFzc05hbWU6IGZpbGVOYW1lRWxDbGFzc05hbWUgfSk7XG4gICAgfTtcbiAgICBJbWFnZVBvcHVwQm9keS5wcm90b3R5cGUuZW1pdEFkZEltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW1hZ2VVcmxFbCA9IHRoaXMucmVmcy51cmw7XG4gICAgICAgIHZhciBhbHRUZXh0RWwgPSB0aGlzLnJlZnMuYWx0VGV4dDtcbiAgICAgICAgdmFyIGltYWdlVXJsID0gaW1hZ2VVcmxFbC52YWx1ZTtcbiAgICAgICAgdmFyIGFsdFRleHQgPSBhbHRUZXh0RWwudmFsdWUgfHwgJ2ltYWdlJztcbiAgICAgICAgcmVtb3ZlQ2xhc3NfMShpbWFnZVVybEVsLCAnd3JvbmcnKTtcbiAgICAgICAgaWYgKCFpbWFnZVVybC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZENsYXNzXzEoaW1hZ2VVcmxFbCwgJ3dyb25nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlVXJsKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmV4ZWNDb21tYW5kKCdhZGRJbWFnZScsIHsgaW1hZ2VVcmw6IGltYWdlVXJsLCBhbHRUZXh0OiBhbHRUZXh0IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbWFnZVBvcHVwQm9keS5wcm90b3R5cGUucHJldmVudFNlbGVjdFN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBJbWFnZVBvcHVwQm9keS5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLnNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbWFnZVBvcHVwQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBhY3RpdmVUYWIgPSBfYS5hY3RpdmVUYWIsIGZpbGUgPSBfYS5maWxlLCBmaWxlTmFtZUVsQ2xhc3NOYW1lID0gX2EuZmlsZU5hbWVFbENsYXNzTmFtZTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSRlIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8XCIsIFwiIHRhYnM9XCIsIFwiIGFjdGl2ZVRhYj1cIiwgXCIgb25DbGljaz1cIiwgXCIgLz5cXG4gICAgICAgIDxkaXYgc3R5bGU9XFxcImRpc3BsYXk6XCIsIFwiXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUltYWdlVXJsSW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpSW1hZ2VVcmxJbnB1dFxcXCJcXG4gICAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBzdHlsZT1cXFwiZGlzcGxheTpcIiwgXCI7cG9zaXRpb246IHJlbGF0aXZlO1xcXCI+XFxuICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlJbWFnZUZpbGVJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgICAgPHNwYW5cXG4gICAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgICAgb25TZWxlY3RzdGFydD1cIiwgXCJcXG4gICAgICAgICAgPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICBpZD1cXFwidG9hc3R1aUltYWdlRmlsZUlucHV0XFxcIlxcbiAgICAgICAgICAgIHR5cGU9XFxcImZpbGVcXFwiXFxuICAgICAgICAgICAgYWNjZXB0PVxcXCJpbWFnZS8qXFxcIlxcbiAgICAgICAgICAgIG9uQ2hhbmdlPVwiLCBcIlxcbiAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUFsdFRleHRJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICBpZD1cXFwidG9hc3R1aUFsdFRleHRJbnB1dFxcXCJcXG4gICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8XCIsIFwiIHRhYnM9XCIsIFwiIGFjdGl2ZVRhYj1cIiwgXCIgb25DbGljaz1cIiwgXCIgLz5cXG4gICAgICAgIDxkaXYgc3R5bGU9XFxcImRpc3BsYXk6XCIsIFwiXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUltYWdlVXJsSW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpSW1hZ2VVcmxJbnB1dFxcXCJcXG4gICAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBzdHlsZT1cXFwiZGlzcGxheTpcIiwgXCI7cG9zaXRpb246IHJlbGF0aXZlO1xcXCI+XFxuICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlJbWFnZUZpbGVJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgICAgPHNwYW5cXG4gICAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgICAgb25TZWxlY3RzdGFydD1cIiwgXCJcXG4gICAgICAgICAgPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgIDxidXR0b25cXG4gICAgICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICBpZD1cXFwidG9hc3R1aUltYWdlRmlsZUlucHV0XFxcIlxcbiAgICAgICAgICAgIHR5cGU9XFxcImZpbGVcXFwiXFxuICAgICAgICAgICAgYWNjZXB0PVxcXCJpbWFnZS8qXFxcIlxcbiAgICAgICAgICAgIG9uQ2hhbmdlPVwiLCBcIlxcbiAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUFsdFRleHRJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICBpZD1cXFwidG9hc3R1aUFsdFRleHRJbnB1dFxcXCJcXG4gICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGkxOG4uZ2V0KCdJbnNlcnQgaW1hZ2UnKSwgVGFicywgdGhpcy50YWJzLCBhY3RpdmVUYWIsIHRoaXMudG9nZ2xlVGFiLCBhY3RpdmVUYWIgPT09ICd1cmwnID8gJ2Jsb2NrJyA6ICdub25lJywgaTE4bi5nZXQoJ0ltYWdlIFVSTCcpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLnVybCA9IGVsKTsgfSwgYWN0aXZlVGFiID09PSAnZmlsZScgPyAnYmxvY2snIDogJ25vbmUnLCBpMThuLmdldCgnU2VsZWN0IGltYWdlIGZpbGUnKSwgY2xzKCdmaWxlLW5hbWUnKSwgZmlsZSA/ICcgaGFzLWZpbGUnIDogZmlsZU5hbWVFbENsYXNzTmFtZSwgdGhpcy5zaG93RmlsZVNlbGVjdEJveCwgdGhpcy5wcmV2ZW50U2VsZWN0U3RhcnQsIGZpbGUgPyBmaWxlLm5hbWUgOiBpMThuLmdldCgnTm8gZmlsZScpLCBjbHMoJ2ZpbGUtc2VsZWN0LWJ1dHRvbicpLCB0aGlzLnNob3dGaWxlU2VsZWN0Qm94LCBpMThuLmdldCgnQ2hvb3NlIGEgZmlsZScpLCB0aGlzLmNoYW5nZUZpbGUsIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZmlsZSA9IGVsKTsgfSwgaTE4bi5nZXQoJ0Rlc2NyaXB0aW9uJyksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuYWx0VGV4dCA9IGVsKTsgfSwgY2xzKCdidXR0b24tY29udGFpbmVyJyksIGNscygnY2xvc2UtYnV0dG9uJyksIHRoaXMucHJvcHMuaGlkZVBvcHVwLCBpMThuLmdldCgnQ2FuY2VsJyksIGNscygnb2stYnV0dG9uJyksIHRoaXMuZXhlY0NvbW1hbmQsIGkxOG4uZ2V0KCdPSycpKTtcbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVBvcHVwQm9keTtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSRlO1xuXG52YXIgTGlua1BvcHVwQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShMaW5rUG9wdXBCb2R5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmtQb3B1cEJvZHkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5leGVjQ29tbWFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsaW5rVXJsRWwgPSBfdGhpcy5yZWZzLnVybDtcbiAgICAgICAgICAgIHZhciBsaW5rVGV4dEVsID0gX3RoaXMucmVmcy50ZXh0O1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfMShsaW5rVXJsRWwsICd3cm9uZycpO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfMShsaW5rVGV4dEVsLCAnd3JvbmcnKTtcbiAgICAgICAgICAgIGlmIChsaW5rVXJsRWwudmFsdWUubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzXzEobGlua1VybEVsLCAnd3JvbmcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hlY2tMaW5rVGV4dCA9IGlzVW5kZWZpbmVkXzEoX3RoaXMucHJvcHMuaW5pdGlhbFZhbHVlcy5saW5rVXJsKTtcbiAgICAgICAgICAgIGlmIChjaGVja0xpbmtUZXh0ICYmIGxpbmtUZXh0RWwudmFsdWUubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzXzEobGlua1RleHRFbCwgJ3dyb25nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucHJvcHMuZXhlY0NvbW1hbmQoJ2FkZExpbmsnLCB7XG4gICAgICAgICAgICAgICAgbGlua1VybDogbGlua1VybEVsLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxpbmtUZXh0OiBsaW5rVGV4dEVsLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGlua1BvcHVwQm9keS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcy5pbml0aWFsVmFsdWVzLCBsaW5rVXJsID0gX2EubGlua1VybCwgbGlua1RleHQgPSBfYS5saW5rVGV4dDtcbiAgICAgICAgdmFyIGxpbmtVcmxFbCA9IHRoaXMucmVmcy51cmw7XG4gICAgICAgIHZhciBsaW5rVGV4dEVsID0gdGhpcy5yZWZzLnRleHQ7XG4gICAgICAgIHJlbW92ZUNsYXNzXzEobGlua1VybEVsLCAnd3JvbmcnKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3NfMShsaW5rVGV4dEVsLCAnd3JvbmcnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgbGlua1RleHRFbC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgIGlmIChsaW5rVXJsKSB7XG4gICAgICAgICAgICBhZGRDbGFzc18xKGxpbmtUZXh0RWwsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgbGlua1RleHRFbC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGlua1VybEVsLnZhbHVlID0gbGlua1VybCB8fCAnJztcbiAgICAgICAgbGlua1RleHRFbC52YWx1ZSA9IGxpbmtUZXh0IHx8ICcnO1xuICAgIH07XG4gICAgTGlua1BvcHVwQm9keS5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfTtcbiAgICBMaW5rUG9wdXBCb2R5LnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAoIXByZXZQcm9wcy5zaG93ICYmIHRoaXMucHJvcHMuc2hvdykge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmtQb3B1cEJvZHkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSRkIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpTGlua1VybElucHV0XFxcIj5cIiwgXCI8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0XFxuICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpTGlua1VybElucHV0XFxcIlxcbiAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUxpbmtUZXh0SW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgaWQ9XFxcInRvYXN0dWlMaW5rVGV4dElucHV0XFxcIlxcbiAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIiwgXCJcXFwiIG9uQ2xpY2s9XCIsIFwiPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIiwgXCJcXFwiIG9uQ2xpY2s9XCIsIFwiPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXYgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlMaW5rVXJsSW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgaWQ9XFxcInRvYXN0dWlMaW5rVXJsSW5wdXRcXFwiXFxuICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpTGlua1RleHRJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICBpZD1cXFwidG9hc3R1aUxpbmtUZXh0SW5wdXRcXFwiXFxuICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiLCBcIlxcXCIgb25DbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiLCBcIlxcXCIgb25DbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBpMThuLmdldCgnSW5zZXJ0IGxpbmsnKSwgaTE4bi5nZXQoJ1VSTCcpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLnVybCA9IGVsKTsgfSwgaTE4bi5nZXQoJ0xpbmsgdGV4dCcpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLnRleHQgPSBlbCk7IH0sIGNscygnYnV0dG9uLWNvbnRhaW5lcicpLCBjbHMoJ2Nsb3NlLWJ1dHRvbicpLCB0aGlzLnByb3BzLmhpZGVQb3B1cCwgaTE4bi5nZXQoJ0NhbmNlbCcpLCBjbHMoJ29rLWJ1dHRvbicpLCB0aGlzLmV4ZWNDb21tYW5kLCBpMThuLmdldCgnT0snKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGlua1BvcHVwQm9keTtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSRkO1xuXG52YXIgQ0VMTF9XSURUSCA9IDIwO1xudmFyIENFTExfSEVJR0hUID0gMjA7XG52YXIgTUlOX1JPV19JTkRFWCA9IDU7XG52YXIgTUFYX1JPV19JTkRFWCA9IDE0O1xudmFyIE1JTl9DT0xfSU5ERVggPSA1O1xudmFyIE1BWF9DT0xfSU5ERVggPSA5O1xudmFyIE1JTl9ST1dfU0VMRUNUSU9OX0lOREVYID0gMTtcbnZhciBNSU5fQ09MX1NFTEVDVElPTl9JTkRFWCA9IDE7XG52YXIgQk9SREVSX1dJRFRIID0gMTtcbnZhciBUYWJsZVBvcHVwQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZVBvcHVwQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZVBvcHVwQm9keShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXh0ZW5kU2VsZWN0aW9uUmFuZ2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBwYWdlWCA9IF9hLnBhZ2VYLCBwYWdlWSA9IF9hLnBhZ2VZO1xuICAgICAgICAgICAgdmFyIHggPSBwYWdlWCAtIF90aGlzLm9mZnNldFJlY3QubGVmdDtcbiAgICAgICAgICAgIHZhciB5ID0gcGFnZVkgLSBfdGhpcy5vZmZzZXRSZWN0LnRvcDtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IF90aGlzLmdldFNlbGVjdGlvblJhbmdlQnlPZmZzZXQoeCwgeSk7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShfX2Fzc2lnbiQxKHt9LCByYW5nZSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5leGVjQ29tbWFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLmV4ZWNDb21tYW5kKCdhZGRUYWJsZScsIHtcbiAgICAgICAgICAgICAgICByb3dDb3VudDogX3RoaXMuc3RhdGUucm93SWR4ICsgMSxcbiAgICAgICAgICAgICAgICBjb2x1bW5Db3VudDogX3RoaXMuc3RhdGUuY29sSWR4ICsgMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHJvd0lkeDogLTEsXG4gICAgICAgICAgICBjb2xJZHg6IC0xLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS5nZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY29sSWR4ID09PSAtMSA/ICcnIDogdGhpcy5zdGF0ZS5jb2xJZHggKyAxICsgXCIgeCBcIiArICh0aGlzLnN0YXRlLnJvd0lkeCArIDEpO1xuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLmdldEJvdW5kQnlSYW5nZSA9IGZ1bmN0aW9uIChjb2xJZHgsIHJvd0lkeCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IChjb2xJZHggKyAxKSAqIENFTExfV0lEVEgsXG4gICAgICAgICAgICBoZWlnaHQ6IChyb3dJZHggKyAxKSAqIENFTExfSEVJR0hULFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLmdldFJhbmdlQnlPZmZzZXQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sSWR4OiBNYXRoLmZsb29yKHggLyBDRUxMX1dJRFRIKSxcbiAgICAgICAgICAgIHJvd0lkeDogTWF0aC5mbG9vcih5IC8gQ0VMTF9IRUlHSFQpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLmdldFRhYmxlUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIG9yZ0NvbElkeCA9IF9hLmNvbElkeCwgb3JnUm93SWR4ID0gX2Eucm93SWR4O1xuICAgICAgICB2YXIgY29sSWR4ID0gTWF0aC5tYXgob3JnQ29sSWR4LCBNSU5fQ09MX0lOREVYKTtcbiAgICAgICAgdmFyIHJvd0lkeCA9IE1hdGgubWF4KG9yZ1Jvd0lkeCwgTUlOX1JPV19JTkRFWCk7XG4gICAgICAgIGlmIChvcmdDb2xJZHggPj0gTUlOX0NPTF9JTkRFWCAmJiBjb2xJZHggPCBNQVhfQ09MX0lOREVYKSB7XG4gICAgICAgICAgICBjb2xJZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JnUm93SWR4ID49IE1JTl9ST1dfSU5ERVggJiYgcm93SWR4IDwgTUFYX1JPV19JTkRFWCkge1xuICAgICAgICAgICAgcm93SWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY29sSWR4OiBjb2xJZHggKyAxLCByb3dJZHg6IHJvd0lkeCArIDEgfTtcbiAgICB9O1xuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS5nZXRTZWxlY3Rpb25BcmVhQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0Qm91bmRCeVJhbmdlKHRoaXMuc3RhdGUuY29sSWR4LCB0aGlzLnN0YXRlLnJvd0lkeCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgaWYgKCF3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4geyBkaXNwbGF5OiAnbm9uZScgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB3aWR0aDogd2lkdGggLSBCT1JERVJfV0lEVEgsIGhlaWdodDogaGVpZ2h0IC0gQk9SREVSX1dJRFRILCBkaXNwbGF5OiAnYmxvY2snIH07XG4gICAgfTtcbiAgICBUYWJsZVBvcHVwQm9keS5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uUmFuZ2VCeU9mZnNldCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2VCeU9mZnNldCh4LCB5KTtcbiAgICAgICAgcmFuZ2Uucm93SWR4ID0gTWF0aC5taW4oTWF0aC5tYXgocmFuZ2Uucm93SWR4LCBNSU5fUk9XX1NFTEVDVElPTl9JTkRFWCksIE1BWF9ST1dfSU5ERVgpO1xuICAgICAgICByYW5nZS5jb2xJZHggPSBNYXRoLm1pbihNYXRoLm1heChyYW5nZS5jb2xJZHgsIE1JTl9DT0xfU0VMRUNUSU9OX0lOREVYKSwgTUFYX0NPTF9JTkRFWCk7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuc2hvdykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvbElkeDogLTEsIHJvd0lkeDogLTEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5jb2xJZHggPT09IC0xICYmIHRoaXMuc3RhdGUucm93SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5yZWZzLnRhYmxlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxlZnQgPSBfYS5sZWZ0LCB0b3BfMSA9IF9hLnRvcDtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0UmVjdCA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB3aW5kb3cucGFnZVhPZmZzZXQgKyBsZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogd2luZG93LnBhZ2VZT2Zmc2V0ICsgdG9wXzEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJsZVBvcHVwQm9keS5wcm90b3R5cGUuY3JlYXRlVGFibGVBcmVhID0gZnVuY3Rpb24gKHRhYmxlUmFuZ2UpIHtcbiAgICAgICAgdmFyIGNvbElkeCA9IHRhYmxlUmFuZ2UuY29sSWR4LCByb3dJZHggPSB0YWJsZVJhbmdlLnJvd0lkeDtcbiAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dJZHg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbElkeDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxDbGFzc05hbWVzID0gXCJcIiArIGNscygndGFibGUtY2VsbCcpICsgKGkgPiAwID8gJycgOiAnIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGMgfHwgKHRlbXBsYXRlT2JqZWN0XzEkYyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+PC9kaXY+XCJdLCBbXCI8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPjwvZGl2PlwiXSkpLCBjZWxsQ2xhc3NOYW1lcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93cy5wdXNoKGh0bWwodGVtcGxhdGVPYmplY3RfMiQ2IHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlwiLCBcIjwvZGl2PlwiXSwgW1wiPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cIiwgXCI8L2Rpdj5cIl0pKSwgY2xzKCd0YWJsZS1yb3cnKSwgY2VsbHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8zJDIgfHwgKHRlbXBsYXRlT2JqZWN0XzMkMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XCIsIFwiPC9kaXY+XCJdLCBbXCI8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlwiLCBcIjwvZGl2PlwiXSkpLCBjbHMoJ3RhYmxlJyksIHJvd3MpO1xuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRhYmxlUmFuZ2UgPSB0aGlzLmdldFRhYmxlUmFuZ2UoKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkFyZWFCb3VuZCA9IHRoaXMuZ2V0U2VsZWN0aW9uQXJlYUJvdW5kKCk7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzQkMSB8fCAodGVtcGxhdGVPYmplY3RfNCQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdiBhcmlhLWxhYmVsPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIG9uTW91c2Vtb3ZlPVwiLCBcIlxcbiAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCI+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxwIGNsYXNzPVxcXCJcIiwgXCJcXFwiPlwiLCBcIjwvcD5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgb25Nb3VzZW1vdmU9XCIsIFwiXFxuICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPHAgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XCIsIFwiPC9wPlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgaTE4bi5nZXQoJ0luc2VydCB0YWJsZScpLCBjbHMoJ3RhYmxlLXNlbGVjdGlvbicpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLnRhYmxlRWwgPSBlbCk7IH0sIHRoaXMuZXh0ZW5kU2VsZWN0aW9uUmFuZ2UsIHRoaXMuZXhlY0NvbW1hbmQsIHRoaXMuY3JlYXRlVGFibGVBcmVhKHRhYmxlUmFuZ2UpLCBjbHMoJ3RhYmxlLXNlbGVjdGlvbi1sYXllcicpLCBzZWxlY3Rpb25BcmVhQm91bmQsIGNscygndGFibGUtZGVzY3JpcHRpb24nKSwgdGhpcy5nZXREZXNjcmlwdGlvbigpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZVBvcHVwQm9keTtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSRjLCB0ZW1wbGF0ZU9iamVjdF8yJDYsIHRlbXBsYXRlT2JqZWN0XzMkMiwgdGVtcGxhdGVPYmplY3RfNCQxO1xuXG52YXIgQ3VzdG9tUG9wdXBCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEN1c3RvbVBvcHVwQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21Qb3B1cEJvZHkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ3VzdG9tUG9wdXBCb2R5LnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGN1c3RvbSBwb3B1cCBib2R5IGVsZW1lbnRcbiAgICAgICAgdGhpcy5yZWZzLmVsLmFwcGVuZENoaWxkKHRoaXMucHJvcHMuYm9keSk7XG4gICAgfTtcbiAgICBDdXN0b21Qb3B1cEJvZHkucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBjdXN0b20gcG9wdXAgZWxlbWVudFxuICAgICAgICB0aGlzLnJlZnMuZWwucmVwbGFjZUNoaWxkKHRoaXMucHJvcHMuYm9keSwgcHJldlByb3BzLmJvZHkpO1xuICAgIH07XG4gICAgQ3VzdG9tUG9wdXBCb2R5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkYiB8fCAodGVtcGxhdGVPYmplY3RfMSRiID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPGRpdiByZWY9XCIsIFwiPjwvZGl2PlwiXSwgW1wiPGRpdiByZWY9XCIsIFwiPjwvZGl2PlwiXSkpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmVsID0gZWwpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDdXN0b21Qb3B1cEJvZHk7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkYjtcblxuZnVuY3Rpb24gY3JlYXRlVG9vbGJhckl0ZW1JbmZvKHR5cGUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdfMSh0eXBlKSA/IGNyZWF0ZURlZmF1bHRUb29sYmFySXRlbUluZm8odHlwZSkgOiB0eXBlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2Nyb2xsU3luY1Rvb2xiYXJJdGVtKCkge1xuICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgdmFyIGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB2YXIgdG9nZ2xlU3dpdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGxhYmVsLmNsYXNzTmFtZSA9ICdzY3JvbGwtc3luYyBhY3RpdmUnO1xuICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgIGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICAgIHRvZ2dsZVN3aXRjaC5jbGFzc05hbWUgPSAnc3dpdGNoJztcbiAgICB2YXIgb25Nb3VudGVkID0gZnVuY3Rpb24gKGV4ZWNDb21tYW5kKSB7XG4gICAgICAgIHJldHVybiBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBjaGVja2VkID0gZXYudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzXzEobGFiZWwsICdhY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzXzEobGFiZWwsICdhY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4ZWNDb21tYW5kKCd0b2dnbGVTY3JvbGxTeW5jJywgeyBhY3RpdmU6IGNoZWNrZWQgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgbGFiZWwuYXBwZW5kQ2hpbGQoY2hlY2tib3gpO1xuICAgIGxhYmVsLmFwcGVuZENoaWxkKHRvZ2dsZVN3aXRjaCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ3Njcm9sbFN5bmMnLFxuICAgICAgICBlbDogbGFiZWwsXG4gICAgICAgIG9uTW91bnRlZDogb25Nb3VudGVkLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0VG9vbGJhckl0ZW1JbmZvKHR5cGUpIHtcbiAgICB2YXIgaW5mbztcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdoZWFkaW5nJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdoZWFkaW5nJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnSGVhZGluZ3MnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2hlYWRpbmcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib2xkJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnQm9sZCcpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnc3Ryb25nJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaXRhbGljJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2l0YWxpYycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnaXRhbGljJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnaXRhbGljJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnSXRhbGljJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdlbXBoJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3N0cmlrZScsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnc3RyaWtlJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnc3RyaWtlJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnU3RyaWtlJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdHJpa2UnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdocic6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdocicsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnaHJsaW5lJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnaHInLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdMaW5lJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICd0aGVtYXRpY0JyZWFrJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncXVvdGUnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAncXVvdGUnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3F1b3RlJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnYmxvY2tRdW90ZScsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0Jsb2NrcXVvdGUnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2Jsb2NrUXVvdGUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1bCc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd1bCcsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnYnVsbGV0LWxpc3QnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdidWxsZXRMaXN0JyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnVW5vcmRlcmVkIGxpc3QnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2J1bGxldExpc3QnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvbCc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdvbCcsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnb3JkZXJlZC1saXN0JyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnb3JkZXJlZExpc3QnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdPcmRlcmVkIGxpc3QnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ29yZGVyZWRMaXN0JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFzayc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0YXNrJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICd0YXNrLWxpc3QnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd0YXNrTGlzdCcsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ1Rhc2snKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3Rhc2tMaXN0JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAndGFibGUnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3RhYmxlJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnSW5zZXJ0IHRhYmxlJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICd0YWJsZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0luc2VydCBpbWFnZScpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdJbnNlcnQgbGluaycpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnQ29kZScpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnY29kZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvZGVibG9jayc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjb2RlYmxvY2snLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2NvZGVibG9jaycsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2NvZGVCbG9jaycsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0luc2VydCBDb2RlQmxvY2snKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2NvZGVCbG9jaycsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luZGVudCc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdpbmRlbnQnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2luZGVudCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2luZGVudCcsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0luZGVudCcpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnaW5kZW50JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3V0ZGVudCc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdvdXRkZW50JyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdvdXRkZW50JyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnb3V0ZGVudCcsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ091dGRlbnQnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ291dGRlbnQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzY3JvbGxTeW5jJzpcbiAgICAgICAgICAgIGluZm8gPSBjcmVhdGVTY3JvbGxTeW5jVG9vbGJhckl0ZW0oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb3JlJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ21vcmUnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ21vcmUnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdNb3JlJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG4gICAgaWYgKGluZm8ubmFtZSAhPT0gJ3Njcm9sbFN5bmMnKSB7XG4gICAgICAgIGluZm8uY2xhc3NOYW1lICs9IFwiIFwiICsgY2xzKCd0b29sYmFyLWljb25zJyk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9wdXBJbmZvKHR5cGUsIHBheWxvYWQpIHtcbiAgICB2YXIgZWwgPSBwYXlsb2FkLmVsLCBwb3MgPSBwYXlsb2FkLnBvcywgcG9wdXAgPSBwYXlsb2FkLnBvcHVwLCBpbml0aWFsVmFsdWVzID0gcGF5bG9hZC5pbml0aWFsVmFsdWVzO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSRhIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSwgW1wiPFwiLCBcIiAuLi5cIiwgXCIgLz5cIl0pKSwgSGVhZGluZ1BvcHVwQm9keSwgcHJvcHMpOyB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzKCdwb3B1cC1hZGQtaGVhZGluZycpLFxuICAgICAgICAgICAgICAgIGZyb21FbDogZWwsXG4gICAgICAgICAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMiQ1IHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSwgW1wiPFwiLCBcIiAuLi5cIiwgXCIgLz5cIl0pKSwgTGlua1BvcHVwQm9keSwgcHJvcHMpOyB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzKCdwb3B1cC1hZGQtbGluaycpLFxuICAgICAgICAgICAgICAgIGZyb21FbDogZWwsXG4gICAgICAgICAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlczogaW5pdGlhbFZhbHVlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMyQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8zJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSwgW1wiPFwiLCBcIiAuLi5cIiwgXCIgLz5cIl0pKSwgSW1hZ2VQb3B1cEJvZHksIHByb3BzKTsgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNscygncG9wdXAtYWRkLWltYWdlJyksXG4gICAgICAgICAgICAgICAgZnJvbUVsOiBlbCxcbiAgICAgICAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfNCB8fCAodGVtcGxhdGVPYmplY3RfNCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxcIiwgXCIgLi4uXCIsIFwiIC8+XCJdLCBbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSkpLCBUYWJsZVBvcHVwQm9keSwgcHJvcHMpOyB9LFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xzKCdwb3B1cC1hZGQtdGFibGUnKSxcbiAgICAgICAgICAgICAgICBmcm9tRWw6IGVsLFxuICAgICAgICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnY3VzdG9tUG9wdXBCb2R5JzpcbiAgICAgICAgICAgIGlmICghcG9wdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgcmVuZGVyOiBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfNSB8fCAodGVtcGxhdGVPYmplY3RfNSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxcIiwgXCIgLi4uXCIsIFwiIGJvZHk9XCIsIFwiIC8+XCJdLCBbXCI8XCIsIFwiIC4uLlwiLCBcIiBib2R5PVwiLCBcIiAvPlwiXSkpLCBDdXN0b21Qb3B1cEJvZHksIHByb3BzLCBwb3B1cC5ib2R5KTsgfSwgZnJvbUVsOiBlbCwgcG9zOiBwb3MgfSwgcG9wdXApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0R3JvdXBTdGF0ZShncm91cCkge1xuICAgIGdyb3VwLmhpZGRlbiA9IGdyb3VwLmxlbmd0aCA9PT0gZ3JvdXAuZmlsdGVyKGZ1bmN0aW9uIChpbmZvKSB7IHJldHVybiBpbmZvLmhpZGRlbjsgfSkubGVuZ3RoO1xufVxuZnVuY3Rpb24gZ3JvdXBUb29sYmFySXRlbXModG9vbGJhckl0ZW1zLCBoaWRkZW5TY3JvbGxTeW5jKSB7XG4gICAgdmFyIHRvZ2dsZVNjcm9sbFN5bmNTdGF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGl0ZW0uaGlkZGVuID0gaXRlbS5uYW1lID09PSAnc2Nyb2xsU3luYycgJiYgaGlkZGVuU2Nyb2xsU3luYztcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfTtcbiAgICByZXR1cm4gdG9vbGJhckl0ZW1zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICAgIGFjYy5wdXNoKGl0ZW0ubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0b2dnbGVTY3JvbGxTeW5jU3RhdGUoY3JlYXRlVG9vbGJhckl0ZW1JbmZvKHR5cGUpKTsgfSkpO1xuICAgICAgICB2YXIgZ3JvdXAgPSBhY2NbKGFjYy5sZW5ndGggfHwgMSkgLSAxXTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBzZXRHcm91cFN0YXRlKGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVNjcm9sbFN5bmModG9vbGJhckl0ZW1zLCBoaWRkZW5TY3JvbGxTeW5jKSB7XG4gICAgdG9vbGJhckl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIChpdGVtLmhpZGRlbiA9IGl0ZW0ubmFtZSA9PT0gJ3Njcm9sbFN5bmMnICYmIGhpZGRlblNjcm9sbFN5bmMpOyB9KTtcbiAgICAgICAgc2V0R3JvdXBTdGF0ZShncm91cCk7XG4gICAgfSk7XG59XG52YXIgdGVtcGxhdGVPYmplY3RfMSRhLCB0ZW1wbGF0ZU9iamVjdF8yJDUsIHRlbXBsYXRlT2JqZWN0XzMkMSwgdGVtcGxhdGVPYmplY3RfNCwgdGVtcGxhdGVPYmplY3RfNTtcblxudmFyIE1BUkdJTl9GUk9NX1JJR0hUX1NJREUgPSAyMDtcbnZhciBQb3B1cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShQb3B1cCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb3B1cCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0KGV2LnRhcmdldCwgXCIuXCIgKyBjbHMoJ3BvcHVwJykpICYmXG4gICAgICAgICAgICAgICAgIWNsb3Nlc3QoZXYudGFyZ2V0LCBfdGhpcy5wcm9wcy5pbmZvLmZyb21FbCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5oaWRlUG9wdXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQb3B1cC5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZWRvd24pO1xuICAgICAgICB0aGlzLnByb3BzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2Nsb3NlUG9wdXAnLCB0aGlzLnByb3BzLmhpZGVQb3B1cCk7XG4gICAgfTtcbiAgICBQb3B1cC5wcm90b3R5cGUuYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZWRvd24pO1xuICAgIH07XG4gICAgUG9wdXAucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNob3cgPSBfYS5zaG93LCBpbmZvID0gX2EuaW5mbztcbiAgICAgICAgaWYgKHNob3cgJiYgaW5mby5wb3MgJiYgcHJldlByb3BzLnNob3cgIT09IHNob3cpIHtcbiAgICAgICAgICAgIHZhciBwb3B1cFBvcyA9IF9fYXNzaWduJDEoe30sIGluZm8ucG9zKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXRXaWR0aCA9IHRoaXMucmVmcy5lbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciB0b29sYmFyRWwgPSBjbG9zZXN0KHRoaXMucmVmcy5lbCwgXCIuXCIgKyBjbHMoJ3Rvb2xiYXInKSk7XG4gICAgICAgICAgICB2YXIgdG9vbGJhck9mZnNldFdpZHRoID0gdG9vbGJhckVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgaWYgKHBvcHVwUG9zLmxlZnQgKyBvZmZzZXRXaWR0aCA+PSB0b29sYmFyT2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBwb3B1cFBvcy5sZWZ0ID0gdG9vbGJhck9mZnNldFdpZHRoIC0gb2Zmc2V0V2lkdGggLSBNQVJHSU5fRlJPTV9SSUdIVF9TSURFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaGFsbG93RXF1YWwodGhpcy5zdGF0ZS5wb3B1cFBvcywgcG9wdXBQb3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHBvcHVwUG9zOiBwb3B1cFBvcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9wdXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgaW5mbyA9IF9hLmluZm8sIHNob3cgPSBfYS5zaG93LCBoaWRlUG9wdXAgPSBfYS5oaWRlUG9wdXAsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlciwgZXhlY0NvbW1hbmQgPSBfYS5leGVjQ29tbWFuZDtcbiAgICAgICAgdmFyIF9iID0gaW5mbyB8fCB7fSwgX2MgPSBfYi5jbGFzc05hbWUsIGNsYXNzTmFtZSA9IF9jID09PSB2b2lkIDAgPyAnJyA6IF9jLCBzdHlsZSA9IF9iLnN0eWxlLCByZW5kZXIgPSBfYi5yZW5kZXIsIF9kID0gX2IuaW5pdGlhbFZhbHVlcywgaW5pdGlhbFZhbHVlcyA9IF9kID09PSB2b2lkIDAgPyB7fSA6IF9kO1xuICAgICAgICB2YXIgcG9wdXBTdHlsZSA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7IGRpc3BsYXk6IHNob3cgPyAnYmxvY2snIDogJ25vbmUnIH0sIHN0eWxlKSwgdGhpcy5zdGF0ZS5wb3B1cFBvcyk7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkOSB8fCAodGVtcGxhdGVPYmplY3RfMSQ5ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcIlwiLCBcIiBcIiwgXCJcXFwiXFxuICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIGFyaWEtcm9sZT1cXFwiZGlhbG9nXFxcIlxcbiAgICAgID5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcIlwiLCBcIiBcIiwgXCJcXFwiXFxuICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIGFyaWEtcm9sZT1cXFwiZGlhbG9nXFxcIlxcbiAgICAgID5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBjbHMoJ3BvcHVwJyksIGNsYXNzTmFtZSwgcG9wdXBTdHlsZSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lbCA9IGVsKTsgfSwgY2xzKCdwb3B1cC1ib2R5JyksIHJlbmRlciAmJiByZW5kZXIoeyBldmVudEVtaXR0ZXI6IGV2ZW50RW1pdHRlciwgc2hvdzogc2hvdywgaGlkZVBvcHVwOiBoaWRlUG9wdXAsIGV4ZWNDb21tYW5kOiBleGVjQ29tbWFuZCwgaW5pdGlhbFZhbHVlczogaW5pdGlhbFZhbHVlcyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gUG9wdXA7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkOTtcblxudmFyIFRPT0xUSVBfSU5ERU5UID0gNjtcbmZ1bmN0aW9uIGNvbm5lY3RIT0MoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKEJ1dHRvbkhPQywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQnV0dG9uSE9DKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnNob3dUb29sdGlwID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXAgPSBfdGhpcy5wcm9wcy5pdGVtLnRvb2x0aXA7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5kaXNhYmxlZCAmJiB0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZCA9IF90aGlzLmdldEJvdW5kKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBib3VuZC5sZWZ0ICsgVE9PTFRJUF9JTkRFTlQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BfMSA9IGJvdW5kLnRvcCArIFRPT0xUSVBfSU5ERU5UICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBjc3NfMShfdGhpcy5wcm9wcy50b29sdGlwUmVmLmN1cnJlbnQsIHsgZGlzcGxheTogJ2Jsb2NrJywgbGVmdDogbGVmdCwgdG9wOiB0b3BfMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMudG9vbHRpcFJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZXh0JykudGV4dENvbnRlbnQgPSB0b29sdGlwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5oaWRlVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjc3NfMShfdGhpcy5wcm9wcy50b29sdGlwUmVmLmN1cnJlbnQsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IHsgYWN0aXZlOiBmYWxzZSwgZGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkIH07XG4gICAgICAgICAgICBfdGhpcy5hZGRFdmVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIEJ1dHRvbkhPQy5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgaXRlbSA9IF9hLml0ZW0sIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgICAgIGlmIChpdGVtLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlVG9vbGJhclN0YXRlJywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvb2xiYXJTdGF0ZSA9IF9hLnRvb2xiYXJTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gKF9iID0gdG9vbGJhclN0YXRlW2l0ZW0uc3RhdGVdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSwgYWN0aXZlID0gX2MuYWN0aXZlLCBkaXNhYmxlZCA9IF9jLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGFjdGl2ZTogISFhY3RpdmUsIGRpc2FibGVkOiBkaXNhYmxlZCAhPT0gbnVsbCAmJiBkaXNhYmxlZCAhPT0gdm9pZCAwID8gZGlzYWJsZWQgOiBfdGhpcy5wcm9wcy5kaXNhYmxlZCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQnV0dG9uSE9DLnByb3RvdHlwZS5nZXRCb3VuZCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0VG90YWxPZmZzZXQoZWwsIGNsb3Nlc3QoZWwsIFwiLlwiICsgY2xzKCd0b29sYmFyJykpKSwgb2Zmc2V0TGVmdCA9IF9hLm9mZnNldExlZnQsIG9mZnNldFRvcCA9IF9hLm9mZnNldFRvcDtcbiAgICAgICAgICAgIHJldHVybiB7IGxlZnQ6IG9mZnNldExlZnQsIHRvcDogZWwub2Zmc2V0SGVpZ2h0ICsgb2Zmc2V0VG9wIH07XG4gICAgICAgIH07XG4gICAgICAgIEJ1dHRvbkhPQy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSQ4IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDggPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgLi4uXCIsIFwiXFxuICAgICAgICAgIGFjdGl2ZT1cIiwgXCJcXG4gICAgICAgICAgc2hvd1Rvb2x0aXA9XCIsIFwiXFxuICAgICAgICAgIGhpZGVUb29sdGlwPVwiLCBcIlxcbiAgICAgICAgICBnZXRCb3VuZD1cIiwgXCJcXG4gICAgICAgICAgZGlzYWJsZWQ9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgIFwiXSwgW1wiXFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICBhY3RpdmU9XCIsIFwiXFxuICAgICAgICAgIHNob3dUb29sdGlwPVwiLCBcIlxcbiAgICAgICAgICBoaWRlVG9vbHRpcD1cIiwgXCJcXG4gICAgICAgICAgZ2V0Qm91bmQ9XCIsIFwiXFxuICAgICAgICAgIGRpc2FibGVkPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICBcIl0pKSwgV3JhcHBlZENvbXBvbmVudCwgdGhpcy5wcm9wcywgdGhpcy5zdGF0ZS5hY3RpdmUsIHRoaXMuc2hvd1Rvb2x0aXAsIHRoaXMuaGlkZVRvb2x0aXAsIHRoaXMuZ2V0Qm91bmQsIHRoaXMuc3RhdGUuZGlzYWJsZWQgfHwgdGhpcy5wcm9wcy5kaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCdXR0b25IT0M7XG4gICAgfShDb21wb25lbnQpKTtcbn1cbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDg7XG5cbnZhciBERUZBVUxUX1dJRFRIID0gODA7XG52YXIgVG9vbGJhckJ1dHRvbkNvbXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVG9vbGJhckJ1dHRvbkNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9vbGJhckJ1dHRvbkNvbXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dUb29sdGlwKF90aGlzLnJlZnMuZWwpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5leGVjQ29tbWFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBpdGVtID0gX2EuaXRlbSwgZXhlY0NvbW1hbmQgPSBfYS5leGVjQ29tbWFuZCwgc2V0UG9wdXBJbmZvID0gX2Euc2V0UG9wdXBJbmZvLCBnZXRCb3VuZCA9IF9hLmdldEJvdW5kLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXI7XG4gICAgICAgICAgICB2YXIgY29tbWFuZCA9IGl0ZW0uY29tbWFuZCwgbmFtZSA9IGl0ZW0ubmFtZSwgcG9wdXAgPSBpdGVtLnBvcHVwO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBleGVjQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwb3B1cE5hbWUgPSBwb3B1cCA/ICdjdXN0b21Qb3B1cEJvZHknIDogbmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFZhbHVlcyA9IGV2ZW50RW1pdHRlci5lbWl0KCdxdWVyeScsICdnZXRQb3B1cEluaXRpYWxWYWx1ZXMnLCB7IHBvcHVwTmFtZTogcG9wdXBOYW1lIH0pWzBdO1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gY3JlYXRlUG9wdXBJbmZvKHBvcHVwTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBlbDogX3RoaXMucmVmcy5lbCxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBnZXRCb3VuZChfdGhpcy5yZWZzLmVsKSxcbiAgICAgICAgICAgICAgICAgICAgcG9wdXA6IHBvcHVwLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWVzOiBpbml0aWFsVmFsdWVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFBvcHVwSW5mbyhpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVG9vbGJhckJ1dHRvbkNvbXAucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0SXRlbVdpZHRoKCk7XG4gICAgfTtcbiAgICBUb29sYmFyQnV0dG9uQ29tcC5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5pdGVtLm5hbWUgIT09IHRoaXMucHJvcHMuaXRlbS5uYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnNldEl0ZW1XaWR0aCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sYmFyQnV0dG9uQ29tcC5wcm90b3R5cGUuc2V0SXRlbVdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBzZXRJdGVtV2lkdGggPSBfYS5zZXRJdGVtV2lkdGgsIGl0ZW0gPSBfYS5pdGVtO1xuICAgICAgICAvLyBzZXQgd2lkdGggb25seSBpZiBpdCBpcyBub3QgYSBkcm9wZG93biB0b29sYmFyXG4gICAgICAgIGlmIChzZXRJdGVtV2lkdGgpIHtcbiAgICAgICAgICAgIHNldEl0ZW1XaWR0aChpdGVtLm5hbWUsIGdldE91dGVyV2lkdGgodGhpcy5yZWZzLmVsKSArIChpdGVtLmhpZGRlbiA/IERFRkFVTFRfV0lEVEggOiAwKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGhpZGVUb29sdGlwID0gX2EuaGlkZVRvb2x0aXAsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIGl0ZW0gPSBfYS5pdGVtLCBhY3RpdmUgPSBfYS5hY3RpdmU7XG4gICAgICAgIHZhciBzdHlsZSA9IF9fYXNzaWduJDEoeyBkaXNwbGF5OiBpdGVtLmhpZGRlbiA/ICdub25lJyA6IG51bGwgfSwgaXRlbS5zdHlsZSk7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gXCJcIiArIChpdGVtLmNsYXNzTmFtZSB8fCAnJykgKyAoYWN0aXZlID8gJyBhY3RpdmUnIDogJycpO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDcgfHwgKHRlbXBsYXRlT2JqZWN0XzEkNyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxidXR0b25cXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIHR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgY2xhc3M9XCIsIFwiXFxuICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgb25Nb3VzZW92ZXI9XCIsIFwiXFxuICAgICAgICBvbk1vdXNlb3V0PVwiLCBcIlxcbiAgICAgICAgZGlzYWJsZWQ9XCIsIFwiXFxuICAgICAgICBhcmlhLWxhYmVsPVwiLCBcIlxcbiAgICAgID5cXG4gICAgICAgIFwiLCBcIlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxidXR0b25cXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIHR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgY2xhc3M9XCIsIFwiXFxuICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgb25Nb3VzZW92ZXI9XCIsIFwiXFxuICAgICAgICBvbk1vdXNlb3V0PVwiLCBcIlxcbiAgICAgICAgZGlzYWJsZWQ9XCIsIFwiXFxuICAgICAgICBhcmlhLWxhYmVsPVwiLCBcIlxcbiAgICAgID5cXG4gICAgICAgIFwiLCBcIlxcbiAgICAgIDwvYnV0dG9uPlxcbiAgICBcIl0pKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lbCA9IGVsKTsgfSwgc3R5bGUsIGNsYXNzTmFtZXMsIHRoaXMuZXhlY0NvbW1hbmQsIHRoaXMuc2hvd1Rvb2x0aXAsIGhpZGVUb29sdGlwLCAhIWRpc2FibGVkLCBpdGVtLnRleHQgfHwgaXRlbS50b29sdGlwIHx8ICcnLCBpdGVtLnRleHQgfHwgJycpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2xiYXJCdXR0b25Db21wO1xufShDb21wb25lbnQpKTtcbnZhciBUb29sYmFyQnV0dG9uID0gY29ubmVjdEhPQyhUb29sYmFyQnV0dG9uQ29tcCk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQ3O1xuXG52YXIgQ3VzdG9tVG9vbGJhckl0ZW1Db21wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEN1c3RvbVRvb2xiYXJJdGVtQ29tcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21Ub29sYmFySXRlbUNvbXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dUb29sdGlwKF90aGlzLnJlZnMuZWwpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zaG93UG9wdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGNyZWF0ZVBvcHVwSW5mbygnY3VzdG9tUG9wdXBCb2R5Jywge1xuICAgICAgICAgICAgICAgIGVsOiBfdGhpcy5yZWZzLmVsLFxuICAgICAgICAgICAgICAgIHBvczogX3RoaXMucHJvcHMuZ2V0Qm91bmQoX3RoaXMucmVmcy5lbCksXG4gICAgICAgICAgICAgICAgcG9wdXA6IF90aGlzLnByb3BzLml0ZW0ucG9wdXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2V0UG9wdXBJbmZvKGluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEN1c3RvbVRvb2xiYXJJdGVtQ29tcC5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgc2V0SXRlbVdpZHRoID0gX2Euc2V0SXRlbVdpZHRoLCBpdGVtID0gX2EuaXRlbTtcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBjdXN0b20gaHRtbCBlbGVtZW50XG4gICAgICAgIHRoaXMucmVmcy5lbC5hcHBlbmRDaGlsZChpdGVtLmVsKTtcbiAgICAgICAgLy8gc2V0IHdpZHRoIG9ubHkgaWYgaXQgaXMgbm90IGEgZHJvcGRvd24gdG9vbGJhclxuICAgICAgICBpZiAoc2V0SXRlbVdpZHRoKSB7XG4gICAgICAgICAgICBzZXRJdGVtV2lkdGgoaXRlbS5uYW1lLCBnZXRPdXRlcldpZHRoKHRoaXMucmVmcy5lbCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLm9uTW91bnRlZCkge1xuICAgICAgICAgICAgaXRlbS5vbk1vdW50ZWQodGhpcy5wcm9wcy5leGVjQ29tbWFuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1c3RvbVRvb2xiYXJJdGVtQ29tcC5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnByb3BzLCBpdGVtID0gX2IuaXRlbSwgYWN0aXZlID0gX2IuYWN0aXZlLCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkO1xuICAgICAgICBpZiAocHJldlByb3BzLmFjdGl2ZSAhPT0gYWN0aXZlIHx8IHByZXZQcm9wcy5kaXNhYmxlZCAhPT0gZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIChfYSA9IGl0ZW0ub25VcGRhdGVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpdGVtLCB7IGFjdGl2ZTogYWN0aXZlLCBkaXNhYmxlZDogZGlzYWJsZWQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEN1c3RvbVRvb2xiYXJJdGVtQ29tcC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBpdGVtID0gX2EuaXRlbTtcbiAgICAgICAgdmFyIHN0eWxlID0geyBkaXNwbGF5OiBpdGVtLmhpZGRlbiA/ICdub25lJyA6ICdpbmxpbmUtYmxvY2snIH07XG4gICAgICAgIHZhciBnZXRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gKGRpc2FibGVkID8gbnVsbCA6IGxpc3RlbmVyKTsgfTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSQ2IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2XFxuICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgIGNsYXNzPVwiLCBcIlxcbiAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgIG9uTW91c2VvdmVyPVwiLCBcIlxcbiAgICAgICAgb25Nb3VzZW91dD1cIiwgXCJcXG4gICAgICA+PC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdlxcbiAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICBjbGFzcz1cIiwgXCJcXG4gICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICBvbk1vdXNlb3Zlcj1cIiwgXCJcXG4gICAgICAgIG9uTW91c2VvdXQ9XCIsIFwiXFxuICAgICAgPjwvZGl2PlxcbiAgICBcIl0pKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lbCA9IGVsKTsgfSwgc3R5bGUsIGNscygndG9vbGJhci1pdGVtLXdyYXBwZXInKSwgZ2V0TGlzdGVuZXIodGhpcy5zaG93UG9wdXApLCBnZXRMaXN0ZW5lcih0aGlzLnNob3dUb29sdGlwKSwgZ2V0TGlzdGVuZXIodGhpcy5wcm9wcy5oaWRlVG9vbHRpcCkpO1xuICAgIH07XG4gICAgcmV0dXJuIEN1c3RvbVRvb2xiYXJJdGVtQ29tcDtcbn0oQ29tcG9uZW50KSk7XG52YXIgQ3VzdG9tVG9vbGJhckl0ZW0gPSBjb25uZWN0SE9DKEN1c3RvbVRvb2xiYXJJdGVtQ29tcCk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQ2O1xuXG52YXIgVG9vbGJhckdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRvb2xiYXJHcm91cCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVG9vbGJhckdyb3VwLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGdyb3VwID0gX2EuZ3JvdXAsIGhpZGRlbkRpdmlkZXIgPSBfYS5oaWRkZW5EaXZpZGVyO1xuICAgICAgICB2YXIgZ3JvdXBTdHlsZSA9IGdyb3VwLmhpZGRlbiA/IHsgZGlzcGxheTogJ25vbmUnIH0gOiBudWxsO1xuICAgICAgICB2YXIgZGl2aWRlclN0eWxlID0gaGlkZGVuRGl2aWRlciA/IHsgZGlzcGxheTogJ25vbmUnIH0gOiBudWxsO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8yJDQgfHwgKHRlbXBsYXRlT2JqZWN0XzIkNCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiPlxcbiAgICAgICAgXCIsIFwiXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj48L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj5cXG4gICAgICAgIFwiLFxuICAgICAgICAgICAgXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiPjwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgY2xzKCd0b29sYmFyLWdyb3VwJyksIGdyb3VwU3R5bGUsIGdyb3VwLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIENvbXAgPSBpdGVtLmVsID8gQ3VzdG9tVG9vbGJhckl0ZW0gOiBUb29sYmFyQnV0dG9uO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSQ1IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8XCIsIFwiIGtleT1cIiwgXCIgLi4uXCIsIFwiIGl0ZW09XCIsIFwiIC8+XCJdLCBbXCI8XCIsIFwiIGtleT1cIiwgXCIgLi4uXCIsIFwiIGl0ZW09XCIsIFwiIC8+XCJdKSksIENvbXAsIGl0ZW0ubmFtZSwgX3RoaXMucHJvcHMsIGl0ZW0pO1xuICAgICAgICB9KSwgY2xzKCd0b29sYmFyLWRpdmlkZXInKSwgZGl2aWRlclN0eWxlKTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sYmFyR3JvdXA7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkNSwgdGVtcGxhdGVPYmplY3RfMiQ0O1xuXG52YXIgUE9QVVBfSU5ERU5UID0gNDtcbnZhciBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHJvcGRvd25Ub29sYmFyQnV0dG9uQ29tcChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlQ2xpY2tEb2N1bWVudCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IF9hLnRhcmdldDtcbiAgICAgICAgICAgIGlmICghY2xvc2VzdCh0YXJnZXQsIFwiLlwiICsgY2xzKCdkcm9wZG93bi10b29sYmFyJykpICYmXG4gICAgICAgICAgICAgICAgIWNsb3Nlc3QodGFyZ2V0LCAnLm1vcmUnKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2hvd0Ryb3Bkb3duOiBmYWxzZSwgZHJvcGRvd25Qb3M6IG51bGwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNob3dUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1Rvb2x0aXAoX3RoaXMucmVmcy5lbCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0YXRlID0geyBzaG93RHJvcGRvd246IGZhbHNlLCBkcm9wZG93blBvczogbnVsbCB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXAucHJvdG90eXBlLmdldEJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMucHJvcHMuZ2V0Qm91bmQodGhpcy5yZWZzLmVsKTtcbiAgICAgICAgcmVjdC50b3AgKz0gUE9QVVBfSU5ERU5UO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCByZWN0KSwgeyBsZWZ0OiBudWxsLCByaWdodDogMTAgfSk7XG4gICAgfTtcbiAgICBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tEb2N1bWVudCk7XG4gICAgfTtcbiAgICBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zaG93RHJvcGRvd24gJiYgIXRoaXMuc3RhdGUuZHJvcGRvd25Qb3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBkcm9wZG93blBvczogdGhpcy5nZXRCb3VuZCgpIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS5iZWZvcmVEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tEb2N1bWVudCk7XG4gICAgfTtcbiAgICBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIHNob3dEcm9wZG93biA9IF9hLnNob3dEcm9wZG93biwgZHJvcGRvd25Qb3MgPSBfYS5kcm9wZG93blBvcztcbiAgICAgICAgdmFyIF9iID0gdGhpcy5wcm9wcywgZGlzYWJsZWQgPSBfYi5kaXNhYmxlZCwgaXRlbSA9IF9iLml0ZW0sIGl0ZW1zID0gX2IuaXRlbXMsIGhpZGVUb29sdGlwID0gX2IuaGlkZVRvb2x0aXA7XG4gICAgICAgIHZhciB2aXNpYmxlSXRlbXMgPSBpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGRyb3Bkb3duSXRlbSkgeyByZXR1cm4gIWRyb3Bkb3duSXRlbS5oaWRkZW47IH0pO1xuICAgICAgICB2YXIgZ3JvdXBTdHlsZSA9IHZpc2libGVJdGVtcy5sZW5ndGggPyBudWxsIDogeyBkaXNwbGF5OiAnbm9uZScgfTtcbiAgICAgICAgdmFyIGRyb3Bkb3duU3R5bGUgPSBzaG93RHJvcGRvd24gPyBudWxsIDogeyBkaXNwbGF5OiAnbm9uZScgfTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMiQzIHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj5cXG4gICAgICAgIDxidXR0b25cXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICAgIGNsYXNzPVwiLCBcIlxcbiAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICBvbk1vdXNlb3Zlcj1cIiwgXCJcXG4gICAgICAgICAgb25Nb3VzZW91dD1cIiwgXCJcXG4gICAgICAgICAgZGlzYWJsZWQ9XCIsIFwiXFxuICAgICAgICA+PC9idXR0b24+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCI+XFxuICAgICAgICA8YnV0dG9uXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgICAgICBjbGFzcz1cIiwgXCJcXG4gICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgb25Nb3VzZW92ZXI9XCIsIFwiXFxuICAgICAgICAgIG9uTW91c2VvdXQ9XCIsIFwiXFxuICAgICAgICAgIGRpc2FibGVkPVwiLCBcIlxcbiAgICAgICAgPjwvYnV0dG9uPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGNscygndG9vbGJhci1ncm91cCcpLCBncm91cFN0eWxlLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmVsID0gZWwpOyB9LCBpdGVtLmNsYXNzTmFtZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2V0U3RhdGUoeyBzaG93RHJvcGRvd246IHRydWUgfSk7IH0sIHRoaXMuc2hvd1Rvb2x0aXAsIGhpZGVUb29sdGlwLCBkaXNhYmxlZCwgY2xzKCdkcm9wZG93bi10b29sYmFyJyksIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgZHJvcGRvd25TdHlsZSksIGRyb3Bkb3duUG9zKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5kcm9wZG93bkVsID0gZWwpOyB9LCB2aXNpYmxlSXRlbXMubGVuZ3RoXG4gICAgICAgICAgICA/IHZpc2libGVJdGVtcy5tYXAoZnVuY3Rpb24gKGdyb3VwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDQgfHwgKHRlbXBsYXRlT2JqZWN0XzEkNCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICAgICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwPVwiLCBcIlxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2aWRlcj1cIiwgXCJcXG4gICAgICAgICAgICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgICAgIFwiXSwgW1wiXFxuICAgICAgICAgICAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA9XCIsIFwiXFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW5EaXZpZGVyPVwiLFxuICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgLi4uXCIsIFwiXFxuICAgICAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICAgICAgXCJdKSksIFRvb2xiYXJHcm91cCwgZ3JvdXAsIGluZGV4ID09PSB2aXNpYmxlSXRlbXMubGVuZ3RoIC0gMSB8fFxuICAgICAgICAgICAgICAgICAgICAoKF9hID0gdmlzaWJsZUl0ZW1zW2luZGV4ICsgMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRkZW4pLCBfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBudWxsKTtcbiAgICB9O1xuICAgIHJldHVybiBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wO1xufShDb21wb25lbnQpKTtcbnZhciBEcm9wZG93blRvb2xiYXJCdXR0b24gPSBjb25uZWN0SE9DKERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXApO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkNCwgdGVtcGxhdGVPYmplY3RfMiQzO1xuXG52YXIgSU5MSU5FX1BBRERJTkcgPSA1MDtcbnZhciBUb29sYmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRvb2xiYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9vbGJhcihwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9nZ2xlVGFiID0gZnVuY3Rpb24gKF8sIGFjdGl2ZVRhYikge1xuICAgICAgICAgICAgdmFyIGV2ZW50RW1pdHRlciA9IF90aGlzLnByb3BzLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5hY3RpdmVUYWIgIT09IGFjdGl2ZVRhYikge1xuICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0gYWN0aXZlVGFiID09PSAnd3JpdGUnID8gJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScgOiAnY2hhbmdlUHJldmlld1RhYlByZXZpZXcnO1xuICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KGV2ZW50XzEpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgYWN0aXZlVGFiOiBhY3RpdmVUYWIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldEl0ZW1XaWR0aCA9IGZ1bmN0aW9uIChuYW1lLCB3aWR0aCkge1xuICAgICAgICAgICAgX3RoaXMuaXRlbVdpZHRoTWFwW25hbWVdID0gd2lkdGg7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldFBvcHVwSW5mbyA9IGZ1bmN0aW9uIChwb3B1cEluZm8pIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2hvd1BvcHVwOiB0cnVlLCBwb3B1cEluZm86IHBvcHVwSW5mbyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub3BlblBvcHVwID0gZnVuY3Rpb24gKHBvcHVwTmFtZSwgaW5pdGlhbFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGluaXRpYWxWYWx1ZXMgPT09IHZvaWQgMCkgeyBpbml0aWFsVmFsdWVzID0ge307IH1cbiAgICAgICAgICAgIHZhciBlbCA9IF90aGlzLnJlZnMuZWwucXVlcnlTZWxlY3RvcihcIi5cIiArIGNscygndG9vbGJhci1ncm91cCcpICsgXCIgLlwiICsgcG9wdXBOYW1lKTtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGdldFRvdGFsT2Zmc2V0KGVsLCBjbG9zZXN0KGVsLCBcIi5cIiArIGNscygndG9vbGJhcicpKSksIG9mZnNldExlZnQgPSBfYS5vZmZzZXRMZWZ0LCBvZmZzZXRUb3AgPSBfYS5vZmZzZXRUb3A7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBjcmVhdGVQb3B1cEluZm8ocG9wdXBOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiB7IGxlZnQ6IG9mZnNldExlZnQsIHRvcDogZWwub2Zmc2V0SGVpZ2h0ICsgb2Zmc2V0VG9wIH0sXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZXM6IGluaXRpYWxWYWx1ZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0UG9wdXBJbmZvKGluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGlkZVBvcHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnNob3dQb3B1cCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2hvd1BvcHVwOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoY29tbWFuZCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50RW1pdHRlciA9IF90aGlzLnByb3BzLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjb21tYW5kJywgY29tbWFuZCwgcGF5bG9hZCk7XG4gICAgICAgICAgICBfdGhpcy5oaWRlUG9wdXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudGFicyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ3dyaXRlJywgdGV4dDogJ1dyaXRlJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAncHJldmlldycsIHRleHQ6ICdQcmV2aWV3JyB9LFxuICAgICAgICBdO1xuICAgICAgICBfdGhpcy5pdGVtV2lkdGhNYXAgPSB7fTtcbiAgICAgICAgX3RoaXMuaW5pdGlhbEl0ZW1zID0gZ3JvdXBUb29sYmFySXRlbXMocHJvcHMudG9vbGJhckl0ZW1zIHx8IFtdLCBfdGhpcy5oaWRkZW5TY3JvbGxTeW5jKCkpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGl0ZW1zOiBfdGhpcy5pbml0aWFsSXRlbXMsXG4gICAgICAgICAgICBkcm9wZG93bkl0ZW1zOiBbXSxcbiAgICAgICAgICAgIHNob3dQb3B1cDogZmFsc2UsXG4gICAgICAgICAgICBwb3B1cEluZm86IHt9LFxuICAgICAgICAgICAgYWN0aXZlVGFiOiAnd3JpdGUnLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy50b29sdGlwUmVmID0geyBjdXJyZW50OiBudWxsIH07XG4gICAgICAgIF90aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IGluZGV4KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmhhbmRsZVJlc2l6ZSgpOyB9KTtcbiAgICAgICAgX3RoaXMuYWRkRXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUb29sYmFyLnByb3RvdHlwZS5pbnNlcnRUb29sYmFySXRlbSA9IGZ1bmN0aW9uIChpbmRleExpc3QsIGl0ZW0pIHtcbiAgICAgICAgdmFyIGdyb3VwSW5kZXggPSBpbmRleExpc3QuZ3JvdXBJbmRleCwgaXRlbUluZGV4ID0gaW5kZXhMaXN0Lml0ZW1JbmRleDtcbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5pbml0aWFsSXRlbXNbZ3JvdXBJbmRleF07XG4gICAgICAgIGl0ZW0gPSBjcmVhdGVUb29sYmFySXRlbUluZm8oaXRlbSk7XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgZ3JvdXAuc3BsaWNlKGl0ZW1JbmRleCwgMCwgaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxJdGVtcy5wdXNoKFtpdGVtXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmNsYXNzaWZ5VG9vbGJhckl0ZW1zKCkpO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUucmVtb3ZlVG9vbGJhckl0ZW0gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBmb3JFYWNoQXJyYXlfMSh0aGlzLmluaXRpYWxJdGVtcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvckVhY2hBcnJheV8xKGdyb3VwLCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX3RoaXMuY2xhc3NpZnlUb29sYmFySXRlbXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBldmVudEVtaXR0ZXIgPSB0aGlzLnByb3BzLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUgPSB0aHJvdHRsZV8xKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHRvb2xiYXIgaXRlbXMgdG8gcmUtbGF5b3V0IHRvb2xiYXIgaXRlbXMgd2l0aCBlYWNoIGNsaWVudFdpZHRoXG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGl0ZW1zOiBfdGhpcy5pbml0aWFsSXRlbXMsIGRyb3Bkb3duSXRlbXM6IFtdIH0pO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX3RoaXMuY2xhc3NpZnlUb29sYmFySXRlbXMoKSk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ29wZW5Qb3B1cCcsIHRoaXMub3BlblBvcHVwKTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLmFwcGVuZFRvb2x0aXBUb1Jvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b29sdGlwID0gXCI8ZGl2IGNsYXNzPVxcXCJcIiArIGNscygndG9vbHRpcCcpICsgXCJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmVcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRleHRcXFwiPjwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cIjtcbiAgICAgICAgdGhpcy50b29sdGlwUmVmLmN1cnJlbnQgPSBjcmVhdGVFbGVtZW50V2l0aCh0b29sdGlwLCB0aGlzLnJlZnMuZWwpO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUuaGlkZGVuU2Nyb2xsU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZWRpdG9yVHlwZSA9PT0gJ3d5c2l3eWcnIHx8IHRoaXMucHJvcHMucHJldmlld1N0eWxlID09PSAndGFiJztcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLm1vdmVQcmV2SXRlbVRvRHJvcGRvd25Ub29sYmFyID0gZnVuY3Rpb24gKGl0ZW1JbmRleCwgaXRlbXMsIGdyb3VwLCBkcm9wZG93bkdyb3VwKSB7XG4gICAgICAgIHZhciBtb3ZlSXRlbSA9IGZ1bmN0aW9uICh0YXJnZXRHcm91cCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0YXJnZXRHcm91cC5wb3AoKTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25Hcm91cC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXRlbUluZGV4ID4gMSkge1xuICAgICAgICAgICAgbW92ZUl0ZW0oZ3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZHcm91cCA9IGxhc3QkMShpdGVtcyk7XG4gICAgICAgICAgICBpZiAocHJldkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgbW92ZUl0ZW0ocHJldkdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUuY2xhc3NpZnlUb29sYmFySXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0b3RhbFdpZHRoID0gMDtcbiAgICAgICAgdmFyIGNsaWVudFdpZHRoID0gdGhpcy5yZWZzLmVsLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgZGl2aWRlciA9IHRoaXMucmVmcy5lbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgY2xzKCd0b29sYmFyLWRpdmlkZXInKSk7XG4gICAgICAgIHZhciBkaXZpZGVyV2lkdGggPSBkaXZpZGVyID8gZ2V0T3V0ZXJXaWR0aChkaXZpZGVyKSA6IDA7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICB2YXIgZHJvcGRvd25JdGVtcyA9IFtdO1xuICAgICAgICB2YXIgbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0aWFsSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaW5pdGlhbEdyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBbXTtcbiAgICAgICAgICAgIHZhciBkcm9wZG93bkdyb3VwID0gW107XG4gICAgICAgICAgICBpbml0aWFsR3JvdXAuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaXRlbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbFdpZHRoICs9IF90aGlzLml0ZW1XaWR0aE1hcFtpdGVtLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxXaWR0aCA+IGNsaWVudFdpZHRoIC0gSU5MSU5FX1BBRERJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBtb3ZlIHRoZSBwcmV2IGl0ZW0gdG8gZHJvcGRvd24gdG9vbGJhciBmb3IgcGxhY2luZyB0aGUgbW9yZSBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tb3ZlUHJldkl0ZW1Ub0Ryb3Bkb3duVG9vbGJhcihpdGVtSW5kZXgsIGl0ZW1zLCBncm91cCwgZHJvcGRvd25Hcm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcGRvd25Hcm91cC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNldEdyb3VwU3RhdGUoZ3JvdXApO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyb3Bkb3duR3JvdXAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0R3JvdXBTdGF0ZShkcm9wZG93bkdyb3VwKTtcbiAgICAgICAgICAgICAgICBkcm9wZG93bkl0ZW1zLnB1c2goZHJvcGRvd25Hcm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgZGl2aWRlciB3aWR0aFxuICAgICAgICAgICAgaWYgKGdyb3VwSW5kZXggPCBfdGhpcy5zdGF0ZS5pdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdG90YWxXaWR0aCArPSBkaXZpZGVyV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBpdGVtczogaXRlbXMsIGRyb3Bkb3duSXRlbXM6IGRyb3Bkb3duSXRlbXMgfTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnByZXZpZXdTdHlsZSA9PT0gJ3RhYicpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsYXNzaWZ5IHRvb2xiYXIgYW5kIGRyb3Bkb3duIHRvb2xiYXIgYWZ0ZXIgRE9NIGhhcyBiZWVuIHJlbmRlcmVkXG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5jbGFzc2lmeVRvb2xiYXJJdGVtcygpKTtcbiAgICAgICAgdGhpcy5hcHBlbmRUb29sdGlwVG9Sb290KCk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnJlZnMuZWwpO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZWRpdG9yVHlwZSA9IF9hLmVkaXRvclR5cGUsIHByZXZpZXdTdHlsZSA9IF9hLnByZXZpZXdTdHlsZSwgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyO1xuICAgICAgICB2YXIgY2hhbmdlZFN0eWxlID0gcHJldmlld1N0eWxlICE9PSBwcmV2UHJvcHMucHJldmlld1N0eWxlO1xuICAgICAgICB2YXIgY2hhbmdlZFR5cGUgPSBlZGl0b3JUeXBlICE9PSBwcmV2UHJvcHMuZWRpdG9yVHlwZTtcbiAgICAgICAgaWYgKGNoYW5nZWRTdHlsZSB8fCBjaGFuZ2VkVHlwZSkge1xuICAgICAgICAgICAgLy8gc2hvdyBvciBoaWRlIHNjcm9sbFN5bmMgYnV0dG9uXG4gICAgICAgICAgICB0b2dnbGVTY3JvbGxTeW5jKHRoaXMuaW5pdGlhbEl0ZW1zLCB0aGlzLmhpZGRlblNjcm9sbFN5bmMoKSk7XG4gICAgICAgICAgICB2YXIgbmV3U3RhdGUgPSB0aGlzLmNsYXNzaWZ5VG9vbGJhckl0ZW1zKCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFN0eWxlIHx8IChwcmV2aWV3U3R5bGUgPT09ICd0YWInICYmIGVkaXRvclR5cGUgPT09ICdtYXJrZG93bicpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScpO1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlLmFjdGl2ZVRhYiA9ICd3cml0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUuYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHJlbW92ZU5vZGUkMSh0aGlzLnRvb2x0aXBSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgICBUb29sYmFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHByZXZpZXdTdHlsZSA9IF9hLnByZXZpZXdTdHlsZSwgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyLCBlZGl0b3JUeXBlID0gX2EuZWRpdG9yVHlwZTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5zdGF0ZSwgcG9wdXBJbmZvID0gX2IucG9wdXBJbmZvLCBzaG93UG9wdXAgPSBfYi5zaG93UG9wdXAsIGFjdGl2ZVRhYiA9IF9iLmFjdGl2ZVRhYiwgaXRlbXMgPSBfYi5pdGVtcywgZHJvcGRvd25JdGVtcyA9IF9iLmRyb3Bkb3duSXRlbXM7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlcjogZXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgdG9vbHRpcFJlZjogdGhpcy50b29sdGlwUmVmLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGVkaXRvclR5cGUgPT09ICdtYXJrZG93bicgJiYgcHJldmlld1N0eWxlID09PSAndGFiJyAmJiBhY3RpdmVUYWIgPT09ICdwcmV2aWV3JyxcbiAgICAgICAgICAgIGV4ZWNDb21tYW5kOiB0aGlzLmV4ZWNDb21tYW5kLFxuICAgICAgICAgICAgc2V0UG9wdXBJbmZvOiB0aGlzLnNldFBvcHVwSW5mbyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRvb2xiYXJTdHlsZSA9IHByZXZpZXdTdHlsZSA9PT0gJ3RhYicgPyB7IGJvcmRlclRvcExlZnRSYWRpdXM6IDAgfSA6IG51bGw7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzIkMiB8fCAodGVtcGxhdGVPYmplY3RfMiQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgc3R5bGU9XFxcImRpc3BsYXk6IFwiLCBcIlxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPFwiLCBcIiB0YWJzPVwiLCBcIiBhY3RpdmVUYWI9XCIsIFwiIG9uQ2xpY2s9XCIsIFwiIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgICBpdGVtPVwiLCBcIlxcbiAgICAgICAgICAgIGl0ZW1zPVwiLCBcIlxcbiAgICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIGluZm89XCIsIFwiXFxuICAgICAgICAgIHNob3c9XCIsIFwiXFxuICAgICAgICAgIGV2ZW50RW1pdHRlcj1cIiwgXCJcXG4gICAgICAgICAgaGlkZVBvcHVwPVwiLCBcIlxcbiAgICAgICAgICBleGVjQ29tbWFuZD1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgc3R5bGU9XFxcImRpc3BsYXk6IFwiLFxuICAgICAgICAgICAgXCJcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIDxcIiwgXCIgdGFicz1cIiwgXCIgYWN0aXZlVGFiPVwiLCBcIiBvbkNsaWNrPVwiLCBcIiAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLFxuICAgICAgICAgICAgXCJcXG4gICAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICAgIGl0ZW09XCIsIFwiXFxuICAgICAgICAgICAgaXRlbXM9XCIsIFwiXFxuICAgICAgICAgICAgLi4uXCIsIFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgaW5mbz1cIiwgXCJcXG4gICAgICAgICAgc2hvdz1cIiwgXCJcXG4gICAgICAgICAgZXZlbnRFbWl0dGVyPVwiLCBcIlxcbiAgICAgICAgICBoaWRlUG9wdXA9XCIsIFwiXFxuICAgICAgICAgIGV4ZWNDb21tYW5kPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGNscygndG9vbGJhcicpLCBjbHMoJ21kLXRhYi1jb250YWluZXInKSwgZWRpdG9yVHlwZSA9PT0gJ3d5c2l3eWcnIHx8IHByZXZpZXdTdHlsZSA9PT0gJ3ZlcnRpY2FsJ1xuICAgICAgICAgICAgPyAnbm9uZSdcbiAgICAgICAgICAgIDogJ2Jsb2NrJywgVGFicywgdGhpcy50YWJzLCBhY3RpdmVUYWIsIHRoaXMudG9nZ2xlVGFiLCBjbHMoJ2RlZmF1bHRVSS10b29sYmFyJyksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZWwgPSBlbCk7IH0sIHRvb2xiYXJTdHlsZSwgaXRlbXMubWFwKGZ1bmN0aW9uIChncm91cCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkMyB8fCAodGVtcGxhdGVPYmplY3RfMSQzID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgICAgICAgIGdyb3VwPVwiLCBcIlxcbiAgICAgICAgICAgICAgICBoaWRkZW5EaXZpZGVyPVwiLCBcIlxcbiAgICAgICAgICAgICAgICBzZXRJdGVtV2lkdGg9XCIsIFwiXFxuICAgICAgICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICAgICAgICBncm91cD1cIiwgXCJcXG4gICAgICAgICAgICAgICAgaGlkZGVuRGl2aWRlcj1cIiwgXCJcXG4gICAgICAgICAgICAgICAgc2V0SXRlbVdpZHRoPVwiLCBcIlxcbiAgICAgICAgICAgICAgICAuLi5cIiwgXCJcXG4gICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgXCJdKSksIFRvb2xiYXJHcm91cCwgZ3JvdXAsIGluZGV4ID09PSBpdGVtcy5sZW5ndGggLSAxIHx8ICgoX2EgPSBpdGVtc1tpbmRleCArIDFdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZGVuKSwgX3RoaXMuc2V0SXRlbVdpZHRoLCBwcm9wcyk7XG4gICAgICAgIH0pLCBEcm9wZG93blRvb2xiYXJCdXR0b24sIGNyZWF0ZVRvb2xiYXJJdGVtSW5mbygnbW9yZScpLCBkcm9wZG93bkl0ZW1zLCBwcm9wcywgUG9wdXAsIHBvcHVwSW5mbywgc2hvd1BvcHVwLCBldmVudEVtaXR0ZXIsIHRoaXMuaGlkZVBvcHVwLCB0aGlzLmV4ZWNDb21tYW5kKTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sYmFyO1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDMsIHRlbXBsYXRlT2JqZWN0XzIkMjtcblxudmFyIENvbnRleHRNZW51ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKENvbnRleHRNZW51LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRleHRNZW51KHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVDbGlja0RvY3VtZW50ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QoZXYudGFyZ2V0LCBcIi5cIiArIGNscygnY29udGV4dC1tZW51JykpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwb3M6IG51bGwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcG9zOiBudWxsLFxuICAgICAgICAgICAgbWVudUdyb3VwczogW10sXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmFkZEV2ZW50KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnByb3BzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gX2EucG9zLCBtZW51R3JvdXBzID0gX2EubWVudUdyb3VwcztcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgcG9zOiBwb3MsIG1lbnVHcm91cHM6IG1lbnVHcm91cHMgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja0RvY3VtZW50KTtcbiAgICB9O1xuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5iZWZvcmVEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tEb2N1bWVudCk7XG4gICAgfTtcbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUuZ2V0TWVudUdyb3VwRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIHBvcyA9IF9hLnBvcywgbWVudUdyb3VwcyA9IF9hLm1lbnVHcm91cHM7XG4gICAgICAgIHJldHVybiBwb3NcbiAgICAgICAgICAgID8gbWVudUdyb3Vwcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVudUl0ZW0gPSBbXTtcbiAgICAgICAgICAgICAgICBncm91cC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBfYS5sYWJlbCwgX2IgPSBfYS5jbGFzc05hbWUsIGNsYXNzTmFtZSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBvbkNsaWNrID0gX2Eub25DbGljaztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHBvczogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbWVudUl0ZW0ucHVzaChodG1sKHRlbXBsYXRlT2JqZWN0XzEkMiB8fCAodGVtcGxhdGVPYmplY3RfMSQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICAgICAgICAgIDxsaVxcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcIm1lbnUtaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgICAgICBhcmlhLXJvbGU9XFxcIm1lbnVpdGVtXFxcIlxcbiAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIlwiLCBcIlxcXCI+XCIsIFwiPC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgICAgICAgPGxpXFxuICAgICAgICAgICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cXFwibWVudS1pdGVtXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgICAgIGFyaWEtcm9sZT1cXFwibWVudWl0ZW1cXFwiXFxuICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cIiwgXCI8L3NwYW4+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICBcIl0pKSwgaGFuZGxlQ2xpY2ssIGRpc2FibGVkID8gJyBkaXNhYmxlZCcgOiAnJywgY2xhc3NOYW1lLCBsYWJlbCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKGh0bWwodGVtcGxhdGVPYmplY3RfMiQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8dWwgY2xhc3M9XFxcIm1lbnUtZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgPC91bD5cIl0sIFtcIjx1bCBjbGFzcz1cXFwibWVudS1ncm91cFxcXCI+XFxuICAgICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgICA8L3VsPlwiXSkpLCBtZW51SXRlbSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICAgIDogW107XG4gICAgfTtcbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBfX2Fzc2lnbiQxKHsgZGlzcGxheTogdGhpcy5zdGF0ZS5wb3MgPyAnYmxvY2snIDogJ25vbmUnIH0sIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMyB8fCAodGVtcGxhdGVPYmplY3RfMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiIGFyaWEtcm9sZT1cXFwibWVudVxcXCI+XFxuICAgICAgXCIsIFwiXFxuICAgIDwvZGl2PlwiXSwgW1wiPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCIgYXJpYS1yb2xlPVxcXCJtZW51XFxcIj5cXG4gICAgICBcIiwgXCJcXG4gICAgPC9kaXY+XCJdKSksIGNscygnY29udGV4dC1tZW51JyksIHN0eWxlLCB0aGlzLmdldE1lbnVHcm91cEVsZW1lbnRzKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRleHRNZW51O1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDIsIHRlbXBsYXRlT2JqZWN0XzIkMSwgdGVtcGxhdGVPYmplY3RfMztcblxudmFyIExheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShMYXlvdXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGF5b3V0KHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jaGFuZ2VNb2RlID0gZnVuY3Rpb24gKGVkaXRvclR5cGUpIHtcbiAgICAgICAgICAgIGlmIChlZGl0b3JUeXBlICE9PSBfdGhpcy5zdGF0ZS5lZGl0b3JUeXBlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBlZGl0b3JUeXBlOiBlZGl0b3JUeXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jaGFuZ2VQcmV2aWV3U3R5bGUgPSBmdW5jdGlvbiAocHJldmlld1N0eWxlKSB7XG4gICAgICAgICAgICBpZiAocHJldmlld1N0eWxlICE9PSBfdGhpcy5zdGF0ZS5wcmV2aWV3U3R5bGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHByZXZpZXdTdHlsZTogcHJldmlld1N0eWxlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBoaWRlOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBoaWRlOiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVkaXRvclR5cGUgPSBwcm9wcy5lZGl0b3JUeXBlLCBwcmV2aWV3U3R5bGUgPSBwcm9wcy5wcmV2aWV3U3R5bGU7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZWRpdG9yVHlwZTogZWRpdG9yVHlwZSxcbiAgICAgICAgICAgIHByZXZpZXdTdHlsZTogcHJldmlld1N0eWxlLFxuICAgICAgICAgICAgaGlkZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmFkZEV2ZW50KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGF5b3V0LnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLnNsb3RzLCB3d0VkaXRvciA9IF9hLnd3RWRpdG9yLCBtZEVkaXRvciA9IF9hLm1kRWRpdG9yLCBtZFByZXZpZXcgPSBfYS5tZFByZXZpZXc7XG4gICAgICAgIHRoaXMucmVmcy53d0NvbnRhaW5lci5hcHBlbmRDaGlsZCh3d0VkaXRvcik7XG4gICAgICAgIHRoaXMucmVmcy5tZENvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyYmVnaW4nLCBtZEVkaXRvcik7XG4gICAgICAgIHRoaXMucmVmcy5tZENvbnRhaW5lci5hcHBlbmRDaGlsZChtZFByZXZpZXcpO1xuICAgIH07XG4gICAgTGF5b3V0LnByb3RvdHlwZS5pbnNlcnRUb29sYmFySXRlbSA9IGZ1bmN0aW9uIChpbmRleExpc3QsIGl0ZW0pIHtcbiAgICAgICAgdGhpcy50b29sYmFyLmluc2VydFRvb2xiYXJJdGVtKGluZGV4TGlzdCwgaXRlbSk7XG4gICAgfTtcbiAgICBMYXlvdXQucHJvdG90eXBlLnJlbW92ZVRvb2xiYXJJdGVtID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy50b29sYmFyLnJlbW92ZVRvb2xiYXJJdGVtKG5hbWUpO1xuICAgIH07XG4gICAgTGF5b3V0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlciwgaGlkZU1vZGVTd2l0Y2ggPSBfYS5oaWRlTW9kZVN3aXRjaCwgdG9vbGJhckl0ZW1zID0gX2EudG9vbGJhckl0ZW1zLCB0aGVtZSA9IF9hLnRoZW1lO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnN0YXRlLCBoaWRlID0gX2IuaGlkZSwgcHJldmlld1N0eWxlID0gX2IucHJldmlld1N0eWxlLCBlZGl0b3JUeXBlID0gX2IuZWRpdG9yVHlwZTtcbiAgICAgICAgdmFyIGRpc3BsYXlDbGFzc05hbWUgPSBoaWRlID8gJyBoaWRkZW4nIDogJyc7XG4gICAgICAgIHZhciBlZGl0b3JUeXBlQ2xhc3NOYW1lID0gY2xzKGVkaXRvclR5cGUgPT09ICdtYXJrZG93bicgPyAnbWQtbW9kZScgOiAnd3ctbW9kZScpO1xuICAgICAgICB2YXIgcHJldmlld0NsYXNzTmFtZSA9IGNscygnbWQnKSArIFwiLVwiICsgcHJldmlld1N0eWxlICsgXCItc3R5bGVcIjtcbiAgICAgICAgdmFyIHRoZW1lQ2xhc3NOYW1lID0gY2xzKFt0aGVtZSAhPT0gJ2xpZ2h0JywgdGhlbWUgKyBcIiBcIl0pO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8yIHx8ICh0ZW1wbGF0ZU9iamVjdF8yID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlwiLCBcIlwiLCBcIlxcXCJcXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICA+XFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgZXZlbnRFbWl0dGVyPVwiLCBcIlxcbiAgICAgICAgICBwcmV2aWV3U3R5bGU9XCIsIFwiXFxuICAgICAgICAgIHRvb2xiYXJJdGVtcz1cIiwgXCJcXG4gICAgICAgICAgZWRpdG9yVHlwZT1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCIgXCIsIFwiXFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIiBcIiwgXCJcXFwiXFxuICAgICAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIiwgXCJcXG4gICAgICAgIDxcIiwgXCIgZXZlbnRFbWl0dGVyPVwiLCBcIiAvPlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcIiwgXCJcIiwgXCJcXFwiXFxuICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgPlxcbiAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIGV2ZW50RW1pdHRlcj1cIiwgXCJcXG4gICAgICAgICAgcHJldmlld1N0eWxlPVwiLCBcIlxcbiAgICAgICAgICB0b29sYmFySXRlbXM9XCIsIFwiXFxuICAgICAgICAgIGVkaXRvclR5cGU9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiIFwiLCBcIlxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCIgXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgXCIsXG4gICAgICAgICAgICBcIlxcbiAgICAgICAgPFwiLCBcIiBldmVudEVtaXR0ZXI9XCIsIFwiIC8+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCB0aGVtZUNsYXNzTmFtZSwgY2xzKCdkZWZhdWx0VUknKSwgZGlzcGxheUNsYXNzTmFtZSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lbCA9IGVsKTsgfSwgVG9vbGJhciwgZnVuY3Rpb24gKHRvb2xiYXIpIHsgcmV0dXJuIChfdGhpcy50b29sYmFyID0gdG9vbGJhcik7IH0sIGV2ZW50RW1pdHRlciwgcHJldmlld1N0eWxlLCB0b29sYmFySXRlbXMsIGVkaXRvclR5cGUsIGNscygnbWFpbicpLCBlZGl0b3JUeXBlQ2xhc3NOYW1lLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmVkaXRvclNlY3Rpb24gPSBlbCk7IH0sIGNscygnbWFpbi1jb250YWluZXInKSwgY2xzKCdtZC1jb250YWluZXInKSwgcHJldmlld0NsYXNzTmFtZSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5tZENvbnRhaW5lciA9IGVsKTsgfSwgY2xzKCdtZC1zcGxpdHRlcicpLCBjbHMoJ3d3LWNvbnRhaW5lcicpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLnd3Q29udGFpbmVyID0gZWwpOyB9LCAhaGlkZU1vZGVTd2l0Y2ggJiYgaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDEgfHwgKHRlbXBsYXRlT2JqZWN0XzEkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxcIiwgXCIgZXZlbnRFbWl0dGVyPVwiLCBcIiBlZGl0b3JUeXBlPVwiLCBcIiAvPlwiXSwgW1wiPFwiLCBcIiBldmVudEVtaXR0ZXI9XCIsIFwiIGVkaXRvclR5cGU9XCIsIFwiIC8+XCJdKSksIFN3aXRjaCwgZXZlbnRFbWl0dGVyLCBlZGl0b3JUeXBlKSwgQ29udGV4dE1lbnUsIGV2ZW50RW1pdHRlcik7XG4gICAgfTtcbiAgICBMYXlvdXQucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXZlbnRFbWl0dGVyID0gdGhpcy5wcm9wcy5ldmVudEVtaXR0ZXI7XG4gICAgICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ2hpZGUnLCB0aGlzLmhpZGUpO1xuICAgICAgICBldmVudEVtaXR0ZXIubGlzdGVuKCdzaG93JywgdGhpcy5zaG93KTtcbiAgICAgICAgZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlTW9kZScsIHRoaXMuY2hhbmdlTW9kZSk7XG4gICAgICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVByZXZpZXdTdHlsZScsIHRoaXMuY2hhbmdlUHJldmlld1N0eWxlKTtcbiAgICB9O1xuICAgIHJldHVybiBMYXlvdXQ7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkMSwgdGVtcGxhdGVPYmplY3RfMjtcblxuLyoqXG4gKiBUb2FzdFVJIEVkaXRvclxuICogQGV4dGVuZHMgVG9hc3RVSUVkaXRvckNvcmVcbiAqL1xudmFyIFRvYXN0VUlFZGl0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVG9hc3RVSUVkaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb2FzdFVJRWRpdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICB2YXIgbGF5b3V0Q29tcDtcbiAgICAgICAgdmFyIGRlc3Ryb3kgPSByZW5kZXIoX3RoaXMub3B0aW9ucy5lbCwgaHRtbCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgZXZlbnRFbWl0dGVyPVwiLCBcIlxcbiAgICAgICAgICBzbG90cz1cIiwgXCJcXG4gICAgICAgICAgaGlkZU1vZGVTd2l0Y2g9XCIsIFwiXFxuICAgICAgICAgIHRvb2xiYXJJdGVtcz1cIiwgXCJcXG4gICAgICAgICAgcHJldmlld1N0eWxlPVwiLCBcIlxcbiAgICAgICAgICBlZGl0b3JUeXBlPVwiLCBcIlxcbiAgICAgICAgICB0aGVtZT1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgXCJdLCBbXCJcXG4gICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICBldmVudEVtaXR0ZXI9XCIsIFwiXFxuICAgICAgICAgIHNsb3RzPVwiLCBcIlxcbiAgICAgICAgICBoaWRlTW9kZVN3aXRjaD1cIiwgXCJcXG4gICAgICAgICAgdG9vbGJhckl0ZW1zPVwiLCBcIlxcbiAgICAgICAgICBwcmV2aWV3U3R5bGU9XCIsIFwiXFxuICAgICAgICAgIGVkaXRvclR5cGU9XCIsIFwiXFxuICAgICAgICAgIHRoZW1lPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICBcIl0pKSwgTGF5b3V0LCBmdW5jdGlvbiAobGF5b3V0KSB7IHJldHVybiAobGF5b3V0Q29tcCA9IGxheW91dCk7IH0sIF90aGlzLmV2ZW50RW1pdHRlciwgX3RoaXMuZ2V0RWRpdG9yRWxlbWVudHMoKSwgX3RoaXMub3B0aW9ucy5oaWRlTW9kZVN3aXRjaCwgX3RoaXMub3B0aW9ucy50b29sYmFySXRlbXMsIF90aGlzLm9wdGlvbnMucHJldmlld1N0eWxlLCBfdGhpcy5vcHRpb25zLmluaXRpYWxFZGl0VHlwZSwgX3RoaXMub3B0aW9ucy50aGVtZSkpO1xuICAgICAgICBfdGhpcy5zZXRNaW5IZWlnaHQoX3RoaXMub3B0aW9ucy5taW5IZWlnaHQpO1xuICAgICAgICBfdGhpcy5zZXRIZWlnaHQoX3RoaXMub3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICBfdGhpcy5kZWZhdWx0VUkgPSB7XG4gICAgICAgICAgICBpbnNlcnRUb29sYmFySXRlbTogbGF5b3V0Q29tcC5pbnNlcnRUb29sYmFySXRlbS5iaW5kKGxheW91dENvbXApLFxuICAgICAgICAgICAgcmVtb3ZlVG9vbGJhckl0ZW06IGxheW91dENvbXAucmVtb3ZlVG9vbGJhckl0ZW0uYmluZChsYXlvdXRDb21wKSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICAgIH07XG4gICAgICAgIChfYSA9IF90aGlzLnBsdWdpbkluZm8udG9vbGJhckl0ZW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChmdW5jdGlvbiAodG9vbGJhckl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBncm91cEluZGV4ID0gdG9vbGJhckl0ZW0uZ3JvdXBJbmRleCwgaXRlbUluZGV4ID0gdG9vbGJhckl0ZW0uaXRlbUluZGV4LCBpdGVtID0gdG9vbGJhckl0ZW0uaXRlbTtcbiAgICAgICAgICAgIF90aGlzLmRlZmF1bHRVSS5pbnNlcnRUb29sYmFySXRlbSh7IGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsIGl0ZW1JbmRleDogaXRlbUluZGV4IH0sIGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2xvYWRVSScsIF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgRWRpdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9uIGZvciBpbml0aWFsaXplIFRVSUVkaXRvclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRvYXN0VUlFZGl0b3Igb3IgVG9hc3RVSUVkaXRvclZpZXdlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3IuZmFjdG9yeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnZpZXdlciA/IG5ldyBUb2FzdFVJRWRpdG9yVmlld2VyKG9wdGlvbnMpIDogbmV3IFRvYXN0VUlFZGl0b3Iob3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBhZGQgdG9vbGJhciBpdGVtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGluZGV4SW5mbyBncm91cCBpbmRleCBhbmQgaXRlbSBpbmRleCBvZiB0aGUgdG9vbGJhciBpdGVtXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBpdGVtIHRvb2xiYXIgaXRlbVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3IucHJvdG90eXBlLmluc2VydFRvb2xiYXJJdGVtID0gZnVuY3Rpb24gKGluZGV4SW5mbywgaXRlbSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRVSS5pbnNlcnRUb29sYmFySXRlbShpbmRleEluZm8sIGl0ZW0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRvb2xiYXIgaXRlbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpdGVtTmFtZSB0b29sYmFyIGl0ZW0gbmFtZVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3IucHJvdG90eXBlLnJlbW92ZVRvb2xiYXJJdGVtID0gZnVuY3Rpb24gKGl0ZW1OYW1lKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFVJLnJlbW92ZVRvb2xiYXJJdGVtKGl0ZW1OYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgVFVJRWRpdG9yIGZyb20gZG9jdW1lbnRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VUkuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvYXN0VUlFZGl0b3I7XG59KFRvYXN0VUlFZGl0b3JDb3JlKSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEkxOE4gZm9yIEVuZ2xpc2hcbiAqIEBhdXRob3IgTkhOIENsb3VkIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5Ub2FzdFVJRWRpdG9yQ29yZS5zZXRMYW5ndWFnZShbJ2VuJywgJ2VuLVVTJ10sIHtcbiAgICBNYXJrZG93bjogJ01hcmtkb3duJyxcbiAgICBXWVNJV1lHOiAnV1lTSVdZRycsXG4gICAgV3JpdGU6ICdXcml0ZScsXG4gICAgUHJldmlldzogJ1ByZXZpZXcnLFxuICAgIEhlYWRpbmdzOiAnSGVhZGluZ3MnLFxuICAgIFBhcmFncmFwaDogJ1BhcmFncmFwaCcsXG4gICAgQm9sZDogJ0JvbGQnLFxuICAgIEl0YWxpYzogJ0l0YWxpYycsXG4gICAgU3RyaWtlOiAnU3RyaWtlJyxcbiAgICBDb2RlOiAnSW5saW5lIGNvZGUnLFxuICAgIExpbmU6ICdMaW5lJyxcbiAgICBCbG9ja3F1b3RlOiAnQmxvY2txdW90ZScsXG4gICAgJ1Vub3JkZXJlZCBsaXN0JzogJ1Vub3JkZXJlZCBsaXN0JyxcbiAgICAnT3JkZXJlZCBsaXN0JzogJ09yZGVyZWQgbGlzdCcsXG4gICAgVGFzazogJ1Rhc2snLFxuICAgIEluZGVudDogJ0luZGVudCcsXG4gICAgT3V0ZGVudDogJ091dGRlbnQnLFxuICAgICdJbnNlcnQgbGluayc6ICdJbnNlcnQgbGluaycsXG4gICAgJ0luc2VydCBDb2RlQmxvY2snOiAnSW5zZXJ0IGNvZGVCbG9jaycsXG4gICAgJ0luc2VydCB0YWJsZSc6ICdJbnNlcnQgdGFibGUnLFxuICAgICdJbnNlcnQgaW1hZ2UnOiAnSW5zZXJ0IGltYWdlJyxcbiAgICBIZWFkaW5nOiAnSGVhZGluZycsXG4gICAgJ0ltYWdlIFVSTCc6ICdJbWFnZSBVUkwnLFxuICAgICdTZWxlY3QgaW1hZ2UgZmlsZSc6ICdTZWxlY3QgaW1hZ2UgZmlsZScsXG4gICAgJ0Nob29zZSBhIGZpbGUnOiAnQ2hvb3NlIGEgZmlsZScsXG4gICAgJ05vIGZpbGUnOiAnTm8gZmlsZScsXG4gICAgRGVzY3JpcHRpb246ICdEZXNjcmlwdGlvbicsXG4gICAgT0s6ICdPSycsXG4gICAgTW9yZTogJ01vcmUnLFxuICAgIENhbmNlbDogJ0NhbmNlbCcsXG4gICAgRmlsZTogJ0ZpbGUnLFxuICAgIFVSTDogJ1VSTCcsXG4gICAgJ0xpbmsgdGV4dCc6ICdMaW5rIHRleHQnLFxuICAgICdBZGQgcm93IHRvIHVwJzogJ0FkZCByb3cgdG8gdXAnLFxuICAgICdBZGQgcm93IHRvIGRvd24nOiAnQWRkIHJvdyB0byBkb3duJyxcbiAgICAnQWRkIGNvbHVtbiB0byBsZWZ0JzogJ0FkZCBjb2x1bW4gdG8gbGVmdCcsXG4gICAgJ0FkZCBjb2x1bW4gdG8gcmlnaHQnOiAnQWRkIGNvbHVtbiB0byByaWdodCcsXG4gICAgJ1JlbW92ZSByb3cnOiAnUmVtb3ZlIHJvdycsXG4gICAgJ1JlbW92ZSBjb2x1bW4nOiAnUmVtb3ZlIGNvbHVtbicsXG4gICAgJ0FsaWduIGNvbHVtbiB0byBsZWZ0JzogJ0FsaWduIGNvbHVtbiB0byBsZWZ0JyxcbiAgICAnQWxpZ24gY29sdW1uIHRvIGNlbnRlcic6ICdBbGlnbiBjb2x1bW4gdG8gY2VudGVyJyxcbiAgICAnQWxpZ24gY29sdW1uIHRvIHJpZ2h0JzogJ0FsaWduIGNvbHVtbiB0byByaWdodCcsXG4gICAgJ1JlbW92ZSB0YWJsZSc6ICdSZW1vdmUgdGFibGUnLFxuICAgICdXb3VsZCB5b3UgbGlrZSB0byBwYXN0ZSBhcyB0YWJsZT8nOiAnV291bGQgeW91IGxpa2UgdG8gcGFzdGUgYXMgdGFibGU/JyxcbiAgICAnVGV4dCBjb2xvcic6ICdUZXh0IGNvbG9yJyxcbiAgICAnQXV0byBzY3JvbGwgZW5hYmxlZCc6ICdBdXRvIHNjcm9sbCBlbmFibGVkJyxcbiAgICAnQXV0byBzY3JvbGwgZGlzYWJsZWQnOiAnQXV0byBzY3JvbGwgZGlzYWJsZWQnLFxuICAgICdDaG9vc2UgbGFuZ3VhZ2UnOiAnQ2hvb3NlIGxhbmd1YWdlJyxcbn0pO1xuXG5leHBvcnQgeyBUb2FzdFVJRWRpdG9yIGFzIEVkaXRvciwgVG9hc3RVSUVkaXRvckNvcmUgYXMgRWRpdG9yQ29yZSwgVG9hc3RVSUVkaXRvciBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@toast-ui/editor/dist/esm/index.js\n')},"./node_modules/rope-sequence/dist/index.es.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\nvar GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn\'t have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nvar ropeSequence = RopeSequence;\n\n/* harmony default export */ __webpack_exports__["default"] = (ropeSequence);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcm9wZS1zZXF1ZW5jZS9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vbm9kZV9tb2R1bGVzL3JvcGUtc2VxdWVuY2UvZGlzdC9pbmRleC5lcy5qcz9jMjFlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBHT09EX0xFQUZfU0laRSA9IDIwMDtcblxuLy8gOjogY2xhc3M8VD4gQSByb3BlIHNlcXVlbmNlIGlzIGEgcGVyc2lzdGVudCBzZXF1ZW5jZSBkYXRhIHN0cnVjdHVyZVxuLy8gdGhhdCBzdXBwb3J0cyBhcHBlbmRpbmcsIHByZXBlbmRpbmcsIGFuZCBzbGljaW5nIHdpdGhvdXQgZG9pbmcgYVxuLy8gZnVsbCBjb3B5LiBJdCBpcyByZXByZXNlbnRlZCBhcyBhIG1vc3RseS1iYWxhbmNlZCB0cmVlLlxudmFyIFJvcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uIFJvcGVTZXF1ZW5jZSAoKSB7fTtcblxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKG90aGVyKSB7XG4gIGlmICghb3RoZXIubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgb3RoZXIgPSBSb3BlU2VxdWVuY2UuZnJvbShvdGhlcik7XG5cbiAgcmV0dXJuICghdGhpcy5sZW5ndGggJiYgb3RoZXIpIHx8XG4gICAgKG90aGVyLmxlbmd0aCA8IEdPT0RfTEVBRl9TSVpFICYmIHRoaXMubGVhZkFwcGVuZChvdGhlcikpIHx8XG4gICAgKHRoaXMubGVuZ3RoIDwgR09PRF9MRUFGX1NJWkUgJiYgb3RoZXIubGVhZlByZXBlbmQodGhpcykpIHx8XG4gICAgdGhpcy5hcHBlbmRJbm5lcihvdGhlcilcbn07XG5cbi8vIDo6ICh1bmlvbjxbVF0sIFJvcGVTZXF1ZW5jZTxUPj4pIOKGkiBSb3BlU2VxdWVuY2U8VD5cbi8vIFByZXBlbmQgYW4gYXJyYXkgb3Igb3RoZXIgcm9wZSB0byB0aGlzIG9uZSwgcmV0dXJuaW5nIGEgbmV3IHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kIChvdGhlcikge1xuICBpZiAoIW90aGVyLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gIHJldHVybiBSb3BlU2VxdWVuY2UuZnJvbShvdGhlcikuYXBwZW5kKHRoaXMpXG59O1xuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmFwcGVuZElubmVyID0gZnVuY3Rpb24gYXBwZW5kSW5uZXIgKG90aGVyKSB7XG4gIHJldHVybiBuZXcgQXBwZW5kKHRoaXMsIG90aGVyKVxufTtcblxuLy8gOjogKD9udW1iZXIsID9udW1iZXIpIOKGkiBSb3BlU2VxdWVuY2U8VD5cbi8vIENyZWF0ZSBhIHJvcGUgcmVwZXNlbnRpbmcgYSBzdWItc2VxdWVuY2Ugb2YgdGhpcyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZnJvbSA+PSB0bykgeyByZXR1cm4gUm9wZVNlcXVlbmNlLmVtcHR5IH1cbiAgcmV0dXJuIHRoaXMuc2xpY2VJbm5lcihNYXRoLm1heCgwLCBmcm9tKSwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHRvKSlcbn07XG5cbi8vIDo6IChudW1iZXIpIOKGkiBUXG4vLyBSZXRyaWV2ZSB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gZnJvbSB0aGlzIHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdW5kZWZpbmVkIH1cbiAgcmV0dXJuIHRoaXMuZ2V0SW5uZXIoaSlcbn07XG5cbi8vIDo6ICgoZWxlbWVudDogVCwgaW5kZXg6IG51bWJlcikg4oaSID9ib29sLCA/bnVtYmVyLCA/bnVtYmVyKVxuLy8gQ2FsbCB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBiZXR3ZWVuIHRoZSBnaXZlblxuLy8gaW5kaWNlcy4gVGhpcyB0ZW5kcyB0byBiZSBtb3JlIGVmZmljaWVudCB0aGFuIGxvb3Bpbmcgb3ZlciB0aGVcbi8vIGluZGljZXMgYW5kIGNhbGxpbmcgYGdldGAsIGJlY2F1c2UgaXQgZG9lc24ndCBoYXZlIHRvIGRlc2NlbmQgdGhlXG4vLyB0cmVlIGZvciBldmVyeSBlbGVtZW50LlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaCAoZiwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGZyb20gPD0gdG8pXG4gICAgeyB0aGlzLmZvckVhY2hJbm5lcihmLCBmcm9tLCB0bywgMCk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBmcm9tLCB0bywgMCk7IH1cbn07XG5cbi8vIDo6ICgoZWxlbWVudDogVCwgaW5kZXg6IG51bWJlcikg4oaSIFUsID9udW1iZXIsID9udW1iZXIpIOKGkiBbVV1cbi8vIE1hcCB0aGUgZ2l2ZW4gZnVuY3Rpb25zIG92ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3BlLCBwcm9kdWNpbmdcbi8vIGEgZmxhdCBhcnJheS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChmLCBmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWx0LCBpKSB7IHJldHVybiByZXN1bHQucHVzaChmKGVsdCwgaSkpOyB9LCBmcm9tLCB0byk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIDo6ICg/dW5pb248W1RdLCBSb3BlU2VxdWVuY2U8VD4+KSDihpIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBDcmVhdGUgYSByb3BlIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gYXJyYXksIG9yIHJldHVybiB0aGUgcm9wZVxuLy8gaXRzZWxmIGlmIGEgcm9wZSB3YXMgZ2l2ZW4uXG5Sb3BlU2VxdWVuY2UuZnJvbSA9IGZ1bmN0aW9uIGZyb20gKHZhbHVlcykge1xuICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUm9wZVNlcXVlbmNlKSB7IHJldHVybiB2YWx1ZXMgfVxuICByZXR1cm4gdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggPyBuZXcgTGVhZih2YWx1ZXMpIDogUm9wZVNlcXVlbmNlLmVtcHR5XG59O1xuXG52YXIgTGVhZiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFJvcGVTZXF1ZW5jZSkge1xuICBmdW5jdGlvbiBMZWFmKHZhbHVlcykge1xuICAgIFJvcGVTZXF1ZW5jZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICB9XG5cbiAgaWYgKCBSb3BlU2VxdWVuY2UgKSBMZWFmLl9fcHJvdG9fXyA9IFJvcGVTZXF1ZW5jZTtcbiAgTGVhZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSb3BlU2VxdWVuY2UgJiYgUm9wZVNlcXVlbmNlLnByb3RvdHlwZSApO1xuICBMZWFmLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExlYWY7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgbGVuZ3RoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGRlcHRoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1xuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLnNsaWNlSW5uZXIgPSBmdW5jdGlvbiBzbGljZUlubmVyIChmcm9tLCB0bykge1xuICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHJldHVybiBuZXcgTGVhZih0aGlzLnZhbHVlcy5zbGljZShmcm9tLCB0bykpXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZ2V0SW5uZXIgPSBmdW5jdGlvbiBnZXRJbm5lciAoaSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1tpXVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZvckVhY2hJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgeyBpZiAoZih0aGlzLnZhbHVlc1tpXSwgc3RhcnQgKyBpKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZvckVhY2hJbnZlcnRlZElubmVyID0gZnVuY3Rpb24gZm9yRWFjaEludmVydGVkSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIGZvciAodmFyIGkgPSBmcm9tIC0gMTsgaSA+PSB0bzsgaS0tKVxuICAgICAgeyBpZiAoZih0aGlzLnZhbHVlc1tpXSwgc3RhcnQgKyBpKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmxlYWZBcHBlbmQgPSBmdW5jdGlvbiBsZWFmQXBwZW5kIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCA8PSBHT09EX0xFQUZfU0laRSlcbiAgICAgIHsgcmV0dXJuIG5ldyBMZWFmKHRoaXMudmFsdWVzLmNvbmNhdChvdGhlci5mbGF0dGVuKCkpKSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUubGVhZlByZXBlbmQgPSBmdW5jdGlvbiBsZWFmUHJlcGVuZCAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGggPD0gR09PRF9MRUFGX1NJWkUpXG4gICAgICB7IHJldHVybiBuZXcgTGVhZihvdGhlci5mbGF0dGVuKCkuY29uY2F0KHRoaXMudmFsdWVzKSkgfVxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5sZW5ndGguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmRlcHRoLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGVhZi5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHJldHVybiBMZWFmO1xufShSb3BlU2VxdWVuY2UpKTtcblxuLy8gOjogUm9wZVNlcXVlbmNlXG4vLyBUaGUgZW1wdHkgcm9wZSBzZXF1ZW5jZS5cblJvcGVTZXF1ZW5jZS5lbXB0eSA9IG5ldyBMZWFmKFtdKTtcblxudmFyIEFwcGVuZCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFJvcGVTZXF1ZW5jZSkge1xuICBmdW5jdGlvbiBBcHBlbmQobGVmdCwgcmlnaHQpIHtcbiAgICBSb3BlU2VxdWVuY2UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoO1xuICAgIHRoaXMuZGVwdGggPSBNYXRoLm1heChsZWZ0LmRlcHRoLCByaWdodC5kZXB0aCkgKyAxO1xuICB9XG5cbiAgaWYgKCBSb3BlU2VxdWVuY2UgKSBBcHBlbmQuX19wcm90b19fID0gUm9wZVNlcXVlbmNlO1xuICBBcHBlbmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUm9wZVNlcXVlbmNlICYmIFJvcGVTZXF1ZW5jZS5wcm90b3R5cGUgKTtcbiAgQXBwZW5kLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFwcGVuZDtcblxuICBBcHBlbmQucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0LmZsYXR0ZW4oKS5jb25jYXQodGhpcy5yaWdodC5mbGF0dGVuKCkpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5nZXRJbm5lciA9IGZ1bmN0aW9uIGdldElubmVyIChpKSB7XG4gICAgcmV0dXJuIGkgPCB0aGlzLmxlZnQubGVuZ3RoID8gdGhpcy5sZWZ0LmdldChpKSA6IHRoaXMucmlnaHQuZ2V0KGkgLSB0aGlzLmxlZnQubGVuZ3RoKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZm9yRWFjaElubmVyID0gZnVuY3Rpb24gZm9yRWFjaElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKGZyb20gPCBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMubGVmdC5mb3JFYWNoSW5uZXIoZiwgZnJvbSwgTWF0aC5taW4odG8sIGxlZnRMZW4pLCBzdGFydCkgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0byA+IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoSW5uZXIoZiwgTWF0aC5tYXgoZnJvbSAtIGxlZnRMZW4sIDApLCBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdG8pIC0gbGVmdExlbiwgc3RhcnQgKyBsZWZ0TGVuKSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mb3JFYWNoSW52ZXJ0ZWRJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbnZlcnRlZElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKGZyb20gPiBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgZnJvbSAtIGxlZnRMZW4sIE1hdGgubWF4KHRvLCBsZWZ0TGVuKSAtIGxlZnRMZW4sIHN0YXJ0ICsgbGVmdExlbikgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0byA8IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hJbnZlcnRlZElubmVyKGYsIE1hdGgubWluKGZyb20sIGxlZnRMZW4pLCB0bywgc3RhcnQpID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLnNsaWNlSW5uZXIgPSBmdW5jdGlvbiBzbGljZUlubmVyIChmcm9tLCB0bykge1xuICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAodG8gPD0gbGVmdExlbikgeyByZXR1cm4gdGhpcy5sZWZ0LnNsaWNlKGZyb20sIHRvKSB9XG4gICAgaWYgKGZyb20gPj0gbGVmdExlbikgeyByZXR1cm4gdGhpcy5yaWdodC5zbGljZShmcm9tIC0gbGVmdExlbiwgdG8gLSBsZWZ0TGVuKSB9XG4gICAgcmV0dXJuIHRoaXMubGVmdC5zbGljZShmcm9tLCBsZWZ0TGVuKS5hcHBlbmQodGhpcy5yaWdodC5zbGljZSgwLCB0byAtIGxlZnRMZW4pKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUubGVhZkFwcGVuZCA9IGZ1bmN0aW9uIGxlYWZBcHBlbmQgKG90aGVyKSB7XG4gICAgdmFyIGlubmVyID0gdGhpcy5yaWdodC5sZWFmQXBwZW5kKG90aGVyKTtcbiAgICBpZiAoaW5uZXIpIHsgcmV0dXJuIG5ldyBBcHBlbmQodGhpcy5sZWZ0LCBpbm5lcikgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUubGVhZlByZXBlbmQgPSBmdW5jdGlvbiBsZWFmUHJlcGVuZCAob3RoZXIpIHtcbiAgICB2YXIgaW5uZXIgPSB0aGlzLmxlZnQubGVhZlByZXBlbmQob3RoZXIpO1xuICAgIGlmIChpbm5lcikgeyByZXR1cm4gbmV3IEFwcGVuZChpbm5lciwgdGhpcy5yaWdodCkgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuYXBwZW5kSW5uZXIgPSBmdW5jdGlvbiBhcHBlbmRJbm5lciAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZWZ0LmRlcHRoID49IE1hdGgubWF4KHRoaXMucmlnaHQuZGVwdGgsIG90aGVyLmRlcHRoKSArIDEpXG4gICAgICB7IHJldHVybiBuZXcgQXBwZW5kKHRoaXMubGVmdCwgbmV3IEFwcGVuZCh0aGlzLnJpZ2h0LCBvdGhlcikpIH1cbiAgICByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLCBvdGhlcilcbiAgfTtcblxuICByZXR1cm4gQXBwZW5kO1xufShSb3BlU2VxdWVuY2UpKTtcblxudmFyIHJvcGVTZXF1ZW5jZSA9IFJvcGVTZXF1ZW5jZTtcblxuZXhwb3J0IGRlZmF1bHQgcm9wZVNlcXVlbmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/rope-sequence/dist/index.es.js\n')},"./source/js/app/common.modules.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiService: function() { return /* binding */ apiService; },\n/* harmony export */   auth: function() { return /* binding */ auth; },\n/* harmony export */   locationModule: function() { return /* binding */ locationModule; },\n/* harmony export */   modalLogin: function() { return /* binding */ modalLogin; },\n/* harmony export */   preloader: function() { return /* binding */ preloader; },\n/* harmony export */   router: function() { return /* binding */ router; },\n/* harmony export */   searchModule: function() { return /* binding */ searchModule; },\n/* harmony export */   userNav: function() { return /* binding */ userNav; }\n/* harmony export */ });\n/* harmony import */ var _core_components_adaptive_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/components/adaptive.component.js */ "./source/js/core/components/adaptive.component.js");\n/* harmony import */ var _service_button_mobile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./service/button.mobile.js */ "./source/js/app/service/button.mobile.js");\n/* harmony import */ var _service_page_overlay_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./service/page.overlay.js */ "./source/js/app/service/page.overlay.js");\n/* harmony import */ var _service_cookie_accept_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./service/cookie.accept.js */ "./source/js/app/service/cookie.accept.js");\n/* harmony import */ var _core_components_preloader_component_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/components/preloader.component.js */ "./source/js/core/components/preloader.component.js");\n/* harmony import */ var _modules_catalog_menu_module_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/catalog.menu.module.js */ "./source/js/app/modules/catalog.menu.module.js");\n/* harmony import */ var _core_components_router_component_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/components/router.component.js */ "./source/js/core/components/router.component.js");\n/* harmony import */ var _controllers_auth_controller_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./controllers/auth.controller.js */ "./source/js/app/controllers/auth.controller.js");\n/* harmony import */ var _modules_location_module_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/location.module.js */ "./source/js/app/modules/location.module.js");\n/* harmony import */ var _modules_user_nav_module_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/user.nav.module.js */ "./source/js/app/modules/user.nav.module.js");\n/* harmony import */ var _modules_login_modal_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/login.modal.js */ "./source/js/app/modules/login.modal.js");\n/* harmony import */ var _modules_search_module_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/search.module.js */ "./source/js/app/modules/search.module.js");\n/* harmony import */ var _configs_adaptive_config_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./configs/adaptive.config.js */ "./source/js/app/configs/adaptive.config.js");\n/* harmony import */ var _core_components_api_service_component_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../core/components/api.service.component.js */ "./source/js/core/components/api.service.component.js");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnew _core_components_adaptive_component_js__WEBPACK_IMPORTED_MODULE_0__["default"]().appendElements(_configs_adaptive_config_js__WEBPACK_IMPORTED_MODULE_12__["default"]);\nconst preloader = new _core_components_preloader_component_js__WEBPACK_IMPORTED_MODULE_4__["default"](\'.page__preloader\');\nconst router = new _core_components_router_component_js__WEBPACK_IMPORTED_MODULE_6__["default"]();\nconst modalLogin = new _modules_login_modal_js__WEBPACK_IMPORTED_MODULE_10__["default"]({\n  container: \'.page-popup__container\',\n  router\n});\nconst auth = new _controllers_auth_controller_js__WEBPACK_IMPORTED_MODULE_7__["default"]({\n  router\n});\nconst apiService = new _core_components_api_service_component_js__WEBPACK_IMPORTED_MODULE_13__["default"](auth);\nnew _modules_catalog_menu_module_js__WEBPACK_IMPORTED_MODULE_5__["default"]({\n  selector: \'#catalog_list\',\n  router,\n  apiService\n}).init();\nconst searchModule = new _modules_search_module_js__WEBPACK_IMPORTED_MODULE_11__["default"]({\n  router,\n  preloader,\n  apiService\n});\nconst locationModule = new _modules_location_module_js__WEBPACK_IMPORTED_MODULE_8__["default"]({\n  auth,\n  router,\n  apiService\n});\nconst userNav = new _modules_user_nav_module_js__WEBPACK_IMPORTED_MODULE_9__["default"]({\n  auth,\n  router,\n  modalLogin,\n  apiService\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL2NvbW1vbi5tb2R1bGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2FwcC9jb21tb24ubW9kdWxlcy5qcz9kOTM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vY29yZS9jb21wb25lbnRzL2FkYXB0aXZlLmNvbXBvbmVudC5qcydcclxuaW1wb3J0ICcuL3NlcnZpY2UvYnV0dG9uLm1vYmlsZS5qcydcclxuaW1wb3J0ICcuL3NlcnZpY2UvcGFnZS5vdmVybGF5LmpzJ1xyXG5pbXBvcnQgJy4vc2VydmljZS9jb29raWUuYWNjZXB0LmpzJ1xyXG5cclxuaW1wb3J0IFByZWxvYWRlckNvbXBvbmVudCBmcm9tICcuLi9jb3JlL2NvbXBvbmVudHMvcHJlbG9hZGVyLmNvbXBvbmVudC5qcydcclxuaW1wb3J0IENhdGFsb2dNZW51TW9kdWxlIGZyb20gJy4vbW9kdWxlcy9jYXRhbG9nLm1lbnUubW9kdWxlLmpzJ1xyXG5pbXBvcnQgUm91dGVyQ29tcG9uZW50IGZyb20gJy4uL2NvcmUvY29tcG9uZW50cy9yb3V0ZXIuY29tcG9uZW50LmpzJ1xyXG5pbXBvcnQgQXV0aENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9hdXRoLmNvbnRyb2xsZXIuanMnXHJcbmltcG9ydCBMb2NhdGlvbk1vZHVsZSBmcm9tICcuL21vZHVsZXMvbG9jYXRpb24ubW9kdWxlLmpzJ1xyXG5pbXBvcnQgVXNlck5hdk1vZHVsZSBmcm9tICcuL21vZHVsZXMvdXNlci5uYXYubW9kdWxlLmpzJ1xyXG5pbXBvcnQgTW9kYWxMb2dpbiBmcm9tICcuL21vZHVsZXMvbG9naW4ubW9kYWwuanMnXHJcbmltcG9ydCBTZWFyY2hNb2R1bGUgZnJvbSAnLi9tb2R1bGVzL3NlYXJjaC5tb2R1bGUuanMnXHJcbmltcG9ydCBjb25maWcgZnJvbSAnLi9jb25maWdzL2FkYXB0aXZlLmNvbmZpZy5qcydcclxuaW1wb3J0IEVsZW1lbnRUcmFuc3BvcnRlciBmcm9tICcuLi9jb3JlL2NvbXBvbmVudHMvYWRhcHRpdmUuY29tcG9uZW50LmpzJ1xyXG5pbXBvcnQgQXBpU2VydmljZUNvbXBvbmVudCBmcm9tICcuLi9jb3JlL2NvbXBvbmVudHMvYXBpLnNlcnZpY2UuY29tcG9uZW50LmpzJ1xyXG5cclxubmV3IEVsZW1lbnRUcmFuc3BvcnRlcigpLmFwcGVuZEVsZW1lbnRzKGNvbmZpZylcclxuZXhwb3J0IGNvbnN0IHByZWxvYWRlciA9IG5ldyBQcmVsb2FkZXJDb21wb25lbnQoJy5wYWdlX19wcmVsb2FkZXInKVxyXG5leHBvcnQgY29uc3Qgcm91dGVyID0gbmV3IFJvdXRlckNvbXBvbmVudCgpXHJcblxyXG5leHBvcnQgY29uc3QgbW9kYWxMb2dpbiA9IG5ldyBNb2RhbExvZ2luKHtcclxuICAgIGNvbnRhaW5lcjogJy5wYWdlLXBvcHVwX19jb250YWluZXInLFxyXG4gICAgcm91dGVyXHJcbn0pXHJcblxyXG5leHBvcnQgY29uc3QgYXV0aCA9IG5ldyBBdXRoQ29udHJvbGxlcih7IHJvdXRlciB9KVxyXG5leHBvcnQgY29uc3QgYXBpU2VydmljZSA9IG5ldyBBcGlTZXJ2aWNlQ29tcG9uZW50KGF1dGgpXHJcblxyXG5cclxubmV3IENhdGFsb2dNZW51TW9kdWxlKHtcclxuICAgIHNlbGVjdG9yOiAnI2NhdGFsb2dfbGlzdCcsXHJcbiAgICByb3V0ZXIsXHJcbiAgICBhcGlTZXJ2aWNlXHJcbn0pLmluaXQoKVxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBzZWFyY2hNb2R1bGUgPSBuZXcgU2VhcmNoTW9kdWxlKHsgcm91dGVyLCBwcmVsb2FkZXIsIGFwaVNlcnZpY2UgfSlcclxuZXhwb3J0IGNvbnN0IGxvY2F0aW9uTW9kdWxlID0gbmV3IExvY2F0aW9uTW9kdWxlKHsgYXV0aCwgcm91dGVyLCBhcGlTZXJ2aWNlIH0pXHJcbmV4cG9ydCBjb25zdCB1c2VyTmF2ID0gbmV3IFVzZXJOYXZNb2R1bGUoeyBhdXRoLCByb3V0ZXIsIG1vZGFsTG9naW4sIGFwaVNlcnZpY2UgfSlcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/app/common.modules.js\n')},"./source/js/app/configs/adaptive.config.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\nconst config = [{\n  what: '.page-header__tel',\n  where: '.page-header__bottom > .page-content',\n  breakpoints: [{\n    key: 'less',\n    value: '960'\n  }],\n  pos: 'beforeend'\n}, {\n  what: '.page-header__tel',\n  where: '.page-header__row-top',\n  breakpoints: [{\n    key: 'more',\n    value: '960'\n  }],\n  pos: 'afterbegin'\n}, {\n  what: '.page-header__nav',\n  where: '.page-header__content',\n  breakpoints: [{\n    key: 'less',\n    value: '1280'\n  }],\n  pos: 'afterend'\n}, {\n  what: '.page-header__nav',\n  where: '.page-header__tel',\n  breakpoints: [{\n    key: 'more',\n    value: '1280'\n  }],\n  pos: 'afterend'\n}, {\n  what: '.page-header__search-wrapper',\n  where: '.page-header__bottom > .page-content',\n  breakpoints: [{\n    key: 'less',\n    value: '960'\n  }],\n  pos: 'afterbegin'\n}, {\n  what: '.page-header__search-wrapper',\n  where: '.page-header__row-top',\n  breakpoints: [{\n    key: 'less',\n    value: '640'\n  }],\n  pos: 'afterbegin'\n}, {\n  what: '.page-header__search-wrapper',\n  where: '.page-header__row_bottom',\n  breakpoints: [{\n    key: 'more',\n    value: '960'\n  }],\n  pos: 'beforeend'\n}, {\n  what: '.button-catalog',\n  where: '.page-header__bottom > .page-content',\n  breakpoints: [{\n    key: 'less',\n    value: '960'\n  }],\n  pos: 'afterbegin'\n}, {\n  what: '.button-catalog',\n  where: '.page-header__column',\n  breakpoints: [{\n    key: 'more',\n    value: '960'\n  }],\n  pos: 'beforeend'\n}, {\n  what: '.button-catalog',\n  where: '.page-header__bottom > .page-content',\n  breakpoints: [{\n    key: 'less',\n    value: '960'\n  }],\n  pos: 'afterbegin'\n}, {\n  what: '.page-header__address',\n  where: '.page-header__bottom  > .page-content',\n  breakpoints: [{\n    key: 'less',\n    value: '640'\n  }],\n  pos: 'afterbegin'\n}, {\n  what: '.page-header__address',\n  where: '.page-header__column',\n  breakpoints: [{\n    key: 'more',\n    value: '640'\n  }],\n  pos: 'afterbegin'\n}];\n/* harmony default export */ __webpack_exports__[\"default\"] = (config);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL2NvbmZpZ3MvYWRhcHRpdmUuY29uZmlnLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2FwcC9jb25maWdzL2FkYXB0aXZlLmNvbmZpZy5qcz9mYjg2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbmZpZyA9IFtcclxuICAgIHtcclxuICAgICAgICB3aGF0OiAnLnBhZ2UtaGVhZGVyX190ZWwnLFxyXG4gICAgICAgIHdoZXJlOiAnLnBhZ2UtaGVhZGVyX19ib3R0b20gPiAucGFnZS1jb250ZW50JyxcclxuICAgICAgICBicmVha3BvaW50czogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXk6ICdsZXNzJyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiAnOTYwJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBwb3M6ICdiZWZvcmVlbmQnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHdoYXQ6ICcucGFnZS1oZWFkZXJfX3RlbCcsXHJcbiAgICAgICAgd2hlcmU6ICcucGFnZS1oZWFkZXJfX3Jvdy10b3AnLFxyXG4gICAgICAgIGJyZWFrcG9pbnRzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogJ21vcmUnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc5NjAnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHBvczogJ2FmdGVyYmVnaW4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHdoYXQ6ICcucGFnZS1oZWFkZXJfX25hdicsXHJcbiAgICAgICAgd2hlcmU6ICcucGFnZS1oZWFkZXJfX2NvbnRlbnQnLFxyXG4gICAgICAgIGJyZWFrcG9pbnRzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogJ2xlc3MnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6ICcxMjgwJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBwb3M6ICdhZnRlcmVuZCdcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgd2hhdDogJy5wYWdlLWhlYWRlcl9fbmF2JyxcclxuICAgICAgICB3aGVyZTogJy5wYWdlLWhlYWRlcl9fdGVsJyxcclxuICAgICAgICBicmVha3BvaW50czogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXk6ICdtb3JlJyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiAnMTI4MCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcG9zOiAnYWZ0ZXJlbmQnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHdoYXQ6ICcucGFnZS1oZWFkZXJfX3NlYXJjaC13cmFwcGVyJyxcclxuICAgICAgICB3aGVyZTogJy5wYWdlLWhlYWRlcl9fYm90dG9tID4gLnBhZ2UtY29udGVudCcsXHJcbiAgICAgICAgYnJlYWtwb2ludHM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiAnbGVzcycsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogJzk2MCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcG9zOiAnYWZ0ZXJiZWdpbidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgd2hhdDogJy5wYWdlLWhlYWRlcl9fc2VhcmNoLXdyYXBwZXInLFxyXG4gICAgICAgIHdoZXJlOiAnLnBhZ2UtaGVhZGVyX19yb3ctdG9wJyxcclxuICAgICAgICBicmVha3BvaW50czogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXk6ICdsZXNzJyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiAnNjQwJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBwb3M6ICdhZnRlcmJlZ2luJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICB3aGF0OiAnLnBhZ2UtaGVhZGVyX19zZWFyY2gtd3JhcHBlcicsXHJcbiAgICAgICAgd2hlcmU6ICcucGFnZS1oZWFkZXJfX3Jvd19ib3R0b20nLFxyXG4gICAgICAgIGJyZWFrcG9pbnRzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogJ21vcmUnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc5NjAnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHBvczogJ2JlZm9yZWVuZCdcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgd2hhdDogJy5idXR0b24tY2F0YWxvZycsXHJcbiAgICAgICAgd2hlcmU6ICcucGFnZS1oZWFkZXJfX2JvdHRvbSA+IC5wYWdlLWNvbnRlbnQnLFxyXG4gICAgICAgIGJyZWFrcG9pbnRzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogJ2xlc3MnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc5NjAnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHBvczogJ2FmdGVyYmVnaW4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHdoYXQ6ICcuYnV0dG9uLWNhdGFsb2cnLFxyXG4gICAgICAgIHdoZXJlOiAnLnBhZ2UtaGVhZGVyX19jb2x1bW4nLFxyXG4gICAgICAgIGJyZWFrcG9pbnRzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogJ21vcmUnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc5NjAnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHBvczogJ2JlZm9yZWVuZCdcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgd2hhdDogJy5idXR0b24tY2F0YWxvZycsXHJcbiAgICAgICAgd2hlcmU6ICcucGFnZS1oZWFkZXJfX2JvdHRvbSA+IC5wYWdlLWNvbnRlbnQnLFxyXG4gICAgICAgIGJyZWFrcG9pbnRzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGtleTogJ2xlc3MnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc5NjAnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHBvczogJ2FmdGVyYmVnaW4nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHdoYXQ6ICcucGFnZS1oZWFkZXJfX2FkZHJlc3MnLFxyXG4gICAgICAgIHdoZXJlOiAnLnBhZ2UtaGVhZGVyX19ib3R0b20gID4gLnBhZ2UtY29udGVudCcsXHJcbiAgICAgICAgYnJlYWtwb2ludHM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiAnbGVzcycsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogJzY0MCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcG9zOiAnYWZ0ZXJiZWdpbidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgd2hhdDogJy5wYWdlLWhlYWRlcl9fYWRkcmVzcycsXHJcbiAgICAgICAgd2hlcmU6ICcucGFnZS1oZWFkZXJfX2NvbHVtbicsXHJcbiAgICAgICAgYnJlYWtwb2ludHM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5OiAnbW9yZScsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogJzY0MCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcG9zOiAnYWZ0ZXJiZWdpbidcclxuICAgIH1cclxuXVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY29uZmlnIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/app/configs/adaptive.config.js\n")},"./source/js/app/configs/login.modal.config.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   states: function() { return /* binding */ states; },\n/* harmony export */   template: function() { return /* binding */ template; }\n/* harmony export */ });\nconst template = `\n    <button class="page-popup__close" data-close></button>\n    <div class="page-popup__container">\n        \n    </div>\n`;\nconst states = {\n  loginEmail: `\n            <h2 class="page-popup__title">Вход на сайт</h2>\n            <div class="page-popup__errors" data-errors>\n            </div>\n            <form >\n                <div class="page-popup__block">\n                    <div class="entry-input">\n                        <input type="email"  name="email" class="page-popup__input entry-input__field" placeholder="E-mail" data-email/>\n                    </div>\n                </div>\n                <div>\n                    <div class="entry-input">\n                        <input type="password" name="password" autocomplete="off" class="page-popup__input entry-input__field" placeholder="Пароль" data-pass/>\n                    </div>\n                    <button type="button" class="page-popup__link page-popup__link-forget" data-forget-pass tabindex="-1">Забыли пароль?</button>\n                </div>\n                <button class="page-popup__button button button_accent" type="submit" data-login-submit autofocus>Войти</button>\n            </form>\n            <div class="page-popup__registration">\n                <a href="/reg" class="page-popup__link-reg">Регистрация</a>\n            </div>\n       `,\n  forgetPass: `\n            <h2 class="page-popup__title">Смена Пароля</h2>\n            <div class="page-popup__descr">Ссылка на смену пароля будет отправлена на email, даже если Вы введёте номер,\n                используемый для авторизации\n            </div>\n            <div class="page-popup__errors" data-errors>\n    \n            </div>\n            <form >\n                <div class="page-popup__block">\n                    <div class="entry-input">\n                        <input type="email" autocomplete="off" class="page-popup__input entry-input__field" placeholder="E-mail" data-email/>\n                    </div>\n                </div>\n                <button class="page-popup__button button button_accent page-popup__button-pass" type="submit" data-login-submit>Отправить письмо</button>\n            </form>\n            <button class="page-popup__link-remember" data-remember-pass>Вспомнил пароль</button>\n         `,\n  sendRecoveryMail: `\n            <h2 class="page-popup__title">Смена Пароля</h2>\n            <div class="page-popup__descr" data-info>Ссылка для смены пароля отправлена на почту <b></b></div>\n            <a href="#" class="page-popup__button button button_accent page-popup__button-close" data-close>Закрыть</a>\n        `\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL2NvbmZpZ3MvbG9naW4ubW9kYWwuY29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QtZ3VscC8uL3NvdXJjZS9qcy9hcHAvY29uZmlncy9sb2dpbi5tb2RhbC5jb25maWcuanM/MmNkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdGVtcGxhdGUgPSBgXHJcbiAgICA8YnV0dG9uIGNsYXNzPVwicGFnZS1wb3B1cF9fY2xvc2VcIiBkYXRhLWNsb3NlPjwvYnV0dG9uPlxyXG4gICAgPGRpdiBjbGFzcz1cInBhZ2UtcG9wdXBfX2NvbnRhaW5lclwiPlxyXG4gICAgICAgIFxyXG4gICAgPC9kaXY+XHJcbmBcclxuXHJcblxyXG5leHBvcnQgY29uc3Qgc3RhdGVzID0ge1xyXG4gICAgbG9naW5FbWFpbDpcclxuICAgICAgICBgXHJcbiAgICAgICAgICAgIDxoMiBjbGFzcz1cInBhZ2UtcG9wdXBfX3RpdGxlXCI+0JLRhdC+0LQg0L3QsCDRgdCw0LnRgjwvaDI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLXBvcHVwX19lcnJvcnNcIiBkYXRhLWVycm9ycz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxmb3JtID5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLXBvcHVwX19ibG9ja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlbnRyeS1pbnB1dFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImVtYWlsXCIgIG5hbWU9XCJlbWFpbFwiIGNsYXNzPVwicGFnZS1wb3B1cF9faW5wdXQgZW50cnktaW5wdXRfX2ZpZWxkXCIgcGxhY2Vob2xkZXI9XCJFLW1haWxcIiBkYXRhLWVtYWlsLz5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZW50cnktaW5wdXRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIG5hbWU9XCJwYXNzd29yZFwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiIGNsYXNzPVwicGFnZS1wb3B1cF9faW5wdXQgZW50cnktaW5wdXRfX2ZpZWxkXCIgcGxhY2Vob2xkZXI9XCLQn9Cw0YDQvtC70YxcIiBkYXRhLXBhc3MvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGFnZS1wb3B1cF9fbGluayBwYWdlLXBvcHVwX19saW5rLWZvcmdldFwiIGRhdGEtZm9yZ2V0LXBhc3MgdGFiaW5kZXg9XCItMVwiPtCX0LDQsdGL0LvQuCDQv9Cw0YDQvtC70Yw/PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJwYWdlLXBvcHVwX19idXR0b24gYnV0dG9uIGJ1dHRvbl9hY2NlbnRcIiB0eXBlPVwic3VibWl0XCIgZGF0YS1sb2dpbi1zdWJtaXQgYXV0b2ZvY3VzPtCS0L7QudGC0Lg8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1wb3B1cF9fcmVnaXN0cmF0aW9uXCI+XHJcbiAgICAgICAgICAgICAgICA8YSBocmVmPVwiL3JlZ1wiIGNsYXNzPVwicGFnZS1wb3B1cF9fbGluay1yZWdcIj7QoNC10LPQuNGB0YLRgNCw0YbQuNGPPC9hPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgIGAsXHJcbiAgICBmb3JnZXRQYXNzOlxyXG4gICAgICAgIGBcclxuICAgICAgICAgICAgPGgyIGNsYXNzPVwicGFnZS1wb3B1cF9fdGl0bGVcIj7QodC80LXQvdCwINCf0LDRgNC+0LvRjzwvaDI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLXBvcHVwX19kZXNjclwiPtCh0YHRi9C70LrQsCDQvdCwINGB0LzQtdC90YMg0L/QsNGA0L7Qu9GPINCx0YPQtNC10YIg0L7RgtC/0YDQsNCy0LvQtdC90LAg0L3QsCBlbWFpbCwg0LTQsNC20LUg0LXRgdC70Lgg0JLRiyDQstCy0LXQtNGR0YLQtSDQvdC+0LzQtdGALFxyXG4gICAgICAgICAgICAgICAg0LjRgdC/0L7Qu9GM0LfRg9C10LzRi9C5INC00LvRjyDQsNCy0YLQvtGA0LjQt9Cw0YbQuNC4XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1wb3B1cF9fZXJyb3JzXCIgZGF0YS1lcnJvcnM+XHJcbiAgICBcclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxmb3JtID5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLXBvcHVwX19ibG9ja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlbnRyeS1pbnB1dFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImVtYWlsXCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgY2xhc3M9XCJwYWdlLXBvcHVwX19pbnB1dCBlbnRyeS1pbnB1dF9fZmllbGRcIiBwbGFjZWhvbGRlcj1cIkUtbWFpbFwiIGRhdGEtZW1haWwvPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicGFnZS1wb3B1cF9fYnV0dG9uIGJ1dHRvbiBidXR0b25fYWNjZW50IHBhZ2UtcG9wdXBfX2J1dHRvbi1wYXNzXCIgdHlwZT1cInN1Ym1pdFwiIGRhdGEtbG9naW4tc3VibWl0PtCe0YLQv9GA0LDQstC40YLRjCDQv9C40YHRjNC80L48L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicGFnZS1wb3B1cF9fbGluay1yZW1lbWJlclwiIGRhdGEtcmVtZW1iZXItcGFzcz7QktGB0L/QvtC80L3QuNC7INC/0LDRgNC+0LvRjDwvYnV0dG9uPlxyXG4gICAgICAgICBgLFxyXG4gICAgc2VuZFJlY292ZXJ5TWFpbDpcclxuICAgICAgICBgXHJcbiAgICAgICAgICAgIDxoMiBjbGFzcz1cInBhZ2UtcG9wdXBfX3RpdGxlXCI+0KHQvNC10L3QsCDQn9Cw0YDQvtC70Y88L2gyPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1wb3B1cF9fZGVzY3JcIiBkYXRhLWluZm8+0KHRgdGL0LvQutCwINC00LvRjyDRgdC80LXQvdGLINC/0LDRgNC+0LvRjyDQvtGC0L/RgNCw0LLQu9C10L3QsCDQvdCwINC/0L7Rh9GC0YMgPGI+PC9iPjwvZGl2PlxyXG4gICAgICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzPVwicGFnZS1wb3B1cF9fYnV0dG9uIGJ1dHRvbiBidXR0b25fYWNjZW50IHBhZ2UtcG9wdXBfX2J1dHRvbi1jbG9zZVwiIGRhdGEtY2xvc2U+0JfQsNC60YDRi9GC0Yw8L2E+XHJcbiAgICAgICAgYFxyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/app/configs/login.modal.config.js\n')},"./source/js/app/controllers/auth.controller.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\nclass AuthController {\n  constructor(config) {\n    this.router = config.router;\n    this.isAuth = false;\n    this.userData = null;\n    this.csrf = null;\n  }\n  async init() {\n    try {\n      const res = await fetch(this.router.authInfoLink);\n      const data = await res.json();\n      if (!data.message) {\n        this.isAuth = true;\n        this.userData = data.info;\n        this.csrf = data.csrf;\n        return data;\n      }\n      return null;\n    } catch (e) {}\n  }\n}\n/* harmony default export */ __webpack_exports__["default"] = (AuthController);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL2NvbnRyb2xsZXJzL2F1dGguY29udHJvbGxlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvYXBwL2NvbnRyb2xsZXJzL2F1dGguY29udHJvbGxlci5qcz80N2FkIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEF1dGhDb250cm9sbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMucm91dGVyID0gY29uZmlnLnJvdXRlclxyXG4gICAgICAgIHRoaXMuaXNBdXRoID0gZmFsc2VcclxuICAgICAgICB0aGlzLnVzZXJEYXRhID0gbnVsbFxyXG4gICAgICAgIHRoaXMuY3NyZiA9IG51bGxcclxuICAgIH1cclxuICAgIGFzeW5jIGluaXQoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godGhpcy5yb3V0ZXIuYXV0aEluZm9MaW5rKVxyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKVxyXG4gICAgICAgICAgICBpZighZGF0YS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzQXV0aCA9IHRydWVcclxuICAgICAgICAgICAgICAgIHRoaXMudXNlckRhdGEgPSBkYXRhLmluZm9cclxuICAgICAgICAgICAgICAgIHRoaXMuY3NyZiA9IGRhdGEuY3NyZlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICAgIH0gY2F0Y2goZSkge1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBBdXRoQ29udHJvbGxlciJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/app/controllers/auth.controller.js\n')},"./source/js/app/modules/catalog.menu.module.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var code_tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! code-tag */ \"./node_modules/code-tag/dist/index.mjs\");\n\nclass CatalogMenuModule {\n  constructor(config) {\n    this.router = config.router;\n    this.apiService = config.apiService;\n    this.$node = document.querySelector(config.selector);\n  }\n  async init() {\n    try {\n      const data = await this.apiService.useRequest(this.router.catalogLink);\n      this.view(data);\n      registerHandlers();\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  view({\n    categories,\n    subCategories\n  }) {\n    const data = categories.map(cat => {\n      return {\n        ...cat,\n        children: subCategories.filter(subcat => subcat.category?._id === cat?._id)\n      };\n    }).sort((prev, next) => prev.number - next.number);\n    let view = ``;\n    data.forEach(block => {\n      const list = block.children.reduce((acc, curr) => {\n        acc += `\n                    <li class=\"catalog-item__point\">\n                        <a href=\"/catalog/${block.link}/${curr.link}\" class=\"catalog-item__link\">${curr.name}</a>\n                    </li> `;\n        return acc;\n      }, '');\n      view += `\n                <div class=\"catalog-item\">\n                    <div class=\"catalog-item__header\">\n                        <b class=\"catalog-item__title\">${block.name}</b>\n                        <a href=\"/catalog/${block.link}\"\n                           class=\"catalog-item__link-all button button_mini button_backwards-accent\">все\n                            <svg>\n                                <use xlink:href=\"img/svg/sprite.svg#arrow-small\"></use>\n                            </svg>\n                        </a>\n                    </div>\n                    <ul class=\"catalog-item__list\">\n                        ${list}\n                    </ul>\n                </div>`;\n    });\n    this.$node.innerHTML = view;\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (CatalogMenuModule);\nfunction registerHandlers() {\n  const $buttonCatalog = document.querySelector('.button-catalog');\n  const $catalogMenu = document.querySelector('.catalog-menu');\n  const $overlay = document.querySelector('.page-overlay');\n  const $catalogHeaders = document.querySelectorAll('.catalog-item__header');\n  $buttonCatalog.addEventListener('click', function () {\n    toggleCatalog();\n  });\n  $overlay.addEventListener('click', function () {\n    if ($catalogMenu.classList.contains('catalog-menu_active')) {\n      toggleCatalog();\n    }\n  });\n  $catalogHeaders.forEach(element => {\n    element.querySelector('.catalog-item__title').addEventListener('click', () => {\n      const $list = element.parentNode.querySelector('.catalog-item__list');\n      if ($list.classList.contains('catalog-item__list_active')) {\n        $list.classList.remove('catalog-item__list_active');\n        element.classList.remove('catalog-item__header_active');\n        return 0;\n      }\n      $catalogHeaders.forEach(item => {\n        const $list = item.parentNode.querySelector('.catalog-item__list');\n        $list.classList.remove('catalog-item__list_active');\n        item.classList.remove('catalog-item__header_active');\n      });\n      $list.classList.add('catalog-item__list_active');\n      element.classList.add('catalog-item__header_active');\n    });\n  });\n  function toggleCatalog() {\n    $buttonCatalog.classList.toggle('button-catalog_active');\n    $overlay.classList.toggle('page-overlay_active');\n    $catalogMenu.classList.toggle('catalog-menu_active');\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL21vZHVsZXMvY2F0YWxvZy5tZW51Lm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2FwcC9tb2R1bGVzL2NhdGFsb2cubWVudS5tb2R1bGUuanM/NGYzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBodG1sIH0gZnJvbSAnY29kZS10YWcnXHJcblxyXG5jbGFzcyBDYXRhbG9nTWVudU1vZHVsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLnJvdXRlciA9IGNvbmZpZy5yb3V0ZXJcclxuICAgICAgICB0aGlzLmFwaVNlcnZpY2UgPSBjb25maWcuYXBpU2VydmljZVxyXG4gICAgICAgIHRoaXMuJG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbmZpZy5zZWxlY3RvcilcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBpbml0KCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmFwaVNlcnZpY2UudXNlUmVxdWVzdCh0aGlzLnJvdXRlci5jYXRhbG9nTGluaylcclxuICAgICAgICAgICAgdGhpcy52aWV3KGRhdGEpXHJcbiAgICAgICAgICAgIHJlZ2lzdGVySGFuZGxlcnMoKVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmlldyh7IGNhdGVnb3JpZXMsIHN1YkNhdGVnb3JpZXMgfSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBjYXRlZ29yaWVzLm1hcChjYXQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4uY2F0LFxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IHN1YkNhdGVnb3JpZXMuZmlsdGVyKHN1YmNhdCA9PiBzdWJjYXQuY2F0ZWdvcnk/Ll9pZCA9PT0gY2F0Py5faWQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5zb3J0KChwcmV2LCBuZXh0KSA9PiBwcmV2Lm51bWJlciAtIG5leHQubnVtYmVyKVxyXG5cclxuICAgICAgICBsZXQgdmlldyA9IGBgXHJcbiAgICAgICAgZGF0YS5mb3JFYWNoKGJsb2NrID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGlzdCA9IGJsb2NrLmNoaWxkcmVuLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhY2MgKz0gYFxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cImNhdGFsb2ctaXRlbV9fcG9pbnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIi9jYXRhbG9nLyR7YmxvY2subGlua30vJHtjdXJyLmxpbmt9XCIgY2xhc3M9XCJjYXRhbG9nLWl0ZW1fX2xpbmtcIj4ke2N1cnIubmFtZX08L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9saT4gYFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY1xyXG4gICAgICAgICAgICB9LCAnJylcclxuICAgICAgICAgICAgdmlldyArPSBgXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2F0YWxvZy1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNhdGFsb2ctaXRlbV9faGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzPVwiY2F0YWxvZy1pdGVtX190aXRsZVwiPiR7YmxvY2submFtZX08L2I+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIvY2F0YWxvZy8ke2Jsb2NrLmxpbmt9XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjYXRhbG9nLWl0ZW1fX2xpbmstYWxsIGJ1dHRvbiBidXR0b25fbWluaSBidXR0b25fYmFja3dhcmRzLWFjY2VudFwiPtCy0YHQtVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN2Zz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9XCJpbWcvc3ZnL3Nwcml0ZS5zdmcjYXJyb3ctc21hbGxcIj48L3VzZT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwiY2F0YWxvZy1pdGVtX19saXN0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR7bGlzdH1cclxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+YFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy4kbm9kZS5pbm5lckhUTUwgPSB2aWV3XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhdGFsb2dNZW51TW9kdWxlXHJcblxyXG5mdW5jdGlvbiByZWdpc3RlckhhbmRsZXJzKCkge1xyXG4gICAgY29uc3QgJGJ1dHRvbkNhdGFsb2cgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYnV0dG9uLWNhdGFsb2cnKVxyXG4gICAgY29uc3QgJGNhdGFsb2dNZW51ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhdGFsb2ctbWVudScpXHJcbiAgICBjb25zdCAkb3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLW92ZXJsYXknKVxyXG4gICAgY29uc3QgJGNhdGFsb2dIZWFkZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhdGFsb2ctaXRlbV9faGVhZGVyJylcclxuXHJcblxyXG4gICAgJGJ1dHRvbkNhdGFsb2cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdG9nZ2xlQ2F0YWxvZygpXHJcbiAgICB9KVxyXG5cclxuICAgICRvdmVybGF5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICgkY2F0YWxvZ01lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKCdjYXRhbG9nLW1lbnVfYWN0aXZlJykpIHtcclxuICAgICAgICAgICAgdG9nZ2xlQ2F0YWxvZygpXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcblxyXG4gICAgJGNhdGFsb2dIZWFkZXJzLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuY2F0YWxvZy1pdGVtX190aXRsZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCAkbGlzdCA9IGVsZW1lbnQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKCcuY2F0YWxvZy1pdGVtX19saXN0JylcclxuXHJcbiAgICAgICAgICAgIGlmICgkbGlzdC5jbGFzc0xpc3QuY29udGFpbnMoJ2NhdGFsb2ctaXRlbV9fbGlzdF9hY3RpdmUnKSkge1xyXG4gICAgICAgICAgICAgICAgJGxpc3QuY2xhc3NMaXN0LnJlbW92ZSgnY2F0YWxvZy1pdGVtX19saXN0X2FjdGl2ZScpXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2NhdGFsb2ctaXRlbV9faGVhZGVyX2FjdGl2ZScpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICRjYXRhbG9nSGVhZGVycy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJGxpc3QgPSBpdGVtLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcignLmNhdGFsb2ctaXRlbV9fbGlzdCcpXHJcbiAgICAgICAgICAgICAgICAkbGlzdC5jbGFzc0xpc3QucmVtb3ZlKCdjYXRhbG9nLWl0ZW1fX2xpc3RfYWN0aXZlJylcclxuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnY2F0YWxvZy1pdGVtX19oZWFkZXJfYWN0aXZlJylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgJGxpc3QuY2xhc3NMaXN0LmFkZCgnY2F0YWxvZy1pdGVtX19saXN0X2FjdGl2ZScpXHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY2F0YWxvZy1pdGVtX19oZWFkZXJfYWN0aXZlJylcclxuICAgICAgICB9KVxyXG4gICAgfSlcclxuXHJcbiAgICBmdW5jdGlvbiB0b2dnbGVDYXRhbG9nKCkge1xyXG4gICAgICAgICRidXR0b25DYXRhbG9nLmNsYXNzTGlzdC50b2dnbGUoJ2J1dHRvbi1jYXRhbG9nX2FjdGl2ZScpXHJcbiAgICAgICAgJG92ZXJsYXkuY2xhc3NMaXN0LnRvZ2dsZSgncGFnZS1vdmVybGF5X2FjdGl2ZScpXHJcbiAgICAgICAgJGNhdGFsb2dNZW51LmNsYXNzTGlzdC50b2dnbGUoJ2NhdGFsb2ctbWVudV9hY3RpdmUnKVxyXG4gICAgfVxyXG5cclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/app/modules/catalog.menu.module.js\n")},"./source/js/app/modules/catalog.module.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ CatalogModule; }\n/* harmony export */ });\n/* harmony import */ var _views_render_products_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../views/render.products.js */ \"./source/js/app/views/render.products.js\");\n/* harmony import */ var _core_components_selectsinputs_select_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/components/selectsinputs/select.component.js */ \"./source/js/core/components/selectsinputs/select.component.js\");\n/* harmony import */ var _service_view_catalog_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../service/view.catalog.js */ \"./source/js/app/service/view.catalog.js\");\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/utils.js */ \"./source/js/app/utils/utils.js\");\n/* harmony import */ var _core_components_pagination_component_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/components/pagination.component.js */ \"./source/js/core/components/pagination.component.js\");\n/* harmony import */ var _core_components_sidebar_component_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/components/sidebar.component.js */ \"./source/js/core/components/sidebar.component.js\");\n/* harmony import */ var _core_modules_module_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/modules/module.core.js */ \"./source/js/core/modules/module.core.js\");\n/* harmony import */ var _filter_module_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./filter.module.js */ \"./source/js/app/modules/filter.module.js\");\n/* harmony import */ var _common_modules_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../common.modules.js */ \"./source/js/app/common.modules.js\");\n/* harmony import */ var _core_components_breadcrumbs_component_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/components/breadcrumbs.component.js */ \"./source/js/core/components/breadcrumbs.component.js\");\n\n\n\n\n\n\n\n\n\n\nclass CatalogModule extends _core_modules_module_core_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"] {\n  constructor(config) {\n    super(config);\n    this.breadcrumbs = new _core_components_breadcrumbs_component_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]('#breadcrumbs');\n    this.filter = new _filter_module_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]('#page-filter', '#filter-list', _common_modules_js__WEBPACK_IMPORTED_MODULE_8__.router);\n    this.$productsList = document.querySelector('#products_list');\n    this.prevFilterStatement = {};\n    this.data = null;\n  }\n  async init() {\n    super.init();\n    try {\n      (0,_service_view_catalog_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n      new _core_components_sidebar_component_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n        root: '[data-sidebar]',\n        overlay: '.page-overlay',\n        buttonOpen: '[data-sidebar-open]',\n        buttonClose: '[data-sidebar-close]'\n      }).init();\n      this.renderSortSelect();\n      this.pagination = new _core_components_pagination_component_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n        query: '#pagination',\n        onChange: pageNumber => {\n          this.addParamState('page', pageNumber, () => {\n            this.changeState();\n            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])('#top-element');\n          });\n        }\n      });\n      const [data] = await Promise.all([this.changeState(), this.renderFilterSidebar()]);\n      this.data = data;\n      this.preloader.hide();\n      this.renderCatalogHeader(this.data);\n    } catch (e) {\n      this.router.redirectNotFound();\n    }\n  }\n  async renderFilterSidebar() {\n    this.filter.showPreloader();\n    const data = await this.apiService.useRequest(this.router.catalogFilter, {\n      method: \"OPTIONS\"\n    });\n    this.filter.init({\n      data: data.filtersData,\n      changeState: data => {\n        this.changeFilterState(data);\n      },\n      onRenderFilter: () => {\n        this.parseFiltersOnLoad();\n      }\n    });\n    this.filter.removePreloader();\n  }\n  renderSortSelect() {\n    this.sortSelect = new _core_components_selectsinputs_select_component_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n      query: '#sort-catalog',\n      data: [{\n        value: 'По популярности',\n        dataset: 'popularity',\n        default: true\n      }, {\n        value: 'По наименованию',\n        dataset: 'name'\n      }, {\n        value: 'По бренду',\n        dataset: 'maker'\n      }],\n      onselect: data => {\n        this.addParamState('sort', data.value, () => {\n          this.changeState();\n          (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])('#top-element');\n        });\n      }\n    });\n    this.sortSelect.render();\n  }\n  async changeState() {\n    this.router.redirectUrlState();\n    this.filter.showPreloader();\n    this.showPreloader();\n    this.pagination.clear();\n    const data = await this.apiService.useRequest(this.router.apiLink);\n    this.renderProducts(data);\n    this.filter.removePreloader();\n    return data;\n  }\n  parseFiltersOnLoad() {\n    const params = this.router.params;\n    const parsedData = {};\n    for (const [key, value] of params.entries()) {\n      if (!value.trim().length) continue;\n      if (key === 'sort') {\n        this.sortSelect.changeState(value);\n      } else if (key === 'name') {\n        parsedData[key] = value;\n        this.filter.addFilterItem({\n          type: key,\n          label: 'Поиск по названию',\n          value\n        });\n      } else if (this.filter.allowedKeys.includes(key)) {\n        if (!parsedData[key]) parsedData[key] = [];\n        value.split(',').forEach(vl => {\n          parsedData[key].push(vl);\n          this.filter.addFilterItem({\n            type: key,\n            value: vl\n          });\n        });\n      }\n    }\n    this.prevFilterStatement = parsedData;\n    this.filter.initialState();\n  }\n  changeFilterState(data) {\n    this.router.removeParam('page');\n    const parsedData = {};\n    data.forEach(data => {\n      if (!parsedData[data.type]) parsedData[data.type] = [];\n      parsedData[data.type].push(data.value);\n    });\n    for (const item of Object.keys(this.prevFilterStatement)) {\n      if (!parsedData.hasOwnProperty(item)) {\n        this.router.removeParam(item);\n      }\n    }\n    for (const item of Object.keys(parsedData)) {\n      this.router.addParams(item, parsedData[item].join(','));\n    }\n    this.prevFilterStatement = parsedData;\n    this.changeState();\n  }\n  renderProducts({\n    products,\n    count,\n    currentPage\n  }) {\n    if (!products.length) {\n      this.$productsList.innerHTML = 'Ничего не найдено';\n    } else {\n      this.$productsList.innerHTML = (0,_views_render_products_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(products, 'products__item');\n      (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__.lazyLoadImages)(this.$productsList);\n      this.pagination.render({\n        count,\n        currentPage\n      });\n    }\n  }\n  renderCatalogHeader({\n    path\n  }) {\n    this.setTitle(path.at(-1).name);\n    this.breadcrumbs.renderPath(path);\n  }\n  showPreloader() {\n    this.$productsList.innerHTML = `<div class=\"preloader\"></div>`;\n  }\n  setTitle(text) {\n    document.querySelector('.page-section__title').innerHTML = text;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL21vZHVsZXMvY2F0YWxvZy5tb2R1bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvYXBwL21vZHVsZXMvY2F0YWxvZy5tb2R1bGUuanM/MDQxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVuZGVyUHJvZHVjdHMgZnJvbSAnLi4vdmlld3MvcmVuZGVyLnByb2R1Y3RzLmpzJ1xyXG5pbXBvcnQgU2VsZWN0Q29tcG9uZW50IGZyb20gJy4uLy4uL2NvcmUvY29tcG9uZW50cy9zZWxlY3RzaW5wdXRzL3NlbGVjdC5jb21wb25lbnQuanMnXHJcbmltcG9ydCBjaGFuZ2VQcm9kdWN0c1ZpZXdIYW5kbGVyIGZyb20gJy4uL3NlcnZpY2Uvdmlldy5jYXRhbG9nLmpzJ1xyXG5pbXBvcnQgc2Nyb2xsVG9Ub3AsIHsgbGF6eUxvYWRJbWFnZXMgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IFBhZ2luYXRpb25Db21wb25lbnQgZnJvbSAnLi4vLi4vY29yZS9jb21wb25lbnRzL3BhZ2luYXRpb24uY29tcG9uZW50LmpzJ1xyXG5pbXBvcnQgU2lkZWJhckNvbXBvbmVudCBmcm9tICcuLi8uLi9jb3JlL2NvbXBvbmVudHMvc2lkZWJhci5jb21wb25lbnQuanMnXHJcbmltcG9ydCBNb2R1bGVDb3JlIGZyb20gJy4uLy4uL2NvcmUvbW9kdWxlcy9tb2R1bGUuY29yZS5qcydcclxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlci5tb2R1bGUuanMnXHJcbmltcG9ydCB7IHJvdXRlciB9IGZyb20gJy4uL2NvbW1vbi5tb2R1bGVzLmpzJ1xyXG5pbXBvcnQgQnJlYWRjcnVtYnNDb21wb25lbnQgZnJvbSAnLi4vLi4vY29yZS9jb21wb25lbnRzL2JyZWFkY3J1bWJzLmNvbXBvbmVudC5qcydcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXRhbG9nTW9kdWxlIGV4dGVuZHMgTW9kdWxlQ29yZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICBzdXBlcihjb25maWcpXHJcbiAgICAgICAgdGhpcy5icmVhZGNydW1icyA9IG5ldyBCcmVhZGNydW1ic0NvbXBvbmVudCgnI2JyZWFkY3J1bWJzJylcclxuICAgICAgICB0aGlzLmZpbHRlciA9IG5ldyBGaWx0ZXIoJyNwYWdlLWZpbHRlcicsICcjZmlsdGVyLWxpc3QnLCByb3V0ZXIpXHJcbiAgICAgICAgdGhpcy4kcHJvZHVjdHNMaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Byb2R1Y3RzX2xpc3QnKVxyXG4gICAgICAgIHRoaXMucHJldkZpbHRlclN0YXRlbWVudCA9IHt9XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGluaXQoKSB7XHJcbiAgICAgICAgc3VwZXIuaW5pdCgpXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY2hhbmdlUHJvZHVjdHNWaWV3SGFuZGxlcigpXHJcbiAgICAgICAgICAgIG5ldyBTaWRlYmFyQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgICAgIHJvb3Q6ICdbZGF0YS1zaWRlYmFyXScsXHJcbiAgICAgICAgICAgICAgICBvdmVybGF5OiAnLnBhZ2Utb3ZlcmxheScsXHJcbiAgICAgICAgICAgICAgICBidXR0b25PcGVuOiAnW2RhdGEtc2lkZWJhci1vcGVuXScsXHJcbiAgICAgICAgICAgICAgICBidXR0b25DbG9zZTogJ1tkYXRhLXNpZGViYXItY2xvc2VdJ1xyXG4gICAgICAgICAgICB9KS5pbml0KClcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTb3J0U2VsZWN0KClcclxuICAgICAgICAgICAgdGhpcy5wYWdpbmF0aW9uID0gbmV3IFBhZ2luYXRpb25Db21wb25lbnQoe1xyXG4gICAgICAgICAgICAgICAgcXVlcnk6ICcjcGFnaW5hdGlvbicsXHJcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogKHBhZ2VOdW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBhcmFtU3RhdGUoJ3BhZ2UnLCBwYWdlTnVtYmVyLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb1RvcCgnI3RvcC1lbGVtZW50JylcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBjb25zdCBbZGF0YV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbHRlclNpZGViYXIoKVxyXG4gICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhXHJcbiAgICAgICAgICAgIHRoaXMucHJlbG9hZGVyLmhpZGUoKVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNhdGFsb2dIZWFkZXIodGhpcy5kYXRhKVxyXG4gICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJvdXRlci5yZWRpcmVjdE5vdEZvdW5kKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyByZW5kZXJGaWx0ZXJTaWRlYmFyKCkge1xyXG4gICAgICAgIHRoaXMuZmlsdGVyLnNob3dQcmVsb2FkZXIoKVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmFwaVNlcnZpY2UudXNlUmVxdWVzdCh0aGlzLnJvdXRlci5jYXRhbG9nRmlsdGVyLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogXCJPUFRJT05TXCJcclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuZmlsdGVyLmluaXQoe1xyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLmZpbHRlcnNEYXRhLFxyXG4gICAgICAgICAgICBjaGFuZ2VTdGF0ZTogKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRmlsdGVyU3RhdGUoZGF0YSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25SZW5kZXJGaWx0ZXI6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VGaWx0ZXJzT25Mb2FkKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5maWx0ZXIucmVtb3ZlUHJlbG9hZGVyKClcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJTb3J0U2VsZWN0KCkge1xyXG4gICAgICAgIHRoaXMuc29ydFNlbGVjdCA9IG5ldyBTZWxlY3RDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBxdWVyeTogJyNzb3J0LWNhdGFsb2cnLFxyXG4gICAgICAgICAgICBkYXRhOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICfQn9C+INC/0L7Qv9GD0LvRj9GA0L3QvtGB0YLQuCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldDogJ3BvcHVsYXJpdHknLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICfQn9C+INC90LDQuNC80LXQvdC+0LLQsNC90LjRjicsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldDogJ25hbWUnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAn0J/QviDQsdGA0LXQvdC00YMnLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXQ6ICdtYWtlcidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgb25zZWxlY3Q6IChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBhcmFtU3RhdGUoJ3NvcnQnLCBkYXRhLnZhbHVlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9Ub3AoJyN0b3AtZWxlbWVudCcpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLnNvcnRTZWxlY3QucmVuZGVyKClcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBjaGFuZ2VTdGF0ZSgpIHtcclxuICAgICAgICB0aGlzLnJvdXRlci5yZWRpcmVjdFVybFN0YXRlKClcclxuICAgICAgICB0aGlzLmZpbHRlci5zaG93UHJlbG9hZGVyKClcclxuICAgICAgICB0aGlzLnNob3dQcmVsb2FkZXIoKVxyXG4gICAgICAgIHRoaXMucGFnaW5hdGlvbi5jbGVhcigpXHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmFwaVNlcnZpY2UudXNlUmVxdWVzdCh0aGlzLnJvdXRlci5hcGlMaW5rKVxyXG5cclxuICAgICAgICB0aGlzLnJlbmRlclByb2R1Y3RzKGRhdGEpXHJcbiAgICAgICAgdGhpcy5maWx0ZXIucmVtb3ZlUHJlbG9hZGVyKClcclxuICAgICAgICByZXR1cm4gZGF0YVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwYXJzZUZpbHRlcnNPbkxvYWQoKSB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5yb3V0ZXIucGFyYW1zXHJcbiAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IHt9XHJcbiAgICAgICAgZm9yICggY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhcmFtcy5lbnRyaWVzKCkgKSB7XHJcbiAgICAgICAgICAgIGlmICghdmFsdWUudHJpbSgpLmxlbmd0aCkgY29udGludWVcclxuXHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdzb3J0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0U2VsZWN0LmNoYW5nZVN0YXRlKHZhbHVlKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ25hbWUnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRhW2tleV0gPSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIuYWRkRmlsdGVySXRlbSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZToga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAn0J/QvtC40YHQuiDQv9C+INC90LDQt9Cy0LDQvdC40Y4nLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlsdGVyLmFsbG93ZWRLZXlzLmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkRGF0YVtrZXldKSBwYXJzZWREYXRhW2tleV0gPSBbXVxyXG4gICAgICAgICAgICAgICAgdmFsdWUuc3BsaXQoJywnKS5mb3JFYWNoKHZsID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhW2tleV0ucHVzaCh2bClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlci5hZGRGaWx0ZXJJdGVtKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZToga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmxcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByZXZGaWx0ZXJTdGF0ZW1lbnQgPSBwYXJzZWREYXRhXHJcbiAgICAgICAgdGhpcy5maWx0ZXIuaW5pdGlhbFN0YXRlKClcclxuICAgIH1cclxuXHJcbiAgICBjaGFuZ2VGaWx0ZXJTdGF0ZShkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIucmVtb3ZlUGFyYW0oJ3BhZ2UnKVxyXG4gICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSB7fVxyXG4gICAgICAgIGRhdGEuZm9yRWFjaCgoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXBhcnNlZERhdGFbZGF0YS50eXBlXSkgcGFyc2VkRGF0YVtkYXRhLnR5cGVdID0gW11cclxuICAgICAgICAgICAgcGFyc2VkRGF0YVtkYXRhLnR5cGVdLnB1c2goZGF0YS52YWx1ZSlcclxuICAgICAgICB9KVxyXG4gICAgICAgIGZvciAoIGNvbnN0IGl0ZW0gb2YgT2JqZWN0LmtleXModGhpcy5wcmV2RmlsdGVyU3RhdGVtZW50KSApIHtcclxuICAgICAgICAgICAgaWYgKCFwYXJzZWREYXRhLmhhc093blByb3BlcnR5KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5yZW1vdmVQYXJhbShpdGVtKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoIGNvbnN0IGl0ZW0gb2YgT2JqZWN0LmtleXMocGFyc2VkRGF0YSkgKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm91dGVyLmFkZFBhcmFtcyhpdGVtLCBwYXJzZWREYXRhW2l0ZW1dLmpvaW4oJywnKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcmV2RmlsdGVyU3RhdGVtZW50ID0gcGFyc2VkRGF0YVxyXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoKVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlclByb2R1Y3RzKHsgcHJvZHVjdHMsIGNvdW50LCBjdXJyZW50UGFnZSB9KSB7XHJcbiAgICAgICAgaWYgKCFwcm9kdWN0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy4kcHJvZHVjdHNMaXN0LmlubmVySFRNTCA9ICfQndC40YfQtdCz0L4g0L3QtSDQvdCw0LnQtNC10L3QvidcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLiRwcm9kdWN0c0xpc3QuaW5uZXJIVE1MID0gcmVuZGVyUHJvZHVjdHMocHJvZHVjdHMsICdwcm9kdWN0c19faXRlbScpXHJcbiAgICAgICAgICAgIGxhenlMb2FkSW1hZ2VzKHRoaXMuJHByb2R1Y3RzTGlzdClcclxuICAgICAgICAgICAgdGhpcy5wYWdpbmF0aW9uLnJlbmRlcih7XHJcbiAgICAgICAgICAgICAgICBjb3VudCxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlckNhdGFsb2dIZWFkZXIoeyBwYXRoIH0pIHtcclxuICAgICAgICB0aGlzLnNldFRpdGxlKHBhdGguYXQoLTEpLm5hbWUpXHJcbiAgICAgICAgdGhpcy5icmVhZGNydW1icy5yZW5kZXJQYXRoKHBhdGgpXHJcbiAgICB9XHJcblxyXG4gICAgc2hvd1ByZWxvYWRlcigpIHtcclxuICAgICAgICB0aGlzLiRwcm9kdWN0c0xpc3QuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJwcmVsb2FkZXJcIj48L2Rpdj5gXHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGl0bGUodGV4dCkge1xyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLXNlY3Rpb25fX3RpdGxlJykuaW5uZXJIVE1MID0gdGV4dFxyXG4gICAgfVxyXG59XHJcblxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/app/modules/catalog.module.js\n")},"./source/js/app/modules/filter.module.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_components_selectsinputs_multiselect_input_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/components/selectsinputs/multiselect.input.component.js */ "./source/js/core/components/selectsinputs/multiselect.input.component.js");\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils.js */ "./source/js/app/utils/utils.js");\n/* harmony import */ var code_tag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! code-tag */ "./node_modules/code-tag/dist/index.mjs");\n\n\n\nclass FilterModule {\n  constructor(root, query) {\n    this.$node = document.querySelector(root);\n    this.$filtersList = document.querySelector(query);\n    this.data = null;\n    this.$fieldTitle = null;\n    this.currentFilters = [];\n    this.selectsList = [];\n  }\n  init({\n    data,\n    changeState,\n    onRenderFilter\n  }) {\n    this.changeState = changeState;\n    this.onRenderFilter = onRenderFilter;\n    this.renderFilters(data);\n  }\n  initialState() {\n    this.parseCheckboxes();\n    this.parseSelects();\n    this.parseInputTitle();\n    this.renderFilterList(true);\n  }\n  parseInputTitle() {\n    this.$fieldTitle.value = this.currentFilters.find(filter => filter.type === \'name\')?.value || \'\';\n  }\n  searchHandler(e) {\n    this.currentFilters = this.currentFilters.filter(filter => filter.type !== \'name\');\n    if (e.target.value.trim()) {\n      this.addFilterItem({\n        type: \'name\',\n        value: (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.sanitalize)(e.target.value),\n        label: \'Поиск по наименованию\'\n      });\n    }\n    this.renderFilterList();\n  }\n  parseCheckboxes() {\n    this.currentFilters.forEach(item => {\n      let $checkbox = document.querySelector(`[data-filter="${item.type}"] [data-checkbox="${item.value}"]`);\n      if ($checkbox) {\n        $checkbox.checked = true;\n      }\n    });\n  }\n  parseSelects() {\n    this.currentFilters.forEach(item => {\n      const select = this.selectsList.find(select => item.type === select.type);\n      if (select && select.hasItem(item.value)) {\n        select.selectItem(item.value, false);\n      }\n    });\n  }\n  handlerClickMore(target) {\n    if (target.dataset.filterMore !== undefined) {\n      const $parentList = target.closest(\'.filter-block__list\');\n      $parentList.classList.toggle(\'filter-block__list_full\');\n      if (target.textContent.trim() === \'Еще\') {\n        target.textContent = \'Свернуть\';\n        target.classList.add(\'filter-block__more_hide\');\n      } else {\n        target.classList.remove(\'filter-block__more_hide\');\n        target.textContent = \'Еще\';\n      }\n    }\n  }\n  handlerCheckboxChange(target) {\n    const type = target.closest(\'.filter-block__list\').dataset.list;\n    const value = target.dataset.checkbox;\n    if (target.checked) {\n      this.addFilterItem({\n        type,\n        value\n      });\n    } else {\n      this.removeFilterItem({\n        type,\n        value\n      });\n    }\n    this.renderFilterList();\n  }\n  handlerFilterListClick(target) {\n    if (target.closest(\'[data-filter-close]\')) {\n      const $parent = target.closest(\'.filters__item\');\n      const type = $parent.querySelector(\'.filters__key\').dataset.filterType;\n      const value = $parent.querySelector(\'.filters__value\').dataset.filterValue;\n      this.removeFilterItem({\n        type,\n        value\n      });\n      this.renderFilterList();\n    }\n    if (target.closest(\'[data-filter-reset]\')) {\n      this.currentFilters.forEach(filter => {\n        this.removeFilterItem(filter);\n      });\n      this.renderFilterList();\n    }\n  }\n  initHandlers() {\n    this.$fieldTitle = document.querySelector(\'[data-filter="name"]\');\n    this.$node.addEventListener(\'click\', ({\n      target\n    }) => {\n      this.handlerClickMore(target);\n    });\n    this.$node.querySelectorAll(\'.checkbox__input\').forEach(checkbox => {\n      checkbox.addEventListener(\'change\', ({\n        target\n      }) => {\n        this.handlerCheckboxChange(target);\n      });\n    });\n    this.$filtersList.addEventListener(\'click\', ({\n      target\n    }) => {\n      this.handlerFilterListClick(target);\n    });\n    const inputWithDebounce = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.debounce)(this.searchHandler.bind(this), 800);\n    this.$fieldTitle.addEventListener(\'input\', e => {\n      inputWithDebounce(e);\n    });\n  }\n  addFilterItem(data) {\n    this.currentFilters.push(data);\n  }\n  removeFilterItem({\n    type,\n    value\n  }) {\n    this.currentFilters = this.currentFilters.filter(filter => filter.value !== value && filter.key !== type);\n    const $checkbox = this.$node.querySelector(`[data-filter=\'${type}\'] [data-checkbox=\'${value}\']`);\n    if ($checkbox) $checkbox.checked = false;\n    const select = this.selectsList.find(select => select.type === type);\n    if (select) select.removeItem(value, false);\n    this.parseInputTitle();\n  }\n  renderFilterList(initialState = false) {\n    this.$filtersList.innerHTML = \'\';\n    let view = \'\';\n    this.currentFilters.forEach(filter => {\n      view += `\n                <li class="filters__item">\n                    <span class="filters__key" data-filter-type="${filter.type}">${filter.label || filter.type}</span>\n                    <span class="filters__value" data-filter-value="${filter.value}">${filter.value}</span>\n                    <span class="filters__close" data-filter-close="true">\n                             <svg>\n                                 <use xlink:href="img/svg/sprite.svg#close"></use>\n                             </svg>\n                         </span>\n                </li>`;\n    });\n    if (this.currentFilters.length) {\n      view += \'<li class="filter__item-reset" data-filter-reset="true">Сбросить все фильтры</li>\';\n    }\n    if (!initialState) this.changeState(this.currentFilters);\n    this.$filtersList.insertAdjacentHTML(\'beforeend\', view);\n  }\n  get allowedKeys() {\n    const keys = [];\n    document.querySelectorAll(\'[data-filter]\').forEach(node => {\n      if (node.dataset.filter) keys.push(node.dataset.filter);\n    });\n    return keys;\n  }\n  renderFilters(data) {\n    this.data = data;\n    this.renderHeader();\n    if (data.maker.length >= 2) {\n      this.renderList({\n        key: \'Марка\',\n        attrs: data.maker\n      });\n    }\n    const lists = [];\n    const selects = [];\n    for (const key in data.attributes) {\n      const filterItem = {\n        key,\n        attrs: data.attributes[key].list\n      };\n      if (data.attributes[key].list.length < 2) {} else if (data.attributes[key].type === \'list\') {\n        lists.push(filterItem);\n      } else {\n        selects.push(filterItem);\n      }\n    }\n    lists.forEach(list => this.renderList(list));\n    selects.forEach(select => this.renderSelect(select));\n    this.initHandlers();\n    this.onRenderFilter();\n  }\n  renderHeader() {\n    let view = \'\';\n    view += `\n            <div class="page-filter__block filter-block">\n                <div class="filter-block__header">\n                    <b class="filter-block__name">Поиск по наименованию</b>\n                </div>\n                <div class="filter-block__body">\n                    <div class="entry-input">\n                        <input type="text" name="name" placeholder="Введите текст" class="entry-input__field" data-filter="name"/>\n                    </div>\n                </div>\n            </div>\n        `;\n    this.$node.innerHTML += view;\n  }\n  renderList({\n    key,\n    attrs\n  }) {\n    attrs = attrs.sort((prev, next) => {\n      const a = +prev.match(/[-]{0,1}[\\d]*[.]{0,1}[\\d]+/g);\n      const b = +next.match(/[-]{0,1}[\\d]*[.]{0,1}[\\d]+/g);\n      if (a === b && a === 0) {\n        if (prev > next) {\n          return 1;\n        } else if (prev < next) {\n          return -1;\n        }\n        return 0;\n      }\n      return a - b;\n    });\n    let view = \'\';\n    view += `\n            <div class="page-filter__block filter-block" data-filter="${key}">\n                <div class="filter-block__header">\n                    <b class="filter-block__name">${key}</b>\n                </div>\n                <ul class="filter-block__list" data-list="${key}">\n                    ${attrs.reduce((acc, attr, index) => {\n      acc += `\n                            <li class="filter-block__item">\n                                <label class="checkbox">\n                                    <input class="checkbox__input" type="checkbox" data-checkbox="${attr}"/>\n                                    <span class="checkbox__view">\n                                                    <svg>\n                                                        <use xlink:href="img/svg/sprite.svg#yes-fit"></use>\n                                                    </svg>\n                                                </span>\n                                    <span class="checkbox__title">${attr}</span>\n                                </label>\n                            </li>`;\n      return acc;\n    }, \'\')}\n                    ${attrs.length > 5 ? \'<li class="filter-block__item filter-block__item_more"><button type="button" class="filter-block__more" data-filter-more>Еще</button></li>\' : \'\'}\n                </ul>\n            </div>\n        `;\n    this.$node.insertAdjacentHTML(\'beforeend\', view);\n  }\n  renderSelect({\n    key,\n    attrs\n  }) {\n    const view = `\n            <div class="page-filter__block filter-block">\n                <div class="filter-block__header">\n                    <b class="filter-block__name">${key}</b>\n                </div>\n                <div class="select select_multi-input" data-filter="${key}" data-select="${key}">\n                    <div class="select__header">\n                        <input type="text" class="select__field" placeholder="Введите наименование" data-input/>\n                        <span class="select__arrow" data-select-arrow></span>\n                    </div>\n                    <ul class="select__added-list" data-select-list>\n\n                    </ul>\n                    <ul class="select__body" data-select-body>\n\n                    </ul>\n                </div>\n            </div>\n        `;\n    this.$node.insertAdjacentHTML(\'beforeend\', view);\n    const multiSelect = new _core_components_selectsinputs_multiselect_input_component_js__WEBPACK_IMPORTED_MODULE_0__["default"]({\n      type: key,\n      query: `[data-select=\'${key}\']`,\n      optionList: attrs.sort().map(item => {\n        return {\n          dataset: key,\n          value: item\n        };\n      }),\n      addObserver: data => {\n        this.addFilterItem(data);\n        this.renderFilterList();\n      },\n      deleteObserver: data => {\n        this.removeFilterItem(data);\n        this.renderFilterList();\n      }\n    });\n    multiSelect.init();\n    multiSelect.render();\n    this.selectsList.push(multiSelect);\n  }\n  showPreloader() {\n    this.$node.querySelector(\'.page-filter__preloader\').classList.add(\'page-filter__preloader_active\');\n  }\n  removePreloader() {\n    this.$node.querySelector(\'.page-filter__preloader\').classList.remove(\'page-filter__preloader_active\');\n  }\n}\n/* harmony default export */ __webpack_exports__["default"] = (FilterModule);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL21vZHVsZXMvZmlsdGVyLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2FwcC9tb2R1bGVzL2ZpbHRlci5tb2R1bGUuanM/NTMzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTXVsdGlTZWxlY3RDb21wb25lbnQgZnJvbSAnLi4vLi4vY29yZS9jb21wb25lbnRzL3NlbGVjdHNpbnB1dHMvbXVsdGlzZWxlY3QuaW5wdXQuY29tcG9uZW50LmpzJ1xyXG5pbXBvcnQgeyBkZWJvdW5jZSwgc2FuaXRhbGl6ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgeyBodG1sIH0gZnJvbSAnY29kZS10YWcnXHJcblxyXG5cclxuY2xhc3MgRmlsdGVyTW9kdWxlIHtcclxuICAgIGNvbnN0cnVjdG9yKHJvb3QsIHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy4kbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdClcclxuICAgICAgICB0aGlzLiRmaWx0ZXJzTGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnkpXHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbFxyXG4gICAgICAgIHRoaXMuJGZpZWxkVGl0bGUgPSBudWxsXHJcbiAgICAgICAgdGhpcy5jdXJyZW50RmlsdGVycyA9IFtdXHJcbiAgICAgICAgdGhpcy5zZWxlY3RzTGlzdCA9IFtdXHJcbiAgICB9XHJcblxyXG4gICAgaW5pdCh7IGRhdGEsIGNoYW5nZVN0YXRlLCBvblJlbmRlckZpbHRlciB9KSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSA9IGNoYW5nZVN0YXRlXHJcbiAgICAgICAgdGhpcy5vblJlbmRlckZpbHRlciA9IG9uUmVuZGVyRmlsdGVyXHJcbiAgICAgICAgdGhpcy5yZW5kZXJGaWx0ZXJzKGRhdGEpXHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhbFN0YXRlKCkge1xyXG4gICAgICAgIHRoaXMucGFyc2VDaGVja2JveGVzKClcclxuICAgICAgICB0aGlzLnBhcnNlU2VsZWN0cygpXHJcbiAgICAgICAgdGhpcy5wYXJzZUlucHV0VGl0bGUoKVxyXG4gICAgICAgIHRoaXMucmVuZGVyRmlsdGVyTGlzdCh0cnVlKVxyXG4gICAgfVxyXG5cclxuICAgIHBhcnNlSW5wdXRUaXRsZSgpIHtcclxuICAgICAgICB0aGlzLiRmaWVsZFRpdGxlLnZhbHVlID0gdGhpcy5jdXJyZW50RmlsdGVycy5maW5kKGZpbHRlciA9PiBmaWx0ZXIudHlwZSA9PT0gJ25hbWUnKT8udmFsdWUgfHwgJydcclxuICAgIH1cclxuXHJcbiAgICBzZWFyY2hIYW5kbGVyKGUpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGaWx0ZXJzID0gdGhpcy5jdXJyZW50RmlsdGVycy5maWx0ZXIoZmlsdGVyID0+IGZpbHRlci50eXBlICE9PSAnbmFtZScpXHJcbiAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlLnRyaW0oKSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEZpbHRlckl0ZW0oe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ25hbWUnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNhbml0YWxpemUoZS50YXJnZXQudmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6ICfQn9C+0LjRgdC6INC/0L4g0L3QsNC40LzQtdC90L7QstCw0L3QuNGOJ1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlckZpbHRlckxpc3QoKVxyXG4gICAgfVxyXG5cclxuICAgIHBhcnNlQ2hlY2tib3hlcygpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGaWx0ZXJzLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGxldCAkY2hlY2tib3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1maWx0ZXI9XCIke2l0ZW0udHlwZX1cIl0gW2RhdGEtY2hlY2tib3g9XCIke2l0ZW0udmFsdWV9XCJdYClcclxuICAgICAgICAgICAgaWYgKCRjaGVja2JveCkge1xyXG4gICAgICAgICAgICAgICAgJGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHBhcnNlU2VsZWN0cygpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGaWx0ZXJzLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdCA9IHRoaXMuc2VsZWN0c0xpc3QuZmluZChzZWxlY3QgPT4gaXRlbS50eXBlID09PSBzZWxlY3QudHlwZSlcclxuICAgICAgICAgICAgaWYgKHNlbGVjdCAmJiBzZWxlY3QuaGFzSXRlbShpdGVtLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0LnNlbGVjdEl0ZW0oaXRlbS52YWx1ZSwgZmFsc2UpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZXJDbGlja01vcmUodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRhcmdldC5kYXRhc2V0LmZpbHRlck1vcmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zdCAkcGFyZW50TGlzdCA9IHRhcmdldC5jbG9zZXN0KCcuZmlsdGVyLWJsb2NrX19saXN0JylcclxuICAgICAgICAgICAgJHBhcmVudExpc3QuY2xhc3NMaXN0LnRvZ2dsZSgnZmlsdGVyLWJsb2NrX19saXN0X2Z1bGwnKVxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0LnRleHRDb250ZW50LnRyaW0oKSA9PT0gJ9CV0YnQtScpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC50ZXh0Q29udGVudCA9ICfQodCy0LXRgNC90YPRgtGMJ1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2ZpbHRlci1ibG9ja19fbW9yZV9oaWRlJylcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdmaWx0ZXItYmxvY2tfX21vcmVfaGlkZScpXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudGV4dENvbnRlbnQgPSAn0JXRidC1J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZXJDaGVja2JveENoYW5nZSh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gdGFyZ2V0LmNsb3Nlc3QoJy5maWx0ZXItYmxvY2tfX2xpc3QnKS5kYXRhc2V0Lmxpc3RcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldC5kYXRhc2V0LmNoZWNrYm94XHJcbiAgICAgICAgaWYgKHRhcmdldC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRmlsdGVySXRlbSh7IHR5cGUsIHZhbHVlIH0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVGaWx0ZXJJdGVtKHsgdHlwZSwgdmFsdWUgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGaWx0ZXJMaXN0KClcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVyRmlsdGVyTGlzdENsaWNrKHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnW2RhdGEtZmlsdGVyLWNsb3NlXScpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0ICRwYXJlbnQgPSB0YXJnZXQuY2xvc2VzdCgnLmZpbHRlcnNfX2l0ZW0nKVxyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gJHBhcmVudC5xdWVyeVNlbGVjdG9yKCcuZmlsdGVyc19fa2V5JykuZGF0YXNldC5maWx0ZXJUeXBlXHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gJHBhcmVudC5xdWVyeVNlbGVjdG9yKCcuZmlsdGVyc19fdmFsdWUnKS5kYXRhc2V0LmZpbHRlclZhbHVlXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRmlsdGVySXRlbSh7XHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWx0ZXJMaXN0KClcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldC5jbG9zZXN0KCdbZGF0YS1maWx0ZXItcmVzZXRdJykpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RmlsdGVycy5mb3JFYWNoKGZpbHRlciA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZpbHRlckl0ZW0oZmlsdGVyKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckZpbHRlckxpc3QoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbml0SGFuZGxlcnMoKSB7XHJcbiAgICAgICAgdGhpcy4kZmllbGRUaXRsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWZpbHRlcj1cIm5hbWVcIl0nKVxyXG4gICAgICAgIHRoaXMuJG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoeyB0YXJnZXQgfSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJDbGlja01vcmUodGFyZ2V0KVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy4kbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcuY2hlY2tib3hfX2lucHV0JykuZm9yRWFjaChjaGVja2JveCA9PiB7XHJcbiAgICAgICAgICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICh7IHRhcmdldCB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJDaGVja2JveENoYW5nZSh0YXJnZXQpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLiRmaWx0ZXJzTGlzdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICh7IHRhcmdldCB9KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlckZpbHRlckxpc3RDbGljayh0YXJnZXQpXHJcbiAgICAgICAgfSlcclxuICAgICAgICBjb25zdCBpbnB1dFdpdGhEZWJvdW5jZSA9IGRlYm91bmNlKHRoaXMuc2VhcmNoSGFuZGxlci5iaW5kKHRoaXMpLCA4MDApXHJcbiAgICAgICAgdGhpcy4kZmllbGRUaXRsZS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGlucHV0V2l0aERlYm91bmNlKGUpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBhZGRGaWx0ZXJJdGVtKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGaWx0ZXJzLnB1c2goZGF0YSlcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVGaWx0ZXJJdGVtKHsgdHlwZSwgdmFsdWUgfSkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZpbHRlcnMgPSB0aGlzLmN1cnJlbnRGaWx0ZXJzLmZpbHRlcihmaWx0ZXIgPT4gZmlsdGVyLnZhbHVlICE9PSB2YWx1ZSAmJiBmaWx0ZXIua2V5ICE9PSB0eXBlKVxyXG4gICAgICAgIGNvbnN0ICRjaGVja2JveCA9IHRoaXMuJG5vZGUucXVlcnlTZWxlY3RvcihgW2RhdGEtZmlsdGVyPScke3R5cGV9J10gW2RhdGEtY2hlY2tib3g9JyR7dmFsdWV9J11gKVxyXG4gICAgICAgIGlmICgkY2hlY2tib3gpICRjaGVja2JveC5jaGVja2VkID0gZmFsc2VcclxuICAgICAgICBjb25zdCBzZWxlY3QgPSB0aGlzLnNlbGVjdHNMaXN0LmZpbmQoc2VsZWN0ID0+IHNlbGVjdC50eXBlID09PSB0eXBlKVxyXG4gICAgICAgIGlmIChzZWxlY3QpIHNlbGVjdC5yZW1vdmVJdGVtKHZhbHVlLCBmYWxzZSlcclxuICAgICAgICB0aGlzLnBhcnNlSW5wdXRUaXRsZSgpXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyRmlsdGVyTGlzdChpbml0aWFsU3RhdGUgPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuJGZpbHRlcnNMaXN0LmlubmVySFRNTCA9ICcnXHJcbiAgICAgICAgbGV0IHZpZXcgPSAnJ1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZpbHRlcnMuZm9yRWFjaChmaWx0ZXIgPT4ge1xyXG4gICAgICAgICAgICB2aWV3ICs9IGBcclxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cImZpbHRlcnNfX2l0ZW1cIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZpbHRlcnNfX2tleVwiIGRhdGEtZmlsdGVyLXR5cGU9XCIke2ZpbHRlci50eXBlfVwiPiR7ZmlsdGVyLmxhYmVsIHx8IGZpbHRlci50eXBlfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZpbHRlcnNfX3ZhbHVlXCIgZGF0YS1maWx0ZXItdmFsdWU9XCIke2ZpbHRlci52YWx1ZX1cIj4ke2ZpbHRlci52YWx1ZX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmaWx0ZXJzX19jbG9zZVwiIGRhdGEtZmlsdGVyLWNsb3NlPVwidHJ1ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj1cImltZy9zdmcvc3ByaXRlLnN2ZyNjbG9zZVwiPjwvdXNlPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9saT5gXHJcbiAgICAgICAgfSlcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RmlsdGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmlldyArPSAnPGxpIGNsYXNzPVwiZmlsdGVyX19pdGVtLXJlc2V0XCIgZGF0YS1maWx0ZXItcmVzZXQ9XCJ0cnVlXCI+0KHQsdGA0L7RgdC40YLRjCDQstGB0LUg0YTQuNC70YzRgtGA0Ys8L2xpPidcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpbml0aWFsU3RhdGUpIHRoaXMuY2hhbmdlU3RhdGUodGhpcy5jdXJyZW50RmlsdGVycylcclxuICAgICAgICB0aGlzLiRmaWx0ZXJzTGlzdC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIHZpZXcpXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGFsbG93ZWRLZXlzKCkge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBbXVxyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWZpbHRlcl0nKS5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhc2V0LmZpbHRlcikga2V5cy5wdXNoKG5vZGUuZGF0YXNldC5maWx0ZXIpXHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4ga2V5c1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlckZpbHRlcnMoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGFcclxuICAgICAgICB0aGlzLnJlbmRlckhlYWRlcigpXHJcbiAgICAgICAgaWYgKGRhdGEubWFrZXIubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJMaXN0KHtcclxuICAgICAgICAgICAgICAgIGtleTogJ9Cc0LDRgNC60LAnLFxyXG4gICAgICAgICAgICAgICAgYXR0cnM6IGRhdGEubWFrZXJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGlzdHMgPSBbXVxyXG4gICAgICAgIGNvbnN0IHNlbGVjdHMgPSBbXVxyXG4gICAgICAgIGZvciAoIGNvbnN0IGtleSBpbiBkYXRhLmF0dHJpYnV0ZXMgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICBhdHRyczogZGF0YS5hdHRyaWJ1dGVzW2tleV0ubGlzdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhLmF0dHJpYnV0ZXNba2V5XS5saXN0Lmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmF0dHJpYnV0ZXNba2V5XS50eXBlID09PSAnbGlzdCcpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RzLnB1c2goZmlsdGVySXRlbSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdHMucHVzaChmaWx0ZXJJdGVtKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpc3RzLmZvckVhY2gobGlzdCA9PiB0aGlzLnJlbmRlckxpc3QobGlzdCkpXHJcbiAgICAgICAgc2VsZWN0cy5mb3JFYWNoKHNlbGVjdCA9PiB0aGlzLnJlbmRlclNlbGVjdChzZWxlY3QpKVxyXG4gICAgICAgIHRoaXMuaW5pdEhhbmRsZXJzKClcclxuICAgICAgICB0aGlzLm9uUmVuZGVyRmlsdGVyKClcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJIZWFkZXIoKSB7XHJcbiAgICAgICAgbGV0IHZpZXcgPSAnJ1xyXG4gICAgICAgIHZpZXcgKz0gYFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1maWx0ZXJfX2Jsb2NrIGZpbHRlci1ibG9ja1wiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpbHRlci1ibG9ja19faGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGIgY2xhc3M9XCJmaWx0ZXItYmxvY2tfX25hbWVcIj7Qn9C+0LjRgdC6INC/0L4g0L3QsNC40LzQtdC90L7QstCw0L3QuNGOPC9iPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsdGVyLWJsb2NrX19ib2R5XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImVudHJ5LWlucHV0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJuYW1lXCIgcGxhY2Vob2xkZXI9XCLQktCy0LXQtNC40YLQtSDRgtC10LrRgdGCXCIgY2xhc3M9XCJlbnRyeS1pbnB1dF9fZmllbGRcIiBkYXRhLWZpbHRlcj1cIm5hbWVcIi8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgYFxyXG4gICAgICAgIHRoaXMuJG5vZGUuaW5uZXJIVE1MICs9IHZpZXdcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmVuZGVyTGlzdCh7IGtleSwgYXR0cnMgfSkge1xyXG4gICAgICAgIGF0dHJzID0gYXR0cnMuc29ydCgocHJldiwgbmV4dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhID0gK3ByZXYubWF0Y2goL1stXXswLDF9W1xcZF0qWy5dezAsMX1bXFxkXSsvZylcclxuICAgICAgICAgICAgY29uc3QgYiA9ICtuZXh0Lm1hdGNoKC9bLV17MCwxfVtcXGRdKlsuXXswLDF9W1xcZF0rL2cpXHJcbiAgICAgICAgICAgIGlmIChhID09PSBiICYmIGEgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2ID4gbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXYgPCBuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhIC0gYlxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgbGV0IHZpZXcgPSAnJ1xyXG4gICAgICAgIHZpZXcgKz0gYFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1maWx0ZXJfX2Jsb2NrIGZpbHRlci1ibG9ja1wiIGRhdGEtZmlsdGVyPVwiJHtrZXl9XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsdGVyLWJsb2NrX19oZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8YiBjbGFzcz1cImZpbHRlci1ibG9ja19fbmFtZVwiPiR7a2V5fTwvYj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwiZmlsdGVyLWJsb2NrX19saXN0XCIgZGF0YS1saXN0PVwiJHtrZXl9XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgJHthdHRycy5yZWR1Y2UoKGFjYywgYXR0ciwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjICs9IGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cImZpbHRlci1ibG9ja19faXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImNoZWNrYm94XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImNoZWNrYm94X19pbnB1dFwiIHR5cGU9XCJjaGVja2JveFwiIGRhdGEtY2hlY2tib3g9XCIke2F0dHJ9XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNoZWNrYm94X192aWV3XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj1cImltZy9zdmcvc3ByaXRlLnN2ZyN5ZXMtZml0XCI+PC91c2U+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNoZWNrYm94X190aXRsZVwiPiR7YXR0cn08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+YFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY1xyXG4gICAgICAgICAgICAgICAgICAgIH0sICcnKX1cclxuICAgICAgICAgICAgICAgICAgICAke2F0dHJzLmxlbmd0aCA+IDUgPyAnPGxpIGNsYXNzPVwiZmlsdGVyLWJsb2NrX19pdGVtIGZpbHRlci1ibG9ja19faXRlbV9tb3JlXCI+PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJmaWx0ZXItYmxvY2tfX21vcmVcIiBkYXRhLWZpbHRlci1tb3JlPtCV0YnQtTwvYnV0dG9uPjwvbGk+JyA6ICcnfVxyXG4gICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgYFxyXG4gICAgICAgIHRoaXMuJG5vZGUuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCB2aWV3KVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlclNlbGVjdCh7IGtleSwgYXR0cnMgfSkge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBgXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWZpbHRlcl9fYmxvY2sgZmlsdGVyLWJsb2NrXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsdGVyLWJsb2NrX19oZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8YiBjbGFzcz1cImZpbHRlci1ibG9ja19fbmFtZVwiPiR7a2V5fTwvYj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNlbGVjdCBzZWxlY3RfbXVsdGktaW5wdXRcIiBkYXRhLWZpbHRlcj1cIiR7a2V5fVwiIGRhdGEtc2VsZWN0PVwiJHtrZXl9XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNlbGVjdF9faGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwic2VsZWN0X19maWVsZFwiIHBsYWNlaG9sZGVyPVwi0JLQstC10LTQuNGC0LUg0L3QsNC40LzQtdC90L7QstCw0L3QuNC1XCIgZGF0YS1pbnB1dC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2VsZWN0X19hcnJvd1wiIGRhdGEtc2VsZWN0LWFycm93Pjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJzZWxlY3RfX2FkZGVkLWxpc3RcIiBkYXRhLXNlbGVjdC1saXN0PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cInNlbGVjdF9fYm9keVwiIGRhdGEtc2VsZWN0LWJvZHk+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgYFxyXG5cclxuICAgICAgICB0aGlzLiRub2RlLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgdmlldylcclxuXHJcbiAgICAgICAgY29uc3QgbXVsdGlTZWxlY3QgPSBuZXcgTXVsdGlTZWxlY3RDb21wb25lbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBrZXksXHJcbiAgICAgICAgICAgIHF1ZXJ5OiBgW2RhdGEtc2VsZWN0PScke2tleX0nXWAsXHJcbiAgICAgICAgICAgIG9wdGlvbkxpc3Q6IGF0dHJzLnNvcnQoKS5tYXAoaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXQ6IGtleSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgYWRkT2JzZXJ2ZXI6IChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZpbHRlckl0ZW0oZGF0YSlcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmlsdGVyTGlzdCgpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlbGV0ZU9ic2VydmVyOiAoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGaWx0ZXJJdGVtKGRhdGEpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbHRlckxpc3QoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICBtdWx0aVNlbGVjdC5pbml0KClcclxuICAgICAgICBtdWx0aVNlbGVjdC5yZW5kZXIoKVxyXG4gICAgICAgIHRoaXMuc2VsZWN0c0xpc3QucHVzaChtdWx0aVNlbGVjdClcclxuICAgIH1cclxuXHJcbiAgICBzaG93UHJlbG9hZGVyKCkge1xyXG4gICAgICAgIHRoaXMuJG5vZGUucXVlcnlTZWxlY3RvcignLnBhZ2UtZmlsdGVyX19wcmVsb2FkZXInKS5jbGFzc0xpc3QuYWRkKCdwYWdlLWZpbHRlcl9fcHJlbG9hZGVyX2FjdGl2ZScpXHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlUHJlbG9hZGVyKCkge1xyXG4gICAgICAgIHRoaXMuJG5vZGUucXVlcnlTZWxlY3RvcignLnBhZ2UtZmlsdGVyX19wcmVsb2FkZXInKS5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlLWZpbHRlcl9fcHJlbG9hZGVyX2FjdGl2ZScpXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZpbHRlck1vZHVsZVxyXG5cclxuXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/app/modules/filter.module.js\n')},"./source/js/app/modules/location.module.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_modules_module_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/modules/module.core.js */ \"./source/js/core/modules/module.core.js\");\n\nclass LocationModule extends _core_modules_module_core_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(config) {\n    super(config);\n    this.state = true;\n    this.locationList = null;\n    this.onChooseCallback = () => {};\n    this.$cityDrop = document.querySelector('.page-address__drop');\n    this.$addressCurrent = document.querySelector('.page-address__current');\n    this.$cityCurrent = document.querySelector('.page-address__current-city');\n    this.$pick = document.querySelector('.pick-address');\n    this.$searchInput = document.querySelector('.pick-address__input');\n    this.$pickList = document.querySelector('.pick-address__list');\n    this.$buttonPlace = document.querySelector('.page-address__buttons');\n    this.defaultValue = 'г. Луганск';\n  }\n  async init() {\n    try {\n      this.initAuthData();\n      this.locationList = await this.apiService.useRequest(this.router.locationsLink);\n      this.registerInitHandlers();\n    } catch (e) {\n      console.log(e.message);\n    }\n  }\n  registerInitHandlers() {\n    this.$addressCurrent.addEventListener('click', () => {\n      this.showLocationChoose();\n      document.addEventListener('mousedown', e => {\n        if (this.state && !e.target.closest('.page-address')) {\n          this.removeDrop();\n          this.hideLocationList();\n        }\n      });\n    });\n  }\n  initAuthData() {\n    let name = this.auth.isAuth ? this.auth.userData?.location?.name : localStorage.getItem('location');\n    this.renderCityLabel(name || this.defaultValue);\n    this.renderCurrentCity(name || this.defaultValue);\n  }\n  async setUserLocation(text, id) {\n    const idLocation = id?.trim() || null;\n    if (this.auth.isAuth) {\n      try {\n        await this.apiService.useRequest(this.router.locationsLink, {\n          method: 'POST',\n          headers: {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            id: idLocation\n          })\n        });\n      } catch (e) {\n        console.log(e.message);\n      }\n    } else {\n      if (text) {\n        localStorage.setItem('location', text);\n      } else {\n        localStorage.removeItem('location');\n      }\n    }\n  }\n  renderCityLabel(text) {\n    this.$addressCurrent.textContent = text;\n  }\n  renderCurrentCity(text) {\n    this.$cityCurrent.innerHTML = text;\n  }\n  showSelectionButtons() {\n    this.$buttonPlace.innerHTML = '<button class=\\'page-address__yes button button_mini button_backwards-accent button_fat\\'>да</button><button class=\\'page-address__no button button_mini  button_backwards-negative button_fat\\'>нет</button>';\n    this.$cityButtonYes = document.querySelector('.page-address__yes');\n    this.$cityButtonNo = document.querySelector('.page-address__no');\n  }\n  showLocationChoose() {\n    this.showDrop();\n    this.$buttonPlace.innerHTML = '<button class=\\'page-address__change button button_mini button_backwards-neutral button_fat\\'>Изменить</button>';\n    document.querySelector('.page-address__change').addEventListener('click', e => {\n      this.$pick.classList.add('pick-address_active');\n      this.searchLocation();\n    });\n  }\n  showLocationList() {\n    this.$pick.classList.add('pick-address_active');\n  }\n  hideLocationList() {\n    this.$pick.classList.remove('pick-address_active');\n  }\n  showDrop() {\n    this.state = true;\n    this.$cityDrop.classList.add('page-address__drop_active');\n  }\n  removeDrop() {\n    this.state = false;\n    this.$cityDrop.classList.remove('page-address__drop_active');\n  }\n  searchLocation() {\n    this.$searchInput.value = '';\n    this.$pickList.innerHTML = '';\n    this.$searchInput.addEventListener('input', () => {\n      this.eventInput();\n    });\n  }\n  eventInput() {\n    let text = this.$searchInput.value;\n    if (text.length === 0) {\n      this.$pickList.innerHTML = '';\n      return;\n    }\n    const foundItems = [];\n    this.locationList.forEach(item => {\n      let region = item.name;\n      if (foundItems.length < 5) {\n        if (region.indexOf(text) >= 0) {\n          const search = text;\n          const replaceWith = `<b>${text}</b>`;\n          const selectedText = region.split(search).join(replaceWith);\n          foundItems.push({\n            text: selectedText,\n            id: item._id\n          });\n        }\n      }\n    });\n    this.$pickList.innerHTML = '';\n    if (!foundItems.length) {\n      this.$pickList.innerHTML += `<li class=\"pick-address__item pick-address__item_notfound\">Ничего не найдено</li>`;\n    } else {\n      foundItems.forEach(item => {\n        this.$pickList.innerHTML += `<li class=\"pick-address__item\" data-id=\"${item.id}\">${item.text}</li>`;\n      });\n      this.registerHandlersForPickItems();\n    }\n  }\n  registerHandlersForPickItems() {\n    this.$pickList.querySelectorAll('.pick-address__item').forEach(element => {\n      element.addEventListener('click', () => {\n        this.onPick(element.textContent, element.dataset.id);\n      });\n    });\n  }\n  onPick(text, id) {\n    this.$pick.classList.remove('pick-address_active');\n    this.renderCurrentCity(`${text} ?`);\n    this.$pickList.innerHTML = '';\n    this.showSelectionButtons();\n    this.$cityButtonNo.addEventListener('click', e => {\n      this.renderCurrentCity(this.defaultValue);\n      this.renderCityLabel(this.defaultValue);\n      this.showLocationList();\n      this.setUserLocation(null, null);\n      this.onChooseCallback(this.defaultValue);\n    });\n    this.$cityButtonYes.addEventListener('click', e => {\n      const value = this.$cityCurrent.textContent.replace('?', '').trim();\n      this.removeDrop();\n      this.renderCityLabel(value);\n      this.state = false;\n      this.setUserLocation(text, id);\n      this.onChooseCallback(value, id);\n    });\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (LocationModule);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL21vZHVsZXMvbG9jYXRpb24ubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QtZ3VscC8uL3NvdXJjZS9qcy9hcHAvbW9kdWxlcy9sb2NhdGlvbi5tb2R1bGUuanM/ZmE4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTW9kdWxlQ29yZSBmcm9tICcuLi8uLi9jb3JlL21vZHVsZXMvbW9kdWxlLmNvcmUuanMnXHJcblxyXG5jbGFzcyBMb2NhdGlvbk1vZHVsZSBleHRlbmRzIE1vZHVsZUNvcmUge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgc3VwZXIoY29uZmlnKVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB0cnVlXHJcbiAgICAgICAgdGhpcy5sb2NhdGlvbkxpc3QgPSBudWxsXHJcbiAgICAgICAgdGhpcy5vbkNob29zZUNhbGxiYWNrID0gKCkgPT4ge31cclxuICAgICAgICB0aGlzLiRjaXR5RHJvcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLWFkZHJlc3NfX2Ryb3AnKVxyXG4gICAgICAgIHRoaXMuJGFkZHJlc3NDdXJyZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2UtYWRkcmVzc19fY3VycmVudCcpXHJcbiAgICAgICAgdGhpcy4kY2l0eUN1cnJlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1hZGRyZXNzX19jdXJyZW50LWNpdHknKVxyXG4gICAgICAgIHRoaXMuJHBpY2sgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGljay1hZGRyZXNzJylcclxuICAgICAgICB0aGlzLiRzZWFyY2hJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5waWNrLWFkZHJlc3NfX2lucHV0JylcclxuICAgICAgICB0aGlzLiRwaWNrTGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5waWNrLWFkZHJlc3NfX2xpc3QnKVxyXG4gICAgICAgIHRoaXMuJGJ1dHRvblBsYWNlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2UtYWRkcmVzc19fYnV0dG9ucycpXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSAn0LMuINCb0YPQs9Cw0L3RgdC6J1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGluaXQoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5pbml0QXV0aERhdGEoKVxyXG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uTGlzdCA9IGF3YWl0IHRoaXMuYXBpU2VydmljZS51c2VSZXF1ZXN0KHRoaXMucm91dGVyLmxvY2F0aW9uc0xpbmspXHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJJbml0SGFuZGxlcnMoKVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZS5tZXNzYWdlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWdpc3RlckluaXRIYW5kbGVycygpIHtcclxuICAgICAgICB0aGlzLiRhZGRyZXNzQ3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zaG93TG9jYXRpb25DaG9vc2UoKVxyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICYmICFlLnRhcmdldC5jbG9zZXN0KCcucGFnZS1hZGRyZXNzJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURyb3AoKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZUxvY2F0aW9uTGlzdCgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBpbml0QXV0aERhdGEoKSB7XHJcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLmF1dGguaXNBdXRoID9cclxuICAgICAgICAgICAgdGhpcy5hdXRoLnVzZXJEYXRhPy5sb2NhdGlvbj8ubmFtZSA6XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdsb2NhdGlvbicpXHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyQ2l0eUxhYmVsKG5hbWUgfHwgdGhpcy5kZWZhdWx0VmFsdWUpXHJcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJyZW50Q2l0eShuYW1lIHx8IHRoaXMuZGVmYXVsdFZhbHVlKVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHNldFVzZXJMb2NhdGlvbih0ZXh0LCBpZCkge1xyXG4gICAgICAgIGNvbnN0IGlkTG9jYXRpb24gPSBpZD8udHJpbSgpIHx8IG51bGxcclxuICAgICAgICBpZiAodGhpcy5hdXRoLmlzQXV0aCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlTZXJ2aWNlLnVzZVJlcXVlc3QodGhpcy5yb3V0ZXIubG9jYXRpb25zTGluaywge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRMb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLm1lc3NhZ2UpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGV4dCkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2xvY2F0aW9uJywgdGV4dClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdsb2NhdGlvbicpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyQ2l0eUxhYmVsKHRleHQpIHtcclxuICAgICAgICB0aGlzLiRhZGRyZXNzQ3VycmVudC50ZXh0Q29udGVudCA9IHRleHRcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJDdXJyZW50Q2l0eSh0ZXh0KSB7XHJcbiAgICAgICAgdGhpcy4kY2l0eUN1cnJlbnQuaW5uZXJIVE1MID0gdGV4dFxyXG4gICAgfVxyXG5cclxuICAgIHNob3dTZWxlY3Rpb25CdXR0b25zKCkge1xyXG4gICAgICAgIHRoaXMuJGJ1dHRvblBsYWNlLmlubmVySFRNTCA9ICc8YnV0dG9uIGNsYXNzPVxcJ3BhZ2UtYWRkcmVzc19feWVzIGJ1dHRvbiBidXR0b25fbWluaSBidXR0b25fYmFja3dhcmRzLWFjY2VudCBidXR0b25fZmF0XFwnPtC00LA8L2J1dHRvbj48YnV0dG9uIGNsYXNzPVxcJ3BhZ2UtYWRkcmVzc19fbm8gYnV0dG9uIGJ1dHRvbl9taW5pICBidXR0b25fYmFja3dhcmRzLW5lZ2F0aXZlIGJ1dHRvbl9mYXRcXCc+0L3QtdGCPC9idXR0b24+J1xyXG4gICAgICAgIHRoaXMuJGNpdHlCdXR0b25ZZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1hZGRyZXNzX195ZXMnKVxyXG4gICAgICAgIHRoaXMuJGNpdHlCdXR0b25ObyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLWFkZHJlc3NfX25vJylcclxuICAgIH1cclxuXHJcbiAgICBzaG93TG9jYXRpb25DaG9vc2UoKSB7XHJcbiAgICAgICAgdGhpcy5zaG93RHJvcCgpXHJcbiAgICAgICAgdGhpcy4kYnV0dG9uUGxhY2UuaW5uZXJIVE1MID0gJzxidXR0b24gY2xhc3M9XFwncGFnZS1hZGRyZXNzX19jaGFuZ2UgYnV0dG9uIGJ1dHRvbl9taW5pIGJ1dHRvbl9iYWNrd2FyZHMtbmV1dHJhbCBidXR0b25fZmF0XFwnPtCY0LfQvNC10L3QuNGC0Yw8L2J1dHRvbj4nXHJcblxyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLWFkZHJlc3NfX2NoYW5nZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuJHBpY2suY2xhc3NMaXN0LmFkZCgncGljay1hZGRyZXNzX2FjdGl2ZScpXHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoTG9jYXRpb24oKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgc2hvd0xvY2F0aW9uTGlzdCgpIHtcclxuICAgICAgICB0aGlzLiRwaWNrLmNsYXNzTGlzdC5hZGQoJ3BpY2stYWRkcmVzc19hY3RpdmUnKVxyXG4gICAgfVxyXG5cclxuICAgIGhpZGVMb2NhdGlvbkxpc3QoKSB7XHJcbiAgICAgICAgdGhpcy4kcGljay5jbGFzc0xpc3QucmVtb3ZlKCdwaWNrLWFkZHJlc3NfYWN0aXZlJylcclxuICAgIH1cclxuXHJcbiAgICBzaG93RHJvcCgpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gdHJ1ZVxyXG4gICAgICAgIHRoaXMuJGNpdHlEcm9wLmNsYXNzTGlzdC5hZGQoJ3BhZ2UtYWRkcmVzc19fZHJvcF9hY3RpdmUnKVxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZURyb3AoKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy4kY2l0eURyb3AuY2xhc3NMaXN0LnJlbW92ZSgncGFnZS1hZGRyZXNzX19kcm9wX2FjdGl2ZScpXHJcbiAgICB9XHJcblxyXG4gICAgc2VhcmNoTG9jYXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy4kc2VhcmNoSW5wdXQudmFsdWUgPSAnJ1xyXG4gICAgICAgIHRoaXMuJHBpY2tMaXN0LmlubmVySFRNTCA9ICcnXHJcbiAgICAgICAgdGhpcy4kc2VhcmNoSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRJbnB1dCgpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBldmVudElucHV0KCkge1xyXG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy4kc2VhcmNoSW5wdXQudmFsdWVcclxuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy4kcGlja0xpc3QuaW5uZXJIVE1MID0gJydcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZvdW5kSXRlbXMgPSBbXVxyXG4gICAgICAgIHRoaXMubG9jYXRpb25MaXN0LmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZWdpb24gPSBpdGVtLm5hbWVcclxuICAgICAgICAgICAgaWYgKGZvdW5kSXRlbXMubGVuZ3RoIDwgNSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lvbi5pbmRleE9mKHRleHQpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2ggPSB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZVdpdGggPSBgPGI+JHt0ZXh0fTwvYj5gXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHJlZ2lvbi5zcGxpdChzZWFyY2gpLmpvaW4ocmVwbGFjZVdpdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogc2VsZWN0ZWRUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5faWRcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLiRwaWNrTGlzdC5pbm5lckhUTUwgPSAnJ1xyXG4gICAgICAgIGlmICghZm91bmRJdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy4kcGlja0xpc3QuaW5uZXJIVE1MICs9IGA8bGkgY2xhc3M9XCJwaWNrLWFkZHJlc3NfX2l0ZW0gcGljay1hZGRyZXNzX19pdGVtX25vdGZvdW5kXCI+0J3QuNGH0LXQs9C+INC90LUg0L3QsNC50LTQtdC90L48L2xpPmBcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3VuZEl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRwaWNrTGlzdC5pbm5lckhUTUwgKz0gYDxsaSBjbGFzcz1cInBpY2stYWRkcmVzc19faXRlbVwiIGRhdGEtaWQ9XCIke2l0ZW0uaWR9XCI+JHtpdGVtLnRleHR9PC9saT5gXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVyc0ZvclBpY2tJdGVtcygpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVySGFuZGxlcnNGb3JQaWNrSXRlbXMoKSB7XHJcbiAgICAgICAgdGhpcy4kcGlja0xpc3QucXVlcnlTZWxlY3RvckFsbCgnLnBpY2stYWRkcmVzc19faXRlbScpLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uUGljayhlbGVtZW50LnRleHRDb250ZW50LCBlbGVtZW50LmRhdGFzZXQuaWQpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBvblBpY2sodGV4dCwgaWQpIHtcclxuICAgICAgICB0aGlzLiRwaWNrLmNsYXNzTGlzdC5yZW1vdmUoJ3BpY2stYWRkcmVzc19hY3RpdmUnKVxyXG4gICAgICAgIHRoaXMucmVuZGVyQ3VycmVudENpdHkoYCR7dGV4dH0gP2ApXHJcbiAgICAgICAgdGhpcy4kcGlja0xpc3QuaW5uZXJIVE1MID0gJydcclxuXHJcbiAgICAgICAgdGhpcy5zaG93U2VsZWN0aW9uQnV0dG9ucygpXHJcblxyXG4gICAgICAgIHRoaXMuJGNpdHlCdXR0b25Oby5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckN1cnJlbnRDaXR5KHRoaXMuZGVmYXVsdFZhbHVlKVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNpdHlMYWJlbCh0aGlzLmRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgdGhpcy5zaG93TG9jYXRpb25MaXN0KClcclxuICAgICAgICAgICAgdGhpcy5zZXRVc2VyTG9jYXRpb24obnVsbCwgbnVsbClcclxuICAgICAgICAgICAgdGhpcy5vbkNob29zZUNhbGxiYWNrKHRoaXMuZGVmYXVsdFZhbHVlKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy4kY2l0eUJ1dHRvblllcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuJGNpdHlDdXJyZW50LnRleHRDb250ZW50LnJlcGxhY2UoJz8nLCAnJykudHJpbSgpXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRHJvcCgpXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2l0eUxhYmVsKHZhbHVlKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gZmFsc2VcclxuICAgICAgICAgICAgdGhpcy5zZXRVc2VyTG9jYXRpb24odGV4dCwgaWQpXHJcbiAgICAgICAgICAgIHRoaXMub25DaG9vc2VDYWxsYmFjayh2YWx1ZSwgaWQpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTG9jYXRpb25Nb2R1bGUiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/app/modules/location.module.js\n")},"./source/js/app/modules/login.modal.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_components_modals_modal_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/components/modals/modal.component.js */ \"./source/js/core/components/modals/modal.component.js\");\n/* harmony import */ var _core_components_validation_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/components/validation.component.js */ \"./source/js/core/components/validation.component.js\");\n/* harmony import */ var _core_components_button_component_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/components/button.component.js */ \"./source/js/core/components/button.component.js\");\n/* harmony import */ var _configs_login_modal_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../configs/login.modal.config.js */ \"./source/js/app/configs/login.modal.config.js\");\n/* harmony import */ var code_tag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! code-tag */ \"./node_modules/code-tag/dist/index.mjs\");\n\n\n\n\n\nclass ModalLogin extends _core_components_modals_modal_component_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(config) {\n    super(config);\n    this.router = config.router;\n    this.states = config.states;\n    this.containerSelector = config.container;\n    this.template = _configs_login_modal_config_js__WEBPACK_IMPORTED_MODULE_3__.template;\n    this.states = _configs_login_modal_config_js__WEBPACK_IMPORTED_MODULE_3__.states;\n    this.container = null;\n    this.currentState = null;\n    this.validateBool = true;\n  }\n  create() {\n    super.create();\n    this.$container = document.querySelector(this.containerSelector);\n    this.changeToEmail();\n    this.registerHandlers();\n  }\n  registerHandlers() {\n    this.$modal.addEventListener('click', e => {\n      if (e.target.tagName.toLowerCase() === 'a') return;\n      e.preventDefault();\n      if (e.target.hasAttribute('data-login-submit')) this.clickSubmit();\n      if (e.target.hasAttribute('data-switch-email')) this.changeToEmail();\n      if (e.target.hasAttribute('data-forget-pass')) this.forgetPassword();\n      if (e.target.hasAttribute('data-remember-pass')) this.changeToEmail();\n    });\n  }\n  clickSubmit() {\n    if (this.currentState !== 'forgetPass') {\n      this.validation();\n    } else {\n      this.validationRecovery();\n    }\n  }\n  renderState(state) {\n    for (const [key, value] of Object.entries(this.states)) {\n      if (value === state) this.currentState = key;\n    }\n    this.$container.innerHTML = state;\n    document.querySelector('.page-popup__button').focus();\n  }\n  changeToEmail() {\n    this.renderState(this.states.loginEmail);\n    this.submit = new _core_components_button_component_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]('[data-login-submit]');\n    this.$email_input = this.$modal.querySelector('[data-email]');\n    this.$errors = this.$modal.querySelector('[data-errors]');\n    this.$pass_input = this.$modal.querySelector('[data-pass]');\n  }\n  forgetPassword() {\n    this.renderState(this.states.forgetPass);\n    this.submit = new _core_components_button_component_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]('[data-login-submit]');\n    this.$email_input = this.$modal.querySelector('[data-email]');\n    this.$errors = this.$modal.querySelector('[data-errors]');\n  }\n  stateMailWasSent() {\n    this.renderState(this.states.sendRecoveryMail);\n    document.querySelector('[data-info] b').innerHTML = this.$email_input.value;\n  }\n  async validation() {\n    this.validateBool = true;\n    this.clearErrors();\n    if (!_core_components_validation_component_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isValidEmail(this.$email_input.value)) {\n      this.renderError('Некорректный ввод почты. Повторите попытку.');\n      this.validateBool = false;\n    }\n    if (!_core_components_validation_component_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isValidPass(this.$pass_input.value)) {\n      this.validateBool = false;\n      this.renderError('Некорректный ввод пароля. Пароль должен иметь как минимум 6 символов.');\n    }\n    if (this.validateBool) {\n      const user = {\n        email: this.$email_input.value,\n        password: this.$pass_input.value\n      };\n      this.submit.setPreloaderState('white');\n      const res = await fetch(this.router.loginLink, {\n        method: 'POST',\n        headers: {\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(user)\n      });\n      const data = await res.json();\n      if (data.message) {\n        this.submit.setTextState();\n        this.renderError(data.message);\n      } else {\n        this.router.redirectMain();\n      }\n    }\n  }\n  clearErrors() {\n    this.$errors.innerHTML = '';\n  }\n  renderError(text) {\n    this.$errors.innerHTML += `\n            <div class=\"page-popup__error message message_error\">\n                ${text}\n            </div>`;\n  }\n  async validationRecovery() {\n    this.clearErrors();\n    if (!_core_components_validation_component_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isValidEmail(this.$email_input.value)) {\n      return this.renderError('Некорректный ввод почты. Повторите попытку.');\n    }\n    this.submit.setPreloaderState('white');\n    const email = this.$email_input.value;\n    let status = null;\n    const res = await fetch(this.router.passRecoveryLink, {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        email\n      })\n    });\n    status = res.status;\n    const data = await res.json();\n    this.submit.setTextState();\n    if (status === 400) {\n      this.renderError(data.message);\n    } else {\n      this.stateMailWasSent();\n    }\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (ModalLogin);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL21vZHVsZXMvbG9naW4ubW9kYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvYXBwL21vZHVsZXMvbG9naW4ubW9kYWwuanM/OTE0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTW9kYWxDb21wb25lbnQgZnJvbSAnLi4vLi4vY29yZS9jb21wb25lbnRzL21vZGFscy9tb2RhbC5jb21wb25lbnQuanMnXHJcbmltcG9ydCBWYWxpZGF0aW9uQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvcmUvY29tcG9uZW50cy92YWxpZGF0aW9uLmNvbXBvbmVudC5qcydcclxuaW1wb3J0IEJ1dHRvbkNvbXBvbmVudCBmcm9tICcuLi8uLi9jb3JlL2NvbXBvbmVudHMvYnV0dG9uLmNvbXBvbmVudC5qcydcclxuaW1wb3J0IHsgdGVtcGxhdGUsIHN0YXRlcyB9IGZyb20gJy4uL2NvbmZpZ3MvbG9naW4ubW9kYWwuY29uZmlnLmpzJ1xyXG5pbXBvcnQgeyBodG1sIH0gZnJvbSAnY29kZS10YWcnXHJcblxyXG5jbGFzcyBNb2RhbExvZ2luIGV4dGVuZHMgTW9kYWxDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgc3VwZXIoY29uZmlnKVxyXG4gICAgICAgIHRoaXMucm91dGVyID0gY29uZmlnLnJvdXRlclxyXG4gICAgICAgIHRoaXMuc3RhdGVzID0gY29uZmlnLnN0YXRlc1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyU2VsZWN0b3IgPSBjb25maWcuY29udGFpbmVyXHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlXHJcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXNcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGxcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG51bGxcclxuICAgICAgICB0aGlzLnZhbGlkYXRlQm9vbCA9IHRydWVcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlKCkge1xyXG4gICAgICAgIHN1cGVyLmNyZWF0ZSgpXHJcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmNvbnRhaW5lclNlbGVjdG9yKVxyXG4gICAgICAgIHRoaXMuY2hhbmdlVG9FbWFpbCgpXHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckhhbmRsZXJzKClcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3RlckhhbmRsZXJzKCkge1xyXG4gICAgICAgIHRoaXMuJG1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSByZXR1cm5cclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbG9naW4tc3VibWl0JykpIHRoaXMuY2xpY2tTdWJtaXQoKVxyXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuaGFzQXR0cmlidXRlKCdkYXRhLXN3aXRjaC1lbWFpbCcpKSB0aGlzLmNoYW5nZVRvRW1haWwoKVxyXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuaGFzQXR0cmlidXRlKCdkYXRhLWZvcmdldC1wYXNzJykpIHRoaXMuZm9yZ2V0UGFzc3dvcmQoKVxyXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuaGFzQXR0cmlidXRlKCdkYXRhLXJlbWVtYmVyLXBhc3MnKSkgdGhpcy5jaGFuZ2VUb0VtYWlsKClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNsaWNrU3VibWl0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSAhPT0gJ2ZvcmdldFBhc3MnKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbigpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52YWxpZGF0aW9uUmVjb3ZlcnkoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGZvciAoIGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnN0YXRlcykgKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gc3RhdGUpIHRoaXMuY3VycmVudFN0YXRlID0ga2V5XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLiRjb250YWluZXIuaW5uZXJIVE1MID0gc3RhdGVcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1wb3B1cF9fYnV0dG9uJykuZm9jdXMoKVxyXG4gICAgfVxyXG5cclxuICAgIGNoYW5nZVRvRW1haWwoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZSh0aGlzLnN0YXRlcy5sb2dpbkVtYWlsKVxyXG4gICAgICAgIHRoaXMuc3VibWl0ID0gbmV3IEJ1dHRvbkNvbXBvbmVudCgnW2RhdGEtbG9naW4tc3VibWl0XScpXHJcbiAgICAgICAgdGhpcy4kZW1haWxfaW5wdXQgPSB0aGlzLiRtb2RhbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1lbWFpbF0nKVxyXG4gICAgICAgIHRoaXMuJGVycm9ycyA9IHRoaXMuJG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWVycm9yc10nKVxyXG4gICAgICAgIHRoaXMuJHBhc3NfaW5wdXQgPSB0aGlzLiRtb2RhbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1wYXNzXScpXHJcbiAgICB9XHJcblxyXG4gICAgZm9yZ2V0UGFzc3dvcmQoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZSh0aGlzLnN0YXRlcy5mb3JnZXRQYXNzKVxyXG4gICAgICAgIHRoaXMuc3VibWl0ID0gbmV3IEJ1dHRvbkNvbXBvbmVudCgnW2RhdGEtbG9naW4tc3VibWl0XScpXHJcbiAgICAgICAgdGhpcy4kZW1haWxfaW5wdXQgPSB0aGlzLiRtb2RhbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1lbWFpbF0nKVxyXG4gICAgICAgIHRoaXMuJGVycm9ycyA9IHRoaXMuJG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWVycm9yc10nKVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlTWFpbFdhc1NlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZSh0aGlzLnN0YXRlcy5zZW5kUmVjb3ZlcnlNYWlsKVxyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWluZm9dIGInKS5pbm5lckhUTUwgPSB0aGlzLiRlbWFpbF9pbnB1dC52YWx1ZVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHZhbGlkYXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZUJvb2wgPSB0cnVlXHJcbiAgICAgICAgdGhpcy5jbGVhckVycm9ycygpXHJcbiAgICAgICAgaWYgKCFWYWxpZGF0aW9uQ29tcG9uZW50LmlzVmFsaWRFbWFpbCh0aGlzLiRlbWFpbF9pbnB1dC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJFcnJvcign0J3QtdC60L7RgNGA0LXQutGC0L3Ri9C5INCy0LLQvtC0INC/0L7Rh9GC0YsuINCf0L7QstGC0L7RgNC40YLQtSDQv9C+0L/Ri9GC0LrRgy4nKVxyXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQm9vbCA9IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghVmFsaWRhdGlvbkNvbXBvbmVudC5pc1ZhbGlkUGFzcyh0aGlzLiRwYXNzX2lucHV0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQm9vbCA9IGZhbHNlXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXJyb3IoJ9Cd0LXQutC+0YDRgNC10LrRgtC90YvQuSDQstCy0L7QtCDQv9Cw0YDQvtC70Y8uINCf0LDRgNC+0LvRjCDQtNC+0LvQttC10L0g0LjQvNC10YLRjCDQutCw0Log0LzQuNC90LjQvNGD0LwgNiDRgdC40LzQstC+0LvQvtCyLicpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZUJvb2wpIHtcclxuICAgICAgICAgICAgY29uc3QgdXNlciA9IHtcclxuICAgICAgICAgICAgICAgIGVtYWlsOiB0aGlzLiRlbWFpbF9pbnB1dC52YWx1ZSxcclxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLiRwYXNzX2lucHV0LnZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdWJtaXQuc2V0UHJlbG9hZGVyU3RhdGUoJ3doaXRlJylcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godGhpcy5yb3V0ZXIubG9naW5MaW5rLCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1c2VyKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKVxyXG4gICAgICAgICAgICBpZiAoZGF0YS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1Ym1pdC5zZXRUZXh0U3RhdGUoKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFcnJvcihkYXRhLm1lc3NhZ2UpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5yZWRpcmVjdE1haW4oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyRXJyb3JzKCkge1xyXG4gICAgICAgIHRoaXMuJGVycm9ycy5pbm5lckhUTUwgPSAnJ1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlckVycm9yKHRleHQpIHtcclxuICAgICAgICB0aGlzLiRlcnJvcnMuaW5uZXJIVE1MICs9IGBcclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtcG9wdXBfX2Vycm9yIG1lc3NhZ2UgbWVzc2FnZV9lcnJvclwiPlxyXG4gICAgICAgICAgICAgICAgJHt0ZXh0fVxyXG4gICAgICAgICAgICA8L2Rpdj5gXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgdmFsaWRhdGlvblJlY292ZXJ5KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJFcnJvcnMoKVxyXG4gICAgICAgIGlmICghVmFsaWRhdGlvbkNvbXBvbmVudC5pc1ZhbGlkRW1haWwodGhpcy4kZW1haWxfaW5wdXQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckVycm9yKCfQndC10LrQvtGA0YDQtdC60YLQvdGL0Lkg0LLQstC+0LQg0L/QvtGH0YLRiy4g0J/QvtCy0YLQvtGA0LjRgtC1INC/0L7Qv9GL0YLQutGDLicpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3VibWl0LnNldFByZWxvYWRlclN0YXRlKCd3aGl0ZScpXHJcbiAgICAgICAgY29uc3QgZW1haWwgPSB0aGlzLiRlbWFpbF9pbnB1dC52YWx1ZVxyXG4gICAgICAgIGxldCBzdGF0dXMgPSBudWxsXHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godGhpcy5yb3V0ZXIucGFzc1JlY292ZXJ5TGluaywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCB9KVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgc3RhdHVzID0gcmVzLnN0YXR1c1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpXHJcbiAgICAgICAgdGhpcy5zdWJtaXQuc2V0VGV4dFN0YXRlKClcclxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDApIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJFcnJvcihkYXRhLm1lc3NhZ2UpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZU1haWxXYXNTZW50KClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTW9kYWxMb2dpblxyXG5cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/app/modules/login.modal.js\n")},"./source/js/app/modules/search.module.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils.js */ \"./source/js/app/utils/utils.js\");\n/* harmony import */ var _views_render_search_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../views/render.search.js */ \"./source/js/app/views/render.search.js\");\n/* harmony import */ var _views_render_products_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../views/render.products.js */ \"./source/js/app/views/render.products.js\");\n/* harmony import */ var _core_components_pagination_component_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/components/pagination.component.js */ \"./source/js/core/components/pagination.component.js\");\n/* harmony import */ var _service_view_catalog_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../service/view.catalog.js */ \"./source/js/app/service/view.catalog.js\");\n/* harmony import */ var _core_components_selectsinputs_select_component_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/components/selectsinputs/select.component.js */ \"./source/js/core/components/selectsinputs/select.component.js\");\n/* harmony import */ var _core_components_sidebar_component_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/components/sidebar.component.js */ \"./source/js/core/components/sidebar.component.js\");\n/* harmony import */ var _core_modules_module_core_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/modules/module.core.js */ \"./source/js/core/modules/module.core.js\");\n\n\n\n\n\n\n\n\nclass SearchModule extends _core_modules_module_core_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"] {\n  constructor(config) {\n    super(config);\n    this.registerHandlers();\n    this.searchIsActive = false;\n    this.alreadyHaveStatement = false;\n    this.requestToSearch = this.requestToSearch.bind(this);\n    this.requestToSearchMaker = this.requestToSearchMaker.bind(this);\n    this.requestToSearchAttributes = this.requestToSearchAttributes.bind(this);\n  }\n  registerHandlers() {\n    window.addEventListener('load', () => {\n      this.$searchField = document.querySelector('.page-search__field');\n      this.$searchIcon = document.querySelector('#page-search .page-search__icon');\n      this.$pageTel = document.querySelector('.page-header__tel');\n      this.$overlay = document.querySelector('.page-overlay');\n      this.$searchWrapper = document.querySelector('#page-search');\n      this.$searchButton = document.querySelector('.page-search__button');\n      this.$searchComplete = document.querySelector('.page-search__complete');\n      this.$searchListHeader = document.querySelector('[data-header-searchlist]');\n      this.$searchLoader = document.querySelector('.page-search__loader');\n      this.$searchIcon.addEventListener('click', () => {\n        if (this.searchIsActive) {\n          this.closeSearch();\n        } else {\n          this.openSearch();\n        }\n      });\n      this.$searchField.addEventListener('focus', this.openSearch.bind(this));\n      this.$overlay.addEventListener('click', this.closeSearch.bind(this));\n      const searchWithDebounce = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(this.searchAction.bind(this), 800);\n      this.$searchField.addEventListener('input', e => {\n        searchWithDebounce();\n      });\n      this.$searchButton.addEventListener('click', () => {\n        const value = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.sanitalize)(this.$searchField.value);\n        this.router.redirect(`/search?text=${value}`);\n      });\n    });\n  }\n  async searchAction() {\n    if (!this.$searchField.value.length) return;\n    this.enableLoader();\n    const res = await this.requestToSearch({\n      text: this.$searchField.value,\n      count: 5\n    });\n    this.disableLoader();\n    this.$searchWrapper.classList.add('page-search_complete');\n    this.$searchComplete.classList.add('page-search__complete_active');\n    this.$searchListHeader.innerHTML = (0,_views_render_search_js__WEBPACK_IMPORTED_MODULE_1__.renderSearchComplete)(res);\n  }\n  openSearch() {\n    this.searchIsActive = true;\n    this.$searchField.focus();\n    this.$searchIcon.classList.add('page-search__icon_active');\n    this.$overlay.classList.add('page-overlay_active');\n    this.$searchWrapper.classList.add('page-search_active');\n    this.$searchButton.classList.add('page-search__button_active');\n    if (window.innerWidth < 960 && window.innerWidth > 640) {\n      this.$pageTel.classList.add('page-header__tel_active');\n    }\n    if (this.$searchField.value.length) {\n      this.$searchComplete.classList.add('page-search__complete_active');\n      this.$searchWrapper.classList.add('page-search_complete');\n    }\n  }\n  closeSearch() {\n    this.searchIsActive = false;\n    this.$searchComplete.classList.remove('page-search__complete_active');\n    this.$overlay.classList.remove('page-overlay_active');\n    this.$searchWrapper.classList.remove('page-search_active');\n    this.$searchWrapper.classList.remove('page-search_complete');\n    this.$searchButton.classList.remove('page-search__button_active');\n    this.$pageTel.classList.remove('page-header__tel_active');\n  }\n  enableLoader() {\n    this.$searchLoader.classList.add('page-search__loader_active');\n  }\n  disableLoader() {\n    this.$searchLoader.classList.remove('page-search__loader_active');\n  }\n  async requestToSearchText(text) {\n    this.router.removeParams(['sort', 'page']);\n    this.router.addParams('text', text);\n    this.router.redirectUrlState();\n    this.router.reload();\n  }\n  async requestToSearchMaker({\n    text,\n    page,\n    name,\n    sort\n  }) {\n    return await this.apiService.useRequest(this.router.searchMakerLink, {\n      method: 'OPTIONS',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        text: (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.escapeRegex)(text),\n        name: name,\n        page,\n        sort\n      })\n    });\n  }\n  async requestToSearchAttributes({\n    text,\n    page,\n    key,\n    value,\n    sort\n  }) {\n    return await this.apiService.useRequest(this.router.searchAttributesLink, {\n      method: 'OPTIONS',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        key: key,\n        value: value,\n        text: (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.escapeRegex)(text),\n        page,\n        sort\n      })\n    });\n  }\n  async requestToSearch({\n    text,\n    count,\n    page,\n    sort\n  }) {\n    return await this.apiService.useRequest(this.router.searchLink, {\n      method: 'OPTIONS',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        text: (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.escapeRegex)(text),\n        count,\n        page,\n        sort\n      })\n    });\n  }\n  async initPage() {\n    new _core_components_sidebar_component_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]({\n      root: '[data-sidebar]',\n      overlay: '.page-overlay',\n      buttonOpen: '[data-sidebar-open]',\n      buttonClose: '[data-sidebar-close]'\n    }).init();\n    (0,_service_view_catalog_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    this.sortSelect = new _core_components_selectsinputs_select_component_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n      query: '#sort-search',\n      data: [{\n        value: 'По популярности',\n        dataset: 'popularity',\n        default: true\n      }, {\n        value: 'По наименованию',\n        dataset: 'name'\n      }, {\n        value: 'По бренду',\n        dataset: 'maker'\n      }],\n      onselect: data => {\n        this.router.addParams('sort', data.value);\n        this.router.redirectUrlState();\n        this.setCurrentState();\n      }\n    });\n    this.sortSelect.render();\n    this.nameParam = this.router.getParam('name');\n    this.textParam = this.router.getParam('text');\n    this.sortParam = this.router.getParam('sort');\n    this.keyParam = this.router.getParam('key');\n    this.valueParam = this.router.getParam('value');\n    this.pageParam = this.router.getParam('page');\n    this.$productList = document.querySelector('#products_list');\n    this.$title = document.querySelector('.page-section__title');\n    this.$searchList = document.querySelector('[data-aside-searchlist]');\n    this.$searchPageInput = document.querySelector('[data-name-search]');\n    this.$searchPageInput.value = this.textParam;\n    this.setPreloaderSearchList();\n    this.sortSelect.changeState(this.sortParam);\n    document.querySelector('[data-search-button]').addEventListener('click', () => {\n      this.requestToSearchText(this.$searchPageInput.value);\n    });\n    this.setCurrentState();\n    window.addEventListener('popstate', () => {\n      this.router.reload();\n    });\n  }\n  async setCurrentState() {\n    this.pagination = new _core_components_pagination_component_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n      query: '#pagination',\n      onChange: pageNumber => {\n        this.router.addParams('page', pageNumber);\n        this.router.redirectUrlState();\n        this.pageParam = pageNumber;\n        this.setCurrentState();\n        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('#top-element');\n      }\n    });\n    this.pagination.clear();\n    this.setPreloaderProducts();\n    if (this.router.url.pathname === '/search' && this.textParam) {\n      const res = await this.setState(this.requestToSearch);\n      if (!this.alreadyHaveStatement) {\n        this.alreadyHaveStatement = true;\n        this.$searchList.innerHTML = (0,_views_render_search_js__WEBPACK_IMPORTED_MODULE_1__.renderSearchComplete)(res, false);\n      }\n    } else if (this.router.url.pathname === '/search/maker' && this.nameParam) {\n      const res = await this.setState(this.requestToSearchMaker);\n      if (!this.alreadyHaveStatement) {\n        this.alreadyHaveStatement = true;\n        this.$title.innerHTML = `Поиск по производителю ${this.nameParam}`;\n        this.$searchList.innerHTML = this.renderSearchListTitle('Поиск по производителю', this.nameParam, res.products.count);\n      }\n    } else if (this.router.url.pathname === '/search/attributes' && this.keyParam && this.valueParam) {\n      const res = await this.setState(this.requestToSearchAttributes);\n      if (!this.alreadyHaveStatement) {\n        this.alreadyHaveStatement = true;\n        this.$title.innerHTML = `Поиск по аттрибуту ${this.keyParam}`;\n        this.$searchList.innerHTML = this.renderSearchListTitle(`${this.keyParam}`, this.valueParam, res.products.count);\n      }\n    } else {\n      this.router.redirectNotFound();\n    }\n    this.preloader.hide();\n  }\n  async setState(stateFunc) {\n    const res = await stateFunc({\n      name: this.nameParam,\n      value: this.valueParam,\n      text: this.textParam,\n      page: this.pageParam,\n      sort: this.sortParam,\n      key: this.keyParam\n    });\n    this.renderProducts(res);\n    this.pagination.render({\n      count: res.products.count,\n      currentPage: this.pageParam || 1\n    });\n    return res;\n  }\n  renderSearchListTitle(type, title, count) {\n    return `\n            <div class=\"search-list__item\">\n                 <div class=\"search-list__header\">\n                     ${type}\n                 </div>\n                 <div class=\"search-list__body\">\n                     <span class=\"search-list__name\">${title}</span>\n                     <span class=\"search-list__count\">(товаров - ${count})</span>\n                 </div>\n            </div>\n        `;\n  }\n  renderProducts(res) {\n    this.$productList.innerHTML = (0,_views_render_products_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(res.products?.list || [], 'products__item') || 'Ничего не найдено';\n    (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.lazyLoadImages)(this.$productList);\n  }\n  setPreloaderProducts() {\n    this.$productList.innerHTML = `<div class=\"preloader\"></div>`;\n  }\n  setPreloaderSearchList() {\n    this.$searchList.innerHTML = '<div class=\"search-list__loader\"><div class=\"loader\"></div></div>';\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (SearchModule);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL21vZHVsZXMvc2VhcmNoLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QtZ3VscC8uL3NvdXJjZS9qcy9hcHAvbW9kdWxlcy9zZWFyY2gubW9kdWxlLmpzP2Y0YmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNjcm9sbFRvVG9wLCB7IGRlYm91bmNlLCBlc2NhcGVSZWdleCwgbGF6eUxvYWRJbWFnZXMsIHNhbml0YWxpemUgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IHsgcmVuZGVyU2VhcmNoQ29tcGxldGUgfSBmcm9tICcuLi92aWV3cy9yZW5kZXIuc2VhcmNoLmpzJ1xyXG5pbXBvcnQgcmVuZGVyUHJvZHVjdHMgZnJvbSAnLi4vdmlld3MvcmVuZGVyLnByb2R1Y3RzLmpzJ1xyXG5pbXBvcnQgUGFnaW5hdGlvbkNvbXBvbmVudCBmcm9tICcuLi8uLi9jb3JlL2NvbXBvbmVudHMvcGFnaW5hdGlvbi5jb21wb25lbnQuanMnXHJcbmltcG9ydCBjaGFuZ2VQcm9kdWN0c1ZpZXdIYW5kbGVyIGZyb20gJy4uL3NlcnZpY2Uvdmlldy5jYXRhbG9nLmpzJ1xyXG5pbXBvcnQgU2VsZWN0Q29tcG9uZW50IGZyb20gJy4uLy4uL2NvcmUvY29tcG9uZW50cy9zZWxlY3RzaW5wdXRzL3NlbGVjdC5jb21wb25lbnQuanMnXHJcbmltcG9ydCBTaWRlYmFyQ29tcG9uZW50IGZyb20gJy4uLy4uL2NvcmUvY29tcG9uZW50cy9zaWRlYmFyLmNvbXBvbmVudC5qcydcclxuaW1wb3J0IE1vZHVsZUNvcmUgZnJvbSAnLi4vLi4vY29yZS9tb2R1bGVzL21vZHVsZS5jb3JlLmpzJ1xyXG5cclxuXHJcbmNsYXNzIFNlYXJjaE1vZHVsZSBleHRlbmRzIE1vZHVsZUNvcmV7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICBzdXBlcihjb25maWcpXHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckhhbmRsZXJzKClcclxuICAgICAgICB0aGlzLnNlYXJjaElzQWN0aXZlID0gZmFsc2VcclxuICAgICAgICB0aGlzLmFscmVhZHlIYXZlU3RhdGVtZW50ID0gZmFsc2VcclxuICAgICAgICB0aGlzLnJlcXVlc3RUb1NlYXJjaCA9IHRoaXMucmVxdWVzdFRvU2VhcmNoLmJpbmQodGhpcylcclxuICAgICAgICB0aGlzLnJlcXVlc3RUb1NlYXJjaE1ha2VyID0gdGhpcy5yZXF1ZXN0VG9TZWFyY2hNYWtlci5iaW5kKHRoaXMpXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0VG9TZWFyY2hBdHRyaWJ1dGVzID0gdGhpcy5yZXF1ZXN0VG9TZWFyY2hBdHRyaWJ1dGVzLmJpbmQodGhpcylcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3RlckhhbmRsZXJzKCkge1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLiRzZWFyY2hGaWVsZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLXNlYXJjaF9fZmllbGQnKVxyXG4gICAgICAgICAgICB0aGlzLiRzZWFyY2hJY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3BhZ2Utc2VhcmNoIC5wYWdlLXNlYXJjaF9faWNvbicpXHJcbiAgICAgICAgICAgIHRoaXMuJHBhZ2VUZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1oZWFkZXJfX3RlbCcpXHJcbiAgICAgICAgICAgIHRoaXMuJG92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1vdmVybGF5JylcclxuICAgICAgICAgICAgdGhpcy4kc2VhcmNoV3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwYWdlLXNlYXJjaCcpXHJcbiAgICAgICAgICAgIHRoaXMuJHNlYXJjaEJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLXNlYXJjaF9fYnV0dG9uJylcclxuICAgICAgICAgICAgdGhpcy4kc2VhcmNoQ29tcGxldGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1zZWFyY2hfX2NvbXBsZXRlJylcclxuICAgICAgICAgICAgdGhpcy4kc2VhcmNoTGlzdEhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWhlYWRlci1zZWFyY2hsaXN0XScpXHJcbiAgICAgICAgICAgIHRoaXMuJHNlYXJjaExvYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLXNlYXJjaF9fbG9hZGVyJylcclxuICAgICAgICAgICAgdGhpcy4kc2VhcmNoSWNvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlYXJjaElzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNlYXJjaCgpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlblNlYXJjaCgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHRoaXMuJHNlYXJjaEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5vcGVuU2VhcmNoLmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgIHRoaXMuJG92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNsb3NlU2VhcmNoLmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFdpdGhEZWJvdW5jZSA9IGRlYm91bmNlKHRoaXMuc2VhcmNoQWN0aW9uLmJpbmQodGhpcyksIDgwMClcclxuICAgICAgICAgICAgdGhpcy4kc2VhcmNoRmllbGQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoV2l0aERlYm91bmNlKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgdGhpcy4kc2VhcmNoQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzYW5pdGFsaXplKHRoaXMuJHNlYXJjaEZpZWxkLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3V0ZXIucmVkaXJlY3QoYC9zZWFyY2g/dGV4dD0ke3ZhbHVlfWApXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgc2VhcmNoQWN0aW9uKCkge1xyXG4gICAgICAgIGlmKCF0aGlzLiRzZWFyY2hGaWVsZC52YWx1ZS5sZW5ndGgpIHJldHVyblxyXG4gICAgICAgIHRoaXMuZW5hYmxlTG9hZGVyKClcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcXVlc3RUb1NlYXJjaCh7XHJcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuJHNlYXJjaEZpZWxkLnZhbHVlLFxyXG4gICAgICAgICAgICBjb3VudDogNVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5kaXNhYmxlTG9hZGVyKClcclxuICAgICAgICB0aGlzLiRzZWFyY2hXcmFwcGVyLmNsYXNzTGlzdC5hZGQoJ3BhZ2Utc2VhcmNoX2NvbXBsZXRlJylcclxuICAgICAgICB0aGlzLiRzZWFyY2hDb21wbGV0ZS5jbGFzc0xpc3QuYWRkKCdwYWdlLXNlYXJjaF9fY29tcGxldGVfYWN0aXZlJylcclxuICAgICAgICB0aGlzLiRzZWFyY2hMaXN0SGVhZGVyLmlubmVySFRNTCA9IHJlbmRlclNlYXJjaENvbXBsZXRlKHJlcylcclxuICAgIH1cclxuXHJcbiAgICBvcGVuU2VhcmNoKCkge1xyXG4gICAgICAgIHRoaXMuc2VhcmNoSXNBY3RpdmUgPSB0cnVlXHJcbiAgICAgICAgdGhpcy4kc2VhcmNoRmllbGQuZm9jdXMoKVxyXG4gICAgICAgIHRoaXMuJHNlYXJjaEljb24uY2xhc3NMaXN0LmFkZCgncGFnZS1zZWFyY2hfX2ljb25fYWN0aXZlJylcclxuICAgICAgICB0aGlzLiRvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ3BhZ2Utb3ZlcmxheV9hY3RpdmUnKVxyXG4gICAgICAgIHRoaXMuJHNlYXJjaFdyYXBwZXIuY2xhc3NMaXN0LmFkZCgncGFnZS1zZWFyY2hfYWN0aXZlJylcclxuICAgICAgICB0aGlzLiRzZWFyY2hCdXR0b24uY2xhc3NMaXN0LmFkZCgncGFnZS1zZWFyY2hfX2J1dHRvbl9hY3RpdmUnKVxyXG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8IDk2MCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IDY0MCkge1xyXG4gICAgICAgICAgICB0aGlzLiRwYWdlVGVsLmNsYXNzTGlzdC5hZGQoJ3BhZ2UtaGVhZGVyX190ZWxfYWN0aXZlJylcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuJHNlYXJjaEZpZWxkLnZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLiRzZWFyY2hDb21wbGV0ZS5jbGFzc0xpc3QuYWRkKCdwYWdlLXNlYXJjaF9fY29tcGxldGVfYWN0aXZlJylcclxuICAgICAgICAgICAgdGhpcy4kc2VhcmNoV3JhcHBlci5jbGFzc0xpc3QuYWRkKCdwYWdlLXNlYXJjaF9jb21wbGV0ZScpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsb3NlU2VhcmNoKCkge1xyXG4gICAgICAgIHRoaXMuc2VhcmNoSXNBY3RpdmUgPSBmYWxzZVxyXG4gICAgICAgIHRoaXMuJHNlYXJjaENvbXBsZXRlLmNsYXNzTGlzdC5yZW1vdmUoJ3BhZ2Utc2VhcmNoX19jb21wbGV0ZV9hY3RpdmUnKVxyXG4gICAgICAgIHRoaXMuJG92ZXJsYXkuY2xhc3NMaXN0LnJlbW92ZSgncGFnZS1vdmVybGF5X2FjdGl2ZScpXHJcbiAgICAgICAgdGhpcy4kc2VhcmNoV3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlLXNlYXJjaF9hY3RpdmUnKVxyXG4gICAgICAgIHRoaXMuJHNlYXJjaFdyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSgncGFnZS1zZWFyY2hfY29tcGxldGUnKVxyXG4gICAgICAgIHRoaXMuJHNlYXJjaEJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlLXNlYXJjaF9fYnV0dG9uX2FjdGl2ZScpXHJcbiAgICAgICAgdGhpcy4kcGFnZVRlbC5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlLWhlYWRlcl9fdGVsX2FjdGl2ZScpXHJcbiAgICB9XHJcblxyXG4gICAgZW5hYmxlTG9hZGVyKCkge1xyXG4gICAgICAgIHRoaXMuJHNlYXJjaExvYWRlci5jbGFzc0xpc3QuYWRkKCdwYWdlLXNlYXJjaF9fbG9hZGVyX2FjdGl2ZScpXHJcbiAgICB9XHJcblxyXG4gICAgZGlzYWJsZUxvYWRlcigpIHtcclxuICAgICAgICB0aGlzLiRzZWFyY2hMb2FkZXIuY2xhc3NMaXN0LnJlbW92ZSgncGFnZS1zZWFyY2hfX2xvYWRlcl9hY3RpdmUnKVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHJlcXVlc3RUb1NlYXJjaFRleHQodGV4dCkge1xyXG4gICAgICAgIHRoaXMucm91dGVyLnJlbW92ZVBhcmFtcyhbJ3NvcnQnLCAncGFnZSddKVxyXG4gICAgICAgIHRoaXMucm91dGVyLmFkZFBhcmFtcygndGV4dCcsIHRleHQpXHJcbiAgICAgICAgdGhpcy5yb3V0ZXIucmVkaXJlY3RVcmxTdGF0ZSgpXHJcbiAgICAgICAgdGhpcy5yb3V0ZXIucmVsb2FkKClcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyByZXF1ZXN0VG9TZWFyY2hNYWtlcih7IHRleHQsIHBhZ2UsIG5hbWUsIHNvcnQgfSkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFwaVNlcnZpY2UudXNlUmVxdWVzdCh0aGlzLnJvdXRlci5zZWFyY2hNYWtlckxpbmssIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnT1BUSU9OUycsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IGVzY2FwZVJlZ2V4KHRleHQpLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgIHBhZ2UsXHJcbiAgICAgICAgICAgICAgICBzb3J0XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyByZXF1ZXN0VG9TZWFyY2hBdHRyaWJ1dGVzKHsgdGV4dCwgcGFnZSwga2V5LCB2YWx1ZSwgc29ydCB9KSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYXBpU2VydmljZS51c2VSZXF1ZXN0KHRoaXMucm91dGVyLnNlYXJjaEF0dHJpYnV0ZXNMaW5rLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ09QVElPTlMnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIHRleHQ6IGVzY2FwZVJlZ2V4KHRleHQpLFxyXG4gICAgICAgICAgICAgICAgcGFnZSxcclxuICAgICAgICAgICAgICAgIHNvcnRcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHJlcXVlc3RUb1NlYXJjaCh7IHRleHQsIGNvdW50LCBwYWdlLCBzb3J0IH0pIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5hcGlTZXJ2aWNlLnVzZVJlcXVlc3QodGhpcy5yb3V0ZXIuc2VhcmNoTGluaywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdPUFRJT05TJyxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgdGV4dDogZXNjYXBlUmVnZXgodGV4dCksXHJcbiAgICAgICAgICAgICAgICBjb3VudCxcclxuICAgICAgICAgICAgICAgIHBhZ2UsXHJcbiAgICAgICAgICAgICAgICBzb3J0XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBpbml0UGFnZSgpIHtcclxuICAgICAgICBuZXcgU2lkZWJhckNvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHJvb3Q6ICdbZGF0YS1zaWRlYmFyXScsXHJcbiAgICAgICAgICAgIG92ZXJsYXk6ICcucGFnZS1vdmVybGF5JyxcclxuICAgICAgICAgICAgYnV0dG9uT3BlbjogJ1tkYXRhLXNpZGViYXItb3Blbl0nLFxyXG4gICAgICAgICAgICBidXR0b25DbG9zZTogJ1tkYXRhLXNpZGViYXItY2xvc2VdJ1xyXG4gICAgICAgIH0pLmluaXQoKVxyXG4gICAgICAgIGNoYW5nZVByb2R1Y3RzVmlld0hhbmRsZXIoKVxyXG4gICAgICAgIHRoaXMuc29ydFNlbGVjdCA9IG5ldyBTZWxlY3RDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBxdWVyeTogJyNzb3J0LXNlYXJjaCcsXHJcbiAgICAgICAgICAgIGRhdGE6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ9Cf0L4g0L/QvtC/0YPQu9GP0YDQvdC+0YHRgtC4JyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhc2V0OiAncG9wdWxhcml0eScsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ9Cf0L4g0L3QsNC40LzQtdC90L7QstCw0L3QuNGOJyxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhc2V0OiAnbmFtZSdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICfQn9C+INCx0YDQtdC90LTRgycsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldDogJ21ha2VyJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBvbnNlbGVjdDogKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm91dGVyLmFkZFBhcmFtcygnc29ydCcsIGRhdGEudmFsdWUpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5yZWRpcmVjdFVybFN0YXRlKClcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFN0YXRlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5zb3J0U2VsZWN0LnJlbmRlcigpXHJcblxyXG4gICAgICAgIHRoaXMubmFtZVBhcmFtID0gdGhpcy5yb3V0ZXIuZ2V0UGFyYW0oJ25hbWUnKVxyXG4gICAgICAgIHRoaXMudGV4dFBhcmFtID0gdGhpcy5yb3V0ZXIuZ2V0UGFyYW0oJ3RleHQnKVxyXG4gICAgICAgIHRoaXMuc29ydFBhcmFtID0gdGhpcy5yb3V0ZXIuZ2V0UGFyYW0oJ3NvcnQnKVxyXG4gICAgICAgIHRoaXMua2V5UGFyYW0gPSB0aGlzLnJvdXRlci5nZXRQYXJhbSgna2V5JylcclxuICAgICAgICB0aGlzLnZhbHVlUGFyYW0gPSB0aGlzLnJvdXRlci5nZXRQYXJhbSgndmFsdWUnKVxyXG4gICAgICAgIHRoaXMucGFnZVBhcmFtID0gdGhpcy5yb3V0ZXIuZ2V0UGFyYW0oJ3BhZ2UnKVxyXG5cclxuICAgICAgICB0aGlzLiRwcm9kdWN0TGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwcm9kdWN0c19saXN0JylcclxuICAgICAgICB0aGlzLiR0aXRsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLXNlY3Rpb25fX3RpdGxlJylcclxuICAgICAgICB0aGlzLiRzZWFyY2hMaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtYXNpZGUtc2VhcmNobGlzdF0nKVxyXG4gICAgICAgIHRoaXMuJHNlYXJjaFBhZ2VJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW5hbWUtc2VhcmNoXScpXHJcblxyXG5cclxuICAgICAgICB0aGlzLiRzZWFyY2hQYWdlSW5wdXQudmFsdWUgPSB0aGlzLnRleHRQYXJhbVxyXG4gICAgICAgIHRoaXMuc2V0UHJlbG9hZGVyU2VhcmNoTGlzdCgpXHJcbiAgICAgICAgdGhpcy5zb3J0U2VsZWN0LmNoYW5nZVN0YXRlKHRoaXMuc29ydFBhcmFtKVxyXG5cclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zZWFyY2gtYnV0dG9uXScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RUb1NlYXJjaFRleHQodGhpcy4kc2VhcmNoUGFnZUlucHV0LnZhbHVlKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50U3RhdGUoKVxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yb3V0ZXIucmVsb2FkKClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHNldEN1cnJlbnRTdGF0ZSgpIHtcclxuICAgICAgICB0aGlzLnBhZ2luYXRpb24gPSBuZXcgUGFnaW5hdGlvbkNvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHF1ZXJ5OiAnI3BhZ2luYXRpb24nLFxyXG4gICAgICAgICAgICBvbkNoYW5nZTogKHBhZ2VOdW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm91dGVyLmFkZFBhcmFtcygncGFnZScsIHBhZ2VOdW1iZXIpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5yZWRpcmVjdFVybFN0YXRlKClcclxuICAgICAgICAgICAgICAgIHRoaXMucGFnZVBhcmFtID0gcGFnZU51bWJlclxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50U3RhdGUoKVxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsVG9Ub3AoJyN0b3AtZWxlbWVudCcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMucGFnaW5hdGlvbi5jbGVhcigpXHJcbiAgICAgICAgdGhpcy5zZXRQcmVsb2FkZXJQcm9kdWN0cygpXHJcbiAgICAgICAgaWYgKHRoaXMucm91dGVyLnVybC5wYXRobmFtZSA9PT0gJy9zZWFyY2gnICYmIHRoaXMudGV4dFBhcmFtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuc2V0U3RhdGUodGhpcy5yZXF1ZXN0VG9TZWFyY2gpXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hbHJlYWR5SGF2ZVN0YXRlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbHJlYWR5SGF2ZVN0YXRlbWVudCA9IHRydWVcclxuICAgICAgICAgICAgICAgIHRoaXMuJHNlYXJjaExpc3QuaW5uZXJIVE1MID0gcmVuZGVyU2VhcmNoQ29tcGxldGUocmVzLCBmYWxzZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5yb3V0ZXIudXJsLnBhdGhuYW1lID09PSAnL3NlYXJjaC9tYWtlcicgJiYgdGhpcy5uYW1lUGFyYW0pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5zZXRTdGF0ZSh0aGlzLnJlcXVlc3RUb1NlYXJjaE1ha2VyKVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxyZWFkeUhhdmVTdGF0ZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxyZWFkeUhhdmVTdGF0ZW1lbnQgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICB0aGlzLiR0aXRsZS5pbm5lckhUTUwgPSBg0J/QvtC40YHQuiDQv9C+INC/0YDQvtC40LfQstC+0LTQuNGC0LXQu9GOICR7dGhpcy5uYW1lUGFyYW19YFxyXG4gICAgICAgICAgICAgICAgdGhpcy4kc2VhcmNoTGlzdC5pbm5lckhUTUwgPSB0aGlzLnJlbmRlclNlYXJjaExpc3RUaXRsZSgn0J/QvtC40YHQuiDQv9C+INC/0YDQvtC40LfQstC+0LTQuNGC0LXQu9GOJywgdGhpcy5uYW1lUGFyYW0sIHJlcy5wcm9kdWN0cy5jb3VudClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5yb3V0ZXIudXJsLnBhdGhuYW1lID09PSAnL3NlYXJjaC9hdHRyaWJ1dGVzJyAmJiB0aGlzLmtleVBhcmFtICYmIHRoaXMudmFsdWVQYXJhbSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnNldFN0YXRlKHRoaXMucmVxdWVzdFRvU2VhcmNoQXR0cmlidXRlcylcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmFscmVhZHlIYXZlU3RhdGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFscmVhZHlIYXZlU3RhdGVtZW50ID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgdGhpcy4kdGl0bGUuaW5uZXJIVE1MID0gYNCf0L7QuNGB0Log0L/QviDQsNGC0YLRgNC40LHRg9GC0YMgJHt0aGlzLmtleVBhcmFtfWBcclxuICAgICAgICAgICAgICAgIHRoaXMuJHNlYXJjaExpc3QuaW5uZXJIVE1MID0gdGhpcy5yZW5kZXJTZWFyY2hMaXN0VGl0bGUoYCR7dGhpcy5rZXlQYXJhbX1gLCB0aGlzLnZhbHVlUGFyYW0sIHJlcy5wcm9kdWN0cy5jb3VudClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucm91dGVyLnJlZGlyZWN0Tm90Rm91bmQoKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByZWxvYWRlci5oaWRlKClcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzZXRTdGF0ZShzdGF0ZUZ1bmMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBzdGF0ZUZ1bmMoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWVQYXJhbSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVQYXJhbSxcclxuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0UGFyYW0sXHJcbiAgICAgICAgICAgIHBhZ2U6IHRoaXMucGFnZVBhcmFtLFxyXG4gICAgICAgICAgICBzb3J0OiB0aGlzLnNvcnRQYXJhbSxcclxuICAgICAgICAgICAga2V5OiB0aGlzLmtleVBhcmFtXHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLnJlbmRlclByb2R1Y3RzKHJlcylcclxuICAgICAgICB0aGlzLnBhZ2luYXRpb24ucmVuZGVyKHtcclxuICAgICAgICAgICAgY291bnQ6IHJlcy5wcm9kdWN0cy5jb3VudCxcclxuICAgICAgICAgICAgY3VycmVudFBhZ2U6IHRoaXMucGFnZVBhcmFtIHx8IDFcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiByZXNcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJTZWFyY2hMaXN0VGl0bGUodHlwZSwgdGl0bGUsIGNvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNlYXJjaC1saXN0X19pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNlYXJjaC1saXN0X19oZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgJHt0eXBlfVxyXG4gICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtbGlzdF9fYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNlYXJjaC1saXN0X19uYW1lXCI+JHt0aXRsZX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2VhcmNoLWxpc3RfX2NvdW50XCI+KNGC0L7QstCw0YDQvtCyIC0gJHtjb3VudH0pPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICBgXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyUHJvZHVjdHMocmVzKSB7XHJcbiAgICAgICAgdGhpcy4kcHJvZHVjdExpc3QuaW5uZXJIVE1MID0gcmVuZGVyUHJvZHVjdHMocmVzLnByb2R1Y3RzPy5saXN0IHx8IFtdLCAncHJvZHVjdHNfX2l0ZW0nKSB8fCAn0J3QuNGH0LXQs9C+INC90LUg0L3QsNC50LTQtdC90L4nXHJcbiAgICAgICAgbGF6eUxvYWRJbWFnZXModGhpcy4kcHJvZHVjdExpc3QpXHJcbiAgICB9XHJcblxyXG4gICAgc2V0UHJlbG9hZGVyUHJvZHVjdHMoKSB7XHJcbiAgICAgICAgdGhpcy4kcHJvZHVjdExpc3QuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJwcmVsb2FkZXJcIj48L2Rpdj5gXHJcbiAgICB9XHJcblxyXG4gICAgc2V0UHJlbG9hZGVyU2VhcmNoTGlzdCgpIHtcclxuICAgICAgICB0aGlzLiRzZWFyY2hMaXN0LmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwic2VhcmNoLWxpc3RfX2xvYWRlclwiPjxkaXYgY2xhc3M9XCJsb2FkZXJcIj48L2Rpdj48L2Rpdj4nXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNlYXJjaE1vZHVsZVxyXG5cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/app/modules/search.module.js\n")},"./source/js/app/modules/user.nav.module.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils.js */ "./source/js/app/utils/utils.js");\n/* harmony import */ var _core_modules_module_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/modules/module.core.js */ "./source/js/core/modules/module.core.js");\n/* harmony import */ var code_tag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! code-tag */ "./node_modules/code-tag/dist/index.mjs");\n\n\n\nclass UserNavModule extends _core_modules_module_core_js__WEBPACK_IMPORTED_MODULE_1__["default"] {\n  constructor(config) {\n    super(config);\n    this.$sign = document.querySelector(\'.user-nav__item_sign\');\n    this.$cart = document.querySelector(\'.user-nav__item_cart\');\n    this.modalLogin = config.modalLogin;\n  }\n  async changeState() {\n    if (this.auth.isAuth) {\n      await this.auth.init();\n      this.render();\n    } else {\n      this.render();\n    }\n  }\n  render() {\n    if (this.auth.isAuth) {\n      this.$cart.dataset.cartCount = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.getProductsCount)(this.auth.userData.cart.list) || \'\';\n      this.$sign.dataset.cartCount = this.auth.userData.unreadMessagesCount || \'\';\n      this.$sign.innerHTML = !this.router.isProfilePage ? `\n                <a href="/user/profile" class="user-nav__link">\n                    <svg>\n                        <use xlink:href="img/svg/sprite.svg#sign-in"></use>\n                    </svg>\n                    <span>${this.auth.userData.firstName}</span>\n                </a>\n            ` : `\n                <span class="user-nav__span">\n                    <svg>\n                        <use xlink:href="img/svg/sprite.svg#sign-in"></use>\n                    </svg>\n                    <span>${this.auth.userData.firstName}</span>\n                </span>\n            `;\n      this.$sign.innerHTML += `\n                <ul class="profile-list">\n                    ${this.auth.userData.role.toLowerCase() === \'admin\' ? `\n                        <li class="profile-list__item">\n                            <a href="/admin" class="profile-list__link">Управление сайтом</a>\n                        </li>\n                    ` : \'\'}\n                    <li class="profile-list__item">\n                        <a href="/user/profile/" class="profile-list__link">Профиль</a>\n                    </li>\n                    <li class="profile-list__item">\n                        <a href="/user/purchases/" class="profile-list__link">Покупки</a>\n                    </li>\n                    <li class="profile-list__item">\n                        <a href="/user/notifications" class="profile-list__link">Уведомления</a>\n                    </li>\n                    <li class="profile-list__item">\n                        <button class="profile-list__link" data-logout>Выйти</button>\n                    </li>\n                </ul>\n            `;\n      this.registerLogout();\n    } else {\n      const cart = JSON.parse(localStorage.getItem(\'cart\'))?.products || [];\n      this.$cart.dataset.cartCount = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.getProductsCount)(cart) || \'\';\n      this.$sign.innerHTML = `\n                <button class="user-nav__link">\n                    <svg>\n                        <use xlink:href="img/svg/sprite.svg#sign-in"></use>\n                    </svg>\n                    <span>Войти</span>\n                </button>\n            `;\n      this.registerLoginModal();\n    }\n  }\n  registerLoginModal() {\n    const $sign_button = document.querySelector(\'.user-nav__item_sign\');\n    $sign_button.addEventListener(\'click\', () => {\n      this.modalLogin.create();\n    });\n  }\n  registerLogout() {\n    document.querySelector(\'[data-logout]\').addEventListener(\'click\', async () => {\n      try {\n        await this.apiService.useRequest(this.router.logoutLink, {\n          method: \'POST\',\n          headers: {\n            \'Accept\': \'application/json\',\n            \'Content-Type\': \'application/json\'\n          },\n          body: JSON.stringify({})\n        });\n        this.router.redirectMain();\n      } catch (e) {\n        console.log(e.message);\n      }\n    });\n  }\n}\n/* harmony default export */ __webpack_exports__["default"] = (UserNavModule);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL21vZHVsZXMvdXNlci5uYXYubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2FwcC9tb2R1bGVzL3VzZXIubmF2Lm1vZHVsZS5qcz9hYmU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFByb2R1Y3RzQ291bnQgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IE1vZHVsZUNvcmUgZnJvbSAnLi4vLi4vY29yZS9tb2R1bGVzL21vZHVsZS5jb3JlLmpzJ1xyXG5pbXBvcnQgeyBodG1sIH0gZnJvbSAnY29kZS10YWcnXHJcblxyXG5jbGFzcyBVc2VyTmF2TW9kdWxlIGV4dGVuZHMgTW9kdWxlQ29yZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICBzdXBlcihjb25maWcpXHJcbiAgICAgICAgdGhpcy4kc2lnbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy51c2VyLW5hdl9faXRlbV9zaWduJylcclxuICAgICAgICB0aGlzLiRjYXJ0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnVzZXItbmF2X19pdGVtX2NhcnQnKVxyXG4gICAgICAgIHRoaXMubW9kYWxMb2dpbiA9IGNvbmZpZy5tb2RhbExvZ2luXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgY2hhbmdlU3RhdGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aC5pc0F1dGgpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoLmluaXQoKVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aC5pc0F1dGgpIHtcclxuICAgICAgICAgICAgdGhpcy4kY2FydC5kYXRhc2V0LmNhcnRDb3VudCA9IGdldFByb2R1Y3RzQ291bnQodGhpcy5hdXRoLnVzZXJEYXRhLmNhcnQubGlzdCkgfHwgJydcclxuICAgICAgICAgICAgdGhpcy4kc2lnbi5kYXRhc2V0LmNhcnRDb3VudCA9IHRoaXMuYXV0aC51c2VyRGF0YS51bnJlYWRNZXNzYWdlc0NvdW50IHx8ICcnXHJcbiAgICAgICAgICAgIHRoaXMuJHNpZ24uaW5uZXJIVE1MID0gIXRoaXMucm91dGVyLmlzUHJvZmlsZVBhZ2UgPyBgXHJcbiAgICAgICAgICAgICAgICA8YSBocmVmPVwiL3VzZXIvcHJvZmlsZVwiIGNsYXNzPVwidXNlci1uYXZfX2xpbmtcIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dXNlIHhsaW5rOmhyZWY9XCJpbWcvc3ZnL3Nwcml0ZS5zdmcjc2lnbi1pblwiPjwvdXNlPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPiR7dGhpcy5hdXRoLnVzZXJEYXRhLmZpcnN0TmFtZX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgIGAgOiBgXHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInVzZXItbmF2X19zcGFuXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHN2Zz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPVwiaW1nL3N2Zy9zcHJpdGUuc3ZnI3NpZ24taW5cIj48L3VzZT5cclxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj4ke3RoaXMuYXV0aC51c2VyRGF0YS5maXJzdE5hbWV9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICBgXHJcbiAgICAgICAgICAgIHRoaXMuJHNpZ24uaW5uZXJIVE1MICs9IGBcclxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cInByb2ZpbGUtbGlzdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICR7dGhpcy5hdXRoLnVzZXJEYXRhLnJvbGUudG9Mb3dlckNhc2UoKSA9PT0gJ2FkbWluJyA/IGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwicHJvZmlsZS1saXN0X19pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiL2FkbWluXCIgY2xhc3M9XCJwcm9maWxlLWxpc3RfX2xpbmtcIj7Qo9C/0YDQsNCy0LvQtdC90LjQtSDRgdCw0LnRgtC+0Lw8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgYCA6ICcnfVxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cInByb2ZpbGUtbGlzdF9faXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiL3VzZXIvcHJvZmlsZS9cIiBjbGFzcz1cInByb2ZpbGUtbGlzdF9fbGlua1wiPtCf0YDQvtGE0LjQu9GMPC9hPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwicHJvZmlsZS1saXN0X19pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIvdXNlci9wdXJjaGFzZXMvXCIgY2xhc3M9XCJwcm9maWxlLWxpc3RfX2xpbmtcIj7Qn9C+0LrRg9C/0LrQuDwvYT5cclxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cInByb2ZpbGUtbGlzdF9faXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVwiL3VzZXIvbm90aWZpY2F0aW9uc1wiIGNsYXNzPVwicHJvZmlsZS1saXN0X19saW5rXCI+0KPQstC10LTQvtC80LvQtdC90LjRjzwvYT5cclxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cInByb2ZpbGUtbGlzdF9faXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicHJvZmlsZS1saXN0X19saW5rXCIgZGF0YS1sb2dvdXQ+0JLRi9C50YLQuDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICBgXHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJMb2dvdXQoKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhcnQgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjYXJ0JykpPy5wcm9kdWN0cyB8fCBbXVxyXG4gICAgICAgICAgICB0aGlzLiRjYXJ0LmRhdGFzZXQuY2FydENvdW50ID0gZ2V0UHJvZHVjdHNDb3VudChjYXJ0KSB8fCAnJ1xyXG4gICAgICAgICAgICB0aGlzLiRzaWduLmlubmVySFRNTCA9IGBcclxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJ1c2VyLW5hdl9fbGlua1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj1cImltZy9zdmcvc3ByaXRlLnN2ZyNzaWduLWluXCI+PC91c2U+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4+0JLQvtC50YLQuDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICBgXHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJMb2dpbk1vZGFsKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJMb2dpbk1vZGFsKCkge1xyXG4gICAgICAgIGNvbnN0ICRzaWduX2J1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy51c2VyLW5hdl9faXRlbV9zaWduJylcclxuXHJcbiAgICAgICAgJHNpZ25fYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGFsTG9naW4uY3JlYXRlKClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZWdpc3RlckxvZ291dCgpIHtcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1sb2dvdXRdJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwaVNlcnZpY2UudXNlUmVxdWVzdCh0aGlzLnJvdXRlci5sb2dvdXRMaW5rLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJywgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGJvZHk6IEpTT04uc3RyaW5naWZ5KHt9KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHRoaXMucm91dGVyLnJlZGlyZWN0TWFpbigpXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUubWVzc2FnZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBVc2VyTmF2TW9kdWxlIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/app/modules/user.nav.module.js\n')},"./source/js/app/service/button.mobile.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\nwindow.addEventListener('load', () => {\n  const $button_menu = document.querySelector('.button-menu');\n  const $overlay = document.querySelector('.page-overlay');\n  const $header_nav = document.querySelector('.page-header__nav');\n  const $page_header = document.querySelector('.page-header');\n  $button_menu.addEventListener('click', () => {\n    $header_nav.classList.toggle('page-header__nav_active');\n    $overlay.classList.toggle('page-overlay_active');\n    $button_menu.classList.toggle('button-menu_active');\n    $page_header.classList.toggle('page-header_active');\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL3NlcnZpY2UvYnV0dG9uLm1vYmlsZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2FwcC9zZXJ2aWNlL2J1dHRvbi5tb2JpbGUuanM/NDlmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcclxuICAgIGNvbnN0ICRidXR0b25fbWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5idXR0b24tbWVudScpXHJcbiAgICBjb25zdCAkb3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLW92ZXJsYXknKVxyXG4gICAgY29uc3QgJGhlYWRlcl9uYXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1oZWFkZXJfX25hdicpXHJcbiAgICBjb25zdCAkcGFnZV9oZWFkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1oZWFkZXInKVxyXG5cclxuICAgICRidXR0b25fbWVudS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAkaGVhZGVyX25hdi5jbGFzc0xpc3QudG9nZ2xlKCdwYWdlLWhlYWRlcl9fbmF2X2FjdGl2ZScpXHJcbiAgICAgICAgJG92ZXJsYXkuY2xhc3NMaXN0LnRvZ2dsZSgncGFnZS1vdmVybGF5X2FjdGl2ZScpXHJcbiAgICAgICAgJGJ1dHRvbl9tZW51LmNsYXNzTGlzdC50b2dnbGUoJ2J1dHRvbi1tZW51X2FjdGl2ZScpXHJcbiAgICAgICAgJHBhZ2VfaGVhZGVyLmNsYXNzTGlzdC50b2dnbGUoJ3BhZ2UtaGVhZGVyX2FjdGl2ZScpXHJcbiAgICB9KVxyXG59KSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/app/service/button.mobile.js\n")},"./source/js/app/service/cookie.accept.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\nwindow.addEventListener('load', () => {\n  const $cookieInfo = document.createElement('div');\n  $cookieInfo.classList.add('cookie-info');\n  if (!localStorage.getItem('cookie-warning')) {\n    $cookieInfo.innerHTML = `\n        <p class=\"cookie-info__text\">Этот сайт использует cookie для хранения данных. Продолжая использовать сайт, Вы даёте согласие на использование данной технологии.</p>\n        <button class=\"cookie-info__button\"></button>\n        `;\n    document.body.appendChild($cookieInfo);\n    document.querySelector('.cookie-info__button').addEventListener('click', () => {\n      $cookieInfo.remove();\n      localStorage.setItem('cookie-warning', JSON.stringify(true));\n    });\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL3NlcnZpY2UvY29va2llLmFjY2VwdC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2FwcC9zZXJ2aWNlL2Nvb2tpZS5hY2NlcHQuanM/YTI0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcclxuICAgIGNvbnN0ICRjb29raWVJbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgICRjb29raWVJbmZvLmNsYXNzTGlzdC5hZGQoJ2Nvb2tpZS1pbmZvJylcclxuXHJcbiAgICBpZiAoIWxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjb29raWUtd2FybmluZycpKSB7XHJcbiAgICAgICAgJGNvb2tpZUluZm8uaW5uZXJIVE1MID0gYFxyXG4gICAgICAgIDxwIGNsYXNzPVwiY29va2llLWluZm9fX3RleHRcIj7QrdGC0L7RgiDRgdCw0LnRgiDQuNGB0L/QvtC70YzQt9GD0LXRgiBjb29raWUg0LTQu9GPINGF0YDQsNC90LXQvdC40Y8g0LTQsNC90L3Ri9GFLiDQn9GA0L7QtNC+0LvQttCw0Y8g0LjRgdC/0L7Qu9GM0LfQvtCy0LDRgtGMINGB0LDQudGCLCDQktGLINC00LDRkdGC0LUg0YHQvtCz0LvQsNGB0LjQtSDQvdCwINC40YHQv9C+0LvRjNC30L7QstCw0L3QuNC1INC00LDQvdC90L7QuSDRgtC10YXQvdC+0LvQvtCz0LjQuC48L3A+XHJcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImNvb2tpZS1pbmZvX19idXR0b25cIj48L2J1dHRvbj5cclxuICAgICAgICBgXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCgkY29va2llSW5mbylcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29va2llLWluZm9fX2J1dHRvbicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAkY29va2llSW5mby5yZW1vdmUoKVxyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY29va2llLXdhcm5pbmcnLCBKU09OLnN0cmluZ2lmeSh0cnVlKSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59KSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/app/service/cookie.accept.js\n")},"./source/js/app/service/page.overlay.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\nconst $search = document.querySelector('.page-search__input');\nconst $searchIcon = document.querySelector('.page-search__icon');\nconst $searchWrapper = document.querySelector('.page-search');\nconst $searchButton = document.querySelector('.page-search__button');\nconst $overlay = document.querySelector('.page-overlay');\nconst $pageTel = document.querySelector('.page-header__tel');\nconst $buttonMenu = document.querySelector('.button-menu');\nconst $headerNav = document.querySelector('.page-header__nav');\nconst $pageHeader = document.querySelector('.page-header');\nconst $pageFilter = document.querySelector('.page-filter');\ndocument.body.addEventListener('click', e => {\n  if (e.target.closest('.page-overlay')) {\n    $buttonMenu.classList.remove('button-menu_active');\n    $pageHeader.classList.remove('page-header_active');\n    $headerNav.classList.remove('page-header__nav_active');\n    $overlay.classList.remove('page-overlay_active');\n    $pageTel.classList.remove('page-header__tel_active');\n  }\n});\nwindow.addEventListener('resize', () => {\n  if ($headerNav.classList.contains('page-header__nav_active') && window.innerWidth > 960) {\n    $overlay.classList.remove('page-overlay_active');\n    $pageHeader.classList.remove('page-header_active');\n  }\n  if ($headerNav.classList.contains('page-header__nav_active') && window.innerWidth < 960) {\n    $overlay.classList.add('page-overlay_active');\n    $pageHeader.classList.add('page-header_active');\n  }\n  if (window.innerWidth < 960 && window.innerWidth > 640 && $searchWrapper.classList.contains('page-search_active')) {\n    $pageTel.classList.add('page-header__tel_active');\n  }\n  if ($pageFilter) {\n    if (window.innerWidth > 1280 && $pageFilter.classList.contains('page-filter_active')) {\n      $pageFilter.classList.remove('page-filter_active');\n      $overlay.classList.remove('page-overlay_active');\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL3NlcnZpY2UvcGFnZS5vdmVybGF5LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2FwcC9zZXJ2aWNlL3BhZ2Uub3ZlcmxheS5qcz8xOWE1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0ICRzZWFyY2ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1zZWFyY2hfX2lucHV0JylcclxuY29uc3QgJHNlYXJjaEljb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1zZWFyY2hfX2ljb24nKVxyXG5jb25zdCAkc2VhcmNoV3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLXNlYXJjaCcpXHJcbmNvbnN0ICRzZWFyY2hCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1zZWFyY2hfX2J1dHRvbicpXHJcbmNvbnN0ICRvdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2Utb3ZlcmxheScpXHJcbmNvbnN0ICRwYWdlVGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2UtaGVhZGVyX190ZWwnKVxyXG5jb25zdCAkYnV0dG9uTWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5idXR0b24tbWVudScpXHJcbmNvbnN0ICRoZWFkZXJOYXYgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2UtaGVhZGVyX19uYXYnKVxyXG5jb25zdCAkcGFnZUhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlLWhlYWRlcicpXHJcbmNvbnN0ICRwYWdlRmlsdGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2UtZmlsdGVyJylcclxuXHJcblxyXG5cclxuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xyXG4gICAgaWYgKGUudGFyZ2V0LmNsb3Nlc3QoJy5wYWdlLW92ZXJsYXknKSkge1xyXG4gICAgICAgICRidXR0b25NZW51LmNsYXNzTGlzdC5yZW1vdmUoJ2J1dHRvbi1tZW51X2FjdGl2ZScpXHJcbiAgICAgICAgJHBhZ2VIZWFkZXIuY2xhc3NMaXN0LnJlbW92ZSgncGFnZS1oZWFkZXJfYWN0aXZlJylcclxuICAgICAgICAkaGVhZGVyTmF2LmNsYXNzTGlzdC5yZW1vdmUoJ3BhZ2UtaGVhZGVyX19uYXZfYWN0aXZlJylcclxuICAgICAgICAkb3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlLW92ZXJsYXlfYWN0aXZlJylcclxuICAgICAgICAkcGFnZVRlbC5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlLWhlYWRlcl9fdGVsX2FjdGl2ZScpXHJcbiAgICB9XHJcbn0pXHJcblxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xyXG4gICAgaWYgKCRoZWFkZXJOYXYuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYWdlLWhlYWRlcl9fbmF2X2FjdGl2ZScpICYmIHdpbmRvdy5pbm5lcldpZHRoID4gOTYwKSB7XHJcbiAgICAgICAgJG92ZXJsYXkuY2xhc3NMaXN0LnJlbW92ZSgncGFnZS1vdmVybGF5X2FjdGl2ZScpXHJcbiAgICAgICAgJHBhZ2VIZWFkZXIuY2xhc3NMaXN0LnJlbW92ZSgncGFnZS1oZWFkZXJfYWN0aXZlJylcclxuICAgIH1cclxuICAgIGlmICgkaGVhZGVyTmF2LmNsYXNzTGlzdC5jb250YWlucygncGFnZS1oZWFkZXJfX25hdl9hY3RpdmUnKSAmJiB3aW5kb3cuaW5uZXJXaWR0aCA8IDk2MCkge1xyXG4gICAgICAgICRvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ3BhZ2Utb3ZlcmxheV9hY3RpdmUnKVxyXG4gICAgICAgICRwYWdlSGVhZGVyLmNsYXNzTGlzdC5hZGQoJ3BhZ2UtaGVhZGVyX2FjdGl2ZScpXHJcbiAgICB9XHJcbiAgICBpZiAod2luZG93LmlubmVyV2lkdGggPCA5NjAgJiYgd2luZG93LmlubmVyV2lkdGggPiA2NDAgJiYgJHNlYXJjaFdyYXBwZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYWdlLXNlYXJjaF9hY3RpdmUnKSkge1xyXG4gICAgICAgICRwYWdlVGVsLmNsYXNzTGlzdC5hZGQoJ3BhZ2UtaGVhZGVyX190ZWxfYWN0aXZlJylcclxuICAgIH1cclxuICAgIGlmICgkcGFnZUZpbHRlcikge1xyXG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDEyODAgJiYgJHBhZ2VGaWx0ZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYWdlLWZpbHRlcl9hY3RpdmUnKSkge1xyXG4gICAgICAgICAgICAkcGFnZUZpbHRlci5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlLWZpbHRlcl9hY3RpdmUnKVxyXG4gICAgICAgICAgICAkb3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlLW92ZXJsYXlfYWN0aXZlJylcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/app/service/page.overlay.js\n")},"./source/js/app/service/view.catalog.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\nfunction changeProductsViewHandler() {\n  const $viewButtons = document.querySelectorAll('.view-catalog__item');\n  const $productList = document.querySelector('#products_list');\n  $viewButtons.forEach(button => {\n    button.addEventListener('click', () => {\n      $viewButtons.forEach(item => {\n        item.classList.remove('view-catalog__item_active');\n      });\n      button.classList.add('view-catalog__item_active');\n      if (button.dataset.view === 'table') {\n        $productList.classList.add('products__list_table');\n      } else {\n        $productList.classList.remove('products__list_table');\n      }\n    });\n  });\n  window.addEventListener('resize', e => {\n    if (window.innerWidth < 1280) {\n      $productList.classList.remove('products__list_table');\n      $viewButtons.forEach(item => {\n        item.classList.remove('view-catalog__item_active');\n      });\n      document.querySelector('[data-view=list]').classList.add('view-catalog__item_active');\n    }\n  });\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (changeProductsViewHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL3NlcnZpY2Uvdmlldy5jYXRhbG9nLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvYXBwL3NlcnZpY2Uvdmlldy5jYXRhbG9nLmpzPzViZDMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY2hhbmdlUHJvZHVjdHNWaWV3SGFuZGxlcigpIHtcclxuICAgIGNvbnN0ICR2aWV3QnV0dG9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy52aWV3LWNhdGFsb2dfX2l0ZW0nKVxyXG4gICAgY29uc3QgJHByb2R1Y3RMaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Byb2R1Y3RzX2xpc3QnKVxyXG5cclxuICAgICR2aWV3QnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XHJcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAkdmlld0J1dHRvbnMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgndmlldy1jYXRhbG9nX19pdGVtX2FjdGl2ZScpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCd2aWV3LWNhdGFsb2dfX2l0ZW1fYWN0aXZlJylcclxuXHJcbiAgICAgICAgICAgIGlmIChidXR0b24uZGF0YXNldC52aWV3ID09PSAndGFibGUnKSB7XHJcbiAgICAgICAgICAgICAgICAkcHJvZHVjdExpc3QuY2xhc3NMaXN0LmFkZCgncHJvZHVjdHNfX2xpc3RfdGFibGUnKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJHByb2R1Y3RMaXN0LmNsYXNzTGlzdC5yZW1vdmUoJ3Byb2R1Y3RzX19saXN0X3RhYmxlJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9KVxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIChlKSA9PiB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDwgMTI4MCkge1xyXG4gICAgICAgICAgICAkcHJvZHVjdExpc3QuY2xhc3NMaXN0LnJlbW92ZSgncHJvZHVjdHNfX2xpc3RfdGFibGUnKVxyXG4gICAgICAgICAgICAkdmlld0J1dHRvbnMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgndmlldy1jYXRhbG9nX19pdGVtX2FjdGl2ZScpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXZpZXc9bGlzdF0nKS5jbGFzc0xpc3QuYWRkKCd2aWV3LWNhdGFsb2dfX2l0ZW1fYWN0aXZlJylcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjaGFuZ2VQcm9kdWN0c1ZpZXdIYW5kbGVyIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/app/service/view.catalog.js\n")},"./source/js/app/utils/utils.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debounce: function() { return /* binding */ debounce; },\n/* harmony export */   decodeString: function() { return /* binding */ decodeString; },\n/* harmony export */   \"default\": function() { return /* binding */ scrollToTop; },\n/* harmony export */   escapeRegex: function() { return /* binding */ escapeRegex; },\n/* harmony export */   getProductsCount: function() { return /* binding */ getProductsCount; },\n/* harmony export */   getTemplateMailFeedback: function() { return /* binding */ getTemplateMailFeedback; },\n/* harmony export */   getTemplateMailSelection: function() { return /* binding */ getTemplateMailSelection; },\n/* harmony export */   getTotalPrice: function() { return /* binding */ getTotalPrice; },\n/* harmony export */   getTotalPriceWithPromo: function() { return /* binding */ getTotalPriceWithPromo; },\n/* harmony export */   lazyLoadImages: function() { return /* binding */ lazyLoadImages; },\n/* harmony export */   parseArrayToHTML: function() { return /* binding */ parseArrayToHTML; },\n/* harmony export */   parseDate: function() { return /* binding */ parseDate; },\n/* harmony export */   sanitalize: function() { return /* binding */ sanitalize; }\n/* harmony export */ });\n/* harmony import */ var _toast_ui_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @toast-ui/editor */ \"./node_modules/@toast-ui/editor/dist/esm/index.js\");\n/* harmony import */ var code_tag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! code-tag */ \"./node_modules/code-tag/dist/index.mjs\");\n\n\nconst dictionary = {\n  'original': 'оригинал',\n  'any': 'любая',\n  'substitute': 'заменитель'\n};\nfunction debounce(callee, timeoutMs) {\n  let previousCall = Date.now();\n  let lastCallTimer = null;\n  return function (...args) {\n    if (Date.now() - previousCall <= timeoutMs) {\n      clearTimeout(lastCallTimer);\n    }\n    previousCall = Date.now();\n    lastCallTimer = setTimeout(() => callee(...args), timeoutMs);\n  };\n}\nfunction lazyLoadImages(node) {\n  const images = node.querySelectorAll('img');\n  const loadImg = img => {\n    observer.unobserve(img);\n    img.src = img.dataset.src;\n    img.style.opacity = 1;\n  };\n  const observer = new IntersectionObserver(items => {\n    items.forEach(element => {\n      if (element.intersectionRatio > 0) loadImg(element.target);\n    });\n  }, {\n    root: null,\n    threshold: 0.1\n  });\n  images.forEach(img => observer.observe(img));\n}\nfunction getTotalPrice(products) {\n  return products.reduce((acc, item) => {\n    acc += item.price * item.count;\n    return acc;\n  }, 0);\n}\nfunction getTotalPriceWithPromo(products, promo = 0) {\n  let total = products.reduce((acc, item) => {\n    acc += item.price * item.count;\n    return acc;\n  }, 0);\n  total = total - promo;\n  if (total < 0) total = 0;\n  return total;\n}\nfunction parseDate(date) {\n  return new Date(date).toLocaleString('en-GB', {\n    year: 'numeric',\n    month: 'numeric',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: 'numeric',\n    second: 'numeric',\n    hour12: false\n  });\n}\nfunction getProductsCount(products) {\n  return products.reduce((acc, item) => {\n    acc += item.count;\n    return acc;\n  }, 0);\n}\nfunction sanitalize(text) {\n  if (!text) return null;\n  return text.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('\"', '&quot;').replaceAll('\\'', '&#039;');\n}\nfunction decodeString(text) {\n  if (!text) return null;\n  return text.replaceAll('&amp;', '&').replaceAll('&lt;', '<').replaceAll('&gt;', '>').replaceAll('&quot;', '\"').replaceAll('&#039;', '\\'');\n}\nfunction escapeRegex(str) {\n  if (!str) return null;\n  return str.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nfunction scrollToTop(node, type = 'smooth') {\n  let root;\n  if (typeof node === 'string') {\n    root = document.querySelector(node);\n  } else {\n    root = node;\n  }\n  root.scrollIntoView({\n    behavior: type,\n    top: true,\n    block: 'center'\n  });\n}\nfunction parseArrayToHTML(description) {\n  if (Array.isArray(description)) {\n    return description.reduce((acc, item) => {\n      const {\n        title,\n        text,\n        textList\n      } = item;\n      if (title) {\n        acc += `<h2>${title}</h2>`;\n      }\n      if (text) {\n        acc += `<p>${text}</p>`;\n      }\n      if (textList) {\n        let list = '';\n        textList.forEach(item => {\n          list += `<li>${item}</li>`;\n        });\n        acc += `<ul>${list}</ul>`;\n      }\n      return acc;\n    }, '');\n  } else {\n    const tempNode = document.createElement('div');\n    tempNode.setAttribute('id', 'editor-temp-element');\n    tempNode.style.display = 'none';\n    document.body.appendChild(tempNode);\n    const editor = new _toast_ui_editor__WEBPACK_IMPORTED_MODULE_0__.Editor({\n      el: document.querySelector('#editor-temp-element'),\n      initialEditType: 'markdown',\n      initialValue: description\n    });\n    return editor.getHTML();\n  }\n}\nfunction getTemplateMailFeedback(data) {\n  return `\n        <h2>Добрый день, уважаемый(-ая) ${data.name}</h2>\n        <p>Вы задали вопрос на нашем сайте. Его содержание - ${data.text}</p>\n        <br>\n        <p>[Текст ответа]</p>\n        <br>\n        <p>С уважением, администрация сайта autoparts.com</p>\n    `;\n}\nfunction getTemplateMailSelection(data) {\n  return `\n        <h2>Добрый день, уважаемый(-ая) ${data.name}</h2>\n        <p>Вы обратились за подбором запчастей к нашим специалистам.\n            Вы запросили деталь - ${data.detail}, тип - ${dictionary[data.partType]}, в количестве ${data.count} шт. ;\n        </p>\n        <br>\n        <p>[Текст ответа]</p>\n        <br>\n        <p>С уважением, администрация сайта autoparts.com</p>\n    `;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL3V0aWxzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QtZ3VscC8uL3NvdXJjZS9qcy9hcHAvdXRpbHMvdXRpbHMuanM/ZDU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3IsIEhUTUxNZE5vZGVDb252ZXJ0b3JNYXAgfSBmcm9tICdAdG9hc3QtdWkvZWRpdG9yJ1xyXG5pbXBvcnQgeyBodG1sIH0gZnJvbSAnY29kZS10YWcnXHJcblxyXG5jb25zdCBkaWN0aW9uYXJ5ID0ge1xyXG4gICAgJ29yaWdpbmFsJzogJ9C+0YDQuNCz0LjQvdCw0LsnLFxyXG4gICAgJ2FueSc6ICfQu9GO0LHQsNGPJyxcclxuICAgICdzdWJzdGl0dXRlJzogJ9C30LDQvNC10L3QuNGC0LXQu9GMJ1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2UoY2FsbGVlLCB0aW1lb3V0TXMpIHtcclxuICAgIGxldCBwcmV2aW91c0NhbGwgPSBEYXRlLm5vdygpXHJcbiAgICBsZXQgbGFzdENhbGxUaW1lciA9IG51bGxcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGlmICgoRGF0ZS5ub3coKSAtIHByZXZpb3VzQ2FsbCkgPD0gdGltZW91dE1zKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChsYXN0Q2FsbFRpbWVyKVxyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2aW91c0NhbGwgPSBEYXRlLm5vdygpXHJcbiAgICAgICAgbGFzdENhbGxUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gY2FsbGVlKC4uLmFyZ3MpLCB0aW1lb3V0TXMpXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXp5TG9hZEltYWdlcyhub2RlKSB7XHJcbiAgICBjb25zdCBpbWFnZXMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZycpXHJcblxyXG4gICAgY29uc3QgbG9hZEltZyA9IChpbWcpID0+IHtcclxuICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoaW1nKVxyXG4gICAgICAgIGltZy5zcmMgPSBpbWcuZGF0YXNldC5zcmNcclxuICAgICAgICBpbWcuc3R5bGUub3BhY2l0eSA9IDFcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoaXRlbXMpID0+IHtcclxuICAgICAgICBpdGVtcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5pbnRlcnNlY3Rpb25SYXRpbyA+IDApIGxvYWRJbWcoZWxlbWVudC50YXJnZXQpXHJcbiAgICAgICAgfSlcclxuICAgIH0sIHtcclxuICAgICAgICByb290OiBudWxsLFxyXG4gICAgICAgIHRocmVzaG9sZDogMC4xXHJcbiAgICB9KVxyXG5cclxuICAgIGltYWdlcy5mb3JFYWNoKGltZyA9PiBvYnNlcnZlci5vYnNlcnZlKGltZykpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3RhbFByaWNlKHByb2R1Y3RzKSB7XHJcbiAgICByZXR1cm4gcHJvZHVjdHMucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcclxuICAgICAgICBhY2MgKz0gKGl0ZW0ucHJpY2UgKiBpdGVtLmNvdW50KVxyXG4gICAgICAgIHJldHVybiBhY2NcclxuICAgIH0sIDApXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3RhbFByaWNlV2l0aFByb21vKHByb2R1Y3RzLCBwcm9tbyA9IDApIHtcclxuICAgIGxldCB0b3RhbCA9IHByb2R1Y3RzLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XHJcbiAgICAgICAgYWNjICs9IChpdGVtLnByaWNlICogaXRlbS5jb3VudClcclxuICAgICAgICByZXR1cm4gYWNjXHJcbiAgICB9LCAwKVxyXG4gICAgdG90YWwgPSB0b3RhbCAtIHByb21vXHJcbiAgICBpZiAodG90YWwgPCAwKSB0b3RhbCA9IDBcclxuICAgIHJldHVybiB0b3RhbFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGUpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKS50b0xvY2FsZVN0cmluZygnZW4tR0InLCB7XHJcbiAgICAgICAgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ251bWVyaWMnLCBkYXk6ICdudW1lcmljJyxcclxuICAgICAgICBob3VyOiAnbnVtZXJpYycsIG1pbnV0ZTogJ251bWVyaWMnLCBzZWNvbmQ6ICdudW1lcmljJyxcclxuICAgICAgICBob3VyMTI6IGZhbHNlXHJcbiAgICB9KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvZHVjdHNDb3VudChwcm9kdWN0cykge1xyXG4gICAgcmV0dXJuIHByb2R1Y3RzLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XHJcbiAgICAgICAgYWNjICs9IGl0ZW0uY291bnRcclxuICAgICAgICByZXR1cm4gYWNjXHJcbiAgICB9LCAwKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRhbGl6ZSh0ZXh0KSB7XHJcbiAgICBpZiAoIXRleHQpIHJldHVybiBudWxsXHJcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlQWxsKCcmJywgJyZhbXA7JykucmVwbGFjZUFsbCgnPCcsICcmbHQ7JykucmVwbGFjZUFsbCgnPicsICcmZ3Q7JykucmVwbGFjZUFsbCgnXCInLCAnJnF1b3Q7JykucmVwbGFjZUFsbCgnXFwnJywgJyYjMDM5OycpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmcodGV4dCkge1xyXG4gICAgaWYgKCF0ZXh0KSByZXR1cm4gbnVsbFxyXG4gICAgcmV0dXJuIHRleHQucmVwbGFjZUFsbCgnJmFtcDsnLCAnJicpLnJlcGxhY2VBbGwoJyZsdDsnLCAnPCcpLnJlcGxhY2VBbGwoJyZndDsnLCAnPicpLnJlcGxhY2VBbGwoJyZxdW90OycsICdcIicpLnJlcGxhY2VBbGwoJyYjMDM5OycsICdcXCcnKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XHJcbiAgICBpZiAoIXN0cikgcmV0dXJuIG51bGxcclxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvWy9cXC1cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJylcclxufVxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNjcm9sbFRvVG9wKG5vZGUsIHR5cGUgPSAnc21vb3RoJykge1xyXG4gICAgbGV0IHJvb3RcclxuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByb290ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihub2RlKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByb290ID0gbm9kZVxyXG4gICAgfVxyXG4gICAgcm9vdC5zY3JvbGxJbnRvVmlldyhcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJlaGF2aW9yOiB0eXBlLFxyXG4gICAgICAgICAgICB0b3A6IHRydWUsXHJcbiAgICAgICAgICAgIGJsb2NrOiAnY2VudGVyJ1xyXG4gICAgICAgIH1cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXJyYXlUb0hUTUwoZGVzY3JpcHRpb24pIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlc2NyaXB0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbi5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHRpdGxlLCB0ZXh0LCB0ZXh0TGlzdCB9ID0gaXRlbVxyXG4gICAgICAgICAgICBpZiAodGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIGFjYyArPSBgPGgyPiR7dGl0bGV9PC9oMj5gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIGFjYyArPSBgPHA+JHt0ZXh0fTwvcD5gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRleHRMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGlzdCA9ICcnXHJcbiAgICAgICAgICAgICAgICB0ZXh0TGlzdC5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QgKz0gYDxsaT4ke2l0ZW19PC9saT5gXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgYWNjICs9IGA8dWw+JHtsaXN0fTwvdWw+YFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhY2NcclxuICAgICAgICB9LCAnJylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgdGVtcE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgICAgIHRlbXBOb2RlLnNldEF0dHJpYnV0ZSgnaWQnLCAnZWRpdG9yLXRlbXAtZWxlbWVudCcpXHJcbiAgICAgICAgdGVtcE5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcE5vZGUpXHJcbiAgICAgICAgY29uc3QgZWRpdG9yID0gbmV3IEVkaXRvcih7XHJcbiAgICAgICAgICAgIGVsOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZWRpdG9yLXRlbXAtZWxlbWVudCcpLFxyXG4gICAgICAgICAgICBpbml0aWFsRWRpdFR5cGU6ICdtYXJrZG93bicsXHJcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZTogZGVzY3JpcHRpb25cclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiBlZGl0b3IuZ2V0SFRNTCgpXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUZW1wbGF0ZU1haWxGZWVkYmFjayhkYXRhKSB7XHJcbiAgICByZXR1cm4gYFxyXG4gICAgICAgIDxoMj7QlNC+0LHRgNGL0Lkg0LTQtdC90YwsINGD0LLQsNC20LDQtdC80YvQuSgt0LDRjykgJHtkYXRhLm5hbWV9PC9oMj5cclxuICAgICAgICA8cD7QktGLINC30LDQtNCw0LvQuCDQstC+0L/RgNC+0YEg0L3QsCDQvdCw0YjQtdC8INGB0LDQudGC0LUuINCV0LPQviDRgdC+0LTQtdGA0LbQsNC90LjQtSAtICR7ZGF0YS50ZXh0fTwvcD5cclxuICAgICAgICA8YnI+XHJcbiAgICAgICAgPHA+W9Ci0LXQutGB0YIg0L7RgtCy0LXRgtCwXTwvcD5cclxuICAgICAgICA8YnI+XHJcbiAgICAgICAgPHA+0KEg0YPQstCw0LbQtdC90LjQtdC8LCDQsNC00LzQuNC90LjRgdGC0YDQsNGG0LjRjyDRgdCw0LnRgtCwIGF1dG9wYXJ0cy5jb208L3A+XHJcbiAgICBgXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUZW1wbGF0ZU1haWxTZWxlY3Rpb24oZGF0YSkge1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICA8aDI+0JTQvtCx0YDRi9C5INC00LXQvdGMLCDRg9Cy0LDQttCw0LXQvNGL0LkoLdCw0Y8pICR7ZGF0YS5uYW1lfTwvaDI+XHJcbiAgICAgICAgPHA+0JLRiyDQvtCx0YDQsNGC0LjQu9C40YHRjCDQt9CwINC/0L7QtNCx0L7RgNC+0Lwg0LfQsNC/0YfQsNGB0YLQtdC5INC6INC90LDRiNC40Lwg0YHQv9C10YbQuNCw0LvQuNGB0YLQsNC8LlxyXG4gICAgICAgICAgICDQktGLINC30LDQv9GA0L7RgdC40LvQuCDQtNC10YLQsNC70YwgLSAke2RhdGEuZGV0YWlsfSwg0YLQuNC/IC0gJHtkaWN0aW9uYXJ5W2RhdGEucGFydFR5cGVdfSwg0LIg0LrQvtC70LjRh9C10YHRgtCy0LUgJHtkYXRhLmNvdW50fSDRiNGCLiA7XHJcbiAgICAgICAgPC9wPlxyXG4gICAgICAgIDxicj5cclxuICAgICAgICA8cD5b0KLQtdC60YHRgiDQvtGC0LLQtdGC0LBdPC9wPlxyXG4gICAgICAgIDxicj5cclxuICAgICAgICA8cD7QoSDRg9Cy0LDQttC10L3QuNC10LwsINCw0LTQvNC40L3QuNGB0YLRgNCw0YbQuNGPINGB0LDQudGC0LAgYXV0b3BhcnRzLmNvbTwvcD5cclxuICAgIGBcclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/app/utils/utils.js\n")},"./source/js/app/views/render.products.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": function() { return /* binding */ renderProducts; }\n/* harmony export */ });\n/* harmony import */ var code_tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! code-tag */ "./node_modules/code-tag/dist/index.mjs");\n\nfunction renderProducts(products, productClass = \'\') {\n  let view = products.map(product => {\n    const formattedAttributes = Object.entries(product.attributes).sort((prev, current) => {\n      if (Array.isArray(prev[1])) {\n        return 1;\n      } else {\n        return -1;\n      }\n    }).filter((_, index) => index <= 2);\n    return `\n            <article class="page-product ${productClass}">\n                <div class="page-product__header">\n                    <img class="page-product__img" data-src="/${product.image || \'img/assets/no_photo.jpg\'}" alt="">\n                </div>\n                <div class="page-product__content">\n                    <b class="page-product__title">${product.title}</b>\n                    <ul class="page-product__spec spec-product">\n                        ${formattedAttributes.map(item => {\n      const key = item[0];\n      let value = Array.isArray(item[1]) ? item[1].join(\', \') : item[1];\n      return `\n                                <li class="spec-product__item">\n                                    <span class="spec-product__key">${key}: </span>\n                                    <span class="spec-product__value">${value}</span>\n                                </li>`;\n    }).join(\'\')}\n                    </ul>\n                    <a href="/products/${product._id}" class="page-product__button button button_backwards-accent">Узнать\n                        цену</a>\n                </div>\n            </article>`;\n  }).join(\'\');\n  return view;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL3ZpZXdzL3JlbmRlci5wcm9kdWN0cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvYXBwL3ZpZXdzL3JlbmRlci5wcm9kdWN0cy5qcz8zM2QwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGh0bWwgfSBmcm9tICdjb2RlLXRhZydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlbmRlclByb2R1Y3RzKHByb2R1Y3RzLCBwcm9kdWN0Q2xhc3MgPSAnJykge1xyXG4gICAgbGV0IHZpZXcgPSBwcm9kdWN0cy5tYXAocHJvZHVjdCA9PiB7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkQXR0cmlidXRlcyA9IE9iamVjdC5lbnRyaWVzKHByb2R1Y3QuYXR0cmlidXRlcykuc29ydCgocHJldiwgY3VycmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcmV2WzFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDFcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkuZmlsdGVyKChfLCBpbmRleCkgPT4gaW5kZXggPD0gMilcclxuXHJcbiAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgPGFydGljbGUgY2xhc3M9XCJwYWdlLXByb2R1Y3QgJHtwcm9kdWN0Q2xhc3N9XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1wcm9kdWN0X19oZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVwicGFnZS1wcm9kdWN0X19pbWdcIiBkYXRhLXNyYz1cIi8ke3Byb2R1Y3QuaW1hZ2UgfHwgJ2ltZy9hc3NldHMvbm9fcGhvdG8uanBnJ31cIiBhbHQ9XCJcIj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtcHJvZHVjdF9fY29udGVudFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxiIGNsYXNzPVwicGFnZS1wcm9kdWN0X190aXRsZVwiPiR7cHJvZHVjdC50aXRsZX08L2I+XHJcbiAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwicGFnZS1wcm9kdWN0X19zcGVjIHNwZWMtcHJvZHVjdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAke2Zvcm1hdHRlZEF0dHJpYnV0ZXMubWFwKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaXRlbVswXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gQXJyYXkuaXNBcnJheShpdGVtWzFdKSA/IGl0ZW1bMV0uam9pbignLCAnKSA6IGl0ZW1bMV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwic3BlYy1wcm9kdWN0X19pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3BlYy1wcm9kdWN0X19rZXlcIj4ke2tleX06IDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzcGVjLXByb2R1Y3RfX3ZhbHVlXCI+JHt2YWx1ZX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIi9wcm9kdWN0cy8ke3Byb2R1Y3QuX2lkfVwiIGNsYXNzPVwicGFnZS1wcm9kdWN0X19idXR0b24gYnV0dG9uIGJ1dHRvbl9iYWNrd2FyZHMtYWNjZW50XCI+0KPQt9C90LDRgtGMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgINGG0LXQvdGDPC9hPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvYXJ0aWNsZT5gXHJcbiAgICB9KS5qb2luKCcnKVxyXG5cclxuICAgIHJldHVybiB2aWV3XHJcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/app/views/render.products.js\n')},"./source/js/app/views/render.search.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   renderSearchComplete: function() { return /* binding */ renderSearchComplete; }\n/* harmony export */ });\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils.js */ "./source/js/app/utils/utils.js");\n/* harmony import */ var code_tag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! code-tag */ "./node_modules/code-tag/dist/index.mjs");\n\n\nfunction renderSearchComplete(data, products = true) {\n  let view = \'\';\n  view += renderSearchBlock(\'Тип категории\', \'category\', data.categories, !products);\n  view += renderSearchBlock(\'Тип подкатегории\', \'subCategory\', data.subCategories, !products);\n  view += renderSearchBlock(\'Производитель\', \'maker\', data.makers, !products);\n  view += renderSearchAttributes(\'Поиск по атрибуту\', data.attributes, !products);\n  if (products) {\n    view += renderSearchProducts(\'Товары\', data.products.list);\n  }\n  if (!view) {\n    view += \'<div class="search-list__notfound">Ничего не найдено</div>\';\n  }\n  return view;\n}\nconst renderSearchBlock = (title, type, data = [], isFull) => {\n  if (!data.length) {\n    return \'\';\n  }\n  if (!isFull) {\n    data.length = 3;\n  } else {\n    data.length = 6;\n  }\n  let link = \'\';\n  return `\n        <div class="search-list__item">\n            <div class="search-list__header">\n                ${title}\n            </div>\n            ${data.reduce((acc, item) => {\n    if (type === \'maker\') {\n      link = `/search/maker?name=${item.name}`;\n    } else if (type === \'category\') {\n      link = `/catalog/${item.link}`;\n    } else if (type === \'subCategory\') {\n      link = `/catalog/${item.category.link}/${item.link}`;\n    }\n    acc += `\n                    <a href="${link}" class="search-list__body">\n                        <span class="search-list__name">${item.name}</span>\n                        <span class="search-list__count">(товаров - ${item.count})</span>\n                    </a>\n                `;\n    return acc;\n  }, \'\')}\n        </div>\n    `;\n};\nconst renderSearchAttributes = (title, data = [], isFull) => {\n  if (!data.length) {\n    return \'\';\n  }\n  if (!isFull) {\n    data.length = 2;\n  } else {\n    data.length = 6;\n  }\n  return data.reduce((acc, attr) => {\n    if (!isFull) {\n      attr.values.length = 3;\n    } else {\n      attr.values.length = 6;\n    }\n    acc += `\n            <div class="search-list__item">\n                <div class="search-list__header">\n                    ${attr.key}\n                </div>\n                ${attr.values.reduce((a, value) => {\n      const url = `/search/attributes?key=${attr.key}&value=${value.name}`;\n      a += `\n                        <a href="${url}" class="search-list__body">\n                            <span class="search-list__name">${value.name}</span>\n                            <span class="search-list__count">(товаров - ${value.count})</span>\n                        </a>\n                    `;\n      return a;\n    }, \'\')}\n            </div>`;\n    return acc;\n  }, \'\');\n};\nconst renderSearchProducts = (title, data = []) => {\n  if (!data.length) {\n    return \'\';\n  }\n  data.length = 5;\n  return `\n        <div class="search-list__item">\n            <div class="search-list__header">\n                ${title}\n            </div>\n            ${data.reduce((acc, product) => {\n    acc += `\n                    <a href="/products/${product._id}" class="search-list__body search-list__body_product">\n                    <img src="/${product.image || \'img/assets/no_photo.jpg\'}" alt="" title="${product.title}">\n                       <span class="search-list__name">${product.title}</span>\n                    </a>\n                         `;\n    return acc;\n  }, \'\')}\n        </div>\n    `;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvYXBwL3ZpZXdzL3JlbmRlci5zZWFyY2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvYXBwL3ZpZXdzL3JlbmRlci5zZWFyY2guanM/ZmMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzYW5pdGFsaXplIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXHJcbmltcG9ydCB7IGh0bWwgfSBmcm9tICdjb2RlLXRhZydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJTZWFyY2hDb21wbGV0ZShkYXRhLCBwcm9kdWN0cyA9IHRydWUpIHtcclxuICAgIGxldCB2aWV3ID0gJydcclxuXHJcbiAgICB2aWV3ICs9IHJlbmRlclNlYXJjaEJsb2NrKCfQotC40L8g0LrQsNGC0LXQs9C+0YDQuNC4JywgJ2NhdGVnb3J5JywgZGF0YS5jYXRlZ29yaWVzLCAhcHJvZHVjdHMpXHJcbiAgICB2aWV3ICs9IHJlbmRlclNlYXJjaEJsb2NrKCfQotC40L8g0L/QvtC00LrQsNGC0LXQs9C+0YDQuNC4JywgJ3N1YkNhdGVnb3J5JywgZGF0YS5zdWJDYXRlZ29yaWVzLCAhcHJvZHVjdHMpXHJcbiAgICB2aWV3ICs9IHJlbmRlclNlYXJjaEJsb2NrKCfQn9GA0L7QuNC30LLQvtC00LjRgtC10LvRjCcsICdtYWtlcicsIGRhdGEubWFrZXJzLCAhcHJvZHVjdHMpXHJcbiAgICB2aWV3ICs9IHJlbmRlclNlYXJjaEF0dHJpYnV0ZXMoJ9Cf0L7QuNGB0Log0L/QviDQsNGC0YDQuNCx0YPRgtGDJywgZGF0YS5hdHRyaWJ1dGVzLCAhcHJvZHVjdHMpXHJcbiAgICBpZiAocHJvZHVjdHMpIHtcclxuICAgICAgICB2aWV3ICs9IHJlbmRlclNlYXJjaFByb2R1Y3RzKCfQotC+0LLQsNGA0YsnLCBkYXRhLnByb2R1Y3RzLmxpc3QpXHJcbiAgICB9XHJcbiAgICBpZiAoIXZpZXcpIHtcclxuICAgICAgICB2aWV3ICs9ICc8ZGl2IGNsYXNzPVwic2VhcmNoLWxpc3RfX25vdGZvdW5kXCI+0J3QuNGH0LXQs9C+INC90LUg0L3QsNC50LTQtdC90L48L2Rpdj4nXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHJldHVybiB2aWV3XHJcblxyXG59XHJcblxyXG5jb25zdCByZW5kZXJTZWFyY2hCbG9jayA9ICh0aXRsZSwgdHlwZSwgZGF0YSA9IFtdLCBpc0Z1bGwpID0+IHtcclxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gJydcclxuICAgIH1cclxuICAgIGlmICghaXNGdWxsKSB7XHJcbiAgICAgICAgZGF0YS5sZW5ndGggPSAzXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGEubGVuZ3RoID0gNlxyXG4gICAgfVxyXG5cclxuICAgIGxldCBsaW5rID0gJydcclxuXHJcblxyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICA8ZGl2IGNsYXNzPVwic2VhcmNoLWxpc3RfX2l0ZW1cIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNlYXJjaC1saXN0X19oZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgICR7dGl0bGV9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAke2RhdGEucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnbWFrZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluayA9IGAvc2VhcmNoL21ha2VyP25hbWU9JHtpdGVtLm5hbWV9YFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2F0ZWdvcnknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluayA9IGAvY2F0YWxvZy8ke2l0ZW0ubGlua31gXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdWJDYXRlZ29yeScpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5rID0gYC9jYXRhbG9nLyR7aXRlbS5jYXRlZ29yeS5saW5rfS8ke2l0ZW0ubGlua31gXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhY2MgKz0gYFxyXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIke2xpbmt9XCIgY2xhc3M9XCJzZWFyY2gtbGlzdF9fYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNlYXJjaC1saXN0X19uYW1lXCI+JHtpdGVtLm5hbWV9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNlYXJjaC1saXN0X19jb3VudFwiPijRgtC+0LLQsNGA0L7QsiAtICR7aXRlbS5jb3VudH0pPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cclxuICAgICAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY2NcclxuICAgICAgICAgICAgfSwgJycpfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYFxyXG59XHJcblxyXG5jb25zdCByZW5kZXJTZWFyY2hBdHRyaWJ1dGVzID0gKHRpdGxlLCBkYXRhID0gW10sIGlzRnVsbCkgPT4ge1xyXG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAnJ1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0Z1bGwpIHtcclxuICAgICAgICBkYXRhLmxlbmd0aCA9IDJcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YS5sZW5ndGggPSA2XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGEucmVkdWNlKChhY2MsIGF0dHIpID0+IHtcclxuICAgICAgICBpZiAoIWlzRnVsbCkge1xyXG4gICAgICAgICAgICBhdHRyLnZhbHVlcy5sZW5ndGggPSAzXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXR0ci52YWx1ZXMubGVuZ3RoID0gNlxyXG4gICAgICAgIH1cclxuICAgICAgICBhY2MgKz0gYFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VhcmNoLWxpc3RfX2l0ZW1cIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtbGlzdF9faGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgJHthdHRyLmtleX1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgJHthdHRyLnZhbHVlcy5yZWR1Y2UoKGEsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gYC9zZWFyY2gvYXR0cmlidXRlcz9rZXk9JHthdHRyLmtleX0mdmFsdWU9JHt2YWx1ZS5uYW1lfWBcclxuICAgICAgICAgICAgICAgICAgICBhICs9IGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIiR7dXJsfVwiIGNsYXNzPVwic2VhcmNoLWxpc3RfX2JvZHlcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2VhcmNoLWxpc3RfX25hbWVcIj4ke3ZhbHVlLm5hbWV9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzZWFyY2gtbGlzdF9fY291bnRcIj4o0YLQvtCy0LDRgNC+0LIgLSAke3ZhbHVlLmNvdW50fSk8L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cclxuICAgICAgICAgICAgICAgICAgICBgXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFcclxuICAgICAgICAgICAgICAgIH0sICcnKX1cclxuICAgICAgICAgICAgPC9kaXY+YFxyXG4gICAgICAgIHJldHVybiBhY2NcclxuICAgIH0sICcnKVxyXG59XHJcblxyXG5jb25zdCByZW5kZXJTZWFyY2hQcm9kdWN0cyA9ICh0aXRsZSwgZGF0YSA9IFtdKSA9PiB7XHJcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuICcnXHJcbiAgICB9XHJcbiAgICBkYXRhLmxlbmd0aCA9IDVcclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInNlYXJjaC1saXN0X19pdGVtXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtbGlzdF9faGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICAke3RpdGxlfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgJHtkYXRhLnJlZHVjZSgoYWNjLCBwcm9kdWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhY2MgKz0gYFxyXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIvcHJvZHVjdHMvJHtwcm9kdWN0Ll9pZH1cIiBjbGFzcz1cInNlYXJjaC1saXN0X19ib2R5IHNlYXJjaC1saXN0X19ib2R5X3Byb2R1Y3RcIj5cclxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cIi8ke3Byb2R1Y3QuaW1hZ2UgfHwgJ2ltZy9hc3NldHMvbm9fcGhvdG8uanBnJ31cIiBhbHQ9XCJcIiB0aXRsZT1cIiR7cHJvZHVjdC50aXRsZX1cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNlYXJjaC1saXN0X19uYW1lXCI+JHtwcm9kdWN0LnRpdGxlfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjXHJcbiAgICAgICAgICAgIH0sICcnKX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgIGBcclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/app/views/render.search.js\n')},"./source/js/core/components/adaptive.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ElementTransporter; }\n/* harmony export */ });\nclass ElementTransporter {\n  prevWindowWidth = null;\n  appendElements(config) {\n    config.forEach(item => this.toChange(item));\n    this.prevWindowWidth = window.innerWidth;\n    window.addEventListener('resize', e => {\n      if (window.innerWidth !== this.prevWindowWidth) {\n        config.forEach(item => this.toChange(item));\n      }\n    });\n  }\n  toChange(config) {\n    const $element = document.querySelector(config.what);\n    const $where_element = document.querySelector(config.where);\n    config.breakpoints.forEach(({\n      key,\n      value\n    }) => {\n      if (key === 'less') {\n        if (window.innerWidth <= value) {\n          $where_element.insertAdjacentElement(config.pos, $element);\n        }\n      }\n      if (key === 'more') {\n        if (window.innerWidth > value) {\n          $where_element.insertAdjacentElement(config.pos, $element);\n        }\n      }\n    });\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL2FkYXB0aXZlLmNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL2FkYXB0aXZlLmNvbXBvbmVudC5qcz9jZWIxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnRUcmFuc3BvcnRlciB7XHJcbiAgICBwcmV2V2luZG93V2lkdGggPSBudWxsXHJcblxyXG4gICAgYXBwZW5kRWxlbWVudHMoY29uZmlnKSB7XHJcbiAgICAgICAgY29uZmlnLmZvckVhY2goaXRlbSA9PiB0aGlzLnRvQ2hhbmdlKGl0ZW0pKVxyXG4gICAgICAgIHRoaXMucHJldldpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGhcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCAhPT0gdGhpcy5wcmV2V2luZG93V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5mb3JFYWNoKGl0ZW0gPT4gdGhpcy50b0NoYW5nZShpdGVtKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgdG9DaGFuZ2UoY29uZmlnKSB7XHJcbiAgICAgICAgY29uc3QgJGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbmZpZy53aGF0KVxyXG4gICAgICAgIGNvbnN0ICR3aGVyZV9lbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb25maWcud2hlcmUpXHJcbiAgICAgICAgY29uZmlnLmJyZWFrcG9pbnRzLmZvckVhY2goKHsga2V5LCB2YWx1ZSB9KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdsZXNzJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDw9IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHdoZXJlX2VsZW1lbnQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KGNvbmZpZy5wb3MsICRlbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdtb3JlJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoID4gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAkd2hlcmVfZWxlbWVudC5pbnNlcnRBZGphY2VudEVsZW1lbnQoY29uZmlnLnBvcywgJGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgIH1cclxufVxyXG5cclxuXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/components/adaptive.component.js\n")},"./source/js/core/components/api.service.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\nclass ApiServiceComponent {\n  constructor(auth) {\n    this.auth = auth || null;\n  }\n  async useRequest(link, rest = {}) {\n    try {\n      if (!rest.headers) rest.headers = {};\n      rest.headers['x-csrf-token'] = this.auth.csrf;\n      const response = await fetch(link, rest);\n      return await response.json();\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  async useRequestStatus(link, rest = {}) {\n    try {\n      if (!rest.headers) rest.headers = {};\n      rest.headers['x-csrf-token'] = this.auth.csrf;\n      const response = await fetch(link, rest);\n      const data = await response.json();\n      return {\n        status: response.status,\n        data\n      };\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (ApiServiceComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL2FwaS5zZXJ2aWNlLmNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2NvcmUvY29tcG9uZW50cy9hcGkuc2VydmljZS5jb21wb25lbnQuanM/ZDk2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBBcGlTZXJ2aWNlQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcclxuICAgICAgICB0aGlzLmF1dGggPSBhdXRofHwgbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHVzZVJlcXVlc3QobGluaywgcmVzdCA9IHt9KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYoIXJlc3QuaGVhZGVycykgcmVzdC5oZWFkZXJzID0ge31cclxuICAgICAgICAgICAgcmVzdC5oZWFkZXJzWyd4LWNzcmYtdG9rZW4nXSA9IHRoaXMuYXV0aC5jc3JmXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobGluaywgcmVzdClcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyB1c2VSZXF1ZXN0U3RhdHVzKGxpbmssIHJlc3QgPSB7fSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmKCFyZXN0LmhlYWRlcnMpIHJlc3QuaGVhZGVycyA9IHt9XHJcbiAgICAgICAgICAgIHJlc3QuaGVhZGVyc1sneC1jc3JmLXRva2VuJ10gPSB0aGlzLmF1dGguY3NyZlxyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChsaW5rLCByZXN0KVxyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgIGRhdGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQXBpU2VydmljZUNvbXBvbmVudCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/components/api.service.component.js\n")},"./source/js/core/components/breadcrumbs.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\nclass BreadcrumbsComponent {\n  constructor(query) {\n    this.$node = document.querySelector(query);\n  }\n  renderMainLink() {\n    this.insertNode(`\n            <li class="breadcrumbs__item">\n                <a href="/" class="breadcrumbs__link" title="Главная">Главная</a>\n            </li>\n        `);\n  }\n  renderPath(path) {\n    this.clear();\n    this.renderMainLink();\n    let html = path.map(item => {\n      if (item === path.at(-1)) {\n        return this.renderCurrent(item);\n      } else {\n        return this.renderLink(item);\n      }\n    }).join(\'\');\n    this.$node.innerHTML += html;\n  }\n  renderLink(item) {\n    return `\n        <li class="breadcrumbs__item">\n            <a href="/${item.link}" class="breadcrumbs__link" title="${item.name}">${item.name}</a>\n        </li>\n        `;\n  }\n  renderCurrent(item) {\n    return `\n         <li class="breadcrumbs__item breadcrumbs__item_span">\n            <span title="${item.name}">${item.name}</span>\n         </li>\n        `;\n  }\n  insertNode(value) {\n    this.$node.innerHTML += value;\n  }\n  clear() {\n    this.$node.innerHTML = \'\';\n  }\n}\n/* harmony default export */ __webpack_exports__["default"] = (BreadcrumbsComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL2JyZWFkY3J1bWJzLmNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2NvcmUvY29tcG9uZW50cy9icmVhZGNydW1icy5jb21wb25lbnQuanM/ZjAwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBCcmVhZGNydW1ic0NvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSkge1xyXG4gICAgICAgIHRoaXMuJG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlck1haW5MaW5rKCkge1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0Tm9kZShgXHJcbiAgICAgICAgICAgIDxsaSBjbGFzcz1cImJyZWFkY3J1bWJzX19pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICA8YSBocmVmPVwiL1wiIGNsYXNzPVwiYnJlYWRjcnVtYnNfX2xpbmtcIiB0aXRsZT1cItCT0LvQsNCy0L3QsNGPXCI+0JPQu9Cw0LLQvdCw0Y88L2E+XHJcbiAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgYClcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJQYXRoKHBhdGgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKClcclxuICAgICAgICB0aGlzLnJlbmRlck1haW5MaW5rKClcclxuICAgICAgICBsZXQgaHRtbCA9IHBhdGgubWFwKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gcGF0aC5hdCgtMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckN1cnJlbnQoaXRlbSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlckxpbmsoaXRlbSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLmpvaW4oJycpXHJcbiAgICAgICAgdGhpcy4kbm9kZS5pbm5lckhUTUwgKz0gaHRtbFxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlckxpbmsoaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgPGxpIGNsYXNzPVwiYnJlYWRjcnVtYnNfX2l0ZW1cIj5cclxuICAgICAgICAgICAgPGEgaHJlZj1cIi8ke2l0ZW0ubGlua31cIiBjbGFzcz1cImJyZWFkY3J1bWJzX19saW5rXCIgdGl0bGU9XCIke2l0ZW0ubmFtZX1cIj4ke2l0ZW0ubmFtZX08L2E+XHJcbiAgICAgICAgPC9saT5cclxuICAgICAgICBgXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyQ3VycmVudChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgPGxpIGNsYXNzPVwiYnJlYWRjcnVtYnNfX2l0ZW0gYnJlYWRjcnVtYnNfX2l0ZW1fc3BhblwiPlxyXG4gICAgICAgICAgICA8c3BhbiB0aXRsZT1cIiR7aXRlbS5uYW1lfVwiPiR7aXRlbS5uYW1lfTwvc3Bhbj5cclxuICAgICAgICAgPC9saT5cclxuICAgICAgICBgXHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0Tm9kZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuJG5vZGUuaW5uZXJIVE1MICs9IHZhbHVlXHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy4kbm9kZS5pbm5lckhUTUwgPSAnJ1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCcmVhZGNydW1ic0NvbXBvbmVudCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/components/breadcrumbs.component.js\n')},"./source/js/core/components/button.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\nclass ButtonComponent {\n  constructor(query) {\n    this.$node = document.querySelector(query);\n    this.text = this.$node.textContent.trim();\n  }\n  setPreloaderState(type = 'white') {\n    this.$node.classList.add('buton_hidden-text');\n    if (type === 'white') {\n      this.$node.innerHTML += '<div class=\"loader loader_white\"></div>';\n    } else {\n      this.$node.innerHTML += '<div class=\"loader\"></div>';\n    }\n    this.$node.disabled = true;\n  }\n  setTextState(text = this.text) {\n    this.$node.querySelector('.loader').remove();\n    this.$node.classList.remove('buton_hidden-text');\n    this.$node.disabled = false;\n  }\n  toggleDisabled() {\n    if (this.$node.disabled) {\n      this.$node.disabled = false;\n    } else {\n      this.$node.disabled = true;\n    }\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (ButtonComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL2J1dHRvbi5jb21wb25lbnQuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2NvcmUvY29tcG9uZW50cy9idXR0b24uY29tcG9uZW50LmpzP2MzODciXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgQnV0dG9uQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy4kbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnkpXHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy4kbm9kZS50ZXh0Q29udGVudC50cmltKClcclxuICAgIH1cclxuXHJcbiAgICBzZXRQcmVsb2FkZXJTdGF0ZSh0eXBlID0gJ3doaXRlJykge1xyXG4gICAgICAgIHRoaXMuJG5vZGUuY2xhc3NMaXN0LmFkZCgnYnV0b25faGlkZGVuLXRleHQnKVxyXG4gICAgICAgIGlmICh0eXBlID09PSAnd2hpdGUnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJG5vZGUuaW5uZXJIVE1MICs9ICc8ZGl2IGNsYXNzPVwibG9hZGVyIGxvYWRlcl93aGl0ZVwiPjwvZGl2PidcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLiRub2RlLmlubmVySFRNTCArPSAnPGRpdiBjbGFzcz1cImxvYWRlclwiPjwvZGl2PidcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4kbm9kZS5kaXNhYmxlZCA9IHRydWVcclxuICAgIH1cclxuXHJcbiAgICBzZXRUZXh0U3RhdGUodGV4dCA9IHRoaXMudGV4dCkge1xyXG4gICAgICAgIHRoaXMuJG5vZGUucXVlcnlTZWxlY3RvcignLmxvYWRlcicpLnJlbW92ZSgpXHJcbiAgICAgICAgdGhpcy4kbm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdidXRvbl9oaWRkZW4tdGV4dCcpXHJcbiAgICAgICAgdGhpcy4kbm9kZS5kaXNhYmxlZCA9IGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgdG9nZ2xlRGlzYWJsZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuJG5vZGUuZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy4kbm9kZS5kaXNhYmxlZCA9IGZhbHNlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy4kbm9kZS5kaXNhYmxlZCA9IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbXBvbmVudCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/components/button.component.js\n")},"./source/js/core/components/modals/modal.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ModalComponent; }\n/* harmony export */ });\n/* harmony import */ var code_tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! code-tag */ \"./node_modules/code-tag/dist/index.mjs\");\n\nclass ModalComponent {\n  constructor({\n    selector,\n    overlay,\n    title,\n    text,\n    template,\n    closeHandler,\n    okayHandler\n  }) {\n    this.$modal = document.querySelector(selector || '.page-popup');\n    this.$overlay = document.querySelector(overlay || '.page-overlay');\n    this.template = template;\n    this.$overlay.setAttribute('data-close', '');\n    this.bindedClose = this.destroy.bind(this);\n    this.handlerChecker = this.handlerChecker.bind(this);\n    this.closeHandler = closeHandler;\n    this.okayHandler = okayHandler;\n    this.title = title;\n    this.text = text;\n  }\n  create() {\n    if (this.template === 'default') {\n      this.template = `\n                <button class=\"page-popup__close\" data-close></button>\n                <div class=\"page-popup__container\">\n                    <h2 class=\"page-popup__title\">${this.title || ''}</h2>\n                    <p class=\"page-popup__descr\" data-info>${this.text || ''}</p>\n                    <button class=\"page-popup__button button button_accent page-popup__button-close\" data-close>\n                        Закрыть\n                    </button>\n                </div>\n            `;\n    } else if (this.template === 'choise') {\n      this.template = `\n                <button class=\"page-popup__close\" data-close></button>\n                <div class=\"page-popup__container\">\n                    <h2 class=\"page-popup__title\">${this.title || ''}</h2>\n                    <p class=\"page-popup__descr\" data-info>${this.text || ''}</p>\n                    <div class=\"page-popup__row\">\n                        <button class=\"page-popup__button button button_danger\" data-okey>\n                            Да\n                        </button>\n                        <button class=\"page-popup__button button button_accent\" data-close>\n                            Нет\n                        </button>\n                    </div>\n                </div>\n            `;\n    }\n    this.$modal.innerHTML = this.template;\n    this.show();\n    document.body.addEventListener('click', this.handlerChecker);\n  }\n  async handlerChecker(e) {\n    if (e.target.dataset.close !== undefined) {\n      this.remove();\n    }\n    if (e.target.closest('[data-okey]')) {\n      if (this.okayHandler) {\n        const result = await this.okayHandler();\n        if (result) {\n          this.remove();\n        }\n      }\n    }\n  }\n  show() {\n    this.$modal.classList.add('page-popup_active');\n    this.$overlay.classList.add('page-overlay_active');\n  }\n  remove() {\n    this.$modal.classList.remove('page-popup_active');\n    this.$overlay.classList.remove('page-overlay_active');\n    this.$modal.addEventListener('transitionend', this.bindedClose);\n  }\n  destroy() {\n    this.$modal.removeEventListener('transitionend', this.bindedClose);\n    document.body.removeEventListener('click', this.handlerChecker);\n    this.$modal.innerHTML = '';\n    if (this.closeHandler) this.closeHandler();\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL21vZGFscy9tb2RhbC5jb21wb25lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL21vZGFscy9tb2RhbC5jb21wb25lbnQuanM/ZDA0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBodG1sIH0gZnJvbSAnY29kZS10YWcnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHNlbGVjdG9yLCBvdmVybGF5LCB0aXRsZSwgdGV4dCwgdGVtcGxhdGUsIGNsb3NlSGFuZGxlciwgb2theUhhbmRsZXIgfSkge1xyXG4gICAgICAgIHRoaXMuJG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvciB8fCAnLnBhZ2UtcG9wdXAnKVxyXG4gICAgICAgIHRoaXMuJG92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG92ZXJsYXkgfHwgJy5wYWdlLW92ZXJsYXknKVxyXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZVxyXG4gICAgICAgIHRoaXMuJG92ZXJsYXkuc2V0QXR0cmlidXRlKCdkYXRhLWNsb3NlJywgJycpXHJcbiAgICAgICAgdGhpcy5iaW5kZWRDbG9zZSA9IHRoaXMuZGVzdHJveS5iaW5kKHRoaXMpXHJcbiAgICAgICAgdGhpcy5oYW5kbGVyQ2hlY2tlciA9IHRoaXMuaGFuZGxlckNoZWNrZXIuYmluZCh0aGlzKVxyXG4gICAgICAgIHRoaXMuY2xvc2VIYW5kbGVyID0gY2xvc2VIYW5kbGVyXHJcbiAgICAgICAgdGhpcy5va2F5SGFuZGxlciA9IG9rYXlIYW5kbGVyXHJcbiAgICAgICAgdGhpcy50aXRsZSA9IHRpdGxlXHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dFxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZSA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSBgXHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicGFnZS1wb3B1cF9fY2xvc2VcIiBkYXRhLWNsb3NlPjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtcG9wdXBfX2NvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxoMiBjbGFzcz1cInBhZ2UtcG9wdXBfX3RpdGxlXCI+JHt0aGlzLnRpdGxlIHx8ICcnfTwvaDI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJwYWdlLXBvcHVwX19kZXNjclwiIGRhdGEtaW5mbz4ke3RoaXMudGV4dCB8fCAnJ308L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInBhZ2UtcG9wdXBfX2J1dHRvbiBidXR0b24gYnV0dG9uX2FjY2VudCBwYWdlLXBvcHVwX19idXR0b24tY2xvc2VcIiBkYXRhLWNsb3NlPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICDQl9Cw0LrRgNGL0YLRjFxyXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIGBcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGVtcGxhdGUgPT09ICdjaG9pc2UnKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSBgXHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicGFnZS1wb3B1cF9fY2xvc2VcIiBkYXRhLWNsb3NlPjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtcG9wdXBfX2NvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxoMiBjbGFzcz1cInBhZ2UtcG9wdXBfX3RpdGxlXCI+JHt0aGlzLnRpdGxlIHx8ICcnfTwvaDI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJwYWdlLXBvcHVwX19kZXNjclwiIGRhdGEtaW5mbz4ke3RoaXMudGV4dCB8fCAnJ308L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtcG9wdXBfX3Jvd1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicGFnZS1wb3B1cF9fYnV0dG9uIGJ1dHRvbiBidXR0b25fZGFuZ2VyXCIgZGF0YS1va2V5PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAg0JTQsFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInBhZ2UtcG9wdXBfX2J1dHRvbiBidXR0b24gYnV0dG9uX2FjY2VudFwiIGRhdGEtY2xvc2U+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICDQndC10YJcclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgYFxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiRtb2RhbC5pbm5lckhUTUwgPSB0aGlzLnRlbXBsYXRlXHJcbiAgICAgICAgdGhpcy5zaG93KClcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVyQ2hlY2tlcilcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBoYW5kbGVyQ2hlY2tlcihlKSB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0LmRhdGFzZXQuY2xvc2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlLnRhcmdldC5jbG9zZXN0KCdbZGF0YS1va2V5XScpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9rYXlIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm9rYXlIYW5kbGVyKClcclxuICAgICAgICAgICAgICAgIGlmKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaG93KCkge1xyXG4gICAgICAgIHRoaXMuJG1vZGFsLmNsYXNzTGlzdC5hZGQoJ3BhZ2UtcG9wdXBfYWN0aXZlJylcclxuICAgICAgICB0aGlzLiRvdmVybGF5LmNsYXNzTGlzdC5hZGQoJ3BhZ2Utb3ZlcmxheV9hY3RpdmUnKVxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZSgpIHtcclxuICAgICAgICB0aGlzLiRtb2RhbC5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlLXBvcHVwX2FjdGl2ZScpXHJcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlLW92ZXJsYXlfYWN0aXZlJylcclxuXHJcbiAgICAgICAgdGhpcy4kbW9kYWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuYmluZGVkQ2xvc2UpXHJcbiAgICB9XHJcblxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLiRtb2RhbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5iaW5kZWRDbG9zZSlcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVyQ2hlY2tlcilcclxuICAgICAgICB0aGlzLiRtb2RhbC5pbm5lckhUTUwgPSAnJ1xyXG4gICAgICAgIGlmICh0aGlzLmNsb3NlSGFuZGxlcikgdGhpcy5jbG9zZUhhbmRsZXIoKVxyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/components/modals/modal.component.js\n")},"./source/js/core/components/pagination.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var code_tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! code-tag */ \"./node_modules/code-tag/dist/index.mjs\");\n\nclass PaginationComponent {\n  constructor({\n    query,\n    onChange\n  }) {\n    this.$node = document.querySelector(query);\n    this.$list = this.$node.firstElementChild;\n    this.onChange = onChange;\n  }\n  clear() {\n    this.$list.innerHTML = '';\n  }\n  render({\n    count,\n    currentPage,\n    limit = 12\n  }) {\n    currentPage = +currentPage;\n    const pagesCount = Math.ceil(count / limit);\n    if (pagesCount === 1) return false;\n    let html = '';\n    if (pagesCount < 7) {\n      for (let i = 1; i <= pagesCount; i++) {\n        if (currentPage === i) {\n          html += this.createPaginationItem(false, i, true);\n        } else {\n          html += this.createPaginationItem(true, i);\n        }\n      }\n    } else if (currentPage >= 5 && currentPage <= pagesCount - 4) {\n      html += this.createPaginationItem(true, 1);\n      html += this.createPaginationItem(false, '...');\n      for (let i = -2; i <= 2; i++) {\n        if (i === 0) {\n          html += this.createPaginationItem(false, currentPage + i, true);\n        } else {\n          html += this.createPaginationItem(true, currentPage + i);\n        }\n      }\n      html += this.createPaginationItem(false, '...');\n      html += this.createPaginationItem(true, pagesCount);\n    } else if (currentPage > pagesCount - 4) {\n      html += this.createPaginationItem(true, 1);\n      html += this.createPaginationItem(false, '...');\n      for (let i = pagesCount - 4; i <= pagesCount; i++) {\n        if (currentPage === i) {\n          html += this.createPaginationItem(false, i, true);\n        } else {\n          html += this.createPaginationItem(true, i);\n        }\n      }\n    } else {\n      for (let i = 1; i <= 5; i++) {\n        if (currentPage === i) {\n          html += this.createPaginationItem(false, i, true);\n        } else {\n          html += this.createPaginationItem(true, i);\n        }\n      }\n      html += this.createPaginationItem(false, '...');\n      html += this.createPaginationItem(true, pagesCount);\n    }\n    this.$list.innerHTML = html;\n    this.registerHandlers();\n  }\n  registerHandlers() {\n    this.$list.querySelectorAll('button').forEach(link => {\n      link.addEventListener('click', e => {\n        e.preventDefault();\n        this.onChange(link.dataset.page);\n      });\n    });\n  }\n  createPaginationItem(isLink = true, value, active = false) {\n    if (isLink) {\n      return `\n                <li class=\"pagination__item\">\n                    <button data-page=\"${value}\" class=\"pagination__link\">${value}</button>\n                </li>`;\n    } else {\n      return `\n                <li class=\"pagination__item\">\n                    <span class=\"pagination__link ${active && 'pagination__link_active'}\">${value}</span>\n                </li>`;\n    }\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (PaginationComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL3BhZ2luYXRpb24uY29tcG9uZW50LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QtZ3VscC8uL3NvdXJjZS9qcy9jb3JlL2NvbXBvbmVudHMvcGFnaW5hdGlvbi5jb21wb25lbnQuanM/ZDlmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBodG1sIH0gZnJvbSAnY29kZS10YWcnXHJcblxyXG5jbGFzcyBQYWdpbmF0aW9uQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHsgcXVlcnksIG9uQ2hhbmdlIH0pIHtcclxuICAgICAgICB0aGlzLiRub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSlcclxuICAgICAgICB0aGlzLiRsaXN0ID0gdGhpcy4kbm9kZS5maXJzdEVsZW1lbnRDaGlsZFxyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZVxyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuJGxpc3QuaW5uZXJIVE1MID0gJydcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoeyBjb3VudCwgY3VycmVudFBhZ2UsIGxpbWl0ID0gMTIgfSkge1xyXG4gICAgICAgIGN1cnJlbnRQYWdlID0gK2N1cnJlbnRQYWdlXHJcbiAgICAgICAgY29uc3QgcGFnZXNDb3VudCA9IE1hdGguY2VpbChjb3VudCAvIGxpbWl0KVxyXG4gICAgICAgIGlmIChwYWdlc0NvdW50ID09PSAxKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgICAgbGV0IGh0bWwgPSAnJ1xyXG5cclxuICAgICAgICBpZiAocGFnZXNDb3VudCA8IDcpIHtcclxuICAgICAgICAgICAgZm9yICggbGV0IGkgPSAxOyBpIDw9IHBhZ2VzQ291bnQ7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gdGhpcy5jcmVhdGVQYWdpbmF0aW9uSXRlbShmYWxzZSwgaSwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSB0aGlzLmNyZWF0ZVBhZ2luYXRpb25JdGVtKHRydWUsIGkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQYWdlID49IDUgJiYgY3VycmVudFBhZ2UgPD0gKHBhZ2VzQ291bnQgLSA0KSkge1xyXG4gICAgICAgICAgICBodG1sICs9IHRoaXMuY3JlYXRlUGFnaW5hdGlvbkl0ZW0odHJ1ZSwgMSlcclxuICAgICAgICAgICAgaHRtbCArPSB0aGlzLmNyZWF0ZVBhZ2luYXRpb25JdGVtKGZhbHNlLCAnLi4uJylcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGxldCBpID0gLTI7IGkgPD0gMjsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMuY3JlYXRlUGFnaW5hdGlvbkl0ZW0oZmFsc2UsIChjdXJyZW50UGFnZSArIGkpLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMuY3JlYXRlUGFnaW5hdGlvbkl0ZW0odHJ1ZSwgKGN1cnJlbnRQYWdlICsgaSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaHRtbCArPSB0aGlzLmNyZWF0ZVBhZ2luYXRpb25JdGVtKGZhbHNlLCAnLi4uJylcclxuICAgICAgICAgICAgaHRtbCArPSB0aGlzLmNyZWF0ZVBhZ2luYXRpb25JdGVtKHRydWUsIHBhZ2VzQ291bnQpXHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFBhZ2UgPiAocGFnZXNDb3VudCAtIDQpKSB7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gdGhpcy5jcmVhdGVQYWdpbmF0aW9uSXRlbSh0cnVlLCAxKVxyXG4gICAgICAgICAgICBodG1sICs9IHRoaXMuY3JlYXRlUGFnaW5hdGlvbkl0ZW0oZmFsc2UsICcuLi4nKVxyXG4gICAgICAgICAgICBmb3IgKCBsZXQgaSA9IHBhZ2VzQ291bnQgLSA0OyBpIDw9IHBhZ2VzQ291bnQ7IGkrKyApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gdGhpcy5jcmVhdGVQYWdpbmF0aW9uSXRlbShmYWxzZSwgaSwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSB0aGlzLmNyZWF0ZVBhZ2luYXRpb25JdGVtKHRydWUsIGkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKCBsZXQgaSA9IDE7IGkgPD0gNTsgaSsrICkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYWdlID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSB0aGlzLmNyZWF0ZVBhZ2luYXRpb25JdGVtKGZhbHNlLCBpLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMuY3JlYXRlUGFnaW5hdGlvbkl0ZW0odHJ1ZSwgaSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBodG1sICs9IHRoaXMuY3JlYXRlUGFnaW5hdGlvbkl0ZW0oZmFsc2UsICcuLi4nKVxyXG4gICAgICAgICAgICBodG1sICs9IHRoaXMuY3JlYXRlUGFnaW5hdGlvbkl0ZW0odHJ1ZSwgcGFnZXNDb3VudClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuJGxpc3QuaW5uZXJIVE1MID0gaHRtbFxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVycygpXHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJIYW5kbGVycygpIHtcclxuICAgICAgICB0aGlzLiRsaXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKGxpbmsuZGF0YXNldC5wYWdlKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlUGFnaW5hdGlvbkl0ZW0oaXNMaW5rID0gdHJ1ZSwgdmFsdWUsIGFjdGl2ZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKGlzTGluaykge1xyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwicGFnaW5hdGlvbl9faXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGF0YS1wYWdlPVwiJHt2YWx1ZX1cIiBjbGFzcz1cInBhZ2luYXRpb25fX2xpbmtcIj4ke3ZhbHVlfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9saT5gXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cInBhZ2luYXRpb25fX2l0ZW1cIj5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInBhZ2luYXRpb25fX2xpbmsgJHthY3RpdmUgJiYgJ3BhZ2luYXRpb25fX2xpbmtfYWN0aXZlJ31cIj4ke3ZhbHVlfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvbGk+YFxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGFnaW5hdGlvbkNvbXBvbmVudCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/components/pagination.component.js\n")},"./source/js/core/components/preloader.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ PreloaderComponent; }\n/* harmony export */ });\nclass PreloaderComponent {\n  constructor(query) {\n    this.$node = document.querySelector(query);\n  }\n  show() {\n    this.$node.classList.remove('page__preloader_hide');\n  }\n  hide() {\n    document.querySelector('.page__wrapper').style.opacity = '1';\n    this.$node.classList.add('page__preloader_hide');\n    this.$node.remove();\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL3ByZWxvYWRlci5jb21wb25lbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL2NvcmUvY29tcG9uZW50cy9wcmVsb2FkZXIuY29tcG9uZW50LmpzP2Y5OGUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJlbG9hZGVyQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy4kbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocXVlcnkpXHJcbiAgICB9XHJcblxyXG4gICAgc2hvdygpIHtcclxuICAgICAgICB0aGlzLiRub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ3BhZ2VfX3ByZWxvYWRlcl9oaWRlJylcclxuICAgIH1cclxuXHJcbiAgICBoaWRlKCkge1xyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlX193cmFwcGVyJykuc3R5bGUub3BhY2l0eSA9ICcxJ1xyXG4gICAgICAgIHRoaXMuJG5vZGUuY2xhc3NMaXN0LmFkZCgncGFnZV9fcHJlbG9hZGVyX2hpZGUnKVxyXG4gICAgICAgIHRoaXMuJG5vZGUucmVtb3ZlKClcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/core/components/preloader.component.js\n")},"./source/js/core/components/router.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\nclass RouterComponent {\n  constructor() {\n    this.init();\n  }\n  init() {\n    this.url = new URL(decodeURI(window.location.href));\n  }\n  addParams(key, value) {\n    if (this.url.searchParams.has(key)) {\n      this.url.searchParams.set(key, value);\n    } else {\n      this.url.searchParams.append(key, value);\n    }\n  }\n  getUrlParams() {\n    const path = this.url.pathname;\n    const [root, tab, menu, additionalAction] = path.split('/').filter(string => string.length);\n    return {\n      root,\n      tab,\n      menu,\n      additionalAction\n    };\n  }\n  removeParam(key) {\n    this.url.searchParams.delete(key);\n  }\n  removeParams(keys) {\n    keys.forEach(key => this.url.searchParams.delete(key));\n  }\n  removeAllParams() {\n    this.url.search = '';\n  }\n  setPrevState() {\n    history.back();\n  }\n  getParam(key) {\n    return this.url.searchParams.get(key);\n  }\n  redirectUrlState(url = this.url) {\n    history.pushState(null, null, url);\n  }\n  reload() {\n    window.location.reload();\n  }\n  get params() {\n    return this.url.searchParams;\n  }\n  get apiLink() {\n    return `/api${this.url.pathname}${this.url.search}`;\n  }\n  get catalogFilter() {\n    return `/api/catalog/filters/${this.url.pathname.replace('/catalog/', '')}`;\n  }\n  redirect(path) {\n    window.location.href = path;\n  }\n  redirectMain() {\n    window.location.href = '/';\n  }\n  redirectOrder() {\n    window.location.href = '/order';\n  }\n  redirectNotFound() {\n    window.location.href = '/404';\n  }\n  get activateLink() {\n    return `/api/auth${this.url.pathname}`;\n  }\n  get recoveryLink() {\n    return `/api/auth${this.url.pathname}`;\n  }\n  get catalogLink() {\n    return `/api/catalog/list`;\n  }\n  get orderLinkParams() {\n    return `/api/order${this.url.search}`;\n  }\n  get orderLink() {\n    return `/api/order`;\n  }\n  get ordersCountLink() {\n    return `/api/order/count-orders`;\n  }\n  get salesCountLink() {\n    return `/api/order/count-sales`;\n  }\n  get passRecoveryLink() {\n    return '/api/auth/pass-recovery';\n  }\n  get logoutLink() {\n    return '/api/auth/logout';\n  }\n  get regLink() {\n    return '/api/auth/registration';\n  }\n  get loginLink() {\n    return '/api/auth/login';\n  }\n  get recoveryPasswordLink() {\n    return `/api/auth/recovery-password`;\n  }\n  get changePasswordLink() {\n    return `/api/auth/change-password`;\n  }\n  get changeProfileLink() {\n    return `/api/auth/change`;\n  }\n  get cartLink() {\n    return `/api/cart/`;\n  }\n  get productsLinkParams() {\n    return `/api/products${this.url.search}`;\n  }\n  get productsLink() {\n    return `/api/products`;\n  }\n  get cartProductsLink() {\n    return `/api/cart/get-products`;\n  }\n  get locationsLink() {\n    return '/api/locations';\n  }\n  get authInfoLink() {\n    return '/api/auth/info';\n  }\n  get selectionLink() {\n    return '/api/selection';\n  }\n  get selectionLinkParams() {\n    return `/api/selection${this.url.search}`;\n  }\n  get feedBackLinkParams() {\n    return `/api/feedback${this.url.search}`;\n  }\n  get feedBackLink() {\n    return `/api/feedback`;\n  }\n  get userOrdersLink() {\n    return '/api/auth/orders';\n  }\n  get searchLink() {\n    return '/api/search';\n  }\n  get searchMakerLink() {\n    return '/api/search/maker';\n  }\n  get searchAttributesLink() {\n    return '/api/search/attributes';\n  }\n  get userNotificationsLink() {\n    return '/api/auth/notifications';\n  }\n  get isProfilePage() {\n    return this.url.pathname.startsWith('/user');\n  }\n  get categoriesLinkParams() {\n    return `/api/categories${this.url.search}`;\n  }\n  get categoriesLink() {\n    return `/api/categories`;\n  }\n  get subcategoriesLinkParams() {\n    return `/api/subcategories${this.url.search}`;\n  }\n  get subcategoriesLink() {\n    return `/api/subcategories`;\n  }\n  productsDescriptionsSearch(value) {\n    return `/api/products_descriptions?title=${value}`;\n  }\n  get productsDescriptionsLink() {\n    return `/api/products_descriptions`;\n  }\n  get productsDescriptionsLinkParams() {\n    return `/api/products_descriptions${this.url.search}`;\n  }\n  get providerLink() {\n    return '/api/products_providers';\n  }\n  get stocksLink() {\n    return '/api/products_stocks';\n  }\n  get makersLink() {\n    return '/api/products_makers';\n  }\n  get usersLinkParams() {\n    return `/api/users${this.url.search}`;\n  }\n  get usersLink() {\n    return `/api/users`;\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (RouterComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL3JvdXRlci5jb21wb25lbnQuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL3JvdXRlci5jb21wb25lbnQuanM/MmIxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBSb3V0ZXJDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0KClcclxuICAgIH1cclxuXHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIHRoaXMudXJsID0gbmV3IFVSTChkZWNvZGVVUkkod2luZG93LmxvY2F0aW9uLmhyZWYpKVxyXG4gICAgfVxyXG5cclxuICAgIGFkZFBhcmFtcyhrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudXJsLnNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRVcmxQYXJhbXMoKSB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMudXJsLnBhdGhuYW1lXHJcbiAgICAgICAgY29uc3QgW3Jvb3QsIHRhYiwgbWVudSwgYWRkaXRpb25hbEFjdGlvbl0gPSBwYXRoLnNwbGl0KCcvJykuZmlsdGVyKHN0cmluZyA9PiBzdHJpbmcubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJvb3QsIHRhYiwgbWVudSwgYWRkaXRpb25hbEFjdGlvblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVQYXJhbShrZXkpIHtcclxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKGtleSlcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVQYXJhbXMoa2V5cykge1xyXG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy51cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShrZXkpKVxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZUFsbFBhcmFtcygpIHtcclxuICAgICAgICB0aGlzLnVybC5zZWFyY2ggPSAnJ1xyXG4gICAgfVxyXG5cclxuICAgIHNldFByZXZTdGF0ZSgpIHtcclxuICAgICAgICBoaXN0b3J5LmJhY2soKVxyXG4gICAgfVxyXG5cclxuICAgIGdldFBhcmFtKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSlcclxuICAgIH1cclxuXHJcbiAgICByZWRpcmVjdFVybFN0YXRlKHVybCA9IHRoaXMudXJsKSB7XHJcbiAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgdXJsKVxyXG4gICAgfVxyXG5cclxuICAgIHJlbG9hZCgpIHtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcclxuICAgIH1cclxuXHJcbiAgICBnZXQgcGFyYW1zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVybC5zZWFyY2hQYXJhbXNcclxuICAgIH1cclxuXHJcbiAgICBnZXQgYXBpTGluaygpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkke3RoaXMudXJsLnBhdGhuYW1lfSR7dGhpcy51cmwuc2VhcmNofWBcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY2F0YWxvZ0ZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkvY2F0YWxvZy9maWx0ZXJzLyR7dGhpcy51cmwucGF0aG5hbWUucmVwbGFjZSgnL2NhdGFsb2cvJywgJycpfWBcclxuICAgIH1cclxuXHJcbiAgICByZWRpcmVjdChwYXRoKSB7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBwYXRoXHJcbiAgICB9XHJcblxyXG4gICAgcmVkaXJlY3RNYWluKCkge1xyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy8nXHJcbiAgICB9XHJcblxyXG4gICAgcmVkaXJlY3RPcmRlcigpIHtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvb3JkZXInXHJcbiAgICB9XHJcblxyXG4gICAgcmVkaXJlY3ROb3RGb3VuZCgpIHtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvNDA0J1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBhY3RpdmF0ZUxpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAvYXBpL2F1dGgke3RoaXMudXJsLnBhdGhuYW1lfWBcclxuICAgIH1cclxuXHJcbiAgICBnZXQgcmVjb3ZlcnlMaW5rKCkge1xyXG4gICAgICAgIHJldHVybiBgL2FwaS9hdXRoJHt0aGlzLnVybC5wYXRobmFtZX1gXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGNhdGFsb2dMaW5rKCkge1xyXG4gICAgICAgIHJldHVybiBgL2FwaS9jYXRhbG9nL2xpc3RgXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldCBvcmRlckxpbmtQYXJhbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAvYXBpL29yZGVyJHt0aGlzLnVybC5zZWFyY2h9YFxyXG4gICAgfVxyXG5cclxuICAgIGdldCBvcmRlckxpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAvYXBpL29yZGVyYFxyXG4gICAgfVxyXG5cclxuICAgIGdldCBvcmRlcnNDb3VudExpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAvYXBpL29yZGVyL2NvdW50LW9yZGVyc2BcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2FsZXNDb3VudExpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAvYXBpL29yZGVyL2NvdW50LXNhbGVzYFxyXG4gICAgfVxyXG5cclxuICAgIGdldCBwYXNzUmVjb3ZlcnlMaW5rKCkge1xyXG4gICAgICAgIHJldHVybiAnL2FwaS9hdXRoL3Bhc3MtcmVjb3ZlcnknXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGxvZ291dExpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuICcvYXBpL2F1dGgvbG9nb3V0J1xyXG4gICAgfVxyXG5cclxuICAgIGdldCByZWdMaW5rKCkge1xyXG4gICAgICAgIHJldHVybiAnL2FwaS9hdXRoL3JlZ2lzdHJhdGlvbidcclxuICAgIH1cclxuXHJcbiAgICBnZXQgbG9naW5MaW5rKCkge1xyXG4gICAgICAgIHJldHVybiAnL2FwaS9hdXRoL2xvZ2luJ1xyXG4gICAgfVxyXG5cclxuICAgIGdldCByZWNvdmVyeVBhc3N3b3JkTGluaygpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkvYXV0aC9yZWNvdmVyeS1wYXNzd29yZGBcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY2hhbmdlUGFzc3dvcmRMaW5rKCkge1xyXG4gICAgICAgIHJldHVybiBgL2FwaS9hdXRoL2NoYW5nZS1wYXNzd29yZGBcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY2hhbmdlUHJvZmlsZUxpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAvYXBpL2F1dGgvY2hhbmdlYFxyXG4gICAgfVxyXG5cclxuICAgIGdldCBjYXJ0TGluaygpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkvY2FydC9gXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHByb2R1Y3RzTGlua1BhcmFtcygpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkvcHJvZHVjdHMke3RoaXMudXJsLnNlYXJjaH1gXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHByb2R1Y3RzTGluaygpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkvcHJvZHVjdHNgXHJcbiAgICB9XHJcbiAgICBnZXQgY2FydFByb2R1Y3RzTGluaygpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkvY2FydC9nZXQtcHJvZHVjdHNgXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGxvY2F0aW9uc0xpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuICcvYXBpL2xvY2F0aW9ucydcclxuICAgIH1cclxuXHJcbiAgICBnZXQgYXV0aEluZm9MaW5rKCkge1xyXG4gICAgICAgIHJldHVybiAnL2FwaS9hdXRoL2luZm8nXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHNlbGVjdGlvbkxpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuICcvYXBpL3NlbGVjdGlvbidcclxuICAgIH1cclxuICAgIGdldCBzZWxlY3Rpb25MaW5rUGFyYW1zKCkge1xyXG4gICAgICAgIHJldHVybiBgL2FwaS9zZWxlY3Rpb24ke3RoaXMudXJsLnNlYXJjaH1gXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGZlZWRCYWNrTGlua1BhcmFtcygpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkvZmVlZGJhY2ske3RoaXMudXJsLnNlYXJjaH1gXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGZlZWRCYWNrTGluaygpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkvZmVlZGJhY2tgXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHVzZXJPcmRlcnNMaW5rKCkge1xyXG4gICAgICAgIHJldHVybiAnL2FwaS9hdXRoL29yZGVycydcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2VhcmNoTGluaygpIHtcclxuICAgICAgICByZXR1cm4gJy9hcGkvc2VhcmNoJ1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBzZWFyY2hNYWtlckxpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuICcvYXBpL3NlYXJjaC9tYWtlcidcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2VhcmNoQXR0cmlidXRlc0xpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuICcvYXBpL3NlYXJjaC9hdHRyaWJ1dGVzJ1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB1c2VyTm90aWZpY2F0aW9uc0xpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuICcvYXBpL2F1dGgvbm90aWZpY2F0aW9ucydcclxuICAgIH1cclxuXHJcbiAgICBnZXQgaXNQcm9maWxlUGFnZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cmwucGF0aG5hbWUuc3RhcnRzV2l0aCgnL3VzZXInKVxyXG4gICAgfVxyXG5cclxuICAgIGdldCBjYXRlZ29yaWVzTGlua1BhcmFtcygpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkvY2F0ZWdvcmllcyR7dGhpcy51cmwuc2VhcmNofWBcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY2F0ZWdvcmllc0xpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAvYXBpL2NhdGVnb3JpZXNgXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHN1YmNhdGVnb3JpZXNMaW5rUGFyYW1zKCkge1xyXG4gICAgICAgIHJldHVybiBgL2FwaS9zdWJjYXRlZ29yaWVzJHt0aGlzLnVybC5zZWFyY2h9YFxyXG4gICAgfVxyXG5cclxuICAgIGdldCBzdWJjYXRlZ29yaWVzTGluaygpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkvc3ViY2F0ZWdvcmllc2BcclxuICAgIH1cclxuXHJcbiAgICBwcm9kdWN0c0Rlc2NyaXB0aW9uc1NlYXJjaCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBgL2FwaS9wcm9kdWN0c19kZXNjcmlwdGlvbnM/dGl0bGU9JHt2YWx1ZX1gXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHByb2R1Y3RzRGVzY3JpcHRpb25zTGluaygpIHtcclxuICAgICAgICByZXR1cm4gYC9hcGkvcHJvZHVjdHNfZGVzY3JpcHRpb25zYFxyXG4gICAgfVxyXG5cclxuICAgIGdldCBwcm9kdWN0c0Rlc2NyaXB0aW9uc0xpbmtQYXJhbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAvYXBpL3Byb2R1Y3RzX2Rlc2NyaXB0aW9ucyR7dGhpcy51cmwuc2VhcmNofWBcclxuICAgIH1cclxuXHJcbiAgICBnZXQgcHJvdmlkZXJMaW5rKCkge1xyXG4gICAgICAgIHJldHVybiAnL2FwaS9wcm9kdWN0c19wcm92aWRlcnMnXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHN0b2Nrc0xpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuICcvYXBpL3Byb2R1Y3RzX3N0b2NrcydcclxuICAgIH1cclxuXHJcbiAgICBnZXQgbWFrZXJzTGluaygpIHtcclxuICAgICAgICByZXR1cm4gJy9hcGkvcHJvZHVjdHNfbWFrZXJzJ1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB1c2Vyc0xpbmtQYXJhbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAvYXBpL3VzZXJzJHt0aGlzLnVybC5zZWFyY2h9YFxyXG4gICAgfVxyXG5cclxuICAgIGdldCB1c2Vyc0xpbmsoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAvYXBpL3VzZXJzYFxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUm91dGVyQ29tcG9uZW50Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/core/components/router.component.js\n")},"./source/js/core/components/selectsinputs/multiselect.input.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\nclass MultiSelectComponent {\n  constructor({\n    query,\n    type,\n    optionList,\n    addObserver,\n    deleteObserver\n  }) {\n    this.$node = document.querySelector(query);\n    this.$body = this.$node.querySelector('[data-select-body]');\n    this.$selectedListNode = this.$node.querySelector('[data-select-list]');\n    this.$arrowIcon = this.$node.querySelector('[data-select-arrow]');\n    this.$field = this.$node.querySelector('[data-input]');\n    this.addObserver = addObserver || new Function();\n    this.removeObserver = deleteObserver || new Function();\n    this.optionList = optionList;\n    this.query = query;\n    this.type = type;\n    this.selectedList = [];\n  }\n  init() {\n    this.registerHandlers();\n  }\n  render() {\n    this.renderSuggestionsList(this.optionList);\n  }\n  registerHandlers() {\n    document.body.addEventListener('click', e => {\n      if (!e.target.closest(this.query) && !e.target.classList.contains('select__item') && !e.target.closest('.select__added-item')) {\n        this.close();\n      }\n    });\n    this.$node.addEventListener('click', ({\n      target\n    }) => {\n      if (target === this.$arrowIcon) {\n        if (this.$body.querySelectorAll('.select__item').length) {\n          this.$node.classList.toggle('select_active');\n        }\n      }\n      if (target === this.$field) {\n        this.open();\n      }\n      if (target.classList.contains('select__item')) {\n        this.selectItem(target.textContent.trim());\n      }\n      if (target.closest('.select__added-item')) {\n        this.removeItem(target.closest('.select__added-item').textContent.trim());\n      }\n    });\n    this.$field.addEventListener('input', e => {\n      this.searchController();\n    });\n  }\n  searchController(target = this.$field) {\n    let searchValue = target.value.trim().toLowerCase();\n    let data = this.optionList.filter(item => item.value.toLowerCase().includes(searchValue));\n    this.open();\n    this.renderSuggestionsList(data);\n    this.renderSelectedList();\n  }\n  renderSuggestionsList(list) {\n    if (!list.length) {\n      this.$body.innerHTML = `<span class=\"select__notfound\">Ничего не найдено...</span>`;\n      return;\n    }\n    this.$body.innerHTML = '';\n    list.forEach(item => {\n      if (!this.selectedList.includes(item.value)) {\n        this.$body.innerHTML += `<li class=\"select__item\" data-select-item data-value=\"${item.dataset}\">${item.value}</li>`;\n      }\n    });\n  }\n  hasItem(value) {\n    return this.optionList.find(item => item.value === value);\n  }\n  removeItem(content, handler = true) {\n    this.selectedList = this.selectedList.filter(item => item !== content);\n    this.searchController();\n    // this.showSelectedList()\n    // this.renderSelectedList()\n    this.open();\n    if (handler) this.removeObserver({\n      type: this.type,\n      value: content\n    });\n  }\n  selectItem(content, handler = true) {\n    this.selectedList.push(content);\n    this.searchController();\n    // this.showSelectedList()\n    // this.renderSelectedList()\n    if (handler) this.addObserver({\n      type: this.type,\n      value: content\n    });\n  }\n  renderSelectedList() {\n    if (this.selectedList.length) {\n      if (this.selectedList.length === this.optionList.length) {\n        this.close();\n      }\n      this.showSelectedList();\n    } else {\n      this.hideSelectedList();\n    }\n    this.$selectedListNode.innerHTML = '';\n    this.selectedList.forEach(content => {\n      this.$selectedListNode.innerHTML += `\n            <li class=\"select__added-item\">\n                ${content}\n                <svg>\n                    <use xlink:href=\"img/svg/sprite.svg#close\"></use>\n                </svg>\n            </li>\n            `;\n    });\n  }\n  open() {\n    this.$node.classList.add('select_active');\n  }\n  close() {\n    this.$node.classList.remove('select_active');\n  }\n  showSelectedList() {\n    this.$selectedListNode.classList.add('select__added-list_active');\n  }\n  hideSelectedList() {\n    this.$selectedListNode.classList.remove('select__added-list_active');\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (MultiSelectComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL3NlbGVjdHNpbnB1dHMvbXVsdGlzZWxlY3QuaW5wdXQuY29tcG9uZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL3NlbGVjdHNpbnB1dHMvbXVsdGlzZWxlY3QuaW5wdXQuY29tcG9uZW50LmpzP2RhZDMiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTXVsdGlTZWxlY3RDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoeyBxdWVyeSwgdHlwZSwgb3B0aW9uTGlzdCwgYWRkT2JzZXJ2ZXIsIGRlbGV0ZU9ic2VydmVyIH0pIHtcclxuICAgICAgICB0aGlzLiRub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihxdWVyeSlcclxuICAgICAgICB0aGlzLiRib2R5ID0gdGhpcy4kbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zZWxlY3QtYm9keV0nKVxyXG4gICAgICAgIHRoaXMuJHNlbGVjdGVkTGlzdE5vZGUgPSB0aGlzLiRub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNlbGVjdC1saXN0XScpXHJcbiAgICAgICAgdGhpcy4kYXJyb3dJY29uID0gdGhpcy4kbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1zZWxlY3QtYXJyb3ddJylcclxuICAgICAgICB0aGlzLiRmaWVsZCA9IHRoaXMuJG5vZGUucXVlcnlTZWxlY3RvcignW2RhdGEtaW5wdXRdJylcclxuICAgICAgICB0aGlzLmFkZE9ic2VydmVyID0gYWRkT2JzZXJ2ZXIgfHwgbmV3IEZ1bmN0aW9uKClcclxuICAgICAgICB0aGlzLnJlbW92ZU9ic2VydmVyID0gZGVsZXRlT2JzZXJ2ZXIgfHwgbmV3IEZ1bmN0aW9uKClcclxuICAgICAgICB0aGlzLm9wdGlvbkxpc3QgPSBvcHRpb25MaXN0XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZVxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRMaXN0ID0gW11cclxuICAgIH1cclxuXHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVycygpXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyU3VnZ2VzdGlvbnNMaXN0KHRoaXMub3B0aW9uTGlzdClcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3RlckhhbmRsZXJzKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcclxuICAgICAgICAgICAgaWYgKCFlLnRhcmdldC5jbG9zZXN0KHRoaXMucXVlcnkpICYmXHJcbiAgICAgICAgICAgICAgICAhZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RfX2l0ZW0nKSAmJlxyXG4gICAgICAgICAgICAgICAgIWUudGFyZ2V0LmNsb3Nlc3QoJy5zZWxlY3RfX2FkZGVkLWl0ZW0nKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLiRub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKHsgdGFyZ2V0IH0pID0+IHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy4kYXJyb3dJY29uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4kYm9keS5xdWVyeVNlbGVjdG9yQWxsKCcuc2VsZWN0X19pdGVtJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbm9kZS5jbGFzc0xpc3QudG9nZ2xlKCdzZWxlY3RfYWN0aXZlJylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB0aGlzLiRmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0X19pdGVtJykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0SXRlbSh0YXJnZXQudGV4dENvbnRlbnQudHJpbSgpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQuY2xvc2VzdCgnLnNlbGVjdF9fYWRkZWQtaXRlbScpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUl0ZW0odGFyZ2V0LmNsb3Nlc3QoJy5zZWxlY3RfX2FkZGVkLWl0ZW0nKS50ZXh0Q29udGVudC50cmltKCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuJGZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZWFyY2hDb250cm9sbGVyKClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHNlYXJjaENvbnRyb2xsZXIodGFyZ2V0ID0gdGhpcy4kZmllbGQpIHtcclxuICAgICAgICBsZXQgc2VhcmNoVmFsdWUgPSB0YXJnZXQudmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKClcclxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMub3B0aW9uTGlzdC5maWx0ZXIoaXRlbSA9PiBpdGVtLnZhbHVlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVmFsdWUpKVxyXG4gICAgICAgIHRoaXMub3BlbigpXHJcbiAgICAgICAgdGhpcy5yZW5kZXJTdWdnZXN0aW9uc0xpc3QoZGF0YSlcclxuICAgICAgICB0aGlzLnJlbmRlclNlbGVjdGVkTGlzdCgpXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyU3VnZ2VzdGlvbnNMaXN0KGxpc3QpIHtcclxuICAgICAgICBpZiAoIWxpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGJvZHkuaW5uZXJIVE1MID0gYDxzcGFuIGNsYXNzPVwic2VsZWN0X19ub3Rmb3VuZFwiPtCd0LjRh9C10LPQviDQvdC1INC90LDQudC00LXQvdC+Li4uPC9zcGFuPmBcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuJGJvZHkuaW5uZXJIVE1MID0gJydcclxuICAgICAgICBsaXN0LmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RlZExpc3QuaW5jbHVkZXMoaXRlbS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGJvZHkuaW5uZXJIVE1MICs9IGA8bGkgY2xhc3M9XCJzZWxlY3RfX2l0ZW1cIiBkYXRhLXNlbGVjdC1pdGVtIGRhdGEtdmFsdWU9XCIke2l0ZW0uZGF0YXNldH1cIj4ke2l0ZW0udmFsdWV9PC9saT5gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGhhc0l0ZW0odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25MaXN0LmZpbmQoaXRlbSA9PiBpdGVtLnZhbHVlID09PSB2YWx1ZSlcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVJdGVtKGNvbnRlbnQsIGhhbmRsZXIgPSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZExpc3QgPSB0aGlzLnNlbGVjdGVkTGlzdC5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSBjb250ZW50KVxyXG5cclxuICAgICAgICB0aGlzLnNlYXJjaENvbnRyb2xsZXIoKVxyXG4gICAgICAgIC8vIHRoaXMuc2hvd1NlbGVjdGVkTGlzdCgpXHJcbiAgICAgICAgLy8gdGhpcy5yZW5kZXJTZWxlY3RlZExpc3QoKVxyXG4gICAgICAgIHRoaXMub3BlbigpXHJcbiAgICAgICAgaWYgKGhhbmRsZXIpIHRoaXMucmVtb3ZlT2JzZXJ2ZXIoeyB0eXBlOiB0aGlzLnR5cGUsIHZhbHVlOiBjb250ZW50IH0pXHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0SXRlbShjb250ZW50LCBoYW5kbGVyID0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRMaXN0LnB1c2goY29udGVudClcclxuXHJcbiAgICAgICAgdGhpcy5zZWFyY2hDb250cm9sbGVyKClcclxuICAgICAgICAvLyB0aGlzLnNob3dTZWxlY3RlZExpc3QoKVxyXG4gICAgICAgIC8vIHRoaXMucmVuZGVyU2VsZWN0ZWRMaXN0KClcclxuICAgICAgICBpZiAoaGFuZGxlcikgdGhpcy5hZGRPYnNlcnZlcih7IHR5cGU6IHRoaXMudHlwZSwgdmFsdWU6IGNvbnRlbnQgfSlcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJTZWxlY3RlZExpc3QoKSB7XHJcbiAgICAgICAgaWYodGhpcy5zZWxlY3RlZExpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc2VsZWN0ZWRMaXN0Lmxlbmd0aCA9PT0gdGhpcy5vcHRpb25MaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaG93U2VsZWN0ZWRMaXN0KClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVTZWxlY3RlZExpc3QoKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiRzZWxlY3RlZExpc3ROb2RlLmlubmVySFRNTCA9ICcnXHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZExpc3QuZm9yRWFjaChjb250ZW50ID0+IHtcclxuICAgICAgICAgICAgdGhpcy4kc2VsZWN0ZWRMaXN0Tm9kZS5pbm5lckhUTUwgKz0gYFxyXG4gICAgICAgICAgICA8bGkgY2xhc3M9XCJzZWxlY3RfX2FkZGVkLWl0ZW1cIj5cclxuICAgICAgICAgICAgICAgICR7Y29udGVudH1cclxuICAgICAgICAgICAgICAgIDxzdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPVwiaW1nL3N2Zy9zcHJpdGUuc3ZnI2Nsb3NlXCI+PC91c2U+XHJcbiAgICAgICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgYFxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgb3BlbigpIHtcclxuICAgICAgICB0aGlzLiRub2RlLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdF9hY3RpdmUnKVxyXG4gICAgfVxyXG5cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMuJG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0X2FjdGl2ZScpXHJcbiAgICB9XHJcblxyXG4gICAgc2hvd1NlbGVjdGVkTGlzdCgpIHtcclxuICAgICAgICB0aGlzLiRzZWxlY3RlZExpc3ROb2RlLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdF9fYWRkZWQtbGlzdF9hY3RpdmUnKVxyXG4gICAgfVxyXG5cclxuICAgIGhpZGVTZWxlY3RlZExpc3QoKSB7XHJcbiAgICAgICAgdGhpcy4kc2VsZWN0ZWRMaXN0Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RfX2FkZGVkLWxpc3RfYWN0aXZlJylcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTXVsdGlTZWxlY3RDb21wb25lbnQiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/core/components/selectsinputs/multiselect.input.component.js\n")},"./source/js/core/components/selectsinputs/select.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SelectComponent; }\n/* harmony export */ });\nclass SelectComponent {\n  constructor({\n    query,\n    data,\n    onselect,\n    key\n  }) {\n    this.onselect = onselect;\n    this.data = data;\n    this.selector = query;\n    this.key = key;\n    this.$select = document.querySelector(query);\n    this.$header = this.$select.querySelector('.select__header');\n    this.$title = this.$select.querySelector('.select__title');\n    this.$body = this.$select.querySelector('.select__body');\n    this.isRendered = false;\n    this.disabled = false;\n  }\n  init() {\n    this.$header.addEventListener('click', e => {\n      if (this.$select.classList.contains('select_active')) {\n        this.close();\n      } else {\n        this.open();\n      }\n    });\n    document.body.addEventListener('click', e => {\n      if (!e.target.closest(this.selector)) {\n        this.close();\n      }\n    });\n    this.registerHandlers();\n  }\n  registerHandlers() {\n    this.$items = this.$body.querySelectorAll('.select__item');\n    this.$items.forEach(element => {\n      element.addEventListener('click', () => {\n        this.$items.forEach(element => {\n          element.classList.remove('select__item_current');\n        });\n        element.classList.add('select__item_current');\n        this.data = this.data.map(item => {\n          item.default = false;\n          return item;\n        });\n        const index = this.data.findIndex(item => item.dataset === element.dataset.value);\n        this.data[index].default = true;\n        this.setTitle(element.textContent);\n        if (this.onselect) {\n          this.removeError();\n          this.onselect({\n            text: element.value || element.textContent,\n            value: element.dataset.value\n          });\n        }\n        this.close();\n      });\n    });\n  }\n  render() {\n    this.renderBody(this.data);\n    if (!this.isRendered) {\n      this.init();\n      this.isRendered = true;\n    } else {\n      this.registerHandlers();\n    }\n    let defaultValue = this.data.find(item => item.default === true)?.value || '';\n    if (defaultValue) {\n      this.setTitle(defaultValue);\n    }\n  }\n  renderBody(data) {\n    if (this.disabled) return;\n    this.$body.innerHTML = '';\n    if (!data.length) {\n      this.$body.innerHTML = '<div class=\"select__notfound\">Ничего не найдено...</div>';\n    }\n    data.map(item => {\n      if (item.default) {\n        this.$body.innerHTML += `<li class=\"select__item select__item_current\" data-value=\"${item.dataset}\">${item.value}</li>`;\n      } else {\n        this.$body.innerHTML += `<li class=\"select__item\" data-value=\"${item.dataset}\">${item.value}</li>`;\n      }\n    });\n  }\n  changeState(value) {\n    const index = this.data.findIndex(item => item.dataset === value);\n    if (index < 0) {\n      return;\n    }\n    this.data.forEach(item => item.default = false);\n    this.data[index].default = true;\n    this.render();\n  }\n  setTitle(value) {\n    this.$title.textContent = value;\n    this.data = this.data.map(item => {\n      item.default = false;\n      return item;\n    });\n    const dataItem = this.data.find(item => item.value === value);\n    if (dataItem) {\n      dataItem.default = true;\n    }\n    const $node = Array.from(this.$items).find(item => dataItem.dataset === item.dataset.value);\n    this.$items.forEach(element => {\n      element.classList.remove('select__item_current');\n    });\n    $node.classList.add('select__item_current');\n  }\n  setDefault(dataset) {\n    this.data = this.data.map(item => {\n      item.default = false;\n      return item;\n    });\n    const index = this.data.findIndex(item => item.dataset === dataset);\n    if (index > -1) {\n      this.data[index].default = true;\n    }\n  }\n  open() {\n    if (this.disabled) return;\n    this.$select.classList.add('select_active');\n  }\n  close() {\n    this.$select.classList.remove('select_active');\n  }\n  getValue() {\n    return this.data.find(item => item?.default === true)?.dataset;\n  }\n  showError(text) {\n    const $fieldBlock = this.$select.closest('.field-block');\n    if ($fieldBlock) {\n      const $error = $fieldBlock.querySelector('.field-block__undertext_error');\n      if ($error) $error.innerHTML = text;\n    }\n  }\n  removeError() {\n    const $fieldBlock = this.$select.closest('.field-block');\n    if ($fieldBlock) {\n      const $error = $fieldBlock.querySelector('.field-block__undertext_error');\n      if ($error) $error.innerHTML = '';\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL3NlbGVjdHNpbnB1dHMvc2VsZWN0LmNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QtZ3VscC8uL3NvdXJjZS9qcy9jb3JlL2NvbXBvbmVudHMvc2VsZWN0c2lucHV0cy9zZWxlY3QuY29tcG9uZW50LmpzP2JiNDUiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHF1ZXJ5LCBkYXRhLCBvbnNlbGVjdCwga2V5IH0pIHtcclxuICAgICAgICB0aGlzLm9uc2VsZWN0ID0gb25zZWxlY3RcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhXHJcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHF1ZXJ5XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXlcclxuICAgICAgICB0aGlzLiRzZWxlY3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KVxyXG4gICAgICAgIHRoaXMuJGhlYWRlciA9IHRoaXMuJHNlbGVjdC5xdWVyeVNlbGVjdG9yKCcuc2VsZWN0X19oZWFkZXInKVxyXG4gICAgICAgIHRoaXMuJHRpdGxlID0gdGhpcy4kc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJy5zZWxlY3RfX3RpdGxlJylcclxuICAgICAgICB0aGlzLiRib2R5ID0gdGhpcy4kc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJy5zZWxlY3RfX2JvZHknKVxyXG4gICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlXHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICB0aGlzLiRoZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuJHNlbGVjdC5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdF9hY3RpdmUnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZS50YXJnZXQuY2xvc2VzdCh0aGlzLnNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJIYW5kbGVycygpXHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJIYW5kbGVycygpIHtcclxuICAgICAgICB0aGlzLiRpdGVtcyA9IHRoaXMuJGJvZHkucXVlcnlTZWxlY3RvckFsbCgnLnNlbGVjdF9faXRlbScpXHJcbiAgICAgICAgdGhpcy4kaXRlbXMuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGl0ZW1zLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RfX2l0ZW1fY3VycmVudCcpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzZWxlY3RfX2l0ZW1fY3VycmVudCcpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEubWFwKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGVmYXVsdCA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGF0YS5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLmRhdGFzZXQgPT09IGVsZW1lbnQuZGF0YXNldC52YWx1ZSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpbmRleF0uZGVmYXVsdCA9IHRydWVcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGl0bGUoZWxlbWVudC50ZXh0Q29udGVudClcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uc2VsZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFcnJvcigpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbnNlbGVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGVsZW1lbnQudmFsdWUgfHwgZWxlbWVudC50ZXh0Q29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGVsZW1lbnQuZGF0YXNldC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckJvZHkodGhpcy5kYXRhKVxyXG4gICAgICAgIGlmICghdGhpcy5pc1JlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpXHJcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IHRydWVcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVySGFuZGxlcnMoKVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGVmYXVsdFZhbHVlID0gdGhpcy5kYXRhLmZpbmQoaXRlbSA9PiBpdGVtLmRlZmF1bHQgPT09IHRydWUpPy52YWx1ZSB8fCAnJ1xyXG4gICAgICAgIGlmKGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFRpdGxlKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyQm9keShkYXRhKSB7XHJcbiAgICAgICAgaWYodGhpcy5kaXNhYmxlZCkgcmV0dXJuXHJcbiAgICAgICAgdGhpcy4kYm9keS5pbm5lckhUTUwgPSAnJ1xyXG4gICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy4kYm9keS5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cInNlbGVjdF9fbm90Zm91bmRcIj7QndC40YfQtdCz0L4g0L3QtSDQvdCw0LnQtNC10L3Qvi4uLjwvZGl2PidcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YS5tYXAoaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGJvZHkuaW5uZXJIVE1MICs9IGA8bGkgY2xhc3M9XCJzZWxlY3RfX2l0ZW0gc2VsZWN0X19pdGVtX2N1cnJlbnRcIiBkYXRhLXZhbHVlPVwiJHtpdGVtLmRhdGFzZXR9XCI+JHtpdGVtLnZhbHVlfTwvbGk+YFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kYm9keS5pbm5lckhUTUwgKz0gYDxsaSBjbGFzcz1cInNlbGVjdF9faXRlbVwiIGRhdGEtdmFsdWU9XCIke2l0ZW0uZGF0YXNldH1cIj4ke2l0ZW0udmFsdWV9PC9saT5gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGNoYW5nZVN0YXRlKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRhdGEuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5kYXRhc2V0ID09PSB2YWx1ZSlcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChpdGVtID0+IGl0ZW0uZGVmYXVsdCA9IGZhbHNlKVxyXG4gICAgICAgIHRoaXMuZGF0YVtpbmRleF0uZGVmYXVsdCA9IHRydWVcclxuICAgICAgICB0aGlzLnJlbmRlcigpXHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGl0bGUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLiR0aXRsZS50ZXh0Q29udGVudCA9IHZhbHVlXHJcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLm1hcChpdGVtID0+IHtcclxuICAgICAgICAgICAgaXRlbS5kZWZhdWx0ID0gZmFsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1cclxuICAgICAgICB9KVxyXG4gICAgICAgIGNvbnN0IGRhdGFJdGVtID0gdGhpcy5kYXRhLmZpbmQoaXRlbSA9PiBpdGVtLnZhbHVlID09PSB2YWx1ZSlcclxuICAgICAgICBpZihkYXRhSXRlbSkge1xyXG4gICAgICAgICAgICBkYXRhSXRlbS5kZWZhdWx0ID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCAkbm9kZSA9IEFycmF5LmZyb20odGhpcy4kaXRlbXMpLmZpbmQoaXRlbSA9PiBkYXRhSXRlbS5kYXRhc2V0ID09PSBpdGVtLmRhdGFzZXQudmFsdWUpXHJcblxyXG5cclxuXHJcbiAgICAgICAgdGhpcy4kaXRlbXMuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RfX2l0ZW1fY3VycmVudCcpXHJcbiAgICAgICAgfSlcclxuICAgICAgICAkbm9kZS5jbGFzc0xpc3QuYWRkKCdzZWxlY3RfX2l0ZW1fY3VycmVudCcpXHJcbiAgICB9XHJcblxyXG4gICAgc2V0RGVmYXVsdChkYXRhc2V0KSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLm1hcChpdGVtID0+IHtcclxuICAgICAgICAgICAgaXRlbS5kZWZhdWx0ID0gZmFsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGF0YS5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLmRhdGFzZXQgPT09IGRhdGFzZXQpXHJcbiAgICAgICAgaWYoaW5kZXggPiAtIDEpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhW2luZGV4XS5kZWZhdWx0ID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvcGVuKCkge1xyXG4gICAgICAgIGlmKHRoaXMuZGlzYWJsZWQpIHJldHVyblxyXG4gICAgICAgIHRoaXMuJHNlbGVjdC5jbGFzc0xpc3QuYWRkKCdzZWxlY3RfYWN0aXZlJylcclxuICAgIH1cclxuXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICB0aGlzLiRzZWxlY3QuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0X2FjdGl2ZScpXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5maW5kKGl0ZW0gPT4gaXRlbT8uZGVmYXVsdCA9PT0gdHJ1ZSk/LmRhdGFzZXRcclxuICAgIH1cclxuXHJcbiAgICBzaG93RXJyb3IodGV4dCkge1xyXG4gICAgICAgIGNvbnN0ICRmaWVsZEJsb2NrID0gdGhpcy4kc2VsZWN0LmNsb3Nlc3QoJy5maWVsZC1ibG9jaycpXHJcbiAgICAgICAgaWYgKCRmaWVsZEJsb2NrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0ICRlcnJvciA9ICRmaWVsZEJsb2NrLnF1ZXJ5U2VsZWN0b3IoJy5maWVsZC1ibG9ja19fdW5kZXJ0ZXh0X2Vycm9yJylcclxuICAgICAgICAgICAgaWYoJGVycm9yKSAkZXJyb3IuaW5uZXJIVE1MID0gdGV4dFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZUVycm9yKCkge1xyXG4gICAgICAgIGNvbnN0ICRmaWVsZEJsb2NrID0gdGhpcy4kc2VsZWN0LmNsb3Nlc3QoJy5maWVsZC1ibG9jaycpXHJcbiAgICAgICAgaWYgKCRmaWVsZEJsb2NrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0ICRlcnJvciA9ICRmaWVsZEJsb2NrLnF1ZXJ5U2VsZWN0b3IoJy5maWVsZC1ibG9ja19fdW5kZXJ0ZXh0X2Vycm9yJylcclxuICAgICAgICAgICAgaWYoJGVycm9yKSAkZXJyb3IuaW5uZXJIVE1MID0gJydcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/components/selectsinputs/select.component.js\n")},"./source/js/core/components/sidebar.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\nclass SidebarComponent {\n  constructor({\n    root,\n    buttonOpen,\n    buttonClose,\n    overlay\n  }) {\n    this.$node = document.querySelector(root);\n    this.$buttonOpen = document.querySelector(buttonOpen);\n    this.$buttonClose = document.querySelector(buttonClose);\n    this.$overlay = document.querySelector(overlay);\n    this.isOpen = false;\n  }\n  init() {\n    this.$buttonOpen.addEventListener('click', () => {\n      this.open();\n    });\n    this.$buttonClose.addEventListener('click', () => {\n      this.close();\n    });\n    document.body.addEventListener('click', e => {\n      if (e.target.closest('.page-overlay')) {\n        this.close();\n      }\n    });\n    window.addEventListener('resize', () => {\n      if (this.isOpen && window.innerWidth > 1280) {\n        this.close();\n      }\n    });\n  }\n  close() {\n    this.$overlay.classList.remove('page-overlay_active');\n    this.$node.classList.remove('page-sidebar_active');\n    this.isOpen = false;\n  }\n  open() {\n    this.$overlay.classList.add('page-overlay_active');\n    this.$node.classList.add('page-sidebar_active');\n    this.isOpen = true;\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (SidebarComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL3NpZGViYXIuY29tcG9uZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QtZ3VscC8uL3NvdXJjZS9qcy9jb3JlL2NvbXBvbmVudHMvc2lkZWJhci5jb21wb25lbnQuanM/ZDI1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBTaWRlYmFyQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHsgcm9vdCwgYnV0dG9uT3BlbiwgYnV0dG9uQ2xvc2UsIG92ZXJsYXkgfSkge1xyXG4gICAgICAgIHRoaXMuJG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJvb3QpXHJcbiAgICAgICAgdGhpcy4kYnV0dG9uT3BlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYnV0dG9uT3BlbilcclxuICAgICAgICB0aGlzLiRidXR0b25DbG9zZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYnV0dG9uQ2xvc2UpXHJcbiAgICAgICAgdGhpcy4kb3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3ZlcmxheSlcclxuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICB0aGlzLiRidXR0b25PcGVuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW4oKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRoaXMuJGJ1dHRvbkNsb3NlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKClcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5jbG9zZXN0KCcucGFnZS1vdmVybGF5JykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgd2luZG93LmlubmVyV2lkdGggPiAxMjgwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlLW92ZXJsYXlfYWN0aXZlJylcclxuICAgICAgICB0aGlzLiRub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ3BhZ2Utc2lkZWJhcl9hY3RpdmUnKVxyXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICBvcGVuKCkge1xyXG4gICAgICAgIHRoaXMuJG92ZXJsYXkuY2xhc3NMaXN0LmFkZCgncGFnZS1vdmVybGF5X2FjdGl2ZScpXHJcbiAgICAgICAgdGhpcy4kbm9kZS5jbGFzc0xpc3QuYWRkKCdwYWdlLXNpZGViYXJfYWN0aXZlJylcclxuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWVcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2lkZWJhckNvbXBvbmVudCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/components/sidebar.component.js\n")},"./source/js/core/components/validation.component.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ValidationComponent; }\n/* harmony export */ });\nclass ValidationComponent {\n  static isValidEmail(str) {\n    const regEmail = /^([a-z0-9_-]+\\.)*[a-z0-9_-]+@[a-z0-9_-]+(\\.[a-z0-9_-]+)*\\.[a-z]{2,6}$/;\n    return regEmail.test(str);\n  }\n  static isValidTel(str) {\n    return !str.includes('_');\n  }\n  static isValidPass(str) {\n    return str.length >= 6;\n  }\n  static isValidName(str) {\n    return str.length > 1 && str.match(/^[ЁёА-я ,.'-]+$/) && !str.match(/\\s+/);\n  }\n  static isEqualPassword(str1, str2) {\n    return str1 === str2;\n  }\n  static isEnoughText(str) {\n    return str.length > 5;\n  }\n  static isValidVin(vin) {\n    return vin.length === 17;\n  }\n  static isValidPart(name) {\n    return name.length >= 3;\n  }\n  static isValidLink(link) {\n    return link.match(/^[^0-9а-яА-я]+$/g);\n  }\n  static isValidNumber(number) {\n    return number.match(/^\\d+$/);\n  }\n  static isValidCategory(category) {\n    return category.match(/^[А-яa-z,. '-]+$/);\n  }\n  static isExist(text) {\n    return text.length >= 1;\n  }\n  static isValidOrder(text) {\n    return text.match(/^(\\<|\\>)+(\\d+)/i);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL3ZhbGlkYXRpb24uY29tcG9uZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvY29yZS9jb21wb25lbnRzL3ZhbGlkYXRpb24uY29tcG9uZW50LmpzPzY0OGQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmFsaWRhdGlvbkNvbXBvbmVudCB7XHJcbiAgICBzdGF0aWMgaXNWYWxpZEVtYWlsKHN0cikge1xyXG4gICAgICAgIGNvbnN0IHJlZ0VtYWlsID0gL14oW2EtejAtOV8tXStcXC4pKlthLXowLTlfLV0rQFthLXowLTlfLV0rKFxcLlthLXowLTlfLV0rKSpcXC5bYS16XXsyLDZ9JC9cclxuICAgICAgICByZXR1cm4gcmVnRW1haWwudGVzdChzdHIpXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzVmFsaWRUZWwoc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuICFzdHIuaW5jbHVkZXMoJ18nKVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBpc1ZhbGlkUGFzcyhzdHIpIHtcclxuICAgICAgICByZXR1cm4gc3RyLmxlbmd0aCA+PSA2XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzVmFsaWROYW1lKHN0cikge1xyXG4gICAgICAgIHJldHVybiBzdHIubGVuZ3RoID4gMSAmJiBzdHIubWF0Y2goL15b0IHRkdCQLdGPICwuJy1dKyQvKSAmJiAhc3RyLm1hdGNoKC9cXHMrLylcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaXNFcXVhbFBhc3N3b3JkKHN0cjEsIHN0cjIpIHtcclxuICAgICAgICByZXR1cm4gc3RyMSA9PT0gc3RyMlxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBpc0Vub3VnaFRleHQoc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0ci5sZW5ndGggPiA1XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzVmFsaWRWaW4odmluKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpbi5sZW5ndGggPT09IDE3XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzVmFsaWRQYXJ0KG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGggPj0gM1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBpc1ZhbGlkTGluayhsaW5rKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpbmsubWF0Y2goL15bXjAtOdCwLdGP0JAt0Y9dKyQvZylcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaXNWYWxpZE51bWJlcihudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyLm1hdGNoKC9eXFxkKyQvKVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBpc1ZhbGlkQ2F0ZWdvcnkoY2F0ZWdvcnkpIHtcclxuICAgICAgICByZXR1cm4gY2F0ZWdvcnkubWF0Y2goL15b0JAt0Y9hLXosLiAnLV0rJC8pXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzRXhpc3QodGV4dCkge1xyXG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA+PSAxXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzVmFsaWRPcmRlcih0ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRleHQubWF0Y2goL14oXFw8fFxcPikrKFxcZCspL2kpXHJcbiAgICB9XHJcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./source/js/core/components/validation.component.js\n")},"./source/js/core/modules/module.core.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\nclass ModuleCore {\n  constructor({\n    preloader,\n    router,\n    auth,\n    apiService,\n    selector,\n    userNav\n  }) {\n    this.preloader = preloader;\n    this.router = router;\n    this.auth = auth;\n    this.apiService = apiService;\n    this.userNav = userNav;\n    this.$node = document.querySelector(selector);\n  }\n  init() {\n    window.addEventListener(\'popstate\', () => {\n      this.router.reload();\n    });\n  }\n  showPreloader() {\n    this.$node.innerHTML = `<div class="preloader"></div>`;\n  }\n  showEmpty() {\n    this.$node.innerHTML = `<div class="not-found">Ничего не найдено</div>`;\n  }\n  setTitle(text) {\n    document.querySelector(\'[data-title]\').innerHTML = text;\n  }\n  addParamState(key, value, handler) {\n    this.router.init();\n    this.router.addParams(key, value);\n    handler();\n  }\n  removeParamState(key, handler) {\n    this.router.init();\n    this.router.removeParam(key);\n    handler();\n  }\n}\n/* harmony default export */ __webpack_exports__["default"] = (ModuleCore);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvY29yZS9tb2R1bGVzL21vZHVsZS5jb3JlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9zb3VyY2UvanMvY29yZS9tb2R1bGVzL21vZHVsZS5jb3JlLmpzP2Q3MzIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTW9kdWxlQ29yZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHByZWxvYWRlciwgcm91dGVyLCBhdXRoLCBhcGlTZXJ2aWNlLCBzZWxlY3RvciwgdXNlck5hdiB9KSB7XHJcbiAgICAgICAgdGhpcy5wcmVsb2FkZXIgPSBwcmVsb2FkZXJcclxuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlclxyXG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGhcclxuICAgICAgICB0aGlzLmFwaVNlcnZpY2UgPSBhcGlTZXJ2aWNlXHJcbiAgICAgICAgdGhpcy51c2VyTmF2ID0gdXNlck5hdlxyXG4gICAgICAgIHRoaXMuJG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxyXG4gICAgfVxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucm91dGVyLnJlbG9hZCgpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgIHNob3dQcmVsb2FkZXIoKSB7XHJcbiAgICAgICAgdGhpcy4kbm9kZS5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cInByZWxvYWRlclwiPjwvZGl2PmBcclxuICAgIH1cclxuICAgIHNob3dFbXB0eSgpIHtcclxuICAgICAgICB0aGlzLiRub2RlLmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwibm90LWZvdW5kXCI+0J3QuNGH0LXQs9C+INC90LUg0L3QsNC50LTQtdC90L48L2Rpdj5gXHJcbiAgICB9XHJcbiAgICBzZXRUaXRsZSh0ZXh0KSB7XHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtdGl0bGVdJykuaW5uZXJIVE1MID0gdGV4dFxyXG4gICAgfVxyXG4gICAgYWRkUGFyYW1TdGF0ZShrZXksIHZhbHVlLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIuaW5pdCgpXHJcbiAgICAgICAgdGhpcy5yb3V0ZXIuYWRkUGFyYW1zKGtleSwgdmFsdWUpXHJcbiAgICAgICAgaGFuZGxlcigpXHJcbiAgICB9XHJcbiAgICByZW1vdmVQYXJhbVN0YXRlKGtleSwgaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMucm91dGVyLmluaXQoKVxyXG4gICAgICAgIHRoaXMucm91dGVyLnJlbW92ZVBhcmFtKGtleSlcclxuICAgICAgICBoYW5kbGVyKClcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTW9kdWxlQ29yZSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./source/js/core/modules/module.core.js\n')},"./source/js/pages/catalog.page.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _app_common_modules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../app/common.modules.js */ \"./source/js/app/common.modules.js\");\n/* harmony import */ var _app_modules_catalog_module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app/modules/catalog.module.js */ \"./source/js/app/modules/catalog.module.js\");\n\n\n(async () => {\n  new _app_modules_catalog_module_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n    preloader: _app_common_modules_js__WEBPACK_IMPORTED_MODULE_0__.preloader,\n    router: _app_common_modules_js__WEBPACK_IMPORTED_MODULE_0__.router,\n    apiService: _app_common_modules_js__WEBPACK_IMPORTED_MODULE_0__.apiService\n  }).init();\n  await _app_common_modules_js__WEBPACK_IMPORTED_MODULE_0__.auth.init();\n  if (document.readyState === 'interactive' || document.readyState === 'complete') {\n    renderModules();\n  } else {\n    document.addEventListener('DOMContentLoaded', renderModules);\n  }\n})();\nconst renderModules = async () => {\n  _app_common_modules_js__WEBPACK_IMPORTED_MODULE_0__.userNav.render();\n  _app_common_modules_js__WEBPACK_IMPORTED_MODULE_0__.locationModule.init();\n};\n\n// document.addEventListener('DOMContentLoaded', async () => {\n// new CatalogModule({\n//     preloader,\n//     router,\n//     apiService\n// }).init()\n// await auth.init()\n// userNav.render()\n// locationModule.init()\n// })//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zb3VyY2UvanMvcGFnZXMvY2F0YWxvZy5wYWdlLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vc291cmNlL2pzL3BhZ2VzL2NhdGFsb2cucGFnZS5qcz9jM2UwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGF1dGgsIGxvY2F0aW9uTW9kdWxlLCB1c2VyTmF2LCBwcmVsb2FkZXIsIHJvdXRlciwgYXBpU2VydmljZSB9IGZyb20gJy4uL2FwcC9jb21tb24ubW9kdWxlcy5qcydcclxuaW1wb3J0IENhdGFsb2dNb2R1bGUgZnJvbSAnLi4vYXBwL21vZHVsZXMvY2F0YWxvZy5tb2R1bGUuanMnXHJcblxyXG4oYXN5bmMgKCkgPT4ge1xyXG4gICAgbmV3IENhdGFsb2dNb2R1bGUoe1xyXG4gICAgICAgIHByZWxvYWRlcixcclxuICAgICAgICByb3V0ZXIsXHJcbiAgICAgICAgYXBpU2VydmljZVxyXG4gICAgfSkuaW5pdCgpXHJcbiAgICBhd2FpdCBhdXRoLmluaXQoKVxyXG5cclxuICAgIGlmKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xyXG4gICAgICAgIHJlbmRlck1vZHVsZXMoKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgcmVuZGVyTW9kdWxlcylcclxuICAgIH1cclxufSkoKVxyXG5cclxuY29uc3QgcmVuZGVyTW9kdWxlcyA9IGFzeW5jICgpID0+IHtcclxuICAgIHVzZXJOYXYucmVuZGVyKClcclxuICAgIGxvY2F0aW9uTW9kdWxlLmluaXQoKVxyXG59XHJcblxyXG5cclxuLy8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIG5ldyBDYXRhbG9nTW9kdWxlKHtcclxuICAgIC8vICAgICBwcmVsb2FkZXIsXHJcbiAgICAvLyAgICAgcm91dGVyLFxyXG4gICAgLy8gICAgIGFwaVNlcnZpY2VcclxuICAgIC8vIH0pLmluaXQoKVxyXG4gICAgLy8gYXdhaXQgYXV0aC5pbml0KClcclxuICAgIC8vIHVzZXJOYXYucmVuZGVyKClcclxuICAgIC8vIGxvY2F0aW9uTW9kdWxlLmluaXQoKVxyXG4vLyB9KVxyXG5cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./source/js/pages/catalog.page.js\n")},"./node_modules/code-tag/dist/index.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   any: function() { return /* binding */ any; },\n/* harmony export */   css: function() { return /* binding */ any; },\n/* harmony export */   gql: function() { return /* binding */ any; },\n/* harmony export */   graphql: function() { return /* binding */ any; },\n/* harmony export */   html: function() { return /* binding */ any; },\n/* harmony export */   markdown: function() { return /* binding */ any; },\n/* harmony export */   md: function() { return /* binding */ any; },\n/* harmony export */   sql: function() { return /* binding */ any; }\n/* harmony export */ });\n// Prettier supports these languages:\n// https://github.com/prettier/prettier/blob/e46aba0ab279c764dc26e0f41f15c55122440c51/src/language-js/embed.js#L13\nvar concatenateTemplateLiteralTag = function concatenateTemplateLiteralTag(raw) {\n  return String.raw.apply(String, [{\n    raw: raw\n  }].concat([].slice.call(arguments, 1)));\n};\n/**\nEnable highlighting/prettifying when used as html`<div>` or css`.a {}`\nhttps://prettier.io/docs/en/options.html#embedded-language-formatting\n*/\n\n\nvar any = concatenateTemplateLiteralTag;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29kZS10YWcvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QtZ3VscC8uL25vZGVfbW9kdWxlcy9jb2RlLXRhZy9kaXN0L2luZGV4Lm1qcz81M2Q1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByZXR0aWVyIHN1cHBvcnRzIHRoZXNlIGxhbmd1YWdlczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9ibG9iL2U0NmFiYTBhYjI3OWM3NjRkYzI2ZTBmNDFmMTVjNTUxMjI0NDBjNTEvc3JjL2xhbmd1YWdlLWpzL2VtYmVkLmpzI0wxM1xudmFyIGNvbmNhdGVuYXRlVGVtcGxhdGVMaXRlcmFsVGFnID0gZnVuY3Rpb24gY29uY2F0ZW5hdGVUZW1wbGF0ZUxpdGVyYWxUYWcocmF3KSB7XG4gIHJldHVybiBTdHJpbmcucmF3LmFwcGx5KFN0cmluZywgW3tcbiAgICByYXc6IHJhd1xuICB9XS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG59O1xuLyoqXG5FbmFibGUgaGlnaGxpZ2h0aW5nL3ByZXR0aWZ5aW5nIHdoZW4gdXNlZCBhcyBodG1sYDxkaXY+YCBvciBjc3NgLmEge31gXG5odHRwczovL3ByZXR0aWVyLmlvL2RvY3MvZW4vb3B0aW9ucy5odG1sI2VtYmVkZGVkLWxhbmd1YWdlLWZvcm1hdHRpbmdcbiovXG5cblxudmFyIGFueSA9IGNvbmNhdGVuYXRlVGVtcGxhdGVMaXRlcmFsVGFnO1xuXG5leHBvcnQgeyBhbnksIGFueSBhcyBjc3MsIGFueSBhcyBncWwsIGFueSBhcyBncmFwaHFsLCBhbnkgYXMgaHRtbCwgYW55IGFzIG1hcmtkb3duLCBhbnkgYXMgbWQsIGFueSBhcyBzcWwgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/code-tag/dist/index.mjs\n")},"./node_modules/orderedmap/dist/index.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: () → Object\n  // Turn ordered map into a plain object.\n  toObject: function() {\n    var result = {};\n    this.forEach(function(key, value) { result[key] = value; });\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (OrderedMap);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb3JkZXJlZG1hcC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vbm9kZV9tb2R1bGVzL29yZGVyZWRtYXAvZGlzdC9pbmRleC5qcz83MGRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDo6LSBQZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhbiBvcmRlcmVkIG1hcHBpbmcgZnJvbVxuLy8gc3RyaW5ncyB0byB2YWx1ZXMsIHdpdGggc29tZSBjb252ZW5pZW50IHVwZGF0ZSBtZXRob2RzLlxuZnVuY3Rpb24gT3JkZXJlZE1hcChjb250ZW50KSB7XG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG59XG5cbk9yZGVyZWRNYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogT3JkZXJlZE1hcCxcblxuICBmaW5kOiBmdW5jdGlvbihrZXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRbaV0gPT09IGtleSkgcmV0dXJuIGlcbiAgICByZXR1cm4gLTFcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nKSDihpIgP2FueVxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWUgc3RvcmVkIHVuZGVyIGBrZXlgLCBvciByZXR1cm4gdW5kZWZpbmVkIHdoZW5cbiAgLy8gbm8gc3VjaCBrZXkgZXhpc3RzLlxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZChrZXkpO1xuICAgIHJldHVybiBmb3VuZCA9PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuY29udGVudFtmb3VuZCArIDFdXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55LCA/c3RyaW5nKSDihpIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBuZXcgbWFwIGJ5IHJlcGxhY2luZyB0aGUgdmFsdWUgb2YgYGtleWAgd2l0aCBhIG5ld1xuICAvLyB2YWx1ZSwgb3IgYWRkaW5nIGEgYmluZGluZyB0byB0aGUgZW5kIG9mIHRoZSBtYXAuIElmIGBuZXdLZXlgIGlzXG4gIC8vIGdpdmVuLCB0aGUga2V5IG9mIHRoZSBiaW5kaW5nIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGF0IGtleS5cbiAgdXBkYXRlOiBmdW5jdGlvbihrZXksIHZhbHVlLCBuZXdLZXkpIHtcbiAgICB2YXIgc2VsZiA9IG5ld0tleSAmJiBuZXdLZXkgIT0ga2V5ID8gdGhpcy5yZW1vdmUobmV3S2V5KSA6IHRoaXM7XG4gICAgdmFyIGZvdW5kID0gc2VsZi5maW5kKGtleSksIGNvbnRlbnQgPSBzZWxmLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHtcbiAgICAgIGNvbnRlbnQucHVzaChuZXdLZXkgfHwga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRbZm91bmQgKyAxXSA9IHZhbHVlO1xuICAgICAgaWYgKG5ld0tleSkgY29udGVudFtmb3VuZF0gPSBuZXdLZXk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIFJldHVybiBhIG1hcCB3aXRoIHRoZSBnaXZlbiBrZXkgcmVtb3ZlZCwgaWYgaXQgZXhpc3RlZC5cbiAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmQoa2V5KTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHJldHVybiB0aGlzXG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBjb250ZW50LnNwbGljZShmb3VuZCwgMik7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55KSDihpIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBuZXcga2V5IHRvIHRoZSBzdGFydCBvZiB0aGUgbWFwLlxuICBhZGRUb1N0YXJ0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKFtrZXksIHZhbHVlXS5jb25jYXQodGhpcy5yZW1vdmUoa2V5KS5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnkpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIG5ldyBrZXkgdG8gdGhlIGVuZCBvZiB0aGUgbWFwLlxuICBhZGRUb0VuZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5yZW1vdmUoa2V5KS5jb250ZW50LnNsaWNlKCk7XG4gICAgY29udGVudC5wdXNoKGtleSwgdmFsdWUpO1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIHN0cmluZywgYW55KSDihpIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBrZXkgYWZ0ZXIgdGhlIGdpdmVuIGtleS4gSWYgYHBsYWNlYCBpcyBub3QgZm91bmQsIHRoZSBuZXdcbiAgLy8ga2V5IGlzIGFkZGVkIHRvIHRoZSBlbmQuXG4gIGFkZEJlZm9yZTogZnVuY3Rpb24ocGxhY2UsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgd2l0aG91dCA9IHRoaXMucmVtb3ZlKGtleSksIGNvbnRlbnQgPSB3aXRob3V0LmNvbnRlbnQuc2xpY2UoKTtcbiAgICB2YXIgZm91bmQgPSB3aXRob3V0LmZpbmQocGxhY2UpO1xuICAgIGNvbnRlbnQuc3BsaWNlKGZvdW5kID09IC0xID8gY29udGVudC5sZW5ndGggOiBmb3VuZCwgMCwga2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkpXG4gIC8vIENhbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBtYXAsIGluXG4gIC8vIG9yZGVyLlxuICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICBmKHRoaXMuY29udGVudFtpXSwgdGhpcy5jb250ZW50W2kgKyAxXSk7XG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgcHJlcGVuZGluZyB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYCBiZWZvcmUgdGhlIGtleXMgaW4gYG1hcGAuXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKG1hcC5jb250ZW50LmNvbmNhdCh0aGlzLnN1YnRyYWN0KG1hcCkuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgYXBwZW5kaW5nIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgIGFmdGVyIHRoZSBrZXlzIGluIGBtYXBgLlxuICBhcHBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKHRoaXMuc3VidHJhY3QobWFwKS5jb250ZW50LmNvbmNhdChtYXAuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG1hcCBjb250YWluaW5nIGFsbCB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYC5cbiAgc3VidHJhY3Q6IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXN1bHQgPSByZXN1bHQucmVtb3ZlKG1hcC5jb250ZW50W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLy8gOjogKCkg4oaSIE9iamVjdFxuICAvLyBUdXJuIG9yZGVyZWQgbWFwIGludG8gYSBwbGFpbiBvYmplY3QuXG4gIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmVzdWx0W2tleV0gPSB2YWx1ZTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9LFxuXG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgYW1vdW50IG9mIGtleXMgaW4gdGhpcyBtYXAuXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID4+IDFcbiAgfVxufTtcblxuLy8gOjogKD91bmlvbjxPYmplY3QsIE9yZGVyZWRNYXA+KSDihpIgT3JkZXJlZE1hcFxuLy8gUmV0dXJuIGEgbWFwIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuIElmIG51bGwsIGNyZWF0ZSBhbiBlbXB0eVxuLy8gbWFwLiBJZiBnaXZlbiBhbiBvcmRlcmVkIG1hcCwgcmV0dXJuIHRoYXQgbWFwIGl0c2VsZi4gSWYgZ2l2ZW4gYW5cbi8vIG9iamVjdCwgY3JlYXRlIGEgbWFwIGZyb20gdGhlIG9iamVjdCdzIHByb3BlcnRpZXMuXG5PcmRlcmVkTWFwLmZyb20gPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPcmRlcmVkTWFwKSByZXR1cm4gdmFsdWVcbiAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgaWYgKHZhbHVlKSBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSBjb250ZW50LnB1c2gocHJvcCwgdmFsdWVbcHJvcF0pO1xuICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE9yZGVyZWRNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/orderedmap/dist/index.js\n")},"./node_modules/prosemirror-commands/dist/index.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: function() { return /* binding */ autoJoin; },\n/* harmony export */   baseKeymap: function() { return /* binding */ baseKeymap; },\n/* harmony export */   chainCommands: function() { return /* binding */ chainCommands; },\n/* harmony export */   createParagraphNear: function() { return /* binding */ createParagraphNear; },\n/* harmony export */   deleteSelection: function() { return /* binding */ deleteSelection; },\n/* harmony export */   exitCode: function() { return /* binding */ exitCode; },\n/* harmony export */   joinBackward: function() { return /* binding */ joinBackward; },\n/* harmony export */   joinDown: function() { return /* binding */ joinDown; },\n/* harmony export */   joinForward: function() { return /* binding */ joinForward; },\n/* harmony export */   joinTextblockBackward: function() { return /* binding */ joinTextblockBackward; },\n/* harmony export */   joinTextblockForward: function() { return /* binding */ joinTextblockForward; },\n/* harmony export */   joinUp: function() { return /* binding */ joinUp; },\n/* harmony export */   lift: function() { return /* binding */ lift; },\n/* harmony export */   liftEmptyBlock: function() { return /* binding */ liftEmptyBlock; },\n/* harmony export */   macBaseKeymap: function() { return /* binding */ macBaseKeymap; },\n/* harmony export */   newlineInCode: function() { return /* binding */ newlineInCode; },\n/* harmony export */   pcBaseKeymap: function() { return /* binding */ pcBaseKeymap; },\n/* harmony export */   selectAll: function() { return /* binding */ selectAll; },\n/* harmony export */   selectNodeBackward: function() { return /* binding */ selectNodeBackward; },\n/* harmony export */   selectNodeForward: function() { return /* binding */ selectNodeForward; },\n/* harmony export */   selectParentNode: function() { return /* binding */ selectParentNode; },\n/* harmony export */   selectTextblockEnd: function() { return /* binding */ selectTextblockEnd; },\n/* harmony export */   selectTextblockStart: function() { return /* binding */ selectTextblockStart; },\n/* harmony export */   setBlockType: function() { return /* binding */ setBlockType; },\n/* harmony export */   splitBlock: function() { return /* binding */ splitBlock; },\n/* harmony export */   splitBlockAs: function() { return /* binding */ splitBlockAs; },\n/* harmony export */   splitBlockKeepMarks: function() { return /* binding */ splitBlockKeepMarks; },\n/* harmony export */   toggleMark: function() { return /* binding */ toggleMark; },\n/* harmony export */   wrapIn: function() { return /* binding */ wrapIn; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");\n\n\n\n\n/**\nDelete the selection, if there is one.\n*/\nconst deleteSelection = (state, dispatch) => {\n    if (state.selection.empty)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n};\nfunction atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock("backward", state)\n        : $cursor.parentOffset > 0))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and at the start of a textblock, try to\nreduce the distance between that block and the one before it—if\nthere\'s a block directly before it that can be joined, join them.\nIf not, try to move the selected block closer to the next one in\nthe document structure by lifting it out of its parent or moving it\ninto a parent of the previous block. Will use the view for accurate\n(bidi-aware) start-of-textblock detection if given.\n*/\nconst joinBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    // If there is no node before this, try to lift\n    if (!$cut) {\n        let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n        if (target == null)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    let before = $cut.nodeBefore;\n    // Apply the joining algorithm\n    if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n        return true;\n    // If the node below has no content and the node above is\n    // selectable, delete the node below and select the one above.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(before, "end") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(before))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(before, "end") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                    : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the node before is an atom, delete it\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nA more limited form of [`joinBackward`]($commands.joinBackward)\nthat only tries to join the current textblock to the one before\nit, if the cursor is at the start of a textblock.\n*/\nconst joinTextblockBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\n/**\nA more limited form of [`joinForward`]($commands.joinForward)\nthat only tries to join the current textblock to the one after\nit, if the cursor is at the end of a textblock.\n*/\nconst joinTextblockForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;\n    for (; !beforeText.isTextblock; beforePos--) {\n        if (beforeText.type.spec.isolating)\n            return false;\n        let child = beforeText.lastChild;\n        if (!child)\n            return false;\n        beforeText = child;\n    }\n    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;\n    for (; !afterText.isTextblock; afterPos++) {\n        if (afterText.type.spec.isolating)\n            return false;\n        let child = afterText.firstChild;\n        if (!child)\n            return false;\n        afterText = child;\n    }\n    let step = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, beforePos, afterPos, prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n    if (!step || step.from != beforePos ||\n        step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep && step.slice.size >= afterPos - beforePos)\n        return false;\n    if (dispatch) {\n        let tr = state.tr.step(step);\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, beforePos));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n}\nfunction textblockAt(node, side, only = false) {\n    for (let scan = node; scan; scan = (side == "start" ? scan.firstChild : scan.lastChild)) {\n        if (scan.isTextblock)\n            return true;\n        if (only && scan.childCount != 1)\n            return false;\n    }\n    return false;\n}\n/**\nWhen the selection is empty and at the start of a textblock, select\nthe node before that textblock, if possible. This is intended to be\nbound to keys like backspace, after\n[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting\ncommands, as a fall-back behavior when the schema doesn\'t allow\ndeletion at the selected point.\n*/\nconst selectNodeBackward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)\n            return false;\n        $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n};\nfunction findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            if ($pos.index(i) > 0)\n                return $pos.doc.resolve($pos.before(i + 1));\n            if ($pos.node(i).type.spec.isolating)\n                break;\n        }\n    return null;\n}\nfunction atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock("forward", state)\n        : $cursor.parentOffset < $cursor.parent.content.size))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and the cursor is at the end of a\ntextblock, try to reduce or remove the boundary between that block\nand the one after it, either by joining them or by moving the other\nblock closer to this one in the tree structure. Will use the view\nfor accurate start-of-textblock detection if given.\n*/\nconst joinForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    // If there is no node after this, there\'s nothing to do\n    if (!$cut)\n        return false;\n    let after = $cut.nodeAfter;\n    // Try the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch))\n        return true;\n    // If the node above has no content and the node below is\n    // selectable, delete the node above and select the one below.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(after, "start") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(after))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(after, "start") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                    : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the next node is an atom, delete it\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nWhen the selection is empty and at the end of a textblock, select\nthe node coming after that textblock, if possible. This is intended\nto be bound to keys like delete, after\n[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting\ncommands, to provide a fall-back behavior when the schema doesn\'t\nallow deletion at the selected point.\n*/\nconst selectNodeForward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)\n            return false;\n        $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n};\nfunction findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            let parent = $pos.node(i);\n            if ($pos.index(i) + 1 < parent.childCount)\n                return $pos.doc.resolve($pos.after(i + 1));\n            if (parent.type.spec.isolating)\n                break;\n        }\n    return null;\n}\n/**\nJoin the selected block or, if there is a text selection, the\nclosest ancestor block of the selection that can be joined, with\nthe sibling above it.\n*/\nconst joinUp = (state, dispatch) => {\n    let sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection, point;\n    if (nodeSel) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from))\n            return false;\n        point = sel.from;\n    }\n    else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch) {\n        let tr = state.tr.join(point);\n        if (nodeSel)\n            tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nJoin the selected block, or the closest ancestor of the selection\nthat can be joined, with the sibling after it.\n*/\nconst joinDown = (state, dispatch) => {\n    let sel = state.selection, point;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to))\n            return false;\n        point = sel.to;\n    }\n    else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch)\n        dispatch(state.tr.join(point).scrollIntoView());\n    return true;\n};\n/**\nLift the selected block, or the closest ancestor block of the\nselection that can be lifted, out of its parent node.\n*/\nconst lift = (state, dispatch) => {\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nIf the selection is in a node whose type has a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the\nselection with a newline character.\n*/\nconst newlineInCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.insertText("\\n").scrollIntoView());\n    return true;\n};\nfunction defaultBlockAt(match) {\n    for (let i = 0; i < match.edgeCount; i++) {\n        let { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs())\n            return type;\n    }\n    return null;\n}\n/**\nWhen the selection is in a node with a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a\ndefault block after the code block, and move the cursor there.\n*/\nconst exitCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type))\n        return false;\n    if (dispatch) {\n        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(tr.doc.resolve(pos), 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf a block node is selected, create an empty paragraph before (if\nit is its parent\'s first child) or after it.\n*/\nconst createParagraphNear = (state, dispatch) => {\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)\n        return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock)\n        return false;\n    if (dispatch) {\n        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n        let tr = state.tr.insert(side, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, side + 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf the cursor is in an empty textblock that can be lifted, lift the\nblock.\n*/\nconst liftEmptyBlock = (state, dispatch) => {\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size)\n        return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n        let before = $cursor.before();\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {\n            if (dispatch)\n                dispatch(state.tr.split(before).scrollIntoView());\n            return true;\n        }\n    }\n    let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nCreate a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses\na custom function to determine the type of the newly split off block.\n*/\nfunction splitBlockAs(splitNode) {\n    return (state, dispatch) => {\n        let { $from, $to } = state.selection;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && state.selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos))\n                return false;\n            if (dispatch)\n                dispatch(state.tr.split($from.pos).scrollIntoView());\n            return true;\n        }\n        if (!$from.parent.isBlock)\n            return false;\n        if (dispatch) {\n            let atEnd = $to.parentOffset == $to.parent.content.size;\n            let tr = state.tr;\n            if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection)\n                tr.deleteSelection();\n            let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n            let splitType = splitNode && splitNode($to.parent, atEnd);\n            let types = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : undefined;\n            let can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n            if (!types && !can && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {\n                if (deflt)\n                    types = [{ type: deflt }];\n                can = true;\n            }\n            if (can) {\n                tr.split(tr.mapping.map($from.pos), 1, types);\n                if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n                    let first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);\n                    if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n                        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                }\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\n/**\nSplit the parent block of the selection. If the selection is a text\nselection, also delete its content.\n*/\nconst splitBlock = splitBlockAs();\n/**\nActs like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without\nresetting the set of active marks at the cursor.\n*/\nconst splitBlockKeepMarks = (state, dispatch) => {\n    return splitBlock(state, dispatch && (tr => {\n        let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n        if (marks)\n            tr.ensureMarks(marks);\n        dispatch(tr);\n    }));\n};\n/**\nMove the selection to the node wrapping the current selection, if\nany. (Will not select the document node.)\n*/\nconst selectParentNode = (state, dispatch) => {\n    let { $from, to } = state.selection, pos;\n    let same = $from.sharedDepth(to);\n    if (same == 0)\n        return false;\n    pos = $from.before(same);\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, pos)));\n    return true;\n};\n/**\nSelect the whole document.\n*/\nconst selectAll = (state, dispatch) => {\n    if (dispatch)\n        dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection(state.doc)));\n    return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type))\n        return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n        if (dispatch)\n            dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n        return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos)))\n        return false;\n    if (dispatch)\n        dispatch(state.tr\n            .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n            .join($pos.pos)\n            .scrollIntoView());\n    return true;\n}\nfunction deleteBarrier(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    if (before.type.spec.isolating || after.type.spec.isolating)\n        return false;\n    if (joinMaybeClear(state, $cut, dispatch))\n        return true;\n    let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter &&\n        (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n        match.matchType(conn[0] || after.type).validEnd) {\n        if (dispatch) {\n            let end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n            for (let i = conn.length - 1; i >= 0; i--)\n                wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(conn[i].create(null, wrap));\n            wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(before.copy(wrap));\n            let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(wrap, 1, 0), conn.length, true));\n            let joinAt = end + 2 * conn.length;\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinAt))\n                tr.join(joinAt);\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n    let selAfter = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target != null && target >= $cut.depth) {\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {\n        let at = before, wrap = [];\n        for (;;) {\n            wrap.push(at);\n            if (at.isTextblock)\n                break;\n            at = at.lastChild;\n        }\n        let afterText = after, afterDepth = 1;\n        for (; !afterText.isTextblock; afterText = afterText.firstChild)\n            afterDepth++;\n        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n            if (dispatch) {\n                let end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n                for (let i = wrap.length - 1; i >= 0; i--)\n                    end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(wrap[i].copy(end));\n                let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(end, wrap.length, 0), 0, true));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction selectTextblockSide(side) {\n    return function (state, dispatch) {\n        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n        let depth = $pos.depth;\n        while ($pos.node(depth).isInline) {\n            if (!depth)\n                return false;\n            depth--;\n        }\n        if (!$pos.node(depth).isTextblock)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n        return true;\n    };\n}\n/**\nMoves the cursor to the start of current text block.\n*/\nconst selectTextblockStart = selectTextblockSide(-1);\n/**\nMoves the cursor to the end of current text block.\n*/\nconst selectTextblockEnd = selectTextblockSide(1);\n// Parameterized commands\n/**\nWrap the selection in a node of the given type with the given\nattributes.\n*/\nfunction wrapIn(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);\n        if (!wrapping)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n        return true;\n    };\n}\n/**\nReturns a command that tries to set the selected textblocks to the\ngiven node type with the given attributes.\n*/\nfunction setBlockType(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let applicable = false;\n        for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {\n            let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n            state.doc.nodesBetween(from, to, (node, pos) => {\n                if (applicable)\n                    return false;\n                if (!node.isTextblock || node.hasMarkup(nodeType, attrs))\n                    return;\n                if (node.type == nodeType) {\n                    applicable = true;\n                }\n                else {\n                    let $pos = state.doc.resolve(pos), index = $pos.index();\n                    applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n                }\n            });\n        }\n        if (!applicable)\n            return false;\n        if (dispatch) {\n            let tr = state.tr;\n            for (let i = 0; i < state.selection.ranges.length; i++) {\n                let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n                tr.setBlockType(from, to, nodeType, attrs);\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction markApplies(doc, ranges, type) {\n    for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i];\n        let can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, node => {\n            if (can)\n                return false;\n            can = node.inlineContent && node.type.allowsMarkType(type);\n        });\n        if (can)\n            return true;\n    }\n    return false;\n}\n/**\nCreate a command function that toggles the given mark with the\ngiven attributes. Will return `false` when the current selection\ndoesn\'t support that mark. This will remove the mark if any marks\nof that type exist in the selection, or add it otherwise. If the\nselection is empty, this applies to the [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the\ndocument.\n*/\nfunction toggleMark(markType, attrs = null) {\n    return function (state, dispatch) {\n        let { empty, $cursor, ranges } = state.selection;\n        if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType))\n            return false;\n        if (dispatch) {\n            if ($cursor) {\n                if (markType.isInSet(state.storedMarks || $cursor.marks()))\n                    dispatch(state.tr.removeStoredMark(markType));\n                else\n                    dispatch(state.tr.addStoredMark(markType.create(attrs)));\n            }\n            else {\n                let has = false, tr = state.tr;\n                for (let i = 0; !has && i < ranges.length; i++) {\n                    let { $from, $to } = ranges[i];\n                    has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n                }\n                for (let i = 0; i < ranges.length; i++) {\n                    let { $from, $to } = ranges[i];\n                    if (has) {\n                        tr.removeMark($from.pos, $to.pos, markType);\n                    }\n                    else {\n                        let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n                        let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n                        let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n                        if (from + spaceStart < to) {\n                            from += spaceStart;\n                            to -= spaceEnd;\n                        }\n                        tr.addMark(from, to, markType.create(attrs));\n                    }\n                }\n                dispatch(tr.scrollIntoView());\n            }\n        }\n        return true;\n    };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n    return (tr) => {\n        if (!tr.isGeneric)\n            return dispatch(tr);\n        let ranges = [];\n        for (let i = 0; i < tr.mapping.maps.length; i++) {\n            let map = tr.mapping.maps[i];\n            for (let j = 0; j < ranges.length; j++)\n                ranges[j] = map.map(ranges[j]);\n            map.forEach((_s, _e, from, to) => ranges.push(from, to));\n        }\n        // Figure out which joinable points exist inside those ranges,\n        // by checking all node boundaries in their parent nodes.\n        let joinable = [];\n        for (let i = 0; i < ranges.length; i += 2) {\n            let from = ranges[i], to = ranges[i + 1];\n            let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n            for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n                let after = parent.maybeChild(index);\n                if (!after)\n                    break;\n                if (index && joinable.indexOf(pos) == -1) {\n                    let before = parent.child(index - 1);\n                    if (before.type == after.type && isJoinable(before, after))\n                        joinable.push(pos);\n                }\n                pos += after.nodeSize;\n            }\n        }\n        // Join the joinable points\n        joinable.sort((a, b) => a - b);\n        for (let i = joinable.length - 1; i >= 0; i--) {\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i]))\n                tr.join(joinable[i]);\n        }\n        dispatch(tr);\n    };\n}\n/**\nWrap a command so that, when it produces a transform that causes\ntwo joinable nodes to end up next to each other, those are joined.\nNodes are considered joinable when they are of the same type and\nwhen the `isJoinable` predicate returns true for them or, if an\narray of strings was passed, if their node type name is in that\narray.\n*/\nfunction autoJoin(command, isJoinable) {\n    let canJoin = Array.isArray(isJoinable) ? (node) => isJoinable.indexOf(node.type.name) > -1\n        : isJoinable;\n    return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n}\n/**\nCombine a number of command functions into a single function (which\ncalls them one by one until one returns true).\n*/\nfunction chainCommands(...commands) {\n    return function (state, dispatch, view) {\n        for (let i = 0; i < commands.length; i++)\n            if (commands[i](state, dispatch, view))\n                return true;\n        return false;\n    };\n}\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n/**\nA basic keymap containing bindings not specific to any schema.\nBinds the following keys (when multiple commands are listed, they\nare chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):\n\n* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n* **Mod-Enter** to `exitCode`\n* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-a** to `selectAll`\n*/\nconst pcBaseKeymap = {\n    "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    "Mod-Enter": exitCode,\n    "Backspace": backspace,\n    "Mod-Backspace": backspace,\n    "Shift-Backspace": backspace,\n    "Delete": del,\n    "Mod-Delete": del,\n    "Mod-a": selectAll\n};\n/**\nA copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\nCtrl-Delete.\n*/\nconst macBaseKeymap = {\n    "Ctrl-h": pcBaseKeymap["Backspace"],\n    "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],\n    "Ctrl-d": pcBaseKeymap["Delete"],\n    "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],\n    "Alt-Delete": pcBaseKeymap["Mod-Delete"],\n    "Alt-d": pcBaseKeymap["Mod-Delete"],\n    "Ctrl-a": selectTextblockStart,\n    "Ctrl-e": selectTextblockEnd\n};\nfor (let key in pcBaseKeymap)\n    macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n    // @ts-ignore\n    : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;\n/**\nDepending on the detected platform, this will hold\n[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or\n[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).\n*/\nconst baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QtZ3VscC8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmpzPzU3MjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGlmdFRhcmdldCwgcmVwbGFjZVN0ZXAsIFJlcGxhY2VTdGVwLCBjYW5Kb2luLCBqb2luUG9pbnQsIGNhblNwbGl0LCBSZXBsYWNlQXJvdW5kU3RlcCwgZmluZFdyYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24sIFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgQWxsU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBpZiB0aGVyZSBpcyBvbmUuXG4qL1xuY29uc3QgZGVsZXRlU2VsZWN0aW9uID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldykge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0ID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHRyeSB0b1xucmVkdWNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYmxvY2sgYW5kIHRoZSBvbmUgYmVmb3JlIGl04oCUaWZcbnRoZXJlJ3MgYSBibG9jayBkaXJlY3RseSBiZWZvcmUgaXQgdGhhdCBjYW4gYmUgam9pbmVkLCBqb2luIHRoZW0uXG5JZiBub3QsIHRyeSB0byBtb3ZlIHRoZSBzZWxlY3RlZCBibG9jayBjbG9zZXIgdG8gdGhlIG5leHQgb25lIGluXG50aGUgZG9jdW1lbnQgc3RydWN0dXJlIGJ5IGxpZnRpbmcgaXQgb3V0IG9mIGl0cyBwYXJlbnQgb3IgbW92aW5nIGl0XG5pbnRvIGEgcGFyZW50IG9mIHRoZSBwcmV2aW91cyBibG9jay4gV2lsbCB1c2UgdGhlIHZpZXcgZm9yIGFjY3VyYXRlXG4oYmlkaS1hd2FyZSkgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSB0aGlzLCB0cnkgdG8gbGlmdFxuICAgIGlmICghJGN1dCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmU7XG4gICAgLy8gQXBwbHkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gICAgaWYgKCFiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGJlbG93IGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBhYm92ZSBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBiZWxvdyBhbmQgc2VsZWN0IHRoZSBvbmUgYWJvdmUuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpIHx8IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGJlZm9yZSkpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcywgLTEpKSwgLTEpXG4gICAgICAgICAgICAgICAgICAgIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgYmVmb3JlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICAgIGlmIChiZWZvcmUuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkY3V0LnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5BIG1vcmUgbGltaXRlZCBmb3JtIG9mIFtgam9pbkJhY2t3YXJkYF0oJGNvbW1hbmRzLmpvaW5CYWNrd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGJlZm9yZVxuaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICAgIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5Gb3J3YXJkYF0oJGNvbW1hbmRzLmpvaW5Gb3J3YXJkKVxudGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYWZ0ZXJcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2suXG4qL1xuY29uc3Qgam9pblRleHRibG9ja0ZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBiZWZvcmVUZXh0ID0gYmVmb3JlLCBiZWZvcmVQb3MgPSAkY3V0LnBvcyAtIDE7XG4gICAgZm9yICg7ICFiZWZvcmVUZXh0LmlzVGV4dGJsb2NrOyBiZWZvcmVQb3MtLSkge1xuICAgICAgICBpZiAoYmVmb3JlVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSBiZWZvcmVUZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYmVmb3JlVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyUG9zID0gJGN1dC5wb3MgKyAxO1xuICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclBvcysrKSB7XG4gICAgICAgIGlmIChhZnRlclRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGFmdGVyVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgc3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgYmVmb3JlUG9zLCBhZnRlclBvcywgU2xpY2UuZW1wdHkpO1xuICAgIGlmICghc3RlcCB8fCBzdGVwLmZyb20gIT0gYmVmb3JlUG9zIHx8XG4gICAgICAgIHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCAmJiBzdGVwLnNsaWNlLnNpemUgPj0gYWZ0ZXJQb3MgLSBiZWZvcmVQb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChzdGVwKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYmVmb3JlUG9zKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRleHRibG9ja0F0KG5vZGUsIHNpZGUsIG9ubHkgPSBmYWxzZSkge1xuICAgIGZvciAobGV0IHNjYW4gPSBub2RlOyBzY2FuOyBzY2FuID0gKHNpZGUgPT0gXCJzdGFydFwiID8gc2Nhbi5maXJzdENoaWxkIDogc2Nhbi5sYXN0Q2hpbGQpKSB7XG4gICAgICAgIGlmIChzY2FuLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvbmx5ICYmIHNjYW4uY2hpbGRDb3VudCAhPSAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCBzZWxlY3RcbnRoZSBub2RlIGJlZm9yZSB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbmJvdW5kIHRvIGtleXMgbGlrZSBiYWNrc3BhY2UsIGFmdGVyXG5bYGpvaW5CYWNrd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luQmFja3dhcmQpIG9yIG90aGVyIGRlbGV0aW5nXG5jb21tYW5kcywgYXMgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3QgYWxsb3dcbmRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbiovXG5jb25zdCBzZWxlY3ROb2RlQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQmVmb3JlO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zIC0gbm9kZS5ub2RlU2l6ZSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRCZWZvcmUoJHBvcykge1xuICAgIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYmVmb3JlKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGkpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0IDwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICRjdXJzb3I7XG59XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhXG50ZXh0YmxvY2ssIHRyeSB0byByZWR1Y2Ugb3IgcmVtb3ZlIHRoZSBib3VuZGFyeSBiZXR3ZWVuIHRoYXQgYmxvY2tcbmFuZCB0aGUgb25lIGFmdGVyIGl0LCBlaXRoZXIgYnkgam9pbmluZyB0aGVtIG9yIGJ5IG1vdmluZyB0aGUgb3RoZXJcbmJsb2NrIGNsb3NlciB0byB0aGlzIG9uZSBpbiB0aGUgdHJlZSBzdHJ1Y3R1cmUuIFdpbGwgdXNlIHRoZSB2aWV3XG5mb3IgYWNjdXJhdGUgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgdGhpcywgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gICAgaWYgKCEkY3V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXI7XG4gICAgLy8gVHJ5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmIChkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGFib3ZlIGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBiZWxvdyBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBhYm92ZSBhbmQgc2VsZWN0IHRoZSBvbmUgYmVsb3cuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShhZnRlcikpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSwgMSlcbiAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5leHQgbm9kZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYWZ0ZXIuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBjb21pbmcgYWZ0ZXIgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkXG50byBiZSBib3VuZCB0byBrZXlzIGxpa2UgZGVsZXRlLCBhZnRlclxuW2Bqb2luRm9yd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luRm9yd2FyZCkgYW5kIHNpbWlsYXIgZGVsZXRpbmdcbmNvbW1hbmRzLCB0byBwcm92aWRlIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0XG5hbGxvdyBkZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPCAkaGVhZC5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAkY3V0ID0gZmluZEN1dEFmdGVyKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUFmdGVyO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEFmdGVyKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoaSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5pbmRleChpKSArIDEgPCBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmFmdGVyKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2sgb3IsIGlmIHRoZXJlIGlzIGEgdGV4dCBzZWxlY3Rpb24sIHRoZVxuY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGUgc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aFxudGhlIHNpYmxpbmcgYWJvdmUgaXQuXG4qL1xuY29uc3Qgam9pblVwID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIG5vZGVTZWwgPSBzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAobm9kZVNlbCkge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwuZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLmZyb207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC5mcm9tLCAtMSk7XG4gICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuam9pbihwb2ludCk7XG4gICAgICAgIGlmIChub2RlU2VsKVxuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9pbnQgLSBzdGF0ZS5kb2MucmVzb2x2ZShwb2ludCkubm9kZUJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Kb2luIHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhlIHNlbGVjdGlvblxudGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoIHRoZSBzaWJsaW5nIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGpvaW5Eb3duID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHBvaW50O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC50bykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLnRvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwudG8sIDEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5qb2luKHBvaW50KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkxpZnQgdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGVcbnNlbGVjdGlvbiB0aGF0IGNhbiBiZSBsaWZ0ZWQsIG91dCBvZiBpdHMgcGFyZW50IG5vZGUuXG4qL1xuY29uc3QgbGlmdCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aG9zZSB0eXBlIGhhcyBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCByZXBsYWNlIHRoZVxuc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGNoYXJhY3Rlci5cbiovXG5jb25zdCBuZXdsaW5lSW5Db2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydFRleHQoXCJcXG5cIikuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aXRoIGEgdHJ1dGh5XG5bYGNvZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29kZSkgcHJvcGVydHkgaW4gaXRzIHNwZWMsIGNyZWF0ZSBhXG5kZWZhdWx0IGJsb2NrIGFmdGVyIHRoZSBjb2RlIGJsb2NrLCBhbmQgbW92ZSB0aGUgY3Vyc29yIHRoZXJlLlxuKi9cbmNvbnN0IGV4aXRDb2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYWJvdmUgPSAkaGVhZC5ub2RlKC0xKSwgYWZ0ZXIgPSAkaGVhZC5pbmRleEFmdGVyKC0xKSwgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KGFib3ZlLmNvbnRlbnRNYXRjaEF0KGFmdGVyKSk7XG4gICAgaWYgKCF0eXBlIHx8ICFhYm92ZS5jYW5SZXBsYWNlV2l0aChhZnRlciwgYWZ0ZXIsIHR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBwb3MgPSAkaGVhZC5hZnRlcigpLCB0ciA9IHN0YXRlLnRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShwb3MpLCAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIGEgYmxvY2sgbm9kZSBpcyBzZWxlY3RlZCwgY3JlYXRlIGFuIGVtcHR5IHBhcmFncmFwaCBiZWZvcmUgKGlmXG5pdCBpcyBpdHMgcGFyZW50J3MgZmlyc3QgY2hpbGQpIG9yIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGNyZWF0ZVBhcmFncmFwaE5lYXIgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KCR0by5wYXJlbnQuY29udGVudE1hdGNoQXQoJHRvLmluZGV4QWZ0ZXIoKSkpO1xuICAgIGlmICghdHlwZSB8fCAhdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2lkZSA9ICghJGZyb20ucGFyZW50T2Zmc2V0ICYmICR0by5pbmRleCgpIDwgJHRvLnBhcmVudC5jaGlsZENvdW50ID8gJGZyb20gOiAkdG8pLnBvcztcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuaW5zZXJ0KHNpZGUsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgc2lkZSArIDEpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIGN1cnNvciBpcyBpbiBhbiBlbXB0eSB0ZXh0YmxvY2sgdGhhdCBjYW4gYmUgbGlmdGVkLCBsaWZ0IHRoZVxuYmxvY2suXG4qL1xuY29uc3QgbGlmdEVtcHR5QmxvY2sgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGN1cnNvci5kZXB0aCA+IDEgJiYgJGN1cnNvci5hZnRlcigpICE9ICRjdXJzb3IuZW5kKC0xKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gJGN1cnNvci5iZWZvcmUoKTtcbiAgICAgICAgaWYgKGNhblNwbGl0KHN0YXRlLmRvYywgYmVmb3JlKSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KGJlZm9yZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ3JlYXRlIGEgdmFyaWFudCBvZiBbYHNwbGl0QmxvY2tgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRCbG9jaykgdGhhdCB1c2VzXG5hIGN1c3RvbSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIG5ld2x5IHNwbGl0IG9mZiBibG9jay5cbiovXG5mdW5jdGlvbiBzcGxpdEJsb2NrQXMoc3BsaXROb2RlKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzdGF0ZS5zZWxlY3Rpb24ubm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoc3RhdGUuZG9jLCAkZnJvbS5wb3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnQuaXNCbG9jaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09ICR0by5wYXJlbnQuY29udGVudC5zaXplO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiB8fCBzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBsZXQgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PSAwID8gbnVsbCA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSk7XG4gICAgICAgICAgICBsZXQgc3BsaXRUeXBlID0gc3BsaXROb2RlICYmIHNwbGl0Tm9kZSgkdG8ucGFyZW50LCBhdEVuZCk7XG4gICAgICAgICAgICBsZXQgdHlwZXMgPSBzcGxpdFR5cGUgPyBbc3BsaXRUeXBlXSA6IGF0RW5kICYmIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgY2FuID0gY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoIXR5cGVzICYmICFjYW4gJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZsdClcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMgPSBbeyB0eXBlOiBkZWZsdCB9XTtcbiAgICAgICAgICAgICAgICBjYW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbikge1xuICAgICAgICAgICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT0gZGVmbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZsdCAmJiAkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblNwbGl0IHRoZSBwYXJlbnQgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbi4gSWYgdGhlIHNlbGVjdGlvbiBpcyBhIHRleHRcbnNlbGVjdGlvbiwgYWxzbyBkZWxldGUgaXRzIGNvbnRlbnQuXG4qL1xuY29uc3Qgc3BsaXRCbG9jayA9IHNwbGl0QmxvY2tBcygpO1xuLyoqXG5BY3RzIGxpa2UgW2BzcGxpdEJsb2NrYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0QmxvY2spLCBidXQgd2l0aG91dFxucmVzZXR0aW5nIHRoZSBzZXQgb2YgYWN0aXZlIG1hcmtzIGF0IHRoZSBjdXJzb3IuXG4qL1xuY29uc3Qgc3BsaXRCbG9ja0tlZXBNYXJrcyA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICByZXR1cm4gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2ggJiYgKHRyID0+IHtcbiAgICAgICAgbGV0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgKHN0YXRlLnNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgfSkpO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBub2RlIHdyYXBwaW5nIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgaWZcbmFueS4gKFdpbGwgbm90IHNlbGVjdCB0aGUgZG9jdW1lbnQgbm9kZS4pXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50Tm9kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbiwgcG9zO1xuICAgIGxldCBzYW1lID0gJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICAgIGlmIChzYW1lID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBwb3MgPSAkZnJvbS5iZWZvcmUoc2FtZSk7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBwb3MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIHdob2xlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdEFsbCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgQWxsU2VsZWN0aW9uKHN0YXRlLmRvYykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBqb2luTWF5YmVDbGVhcihzdGF0ZSwgJHBvcywgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBhZnRlciA9ICRwb3Mubm9kZUFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICBpZiAoIWJlZm9yZSB8fCAhYWZ0ZXIgfHwgIWJlZm9yZS50eXBlLmNvbXBhdGlibGVDb250ZW50KGFmdGVyLnR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFiZWZvcmUuY29udGVudC5zaXplICYmICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXggLSAxLCBpbmRleCkpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRwb3MucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkcG9zLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoISRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkgfHwgIShhZnRlci5pc1RleHRibG9jayB8fCBjYW5Kb2luKHN0YXRlLmRvYywgJHBvcy5wb3MpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHJcbiAgICAgICAgICAgIC5jbGVhckluY29tcGF0aWJsZSgkcG9zLnBvcywgYmVmb3JlLnR5cGUsIGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpXG4gICAgICAgICAgICAuam9pbigkcG9zLnBvcylcbiAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgY29ubiwgbWF0Y2g7XG4gICAgaWYgKGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoam9pbk1heWJlQ2xlYXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGNhbkRlbEFmdGVyID0gJGN1dC5wYXJlbnQuY2FuUmVwbGFjZSgkY3V0LmluZGV4KCksICRjdXQuaW5kZXgoKSArIDEpO1xuICAgIGlmIChjYW5EZWxBZnRlciAmJlxuICAgICAgICAoY29ubiA9IChtYXRjaCA9IGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpLmZpbmRXcmFwcGluZyhhZnRlci50eXBlKSkgJiZcbiAgICAgICAgbWF0Y2gubWF0Y2hUeXBlKGNvbm5bMF0gfHwgYWZ0ZXIudHlwZSkudmFsaWRFbmQpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbm4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oY29ubltpXS5jcmVhdGUobnVsbCwgd3JhcCkpO1xuICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oYmVmb3JlLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSAxLCBlbmQsICRjdXQucG9zLCBlbmQsIG5ldyBTbGljZSh3cmFwLCAxLCAwKSwgY29ubi5sZW5ndGgsIHRydWUpKTtcbiAgICAgICAgICAgIGxldCBqb2luQXQgPSBlbmQgKyAyICogY29ubi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGpvaW5BdCkpXG4gICAgICAgICAgICAgICAgdHIuam9pbihqb2luQXQpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBzZWxBZnRlciA9IFNlbGVjdGlvbi5maW5kRnJvbSgkY3V0LCAxKTtcbiAgICBsZXQgcmFuZ2UgPSBzZWxBZnRlciAmJiBzZWxBZnRlci4kZnJvbS5ibG9ja1JhbmdlKHNlbEFmdGVyLiR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQgPj0gJGN1dC5kZXB0aCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNhbkRlbEFmdGVyICYmIHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIsIHRydWUpICYmIHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikpIHtcbiAgICAgICAgbGV0IGF0ID0gYmVmb3JlLCB3cmFwID0gW107XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHdyYXAucHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBhdCA9IGF0Lmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyRGVwdGggPSAxO1xuICAgICAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJUZXh0ID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBhZnRlckRlcHRoKys7XG4gICAgICAgIGlmIChhdC5jYW5SZXBsYWNlKGF0LmNoaWxkQ291bnQsIGF0LmNoaWxkQ291bnQsIGFmdGVyVGV4dC5jb250ZW50KSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBGcmFnbWVudC5mcm9tKHdyYXBbaV0uY29weShlbmQpKTtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIHdyYXAubGVuZ3RoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCAkY3V0LnBvcyArIGFmdGVyRGVwdGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUgLSBhZnRlckRlcHRoLCBuZXcgU2xpY2UoZW5kLCB3cmFwLmxlbmd0aCwgMCksIDAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRleHRibG9ja1NpZGUoc2lkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sICRwb3MgPSBzaWRlIDwgMCA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgICAgIGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7XG4gICAgICAgIHdoaWxlICgkcG9zLm5vZGUoZGVwdGgpLmlzSW5saW5lKSB7XG4gICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkcG9zLm5vZGUoZGVwdGgpLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBzaWRlIDwgMCA/ICRwb3Muc3RhcnQoZGVwdGgpIDogJHBvcy5lbmQoZGVwdGgpKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Nb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrU3RhcnQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKC0xKTtcbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgZW5kIG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiovXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tFbmQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKDEpO1xuLy8gUGFyYW1ldGVyaXplZCBjb21tYW5kc1xuLyoqXG5XcmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdpdGggdGhlIGdpdmVuXG5hdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHdyYXBJbihub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHdyYXBwaW5nID0gcmFuZ2UgJiYgZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICBpZiAoIXdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci53cmFwKHJhbmdlLCB3cmFwcGluZykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblJldHVybnMgYSBjb21tYW5kIHRoYXQgdHJpZXMgdG8gc2V0IHRoZSBzZWxlY3RlZCB0ZXh0YmxvY2tzIHRvIHRoZVxuZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4qL1xuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKG5vZGVUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgYXBwbGljYWJsZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoICYmICFhcHBsaWNhYmxlOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tOiB7IHBvczogZnJvbSB9LCAkdG86IHsgcG9zOiB0byB9IH0gPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW2ldO1xuICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcHBsaWNhYmxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUuaGFzTWFya3VwKG5vZGVUeXBlLCBhdHRycykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09IG5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZSA9ICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFwcGxpY2FibGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICB0ci5zZXRCbG9ja1R5cGUoZnJvbSwgdG8sIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFya0FwcGxpZXMoZG9jLCByYW5nZXMsIHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgIGxldCBjYW4gPSAkZnJvbS5kZXB0aCA9PSAwID8gZG9jLmlubGluZUNvbnRlbnQgJiYgZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSkgOiBmYWxzZTtcbiAgICAgICAgZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYW4gPSBub2RlLmlubGluZUNvbnRlbnQgJiYgbm9kZS50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB0b2dnbGVzIHRoZSBnaXZlbiBtYXJrIHdpdGggdGhlXG5naXZlbiBhdHRyaWJ1dGVzLiBXaWxsIHJldHVybiBgZmFsc2VgIHdoZW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5kb2Vzbid0IHN1cHBvcnQgdGhhdCBtYXJrLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBtYXJrIGlmIGFueSBtYXJrc1xub2YgdGhhdCB0eXBlIGV4aXN0IGluIHRoZSBzZWxlY3Rpb24sIG9yIGFkZCBpdCBvdGhlcndpc2UuIElmIHRoZVxuc2VsZWN0aW9uIGlzIGVtcHR5LCB0aGlzIGFwcGxpZXMgdG8gdGhlIFtzdG9yZWRcbm1hcmtzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpIGluc3RlYWQgb2YgYSByYW5nZSBvZiB0aGVcbmRvY3VtZW50LlxuKi9cbmZ1bmN0aW9uIHRvZ2dsZU1hcmsobWFya1R5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7IGVtcHR5LCAkY3Vyc29yLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKChlbXB0eSAmJiAhJGN1cnNvcikgfHwgIW1hcmtBcHBsaWVzKHN0YXRlLmRvYywgcmFuZ2VzLCBtYXJrVHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUuaXNJblNldChzdGF0ZS5zdG9yZWRNYXJrcyB8fCAkY3Vyc29yLm1hcmtzKCkpKVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5hZGRTdG9yZWRNYXJrKG1hcmtUeXBlLmNyZWF0ZShhdHRycykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBoYXMgPSBmYWxzZSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgIWhhcyAmJiBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaGFzID0gc3RhdGUuZG9jLnJhbmdlSGFzTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKCRmcm9tLnBvcywgJHRvLnBvcywgbWFya1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSAkZnJvbS5wb3MsIHRvID0gJHRvLnBvcywgc3RhcnQgPSAkZnJvbS5ub2RlQWZ0ZXIsIGVuZCA9ICR0by5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlU3RhcnQgPSBzdGFydCAmJiBzdGFydC5pc1RleHQgPyAvXlxccyovLmV4ZWMoc3RhcnQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUVuZCA9IGVuZCAmJiBlbmQuaXNUZXh0ID8gL1xccyokLy5leGVjKGVuZC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gKyBzcGFjZVN0YXJ0IDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHNwYWNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gLT0gc3BhY2VFbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSkge1xuICAgIHJldHVybiAodHIpID0+IHtcbiAgICAgICAgaWYgKCF0ci5pc0dlbmVyaWMpXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2godHIpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHIubWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdHIubWFwcGluZy5tYXBzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gbWFwLm1hcChyYW5nZXNbal0pO1xuICAgICAgICAgICAgbWFwLmZvckVhY2goKF9zLCBfZSwgZnJvbSwgdG8pID0+IHJhbmdlcy5wdXNoKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBqb2luYWJsZSBwb2ludHMgZXhpc3QgaW5zaWRlIHRob3NlIHJhbmdlcyxcbiAgICAgICAgLy8gYnkgY2hlY2tpbmcgYWxsIG5vZGUgYm91bmRhcmllcyBpbiB0aGVpciBwYXJlbnQgbm9kZXMuXG4gICAgICAgIGxldCBqb2luYWJsZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaV0sIHRvID0gcmFuZ2VzW2kgKyAxXTtcbiAgICAgICAgICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCBkZXB0aCA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKSwgcGFyZW50ID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9ICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpLCBwb3MgPSAkZnJvbS5hZnRlcihkZXB0aCArIDEpOyBwb3MgPD0gdG87ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICYmIGpvaW5hYmxlLmluZGV4T2YocG9zKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUudHlwZSA9PSBhZnRlci50eXBlICYmIGlzSm9pbmFibGUoYmVmb3JlLCBhZnRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luYWJsZS5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKb2luIHRoZSBqb2luYWJsZSBwb2ludHNcbiAgICAgICAgam9pbmFibGUuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBmb3IgKGxldCBpID0gam9pbmFibGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbmFibGVbaV0pKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oam9pbmFibGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9O1xufVxuLyoqXG5XcmFwIGEgY29tbWFuZCBzbyB0aGF0LCB3aGVuIGl0IHByb2R1Y2VzIGEgdHJhbnNmb3JtIHRoYXQgY2F1c2VzXG50d28gam9pbmFibGUgbm9kZXMgdG8gZW5kIHVwIG5leHQgdG8gZWFjaCBvdGhlciwgdGhvc2UgYXJlIGpvaW5lZC5cbk5vZGVzIGFyZSBjb25zaWRlcmVkIGpvaW5hYmxlIHdoZW4gdGhleSBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmRcbndoZW4gdGhlIGBpc0pvaW5hYmxlYCBwcmVkaWNhdGUgcmV0dXJucyB0cnVlIGZvciB0aGVtIG9yLCBpZiBhblxuYXJyYXkgb2Ygc3RyaW5ncyB3YXMgcGFzc2VkLCBpZiB0aGVpciBub2RlIHR5cGUgbmFtZSBpcyBpbiB0aGF0XG5hcnJheS5cbiovXG5mdW5jdGlvbiBhdXRvSm9pbihjb21tYW5kLCBpc0pvaW5hYmxlKSB7XG4gICAgbGV0IGNhbkpvaW4gPSBBcnJheS5pc0FycmF5KGlzSm9pbmFibGUpID8gKG5vZGUpID0+IGlzSm9pbmFibGUuaW5kZXhPZihub2RlLnR5cGUubmFtZSkgPiAtMVxuICAgICAgICA6IGlzSm9pbmFibGU7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IGNvbW1hbmQoc3RhdGUsIGRpc3BhdGNoICYmIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGNhbkpvaW4pLCB2aWV3KTtcbn1cbi8qKlxuQ29tYmluZSBhIG51bWJlciBvZiBjb21tYW5kIGZ1bmN0aW9ucyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uICh3aGljaFxuY2FsbHMgdGhlbSBvbmUgYnkgb25lIHVudGlsIG9uZSByZXR1cm5zIHRydWUpLlxuKi9cbmZ1bmN0aW9uIGNoYWluQ29tbWFuZHMoLi4uY29tbWFuZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbW1hbmRzW2ldKHN0YXRlLCBkaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxubGV0IGJhY2tzcGFjZSA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luQmFja3dhcmQsIHNlbGVjdE5vZGVCYWNrd2FyZCk7XG5sZXQgZGVsID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5Gb3J3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCk7XG4vKipcbkEgYmFzaWMga2V5bWFwIGNvbnRhaW5pbmcgYmluZGluZ3Mgbm90IHNwZWNpZmljIHRvIGFueSBzY2hlbWEuXG5CaW5kcyB0aGUgZm9sbG93aW5nIGtleXMgKHdoZW4gbXVsdGlwbGUgY29tbWFuZHMgYXJlIGxpc3RlZCwgdGhleVxuYXJlIGNoYWluZWQgd2l0aCBbYGNoYWluQ29tbWFuZHNgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuY2hhaW5Db21tYW5kcykpOlxuXG4qICoqRW50ZXIqKiB0byBgbmV3bGluZUluQ29kZWAsIGBjcmVhdGVQYXJhZ3JhcGhOZWFyYCwgYGxpZnRFbXB0eUJsb2NrYCwgYHNwbGl0QmxvY2tgXG4qICoqTW9kLUVudGVyKiogdG8gYGV4aXRDb2RlYFxuKiAqKkJhY2tzcGFjZSoqIGFuZCAqKk1vZC1CYWNrc3BhY2UqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5CYWNrd2FyZGAsIGBzZWxlY3ROb2RlQmFja3dhcmRgXG4qICoqRGVsZXRlKiogYW5kICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLWEqKiB0byBgc2VsZWN0QWxsYFxuKi9cbmNvbnN0IHBjQmFzZUtleW1hcCA9IHtcbiAgICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICAgIFwiTW9kLUVudGVyXCI6IGV4aXRDb2RlLFxuICAgIFwiQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiU2hpZnQtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIkRlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgICBcIk1vZC1hXCI6IHNlbGVjdEFsbFxufTtcbi8qKlxuQSBjb3B5IG9mIGBwY0Jhc2VLZXltYXBgIHRoYXQgYWxzbyBiaW5kcyAqKkN0cmwtaCoqIGxpa2UgQmFja3NwYWNlLFxuKipDdHJsLWQqKiBsaWtlIERlbGV0ZSwgKipBbHQtQmFja3NwYWNlKiogbGlrZSBDdHJsLUJhY2tzcGFjZSwgYW5kXG4qKkN0cmwtQWx0LUJhY2tzcGFjZSoqLCAqKkFsdC1EZWxldGUqKiwgYW5kICoqQWx0LWQqKiBsaWtlXG5DdHJsLURlbGV0ZS5cbiovXG5jb25zdCBtYWNCYXNlS2V5bWFwID0ge1xuICAgIFwiQ3RybC1oXCI6IHBjQmFzZUtleW1hcFtcIkJhY2tzcGFjZVwiXSxcbiAgICBcIkFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLUJhY2tzcGFjZVwiXSxcbiAgICBcIkN0cmwtZFwiOiBwY0Jhc2VLZXltYXBbXCJEZWxldGVcIl0sXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1EZWxldGVcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1kXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJDdHJsLWFcIjogc2VsZWN0VGV4dGJsb2NrU3RhcnQsXG4gICAgXCJDdHJsLWVcIjogc2VsZWN0VGV4dGJsb2NrRW5kXG59O1xuZm9yIChsZXQga2V5IGluIHBjQmFzZUtleW1hcClcbiAgICBtYWNCYXNlS2V5bWFwW2tleV0gPSBwY0Jhc2VLZXltYXBba2V5XTtcbmNvbnN0IG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IC9NYWN8aVAoaG9uZXxbb2FdZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICA6IHR5cGVvZiBvcyAhPSBcInVuZGVmaW5lZFwiICYmIG9zLnBsYXRmb3JtID8gb3MucGxhdGZvcm0oKSA9PSBcImRhcndpblwiIDogZmFsc2U7XG4vKipcbkRlcGVuZGluZyBvbiB0aGUgZGV0ZWN0ZWQgcGxhdGZvcm0sIHRoaXMgd2lsbCBob2xkXG5bYHBjQmFzZWtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5wY0Jhc2VLZXltYXApIG9yXG5bYG1hY0Jhc2VLZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMubWFjQmFzZUtleW1hcCkuXG4qL1xuY29uc3QgYmFzZUtleW1hcCA9IG1hYyA/IG1hY0Jhc2VLZXltYXAgOiBwY0Jhc2VLZXltYXA7XG5cbmV4cG9ydCB7IGF1dG9Kb2luLCBiYXNlS2V5bWFwLCBjaGFpbkNvbW1hbmRzLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBkZWxldGVTZWxlY3Rpb24sIGV4aXRDb2RlLCBqb2luQmFja3dhcmQsIGpvaW5Eb3duLCBqb2luRm9yd2FyZCwgam9pblRleHRibG9ja0JhY2t3YXJkLCBqb2luVGV4dGJsb2NrRm9yd2FyZCwgam9pblVwLCBsaWZ0LCBsaWZ0RW1wdHlCbG9jaywgbWFjQmFzZUtleW1hcCwgbmV3bGluZUluQ29kZSwgcGNCYXNlS2V5bWFwLCBzZWxlY3RBbGwsIHNlbGVjdE5vZGVCYWNrd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQsIHNlbGVjdFBhcmVudE5vZGUsIHNlbGVjdFRleHRibG9ja0VuZCwgc2VsZWN0VGV4dGJsb2NrU3RhcnQsIHNldEJsb2NrVHlwZSwgc3BsaXRCbG9jaywgc3BsaXRCbG9ja0FzLCBzcGxpdEJsb2NrS2VlcE1hcmtzLCB0b2dnbGVNYXJrLCB3cmFwSW4gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-commands/dist/index.js\n')},"./node_modules/prosemirror-history/dist/index.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: function() { return /* binding */ closeHistory; },\n/* harmony export */   history: function() { return /* binding */ history; },\n/* harmony export */   redo: function() { return /* binding */ redo; },\n/* harmony export */   redoDepth: function() { return /* binding */ redoDepth; },\n/* harmony export */   undo: function() { return /* binding */ undo; },\n/* harmony export */   undoDepth: function() { return /* binding */ undoDepth; }\n/* harmony export */ });\n/* harmony import */ var rope_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rope-sequence */ "./node_modules/rope-sequence/dist/index.es.js");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");\n\n\n\n\n// ProseMirror\'s history isn\'t simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each \'Branch\' (one for the undo history and one for\n// the redo history) keeps an array of \'Items\', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an \'event\' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don\'t have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch\'s history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__["default"].from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__["default"].empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse\'s offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta("appendedTransaction");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta("composition");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta("rebased")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(map) {\n    let result = [];\n    map.forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist }).scrollIntoView());\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey("history");\nconst closeHistoryKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey("closeHistory");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `"addToHistory"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.done.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, false);\n    return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.undone.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, true);\n    return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItaGlzdG9yeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWhpc3RvcnkvZGlzdC9pbmRleC5qcz9kYjY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSb3BlU2VxdWVuY2UgZnJvbSAncm9wZS1zZXF1ZW5jZSc7XG5pbXBvcnQgeyBNYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFBsdWdpbktleSwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vLyBQcm9zZU1pcnJvcidzIGhpc3RvcnkgaXNuJ3Qgc2ltcGx5IGEgd2F5IHRvIHJvbGwgYmFjayB0byBhIHByZXZpb3VzXG4vLyBzdGF0ZSwgYmVjYXVzZSBQcm9zZU1pcnJvciBzdXBwb3J0cyBhcHBseWluZyBjaGFuZ2VzIHdpdGhvdXQgYWRkaW5nXG4vLyB0aGVtIHRvIHRoZSBoaXN0b3J5IChmb3IgZXhhbXBsZSBkdXJpbmcgY29sbGFib3JhdGlvbikuXG4vL1xuLy8gVG8gdGhpcyBlbmQsIGVhY2ggJ0JyYW5jaCcgKG9uZSBmb3IgdGhlIHVuZG8gaGlzdG9yeSBhbmQgb25lIGZvclxuLy8gdGhlIHJlZG8gaGlzdG9yeSkga2VlcHMgYW4gYXJyYXkgb2YgJ0l0ZW1zJywgd2hpY2ggY2FuIG9wdGlvbmFsbHlcbi8vIGhvbGQgYSBzdGVwIChhbiBhY3R1YWwgdW5kb2FibGUgY2hhbmdlKSwgYW5kIGFsd2F5cyBob2xkIGEgcG9zaXRpb25cbi8vIG1hcCAod2hpY2ggaXMgbmVlZGVkIHRvIG1vdmUgY2hhbmdlcyBiZWxvdyB0aGVtIHRvIGFwcGx5IHRvIHRoZVxuLy8gY3VycmVudCBkb2N1bWVudCkuXG4vL1xuLy8gQW4gaXRlbSB0aGF0IGhhcyBib3RoIGEgc3RlcCBhbmQgYSBzZWxlY3Rpb24gYm9va21hcmsgaXMgdGhlIHN0YXJ0XG4vLyBvZiBhbiAnZXZlbnQnIOKAlCBhIGdyb3VwIG9mIGNoYW5nZXMgdGhhdCB3aWxsIGJlIHVuZG9uZSBvciByZWRvbmUgYXRcbi8vIG9uY2UuIChJdCBzdG9yZXMgb25seSB0aGUgYm9va21hcmssIHNpbmNlIHRoYXQgd2F5IHdlIGRvbid0IGhhdmUgdG9cbi8vIHByb3ZpZGUgYSBkb2N1bWVudCB1bnRpbCB0aGUgc2VsZWN0aW9uIGlzIGFjdHVhbGx5IGFwcGxpZWQsIHdoaWNoXG4vLyBpcyB1c2VmdWwgd2hlbiBjb21wcmVzc2luZy4pXG4vLyBVc2VkIHRvIHNjaGVkdWxlIGhpc3RvcnkgY29tcHJlc3Npb25cbmNvbnN0IG1heF9lbXB0eV9pdGVtcyA9IDUwMDtcbmNsYXNzIEJyYW5jaCB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMsIGV2ZW50Q291bnQpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmV2ZW50Q291bnQgPSBldmVudENvdW50O1xuICAgIH1cbiAgICAvLyBQb3AgdGhlIGxhdGVzdCBldmVudCBvZmYgdGhlIGJyYW5jaCdzIGhpc3RvcnkgYW5kIGFwcGx5IGl0XG4gICAgLy8gdG8gYSBkb2N1bWVudCB0cmFuc2Zvcm0uXG4gICAgcG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yICg7OyBlbmQtLSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLml0ZW1zLmdldChlbmQgLSAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0LnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC0tZW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZW1hcCwgbWFwRnJvbTtcbiAgICAgICAgaWYgKHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoZW5kLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHN0YXRlLnRyO1xuICAgICAgICBsZXQgc2VsZWN0aW9uLCByZW1haW5pbmc7XG4gICAgICAgIGxldCBhZGRBZnRlciA9IFtdLCBhZGRCZWZvcmUgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAgPSB0aGlzLnJlbWFwcGluZyhlbmQsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFwKSB7XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2gobmV3IEl0ZW0oaXRlbS5tYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLCBtYXA7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXAgJiYgdHJhbnNmb3JtLm1heWJlU3RlcChzdGVwKS5kb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwID0gdHJhbnNmb3JtLm1hcHBpbmcubWFwc1t0cmFuc2Zvcm0ubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBhZGRBZnRlci5wdXNoKG5ldyBJdGVtKG1hcCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFkZEFmdGVyLmxlbmd0aCArIGFkZEJlZm9yZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgICAgIGlmIChtYXApXG4gICAgICAgICAgICAgICAgICAgIHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLm1heWJlU3RlcChpdGVtLnN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gcmVtYXAgPyBpdGVtLnNlbGVjdGlvbi5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpIDogaXRlbS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gbmV3IEJyYW5jaCh0aGlzLml0ZW1zLnNsaWNlKDAsIGVuZCkuYXBwZW5kKGFkZEJlZm9yZS5yZXZlcnNlKCkuY29uY2F0KGFkZEFmdGVyKSksIHRoaXMuZXZlbnRDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4geyByZW1haW5pbmc6IHJlbWFpbmluZywgdHJhbnNmb3JtLCBzZWxlY3Rpb246IHNlbGVjdGlvbiB9O1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBuZXcgYnJhbmNoIHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybSBhZGRlZC5cbiAgICBhZGRUcmFuc2Zvcm0odHJhbnNmb3JtLCBzZWxlY3Rpb24sIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgIGxldCBuZXdJdGVtcyA9IFtdLCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICBsZXQgb2xkSXRlbXMgPSB0aGlzLml0ZW1zLCBsYXN0SXRlbSA9ICFwcmVzZXJ2ZUl0ZW1zICYmIG9sZEl0ZW1zLmxlbmd0aCA/IG9sZEl0ZW1zLmdldChvbGRJdGVtcy5sZW5ndGggLSAxKSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IHRyYW5zZm9ybS5zdGVwc1tpXS5pbnZlcnQodHJhbnNmb3JtLmRvY3NbaV0pO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgSXRlbSh0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW2ldLCBzdGVwLCBzZWxlY3Rpb24pLCBtZXJnZWQ7XG4gICAgICAgICAgICBpZiAobWVyZ2VkID0gbGFzdEl0ZW0gJiYgbGFzdEl0ZW0ubWVyZ2UoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gbWVyZ2VkO1xuICAgICAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgICAgICBuZXdJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9sZEl0ZW1zID0gb2xkSXRlbXMuc2xpY2UoMCwgb2xkSXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGV2ZW50Q291bnQrKztcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlSXRlbXMpXG4gICAgICAgICAgICAgICAgbGFzdEl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdmVyZmxvdyA9IGV2ZW50Q291bnQgLSBoaXN0T3B0aW9ucy5kZXB0aDtcbiAgICAgICAgaWYgKG92ZXJmbG93ID4gREVQVEhfT1ZFUkZMT1cpIHtcbiAgICAgICAgICAgIG9sZEl0ZW1zID0gY3V0T2ZmRXZlbnRzKG9sZEl0ZW1zLCBvdmVyZmxvdyk7XG4gICAgICAgICAgICBldmVudENvdW50IC09IG92ZXJmbG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKG9sZEl0ZW1zLmFwcGVuZChuZXdJdGVtcyksIGV2ZW50Q291bnQpO1xuICAgIH1cbiAgICByZW1hcHBpbmcoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IG1hcHMgPSBuZXcgTWFwcGluZztcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWlycm9yUG9zID0gaXRlbS5taXJyb3JPZmZzZXQgIT0gbnVsbCAmJiBpIC0gaXRlbS5taXJyb3JPZmZzZXQgPj0gZnJvbVxuICAgICAgICAgICAgICAgID8gbWFwcy5tYXBzLmxlbmd0aCAtIGl0ZW0ubWlycm9yT2Zmc2V0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbWFwcy5hcHBlbmRNYXAoaXRlbS5tYXAsIG1pcnJvclBvcyk7XG4gICAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIG1hcHM7XG4gICAgfVxuICAgIGFkZE1hcHMoYXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKHRoaXMuaXRlbXMuYXBwZW5kKGFycmF5Lm1hcChtYXAgPT4gbmV3IEl0ZW0obWFwKSkpLCB0aGlzLmV2ZW50Q291bnQpO1xuICAgIH1cbiAgICAvLyBXaGVuIHRoZSBjb2xsYWIgbW9kdWxlIHJlY2VpdmVzIHJlbW90ZSBjaGFuZ2VzLCB0aGUgaGlzdG9yeSBoYXNcbiAgICAvLyB0byBrbm93IGFib3V0IHRob3NlLCBzbyB0aGF0IGl0IGNhbiBhZGp1c3QgdGhlIHN0ZXBzIHRoYXQgd2VyZVxuICAgIC8vIHJlYmFzZWQgb24gdG9wIG9mIHRoZSByZW1vdGUgY2hhbmdlcywgYW5kIGluY2x1ZGUgdGhlIHBvc2l0aW9uXG4gICAgLy8gbWFwcyBmb3IgdGhlIHJlbW90ZSBjaGFuZ2VzIGluIGl0cyBhcnJheSBvZiBpdGVtcy5cbiAgICByZWJhc2VkKHJlYmFzZWRUcmFuc2Zvcm0sIHJlYmFzZWRDb3VudCkge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRDb3VudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcmViYXNlZEl0ZW1zID0gW10sIHN0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5pdGVtcy5sZW5ndGggLSByZWJhc2VkQ291bnQpO1xuICAgICAgICBsZXQgbWFwcGluZyA9IHJlYmFzZWRUcmFuc2Zvcm0ubWFwcGluZztcbiAgICAgICAgbGV0IG5ld1VudGlsID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7XG4gICAgICAgIGxldCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7IGlmIChpdGVtLnNlbGVjdGlvbilcbiAgICAgICAgICAgIGV2ZW50Q291bnQtLTsgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgaVJlYmFzZWQgPSByZWJhc2VkQ291bnQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLmdldE1pcnJvcigtLWlSZWJhc2VkKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBuZXdVbnRpbCA9IE1hdGgubWluKG5ld1VudGlsLCBwb3MpO1xuICAgICAgICAgICAgbGV0IG1hcCA9IG1hcHBpbmcubWFwc1twb3NdO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwc1twb3NdLmludmVydChyZWJhc2VkVHJhbnNmb3JtLmRvY3NbcG9zXSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChtYXBwaW5nLnNsaWNlKGlSZWJhc2VkICsgMSwgcG9zKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDb3VudCsrO1xuICAgICAgICAgICAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCwgc3RlcCwgc2VsZWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWJhc2VkSXRlbXMucHVzaChuZXcgSXRlbShtYXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgbmV3TWFwcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gcmViYXNlZENvdW50OyBpIDwgbmV3VW50aWw7IGkrKylcbiAgICAgICAgICAgIG5ld01hcHMucHVzaChuZXcgSXRlbShtYXBwaW5nLm1hcHNbaV0pKTtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwLCBzdGFydCkuYXBwZW5kKG5ld01hcHMpLmFwcGVuZChyZWJhc2VkSXRlbXMpO1xuICAgICAgICBsZXQgYnJhbmNoID0gbmV3IEJyYW5jaChpdGVtcywgZXZlbnRDb3VudCk7XG4gICAgICAgIGlmIChicmFuY2guZW1wdHlJdGVtQ291bnQoKSA+IG1heF9lbXB0eV9pdGVtcylcbiAgICAgICAgICAgIGJyYW5jaCA9IGJyYW5jaC5jb21wcmVzcyh0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRJdGVtcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIH1cbiAgICBlbXB0eUl0ZW1Db3VudCgpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4geyBpZiAoIWl0ZW0uc3RlcClcbiAgICAgICAgICAgIGNvdW50Kys7IH0pO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8vIENvbXByZXNzaW5nIGEgYnJhbmNoIG1lYW5zIHJld3JpdGluZyBpdCB0byBwdXNoIHRoZSBhaXIgKG1hcC1vbmx5XG4gICAgLy8gaXRlbXMpIG91dC4gRHVyaW5nIGNvbGxhYm9yYXRpb24sIHRoZXNlIG5hdHVyYWxseSBhY2N1bXVsYXRlXG4gICAgLy8gYmVjYXVzZSBlYWNoIHJlbW90ZSBjaGFuZ2UgYWRkcyBvbmUuIFRoZSBgdXB0b2AgYXJndW1lbnQgaXMgdXNlZFxuICAgIC8vIHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGl0ZW1zIGJlbG93IGEgZ2l2ZW4gbGV2ZWwgYXJlIGNvbXByZXNzZWQsXG4gICAgLy8gYmVjYXVzZSBgcmViYXNlZGAgcmVsaWVzIG9uIGEgY2xlYW4sIHVudG91Y2hlZCBzZXQgb2YgaXRlbXMgaW5cbiAgICAvLyBvcmRlciB0byBhc3NvY2lhdGUgb2xkIGl0ZW1zIHdpdGggcmViYXNlZCBzdGVwcy5cbiAgICBjb21wcmVzcyh1cHRvID0gdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoMCwgdXB0byksIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgbGV0IGl0ZW1zID0gW10sIGV2ZW50cyA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPj0gdXB0bykge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcCA9IHN0ZXAgJiYgc3RlcC5nZXRNYXAoKTtcbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgaWYgKG1hcClcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAuYXBwZW5kTWFwKG1hcCwgbWFwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0l0ZW0gPSBuZXcgSXRlbShtYXAuaW52ZXJ0KCksIHN0ZXAsIHNlbGVjdGlvbiksIG1lcmdlZCwgbGFzdCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXJnZWQgPSBpdGVtcy5sZW5ndGggJiYgaXRlbXNbbGFzdF0ubWVyZ2UobmV3SXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tsYXN0XSA9IG1lcmdlZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLm1hcCkge1xuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4gbmV3IEJyYW5jaChSb3BlU2VxdWVuY2UuZnJvbShpdGVtcy5yZXZlcnNlKCkpLCBldmVudHMpO1xuICAgIH1cbn1cbkJyYW5jaC5lbXB0eSA9IG5ldyBCcmFuY2goUm9wZVNlcXVlbmNlLmVtcHR5LCAwKTtcbmZ1bmN0aW9uIGN1dE9mZkV2ZW50cyhpdGVtcywgbikge1xuICAgIGxldCBjdXRQb2ludDtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbiAmJiAobi0tID09IDApKSB7XG4gICAgICAgICAgICBjdXRQb2ludCA9IGk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXRlbXMuc2xpY2UoY3V0UG9pbnQpO1xufVxuY2xhc3MgSXRlbSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIChmb3J3YXJkKSBzdGVwIG1hcCBmb3IgdGhpcyBpdGVtLlxuICAgIG1hcCwgXG4gICAgLy8gVGhlIGludmVydGVkIHN0ZXBcbiAgICBzdGVwLCBcbiAgICAvLyBJZiB0aGlzIGlzIG5vbi1udWxsLCB0aGlzIGl0ZW0gaXMgdGhlIHN0YXJ0IG9mIGEgZ3JvdXAsIGFuZFxuICAgIC8vIHRoaXMgc2VsZWN0aW9uIGlzIHRoZSBzdGFydGluZyBzZWxlY3Rpb24gZm9yIHRoZSBncm91cCAodGhlIG9uZVxuICAgIC8vIHRoYXQgd2FzIGFjdGl2ZSBiZWZvcmUgdGhlIGZpcnN0IHN0ZXAgd2FzIGFwcGxpZWQpXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvLyBJZiB0aGlzIGl0ZW0gaXMgdGhlIGludmVyc2Ugb2YgYSBwcmV2aW91cyBtYXBwaW5nIG9uIHRoZSBzdGFjayxcbiAgICAvLyB0aGlzIHBvaW50cyBhdCB0aGUgaW52ZXJzZSdzIG9mZnNldFxuICAgIG1pcnJvck9mZnNldCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5zdGVwID0gc3RlcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGVwICYmIG90aGVyLnN0ZXAgJiYgIW90aGVyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHN0ZXAgPSBvdGhlci5zdGVwLm1lcmdlKHRoaXMuc3RlcCk7XG4gICAgICAgICAgICBpZiAoc3RlcClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZW0oc3RlcC5nZXRNYXAoKS5pbnZlcnQoKSwgc3RlcCwgdGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlIHZhbHVlIG9mIHRoZSBzdGF0ZSBmaWVsZCB0aGF0IHRyYWNrcyB1bmRvL3JlZG8gaGlzdG9yeSBmb3IgdGhhdFxuLy8gc3RhdGUuIFdpbGwgYmUgc3RvcmVkIGluIHRoZSBwbHVnaW4gc3RhdGUgd2hlbiB0aGUgaGlzdG9yeSBwbHVnaW5cbi8vIGlzIGFjdGl2ZS5cbmNsYXNzIEhpc3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZG9uZSwgdW5kb25lLCBwcmV2UmFuZ2VzLCBwcmV2VGltZSwgcHJldkNvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIHRoaXMudW5kb25lID0gdW5kb25lO1xuICAgICAgICB0aGlzLnByZXZSYW5nZXMgPSBwcmV2UmFuZ2VzO1xuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG4gICAgICAgIHRoaXMucHJldkNvbXBvc2l0aW9uID0gcHJldkNvbXBvc2l0aW9uO1xuICAgIH1cbn1cbmNvbnN0IERFUFRIX09WRVJGTE9XID0gMjA7XG4vLyBSZWNvcmQgYSB0cmFuc2Zvcm1hdGlvbiBpbiB1bmRvIGhpc3RvcnkuXG5mdW5jdGlvbiBhcHBseVRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCB0ciwgb3B0aW9ucykge1xuICAgIGxldCBoaXN0b3J5VHIgPSB0ci5nZXRNZXRhKGhpc3RvcnlLZXkpLCByZWJhc2VkO1xuICAgIGlmIChoaXN0b3J5VHIpXG4gICAgICAgIHJldHVybiBoaXN0b3J5VHIuaGlzdG9yeVN0YXRlO1xuICAgIGlmICh0ci5nZXRNZXRhKGNsb3NlSGlzdG9yeUtleSkpXG4gICAgICAgIGhpc3RvcnkgPSBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUsIG51bGwsIDAsIC0xKTtcbiAgICBsZXQgYXBwZW5kZWQgPSB0ci5nZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiKTtcbiAgICBpZiAodHIuc3RlcHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIGhpc3Rvcnk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwcGVuZGVkICYmIGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkpIHtcbiAgICAgICAgaWYgKGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkucmVkbylcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgaGlzdG9yeS51bmRvbmUsIHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUuYWRkVHJhbnNmb3JtKHRyLCB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIG51bGwsIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHIuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSAhPT0gZmFsc2UgJiYgIShhcHBlbmRlZCAmJiBhcHBlbmRlZC5nZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIpID09PSBmYWxzZSkpIHtcbiAgICAgICAgLy8gR3JvdXAgdHJhbnNmb3JtcyB0aGF0IG9jY3VyIGluIHF1aWNrIHN1Y2Nlc3Npb24gaW50byBvbmUgZXZlbnQuXG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHRyLmdldE1ldGEoXCJjb21wb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0dyb3VwID0gaGlzdG9yeS5wcmV2VGltZSA9PSAwIHx8XG4gICAgICAgICAgICAoIWFwcGVuZGVkICYmIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uICE9IGNvbXBvc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgKGhpc3RvcnkucHJldlRpbWUgPCAodHIudGltZSB8fCAwKSAtIG9wdGlvbnMubmV3R3JvdXBEZWxheSB8fCAhaXNBZGphY2VudFRvKHRyLCBoaXN0b3J5LnByZXZSYW5nZXMpKSk7XG4gICAgICAgIGxldCBwcmV2UmFuZ2VzID0gYXBwZW5kZWQgPyBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSA6IHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHNbdHIuc3RlcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUuYWRkVHJhbnNmb3JtKHRyLCBuZXdHcm91cCA/IHN0YXRlLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpIDogdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBCcmFuY2guZW1wdHksIHByZXZSYW5nZXMsIHRyLnRpbWUsIGNvbXBvc2l0aW9uID09IG51bGwgPyBoaXN0b3J5LnByZXZDb21wb3NpdGlvbiA6IGNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmViYXNlZCA9IHRyLmdldE1ldGEoXCJyZWJhc2VkXCIpKSB7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIGNvbGxhYiBtb2R1bGUgdG8gdGVsbCB0aGUgaGlzdG9yeSB0aGF0IHNvbWUgb2YgaXRzXG4gICAgICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gcmViYXNlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBoaXN0b3J5LnVuZG9uZS5yZWJhc2VkKHRyLCByZWJhc2VkKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRNYXBzKHRyLm1hcHBpbmcubWFwcyksIGhpc3RvcnkudW5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0FkamFjZW50VG8odHJhbnNmb3JtLCBwcmV2UmFuZ2VzKSB7XG4gICAgaWYgKCFwcmV2UmFuZ2VzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF0cmFuc2Zvcm0uZG9jQ2hhbmdlZClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGFkamFjZW50ID0gZmFsc2U7XG4gICAgdHJhbnNmb3JtLm1hcHBpbmcubWFwc1swXS5mb3JFYWNoKChzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldlJhbmdlcy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIGlmIChzdGFydCA8PSBwcmV2UmFuZ2VzW2kgKyAxXSAmJiBlbmQgPj0gcHJldlJhbmdlc1tpXSlcbiAgICAgICAgICAgICAgICBhZGphY2VudCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkamFjZW50O1xufVxuZnVuY3Rpb24gcmFuZ2VzRm9yKG1hcCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgZnJvbSwgdG8pID0+IHJlc3VsdC5wdXNoKGZyb20sIHRvKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlcyhyYW5nZXMsIG1hcHBpbmcpIHtcbiAgICBpZiAoIXJhbmdlcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAocmFuZ2VzW2ldLCAxKSwgdG8gPSBtYXBwaW5nLm1hcChyYW5nZXNbaSArIDFdLCAtMSk7XG4gICAgICAgIGlmIChmcm9tIDw9IHRvKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJvbSwgdG8pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQXBwbHkgdGhlIGxhdGVzdCBldmVudCBmcm9tIG9uZSBicmFuY2ggdG8gdGhlIGRvY3VtZW50IGFuZCBzaGlmdCB0aGUgZXZlbnRcbi8vIG9udG8gdGhlIG90aGVyIGJyYW5jaC5cbmZ1bmN0aW9uIGhpc3RUcmFuc2FjdGlvbihoaXN0b3J5LCBzdGF0ZSwgZGlzcGF0Y2gsIHJlZG8pIHtcbiAgICBsZXQgcHJlc2VydmVJdGVtcyA9IG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKTtcbiAgICBsZXQgaGlzdE9wdGlvbnMgPSBoaXN0b3J5S2V5LmdldChzdGF0ZSkuc3BlYy5jb25maWc7XG4gICAgbGV0IHBvcCA9IChyZWRvID8gaGlzdG9yeS51bmRvbmUgOiBoaXN0b3J5LmRvbmUpLnBvcEV2ZW50KHN0YXRlLCBwcmVzZXJ2ZUl0ZW1zKTtcbiAgICBpZiAoIXBvcClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzZWxlY3Rpb24gPSBwb3Auc2VsZWN0aW9uLnJlc29sdmUocG9wLnRyYW5zZm9ybS5kb2MpO1xuICAgIGxldCBhZGRlZCA9IChyZWRvID8gaGlzdG9yeS5kb25lIDogaGlzdG9yeS51bmRvbmUpLmFkZFRyYW5zZm9ybShwb3AudHJhbnNmb3JtLCBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpO1xuICAgIGxldCBuZXdIaXN0ID0gbmV3IEhpc3RvcnlTdGF0ZShyZWRvID8gYWRkZWQgOiBwb3AucmVtYWluaW5nLCByZWRvID8gcG9wLnJlbWFpbmluZyA6IGFkZGVkLCBudWxsLCAwLCAtMSk7XG4gICAgZGlzcGF0Y2gocG9wLnRyYW5zZm9ybS5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKS5zZXRNZXRhKGhpc3RvcnlLZXksIHsgcmVkbywgaGlzdG9yeVN0YXRlOiBuZXdIaXN0IH0pLnNjcm9sbEludG9WaWV3KCkpO1xufVxubGV0IGNhY2hlZFByZXNlcnZlSXRlbXMgPSBmYWxzZSwgY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgPSBudWxsO1xuLy8gQ2hlY2sgd2hldGhlciBhbnkgcGx1Z2luIGluIHRoZSBnaXZlbiBzdGF0ZSBoYXMgYVxuLy8gYGhpc3RvcnlQcmVzZXJ2ZUl0ZW1zYCBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0XG4vLyBwcmVzZXJ2ZSBzdGVwcyBleGFjdGx5IGFzIHRoZXkgY2FtZSBpbiwgc28gdGhhdCB0aGV5IGNhbiBiZVxuLy8gcmViYXNlZC5cbmZ1bmN0aW9uIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSB7XG4gICAgbGV0IHBsdWdpbnMgPSBzdGF0ZS5wbHVnaW5zO1xuICAgIGlmIChjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyAhPSBwbHVnaW5zKSB7XG4gICAgICAgIGNhY2hlZFByZXNlcnZlSXRlbXMgPSBmYWxzZTtcbiAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgPSBwbHVnaW5zO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAocGx1Z2luc1tpXS5zcGVjLmhpc3RvcnlQcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRQcmVzZXJ2ZUl0ZW1zO1xufVxuLyoqXG5TZXQgYSBmbGFnIG9uIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0aGF0IHdpbGwgcHJldmVudCBmdXJ0aGVyIHN0ZXBzXG5mcm9tIGJlaW5nIGFwcGVuZGVkIHRvIGFuIGV4aXN0aW5nIGhpc3RvcnkgZXZlbnQgKHNvIHRoYXQgdGhleVxucmVxdWlyZSBhIHNlcGFyYXRlIHVuZG8gY29tbWFuZCB0byB1bmRvKS5cbiovXG5mdW5jdGlvbiBjbG9zZUhpc3RvcnkodHIpIHtcbiAgICByZXR1cm4gdHIuc2V0TWV0YShjbG9zZUhpc3RvcnlLZXksIHRydWUpO1xufVxuY29uc3QgaGlzdG9yeUtleSA9IG5ldyBQbHVnaW5LZXkoXCJoaXN0b3J5XCIpO1xuY29uc3QgY2xvc2VIaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImNsb3NlSGlzdG9yeVwiKTtcbi8qKlxuUmV0dXJucyBhIHBsdWdpbiB0aGF0IGVuYWJsZXMgdGhlIHVuZG8gaGlzdG9yeSBmb3IgYW4gZWRpdG9yLiBUaGVcbnBsdWdpbiB3aWxsIHRyYWNrIHVuZG8gYW5kIHJlZG8gc3RhY2tzLCB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIHRoZVxuW2B1bmRvYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2hpc3RvcnkudW5kbykgYW5kIFtgcmVkb2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNoaXN0b3J5LnJlZG8pIGNvbW1hbmRzLlxuXG5Zb3UgY2FuIHNldCBhbiBgXCJhZGRUb0hpc3RvcnlcImAgW21ldGFkYXRhXG5wcm9wZXJ0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNldE1ldGEpIG9mIGBmYWxzZWAgb24gYSB0cmFuc2FjdGlvblxudG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJvbGxlZCBiYWNrIGJ5IHVuZG8uXG4qL1xuZnVuY3Rpb24gaGlzdG9yeShjb25maWcgPSB7fSkge1xuICAgIGNvbmZpZyA9IHsgZGVwdGg6IGNvbmZpZy5kZXB0aCB8fCAxMDAsXG4gICAgICAgIG5ld0dyb3VwRGVsYXk6IGNvbmZpZy5uZXdHcm91cERlbGF5IHx8IDUwMCB9O1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBoaXN0b3J5S2V5LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShCcmFuY2guZW1wdHksIEJyYW5jaC5lbXB0eSwgbnVsbCwgMCwgLTEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGx5KHRyLCBoaXN0LCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseVRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCB0ciwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgYmVmb3JlaW5wdXQodmlldywgZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5wdXRUeXBlID0gZS5pbnB1dFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gaW5wdXRUeXBlID09IFwiaGlzdG9yeVVuZG9cIiA/IHVuZG8gOiBpbnB1dFR5cGUgPT0gXCJoaXN0b3J5UmVkb1wiID8gcmVkbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdW5kb2VzIHRoZSBsYXN0IGNoYW5nZSwgaWYgYW55LlxuKi9cbmNvbnN0IHVuZG8gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICBpZiAoIWhpc3QgfHwgaGlzdC5kb25lLmV2ZW50Q291bnQgPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgaGlzdFRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgcmVkb2VzIHRoZSBsYXN0IHVuZG9uZSBjaGFuZ2UsIGlmIGFueS5cbiovXG5jb25zdCByZWRvID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgaWYgKCFoaXN0IHx8IGhpc3QudW5kb25lLmV2ZW50Q291bnQgPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgaGlzdFRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5UaGUgYW1vdW50IG9mIHVuZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiB1bmRvRGVwdGgoc3RhdGUpIHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBoaXN0ID8gaGlzdC5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gcmVkb0RlcHRoKHN0YXRlKSB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gaGlzdCA/IGhpc3QudW5kb25lLmV2ZW50Q291bnQgOiAwO1xufVxuXG5leHBvcnQgeyBjbG9zZUhpc3RvcnksIGhpc3RvcnksIHJlZG8sIHJlZG9EZXB0aCwgdW5kbywgdW5kb0RlcHRoIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-history/dist/index.js\n')},"./node_modules/prosemirror-inputrules/dist/index.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputRule: function() { return /* binding */ InputRule; },\n/* harmony export */   closeDoubleQuote: function() { return /* binding */ closeDoubleQuote; },\n/* harmony export */   closeSingleQuote: function() { return /* binding */ closeSingleQuote; },\n/* harmony export */   ellipsis: function() { return /* binding */ ellipsis; },\n/* harmony export */   emDash: function() { return /* binding */ emDash; },\n/* harmony export */   inputRules: function() { return /* binding */ inputRules; },\n/* harmony export */   openDoubleQuote: function() { return /* binding */ openDoubleQuote; },\n/* harmony export */   openSingleQuote: function() { return /* binding */ openSingleQuote; },\n/* harmony export */   smartQuotes: function() { return /* binding */ smartQuotes; },\n/* harmony export */   textblockTypeInputRule: function() { return /* binding */ textblockTypeInputRule; },\n/* harmony export */   undoInputRule: function() { return /* binding */ undoInputRule; },\n/* harmony export */   wrappingInputRule: function() { return /* binding */ wrappingInputRule; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");\n\n\n\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `"> "` into a blockquote, or something entirely different.\n*/\nclass InputRule {\n    // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n    /**\n    Create an input rule. The rule applies when the user typed\n    something and the text directly in front of the cursor matches\n    `match`, which should end with `$`.\n    \n    The `handler` can be a string, in which case the matched text, or\n    the first matched group in the regexp, is replaced by that\n    string.\n    \n    Or a it can be a function, which will be called with the match\n    array produced by\n    [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n    as well as the start and end of the matched range, and which can\n    return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\n    rule\'s effect, or null to indicate the input was not handled.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    match, handler) {\n        this.match = match;\n        this.match = match;\n        this.handler = typeof handler == "string" ? stringHandler(handler) : handler;\n    }\n}\nfunction stringHandler(string) {\n    return function (state, match, start, end) {\n        let insert = string;\n        if (match[1]) {\n            let offset = match[0].lastIndexOf(match[1]);\n            insert += match[0].slice(offset + match[1].length);\n            start += offset;\n            let cutOff = start - end;\n            if (cutOff > 0) {\n                insert = match[0].slice(offset - cutOff, offset) + insert;\n                start = end;\n            }\n        }\n        return state.tr.insertText(insert, start, end);\n    };\n}\nconst MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule\'s\naction.\n*/\nfunction inputRules({ rules }) {\n    let plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        state: {\n            init() { return null; },\n            apply(tr, prev) {\n                let stored = tr.getMeta(this);\n                if (stored)\n                    return stored;\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput(view, from, to, text) {\n                return run(view, from, to, text, rules, plugin);\n            },\n            handleDOMEvents: {\n                compositionend: (view) => {\n                    setTimeout(() => {\n                        let { $cursor } = view.state.selection;\n                        if ($cursor)\n                            run(view, $cursor.pos, $cursor.pos, "", rules, plugin);\n                    });\n                }\n            }\n        },\n        isInputRules: true\n    });\n    return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n    if (view.composing)\n        return false;\n    let state = view.state, $from = state.doc.resolve(from);\n    if ($from.parent.type.spec.code)\n        return false;\n    let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, "\\ufffc") + text;\n    for (let i = 0; i < rules.length; i++) {\n        let match = rules[i].match.exec(textBefore);\n        let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n        if (!tr)\n            continue;\n        view.dispatch(tr.setMeta(plugin, { transform: tr, from, to, text }));\n        return true;\n    }\n    return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/\nconst undoInputRule = (state, dispatch) => {\n    let plugins = state.plugins;\n    for (let i = 0; i < plugins.length; i++) {\n        let plugin = plugins[i], undoable;\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n            if (dispatch) {\n                let tr = state.tr, toUndo = undoable.transform;\n                for (let j = toUndo.steps.length - 1; j >= 0; j--)\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                if (undoable.text) {\n                    let marks = tr.doc.resolve(undoable.from).marks();\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                }\n                else {\n                    tr.delete(undoable.from, undoable.to);\n                }\n                dispatch(tr);\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\nConverts double dashes to an emdash.\n*/\nconst emDash = new InputRule(/--$/, "—");\n/**\nConverts three dots to an ellipsis character.\n*/\nconst ellipsis = new InputRule(/\\.\\.\\.$/, "…");\n/**\n“Smart” opening double quotes.\n*/\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<\'"\\u2018\\u201C])(")$/, "“");\n/**\n“Smart” closing double quotes.\n*/\nconst closeDoubleQuote = new InputRule(/"$/, "”");\n/**\n“Smart” opening single quotes.\n*/\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<\'"\\u2018\\u201C])(\')$/, "‘");\n/**\n“Smart” closing single quotes.\n*/\nconst closeSingleQuote = new InputRule(/\'$/, "’");\n/**\nSmart-quote related input rules.\n*/\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You\'ll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there\'s a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/\nfunction wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        let tr = state.tr.delete(start, end);\n        let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(range, nodeType, attrs);\n        if (!wrapping)\n            return null;\n        tr.wrap(range, wrapping);\n        let before = tr.doc.resolve(start - 1).nodeBefore;\n        if (before && before.type == nodeType && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, start - 1) &&\n            (!joinPredicate || joinPredicate(match, before)))\n            tr.join(start - 1);\n        return tr;\n    });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You\'ll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node\'s attributes, and works the same as in the\n`wrappingInputRule` function.\n*/\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let $start = state.doc.resolve(start);\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType))\n            return null;\n        return state.tr\n            .delete(start, end)\n            .setBlockType(start, start, nodeType, attrs);\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItaW5wdXRydWxlcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QtZ3VscC8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1pbnB1dHJ1bGVzL2Rpc3QvaW5kZXguanM/NDY0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBmaW5kV3JhcHBpbmcsIGNhbkpvaW4gfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG4vKipcbklucHV0IHJ1bGVzIGFyZSByZWd1bGFyIGV4cHJlc3Npb25zIGRlc2NyaWJpbmcgYSBwaWVjZSBvZiB0ZXh0XG50aGF0LCB3aGVuIHR5cGVkLCBjYXVzZXMgc29tZXRoaW5nIHRvIGhhcHBlbi4gVGhpcyBtaWdodCBiZVxuY2hhbmdpbmcgdHdvIGRhc2hlcyBpbnRvIGFuIGVtZGFzaCwgd3JhcHBpbmcgYSBwYXJhZ3JhcGggc3RhcnRpbmdcbndpdGggYFwiPiBcImAgaW50byBhIGJsb2NrcXVvdGUsIG9yIHNvbWV0aGluZyBlbnRpcmVseSBkaWZmZXJlbnQuXG4qL1xuY2xhc3MgSW5wdXRSdWxlIHtcbiAgICAvLyA6OiAoUmVnRXhwLCB1bmlvbjxzdHJpbmcsIChzdGF0ZTogRWRpdG9yU3RhdGUsIG1hdGNoOiBbc3RyaW5nXSwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpIOKGkiA/VHJhbnNhY3Rpb24+KVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnB1dCBydWxlLiBUaGUgcnVsZSBhcHBsaWVzIHdoZW4gdGhlIHVzZXIgdHlwZWRcbiAgICBzb21ldGhpbmcgYW5kIHRoZSB0ZXh0IGRpcmVjdGx5IGluIGZyb250IG9mIHRoZSBjdXJzb3IgbWF0Y2hlc1xuICAgIGBtYXRjaGAsIHdoaWNoIHNob3VsZCBlbmQgd2l0aCBgJGAuXG4gICAgXG4gICAgVGhlIGBoYW5kbGVyYCBjYW4gYmUgYSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgdGhlIG1hdGNoZWQgdGV4dCwgb3JcbiAgICB0aGUgZmlyc3QgbWF0Y2hlZCBncm91cCBpbiB0aGUgcmVnZXhwLCBpcyByZXBsYWNlZCBieSB0aGF0XG4gICAgc3RyaW5nLlxuICAgIFxuICAgIE9yIGEgaXQgY2FuIGJlIGEgZnVuY3Rpb24sIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG1hdGNoXG4gICAgYXJyYXkgcHJvZHVjZWQgYnlcbiAgICBbYFJlZ0V4cC5leGVjYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwL2V4ZWMpLFxuICAgIGFzIHdlbGwgYXMgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIG1hdGNoZWQgcmFuZ2UsIGFuZCB3aGljaCBjYW5cbiAgICByZXR1cm4gYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgdGhhdCBkZXNjcmliZXMgdGhlXG4gICAgcnVsZSdzIGVmZmVjdCwgb3IgbnVsbCB0byBpbmRpY2F0ZSB0aGUgaW5wdXQgd2FzIG5vdCBoYW5kbGVkLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXRjaCwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gdHlwZW9mIGhhbmRsZXIgPT0gXCJzdHJpbmdcIiA/IHN0cmluZ0hhbmRsZXIoaGFuZGxlcikgOiBoYW5kbGVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ0hhbmRsZXIoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgbWF0Y2gsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgbGV0IGluc2VydCA9IHN0cmluZztcbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xuICAgICAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICBzdGFydCArPSBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgY3V0T2ZmID0gc3RhcnQgLSBlbmQ7XG4gICAgICAgICAgICBpZiAoY3V0T2ZmID4gMCkge1xuICAgICAgICAgICAgICAgIGluc2VydCA9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCAtIGN1dE9mZiwgb2Zmc2V0KSArIGluc2VydDtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUudHIuaW5zZXJ0VGV4dChpbnNlcnQsIHN0YXJ0LCBlbmQpO1xuICAgIH07XG59XG5jb25zdCBNQVhfTUFUQ0ggPSA1MDA7XG4vKipcbkNyZWF0ZSBhbiBpbnB1dCBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSB0ZXh0XG5pbnB1dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxlJ3NcbmFjdGlvbi5cbiovXG5mdW5jdGlvbiBpbnB1dFJ1bGVzKHsgcnVsZXMgfSkge1xuICAgIGxldCBwbHVnaW4gPSBuZXcgUGx1Z2luKHtcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgIGluaXQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgYXBwbHkodHIsIHByZXYpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RvcmVkID0gdHIuZ2V0TWV0YSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlVGV4dElucHV0KHZpZXcsIGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bih2aWV3LCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25lbmQ6ICh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGN1cnNvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW4odmlldywgJGN1cnNvci5wb3MsICRjdXJzb3IucG9zLCBcIlwiLCBydWxlcywgcGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc0lucHV0UnVsZXM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gcGx1Z2luO1xufVxuZnVuY3Rpb24gcnVuKHZpZXcsIGZyb20sIHRvLCB0ZXh0LCBydWxlcywgcGx1Z2luKSB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZSwgJGZyb20gPSBzdGF0ZS5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICBpZiAoJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHRleHRCZWZvcmUgPSAkZnJvbS5wYXJlbnQudGV4dEJldHdlZW4oTWF0aC5tYXgoMCwgJGZyb20ucGFyZW50T2Zmc2V0IC0gTUFYX01BVENIKSwgJGZyb20ucGFyZW50T2Zmc2V0LCBudWxsLCBcIlxcdWZmZmNcIikgKyB0ZXh0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG1hdGNoID0gcnVsZXNbaV0ubWF0Y2guZXhlYyh0ZXh0QmVmb3JlKTtcbiAgICAgICAgbGV0IHRyID0gbWF0Y2ggJiYgcnVsZXNbaV0uaGFuZGxlcihzdGF0ZSwgbWF0Y2gsIGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLCB0byk7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0ci5zZXRNZXRhKHBsdWdpbiwgeyB0cmFuc2Zvcm06IHRyLCBmcm9tLCB0bywgdGV4dCB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcblRoaXMgaXMgYSBjb21tYW5kIHRoYXQgd2lsbCB1bmRvIGFuIGlucHV0IHJ1bGUsIGlmIGFwcGx5aW5nIHN1Y2ggYVxucnVsZSB3YXMgdGhlIGxhc3QgdGhpbmcgdGhhdCB0aGUgdXNlciBkaWQuXG4qL1xuY29uc3QgdW5kb0lucHV0UnVsZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBwbHVnaW4gPSBwbHVnaW5zW2ldLCB1bmRvYWJsZTtcbiAgICAgICAgaWYgKHBsdWdpbi5zcGVjLmlzSW5wdXRSdWxlcyAmJiAodW5kb2FibGUgPSBwbHVnaW4uZ2V0U3RhdGUoc3RhdGUpKSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIsIHRvVW5kbyA9IHVuZG9hYmxlLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdG9VbmRvLnN0ZXBzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgICAgICAgICB0ci5zdGVwKHRvVW5kby5zdGVwc1tqXS5pbnZlcnQodG9VbmRvLmRvY3Nbal0pKTtcbiAgICAgICAgICAgICAgICBpZiAodW5kb2FibGUudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFya3MgPSB0ci5kb2MucmVzb2x2ZSh1bmRvYWJsZS5mcm9tKS5tYXJrcygpO1xuICAgICAgICAgICAgICAgICAgICB0ci5yZXBsYWNlV2l0aCh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50bywgc3RhdGUuc2NoZW1hLnRleHQodW5kb2FibGUudGV4dCwgbWFya3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuQ29udmVydHMgZG91YmxlIGRhc2hlcyB0byBhbiBlbWRhc2guXG4qL1xuY29uc3QgZW1EYXNoID0gbmV3IElucHV0UnVsZSgvLS0kLywgXCLigJRcIik7XG4vKipcbkNvbnZlcnRzIHRocmVlIGRvdHMgdG8gYW4gZWxsaXBzaXMgY2hhcmFjdGVyLlxuKi9cbmNvbnN0IGVsbGlwc2lzID0gbmV3IElucHV0UnVsZSgvXFwuXFwuXFwuJC8sIFwi4oCmXCIpO1xuLyoqXG7igJxTbWFydOKAnSBvcGVuaW5nIGRvdWJsZSBxdW90ZXMuXG4qL1xuY29uc3Qgb3BlbkRvdWJsZVF1b3RlID0gbmV3IElucHV0UnVsZSgvKD86XnxbXFxzXFx7XFxbXFwoXFw8J1wiXFx1MjAxOFxcdTIwMUNdKShcIikkLywgXCLigJxcIik7XG4vKipcbuKAnFNtYXJ04oCdIGNsb3NpbmcgZG91YmxlIHF1b3Rlcy5cbiovXG5jb25zdCBjbG9zZURvdWJsZVF1b3RlID0gbmV3IElucHV0UnVsZSgvXCIkLywgXCLigJ1cIik7XG4vKipcbuKAnFNtYXJ04oCdIG9wZW5pbmcgc2luZ2xlIHF1b3Rlcy5cbiovXG5jb25zdCBvcGVuU2luZ2xlUXVvdGUgPSBuZXcgSW5wdXRSdWxlKC8oPzpefFtcXHNcXHtcXFtcXChcXDwnXCJcXHUyMDE4XFx1MjAxQ10pKCcpJC8sIFwi4oCYXCIpO1xuLyoqXG7igJxTbWFydOKAnSBjbG9zaW5nIHNpbmdsZSBxdW90ZXMuXG4qL1xuY29uc3QgY2xvc2VTaW5nbGVRdW90ZSA9IG5ldyBJbnB1dFJ1bGUoLyckLywgXCLigJlcIik7XG4vKipcblNtYXJ0LXF1b3RlIHJlbGF0ZWQgaW5wdXQgcnVsZXMuXG4qL1xuY29uc3Qgc21hcnRRdW90ZXMgPSBbb3BlbkRvdWJsZVF1b3RlLCBjbG9zZURvdWJsZVF1b3RlLCBvcGVuU2luZ2xlUXVvdGUsIGNsb3NlU2luZ2xlUXVvdGVdO1xuXG4vKipcbkJ1aWxkIGFuIGlucHV0IHJ1bGUgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgYSB0ZXh0YmxvY2sgd2hlbiBhXG5naXZlbiBzdHJpbmcgaXMgdHlwZWQuIFRoZSBgcmVnZXhwYCBhcmd1bWVudCBpc1xuZGlyZWN0bHkgcGFzc2VkIHRocm91Z2ggdG8gdGhlIGBJbnB1dFJ1bGVgIGNvbnN0cnVjdG9yLiBZb3UnbGxcbnByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbm9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuXG5gbm9kZVR5cGVgIGlzIHRoZSB0eXBlIG9mIG5vZGUgdG8gd3JhcCBpbi4gSWYgaXQgbmVlZHMgYXR0cmlidXRlcyxcbnlvdSBjYW4gZWl0aGVyIHBhc3MgdGhlbSBkaXJlY3RseSwgb3IgcGFzcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbFxuY29tcHV0ZSB0aGVtIGZyb20gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaC5cblxuQnkgZGVmYXVsdCwgaWYgdGhlcmUncyBhIG5vZGUgd2l0aCB0aGUgc2FtZSB0eXBlIGFib3ZlIHRoZSBuZXdseVxud3JhcHBlZCBub2RlLCB0aGUgcnVsZSB3aWxsIHRyeSB0byBbam9pbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5UcmFuc2Zvcm0uam9pbikgdGhvc2VcbnR3byBub2Rlcy4gWW91IGNhbiBwYXNzIGEgam9pbiBwcmVkaWNhdGUsIHdoaWNoIHRha2VzIGEgcmVndWxhclxuZXhwcmVzc2lvbiBtYXRjaCBhbmQgdGhlIG5vZGUgYmVmb3JlIHRoZSB3cmFwcGVkIG5vZGUsIGFuZCBjYW5cbnJldHVybiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciBhIGpvaW4gc2hvdWxkIGhhcHBlbi5cbiovXG5mdW5jdGlvbiB3cmFwcGluZ0lucHV0UnVsZShyZWdleHAsIG5vZGVUeXBlLCBnZXRBdHRycyA9IG51bGwsIGpvaW5QcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gbmV3IElucHV0UnVsZShyZWdleHAsIChzdGF0ZSwgbWF0Y2gsIHN0YXJ0LCBlbmQpID0+IHtcbiAgICAgICAgbGV0IGF0dHJzID0gZ2V0QXR0cnMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGdldEF0dHJzKG1hdGNoKSA6IGdldEF0dHJzO1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5kZWxldGUoc3RhcnQsIGVuZCk7XG4gICAgICAgIGxldCAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShzdGFydCksIHJhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKSwgd3JhcHBpbmcgPSByYW5nZSAmJiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgICAgIGlmICghd3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdHIud3JhcChyYW5nZSwgd3JhcHBpbmcpO1xuICAgICAgICBsZXQgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUoc3RhcnQgLSAxKS5ub2RlQmVmb3JlO1xuICAgICAgICBpZiAoYmVmb3JlICYmIGJlZm9yZS50eXBlID09IG5vZGVUeXBlICYmIGNhbkpvaW4odHIuZG9jLCBzdGFydCAtIDEpICYmXG4gICAgICAgICAgICAoIWpvaW5QcmVkaWNhdGUgfHwgam9pblByZWRpY2F0ZShtYXRjaCwgYmVmb3JlKSkpXG4gICAgICAgICAgICB0ci5qb2luKHN0YXJ0IC0gMSk7XG4gICAgICAgIHJldHVybiB0cjtcbiAgICB9KTtcbn1cbi8qKlxuQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGNoYW5nZXMgdGhlIHR5cGUgb2YgYSB0ZXh0YmxvY2sgd2hlbiB0aGVcbm1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LiBZb3UnbGwgdXN1YWxseSB3YW50IHRvIHN0YXJ0IHlvdXJcbnJlZ2V4cCB3aXRoIGBeYCB0byB0aGF0IGl0IGlzIG9ubHkgbWF0Y2hlZCBhdCB0aGUgc3RhcnQgb2YgYVxudGV4dGJsb2NrLiBUaGUgb3B0aW9uYWwgYGdldEF0dHJzYCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gY29tcHV0ZVxudGhlIG5ldyBub2RlJ3MgYXR0cmlidXRlcywgYW5kIHdvcmtzIHRoZSBzYW1lIGFzIGluIHRoZVxuYHdyYXBwaW5nSW5wdXRSdWxlYCBmdW5jdGlvbi5cbiovXG5mdW5jdGlvbiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHJlZ2V4cCwgbm9kZVR5cGUsIGdldEF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgSW5wdXRSdWxlKHJlZ2V4cCwgKHN0YXRlLCBtYXRjaCwgc3RhcnQsIGVuZCkgPT4ge1xuICAgICAgICBsZXQgJHN0YXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUoc3RhcnQpO1xuICAgICAgICBsZXQgYXR0cnMgPSBnZXRBdHRycyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZ2V0QXR0cnMobWF0Y2gpIDogZ2V0QXR0cnM7XG4gICAgICAgIGlmICghJHN0YXJ0Lm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRzdGFydC5pbmRleCgtMSksICRzdGFydC5pbmRleEFmdGVyKC0xKSwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBzdGF0ZS50clxuICAgICAgICAgICAgLmRlbGV0ZShzdGFydCwgZW5kKVxuICAgICAgICAgICAgLnNldEJsb2NrVHlwZShzdGFydCwgc3RhcnQsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IElucHV0UnVsZSwgY2xvc2VEb3VibGVRdW90ZSwgY2xvc2VTaW5nbGVRdW90ZSwgZWxsaXBzaXMsIGVtRGFzaCwgaW5wdXRSdWxlcywgb3BlbkRvdWJsZVF1b3RlLCBvcGVuU2luZ2xlUXVvdGUsIHNtYXJ0UXVvdGVzLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLCB1bmRvSW5wdXRSdWxlLCB3cmFwcGluZ0lucHV0UnVsZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-inputrules/dist/index.js\n')},"./node_modules/prosemirror-keymap/dist/index.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: function() { return /* binding */ keydownHandler; },\n/* harmony export */   keymap: function() { return /* binding */ keymap; }\n/* harmony export */ });\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! w3c-keyname */ "./node_modules/w3c-keyname/index.es.js");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");\n\n\n\nconst mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\nfunction normalizeKeyName(name) {\n    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n    if (result == "Space")\n        result = " ";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; i++) {\n        let mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (mac)\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error("Unrecognized modifier name: " + mod);\n    }\n    if (alt)\n        result = "Alt-" + result;\n    if (ctrl)\n        result = "Ctrl-" + result;\n    if (meta)\n        result = "Meta-" + result;\n    if (shift)\n        result = "Shift-" + result;\n    return result;\n}\nfunction normalize(map) {\n    let copy = Object.create(null);\n    for (let prop in map)\n        copy[normalizeKeyName(prop)] = map[prop];\n    return copy;\n}\nfunction modifiers(name, event, shift = true) {\n    if (event.altKey)\n        name = "Alt-" + name;\n    if (event.ctrlKey)\n        name = "Ctrl-" + name;\n    if (event.metaKey)\n        name = "Meta-" + name;\n    if (shift && event.shiftKey)\n        name = "Shift-" + name;\n    return name;\n}\n/**\nCreate a keymap plugin for the given set of bindings.\n\nBindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style\nfunctions, which will be called with `(EditorState, dispatch,\nEditorView)` arguments, and should return true when they\'ve handled\nthe key. Note that the view argument isn\'t part of the command\nprotocol, but can be used as an escape hatch if a binding needs to\ndirectly interact with the UI.\n\nKey names may be strings like `"Shift-Ctrl-Enter"`—a key\nidentifier prefixed with zero or more modifiers. Key identifiers\nare based on the strings that can appear in\n[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\nUse lowercase letters to refer to letter keys (or uppercase letters\nif you want shift to be held). You may use `"Space"` as an alias\nfor the `" "` name.\n\nModifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n`Meta-`) are recognized. For characters that are created by holding\nshift, the `Shift-` prefix is implied, and should not be added\nexplicitly.\n\nYou can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\nother platforms.\n\nYou can add multiple keymap plugins to an editor. The order in\nwhich they appear determines their precedence (the ones early in\nthe array get to dispatch first).\n*/\nfunction keymap(bindings) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });\n}\n/**\nGiven a set of bindings (using the same format as\n[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown\nhandler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.\n*/\nfunction keydownHandler(bindings) {\n    let map = normalize(bindings);\n    return function (view, event) {\n        let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.keyName)(event), baseName, direct = map[modifiers(name, event)];\n        if (direct && direct(view.state, view.dispatch, view))\n            return true;\n        // A character key\n        if (name.length == 1 && name != " ") {\n            if (event.shiftKey) {\n                // In case the name was already modified by shift, try looking\n                // it up without its shift modifier\n                let noShift = map[modifiers(name, event, false)];\n                if (noShift && noShift(view.state, view.dispatch, view))\n                    return true;\n            }\n            if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n                (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.base[event.keyCode]) && baseName != name) {\n                // Try falling back to the keyCode when there\'s a modifier\n                // active or the character produced isn\'t ASCII, and our table\n                // produces a different name from the the keyCode. See #668,\n                // #1060\n                let fromCode = map[modifiers(baseName, event)];\n                if (fromCode && fromCode(view.state, view.dispatch, view))\n                    return true;\n            }\n        }\n        return false;\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Ita2V5bWFwL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Ita2V5bWFwL2Rpc3QvaW5kZXguanM/NDc1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZXlOYW1lLCBiYXNlIH0gZnJvbSAndzNjLWtleW5hbWUnO1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG5jb25zdCBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSkge1xuICAgIGxldCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pLCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAocmVzdWx0ID09IFwiU3BhY2VcIilcbiAgICAgICAgcmVzdWx0ID0gXCIgXCI7XG4gICAgbGV0IGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKG1hYylcbiAgICAgICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpO1xuICAgIH1cbiAgICBpZiAoYWx0KVxuICAgICAgICByZXN1bHQgPSBcIkFsdC1cIiArIHJlc3VsdDtcbiAgICBpZiAoY3RybClcbiAgICAgICAgcmVzdWx0ID0gXCJDdHJsLVwiICsgcmVzdWx0O1xuICAgIGlmIChtZXRhKVxuICAgICAgICByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7XG4gICAgaWYgKHNoaWZ0KVxuICAgICAgICByZXN1bHQgPSBcIlNoaWZ0LVwiICsgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemUobWFwKSB7XG4gICAgbGV0IGNvcHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICBjb3B5W25vcm1hbGl6ZUtleU5hbWUocHJvcCldID0gbWFwW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCA9IHRydWUpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0ICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG4vKipcbkNyZWF0ZSBhIGtleW1hcCBwbHVnaW4gZm9yIHRoZSBnaXZlbiBzZXQgb2YgYmluZGluZ3MuXG5cbkJpbmRpbmdzIHNob3VsZCBtYXAga2V5IG5hbWVzIHRvIFtjb21tYW5kXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMpLXN0eWxlXG5mdW5jdGlvbnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYChFZGl0b3JTdGF0ZSwgZGlzcGF0Y2gsXG5FZGl0b3JWaWV3KWAgYXJndW1lbnRzLCBhbmQgc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gdGhleSd2ZSBoYW5kbGVkXG50aGUga2V5LiBOb3RlIHRoYXQgdGhlIHZpZXcgYXJndW1lbnQgaXNuJ3QgcGFydCBvZiB0aGUgY29tbWFuZFxucHJvdG9jb2wsIGJ1dCBjYW4gYmUgdXNlZCBhcyBhbiBlc2NhcGUgaGF0Y2ggaWYgYSBiaW5kaW5nIG5lZWRzIHRvXG5kaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZSBVSS5cblxuS2V5IG5hbWVzIG1heSBiZSBzdHJpbmdzIGxpa2UgYFwiU2hpZnQtQ3RybC1FbnRlclwiYOKAlGEga2V5XG5pZGVudGlmaWVyIHByZWZpeGVkIHdpdGggemVybyBvciBtb3JlIG1vZGlmaWVycy4gS2V5IGlkZW50aWZpZXJzXG5hcmUgYmFzZWQgb24gdGhlIHN0cmluZ3MgdGhhdCBjYW4gYXBwZWFyIGluXG5bYEtleUV2ZW50LmtleWBdKGh0dHBzOmRldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkpLlxuVXNlIGxvd2VyY2FzZSBsZXR0ZXJzIHRvIHJlZmVyIHRvIGxldHRlciBrZXlzIChvciB1cHBlcmNhc2UgbGV0dGVyc1xuaWYgeW91IHdhbnQgc2hpZnQgdG8gYmUgaGVsZCkuIFlvdSBtYXkgdXNlIGBcIlNwYWNlXCJgIGFzIGFuIGFsaWFzXG5mb3IgdGhlIGBcIiBcImAgbmFtZS5cblxuTW9kaWZpZXJzIGNhbiBiZSBnaXZlbiBpbiBhbnkgb3JkZXIuIGBTaGlmdC1gIChvciBgcy1gKSwgYEFsdC1gIChvclxuYGEtYCksIGBDdHJsLWAgKG9yIGBjLWAgb3IgYENvbnRyb2wtYCkgYW5kIGBDbWQtYCAob3IgYG0tYCBvclxuYE1ldGEtYCkgYXJlIHJlY29nbml6ZWQuIEZvciBjaGFyYWN0ZXJzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgaG9sZGluZ1xuc2hpZnQsIHRoZSBgU2hpZnQtYCBwcmVmaXggaXMgaW1wbGllZCwgYW5kIHNob3VsZCBub3QgYmUgYWRkZWRcbmV4cGxpY2l0bHkuXG5cbllvdSBjYW4gdXNlIGBNb2QtYCBhcyBhIHNob3J0aGFuZCBmb3IgYENtZC1gIG9uIE1hYyBhbmQgYEN0cmwtYCBvblxub3RoZXIgcGxhdGZvcm1zLlxuXG5Zb3UgY2FuIGFkZCBtdWx0aXBsZSBrZXltYXAgcGx1Z2lucyB0byBhbiBlZGl0b3IuIFRoZSBvcmRlciBpblxud2hpY2ggdGhleSBhcHBlYXIgZGV0ZXJtaW5lcyB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBlYXJseSBpblxudGhlIGFycmF5IGdldCB0byBkaXNwYXRjaCBmaXJzdCkuXG4qL1xuZnVuY3Rpb24ga2V5bWFwKGJpbmRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oeyBwcm9wczogeyBoYW5kbGVLZXlEb3duOiBrZXlkb3duSGFuZGxlcihiaW5kaW5ncykgfSB9KTtcbn1cbi8qKlxuR2l2ZW4gYSBzZXQgb2YgYmluZGluZ3MgKHVzaW5nIHRoZSBzYW1lIGZvcm1hdCBhc1xuW2BrZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8ja2V5bWFwLmtleW1hcCkpLCByZXR1cm4gYSBba2V5ZG93blxuaGFuZGxlcl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuaGFuZGxlS2V5RG93bikgdGhhdCBoYW5kbGVzIHRoZW0uXG4qL1xuZnVuY3Rpb24ga2V5ZG93bkhhbmRsZXIoYmluZGluZ3MpIHtcbiAgICBsZXQgbWFwID0gbm9ybWFsaXplKGJpbmRpbmdzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCksIGJhc2VOYW1lLCBkaXJlY3QgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50KV07XG4gICAgICAgIGlmIChkaXJlY3QgJiYgZGlyZWN0KHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIEEgY2hhcmFjdGVyIGtleVxuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT0gMSAmJiBuYW1lICE9IFwiIFwiKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBuYW1lIHdhcyBhbHJlYWR5IG1vZGlmaWVkIGJ5IHNoaWZ0LCB0cnkgbG9va2luZ1xuICAgICAgICAgICAgICAgIC8vIGl0IHVwIHdpdGhvdXQgaXRzIHNoaWZ0IG1vZGlmaWVyXG4gICAgICAgICAgICAgICAgbGV0IG5vU2hpZnQgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBmYWxzZSldO1xuICAgICAgICAgICAgICAgIGlmIChub1NoaWZ0ICYmIG5vU2hpZnQodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBuYW1lLmNoYXJDb2RlQXQoMCkgPiAxMjcpICYmXG4gICAgICAgICAgICAgICAgKGJhc2VOYW1lID0gYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyeSBmYWxsaW5nIGJhY2sgdG8gdGhlIGtleUNvZGUgd2hlbiB0aGVyZSdzIGEgbW9kaWZpZXJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmUgb3IgdGhlIGNoYXJhY3RlciBwcm9kdWNlZCBpc24ndCBBU0NJSSwgYW5kIG91ciB0YWJsZVxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y2VzIGEgZGlmZmVyZW50IG5hbWUgZnJvbSB0aGUgdGhlIGtleUNvZGUuIFNlZSAjNjY4LFxuICAgICAgICAgICAgICAgIC8vICMxMDYwXG4gICAgICAgICAgICAgICAgbGV0IGZyb21Db2RlID0gbWFwW21vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQpXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUNvZGUgJiYgZnJvbUNvZGUodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBrZXlkb3duSGFuZGxlciwga2V5bWFwIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-keymap/dist/index.js\n')},"./node_modules/prosemirror-model/dist/index.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: function() { return /* binding */ ContentMatch; },\n/* harmony export */   DOMParser: function() { return /* binding */ DOMParser; },\n/* harmony export */   DOMSerializer: function() { return /* binding */ DOMSerializer; },\n/* harmony export */   Fragment: function() { return /* binding */ Fragment; },\n/* harmony export */   Mark: function() { return /* binding */ Mark; },\n/* harmony export */   MarkType: function() { return /* binding */ MarkType; },\n/* harmony export */   Node: function() { return /* binding */ Node; },\n/* harmony export */   NodeRange: function() { return /* binding */ NodeRange; },\n/* harmony export */   NodeType: function() { return /* binding */ NodeType; },\n/* harmony export */   ReplaceError: function() { return /* binding */ ReplaceError; },\n/* harmony export */   ResolvedPos: function() { return /* binding */ ResolvedPos; },\n/* harmony export */   Schema: function() { return /* binding */ Schema; },\n/* harmony export */   Slice: function() { return /* binding */ Slice; }\n/* harmony export */ });\n/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orderedmap */ "./node_modules/orderedmap/dist/index.js");\n\n\nfunction findDiffStart(a, b, pos) {\n    for (let i = 0;; i++) {\n        if (i == a.childCount || i == b.childCount)\n            return a.childCount == b.childCount ? null : pos;\n        let childA = a.child(i), childB = b.child(i);\n        if (childA == childB) {\n            pos += childA.nodeSize;\n            continue;\n        }\n        if (!childA.sameMarkup(childB))\n            return pos;\n        if (childA.isText && childA.text != childB.text) {\n            for (let j = 0; childA.text[j] == childB.text[j]; j++)\n                pos++;\n            return pos;\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffStart(childA.content, childB.content, pos + 1);\n            if (inner != null)\n                return inner;\n        }\n        pos += childA.nodeSize;\n    }\n}\nfunction findDiffEnd(a, b, posA, posB) {\n    for (let iA = a.childCount, iB = b.childCount;;) {\n        if (iA == 0 || iB == 0)\n            return iA == iB ? null : { a: posA, b: posB };\n        let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n        if (childA == childB) {\n            posA -= size;\n            posB -= size;\n            continue;\n        }\n        if (!childA.sameMarkup(childB))\n            return { a: posA, b: posB };\n        if (childA.isText && childA.text != childB.text) {\n            let same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n            while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n                same++;\n                posA--;\n                posB--;\n            }\n            return { a: posA, b: posB };\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n            if (inner)\n                return inner;\n        }\n        posA -= size;\n        posB -= size;\n    }\n}\n\n/**\nA fragment represents a node\'s collection of child nodes.\n\nLike nodes, fragments are persistent data structures, and you\nshould not mutate them or their content. Rather, you create new\ninstances whenever needed. The API tries to make this easy.\n*/\nclass Fragment {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    content, size) {\n        this.content = content;\n        this.size = size || 0;\n        if (size == null)\n            for (let i = 0; i < content.length; i++)\n                this.size += content[i].nodeSize;\n    }\n    /**\n    Invoke a callback for all descendant nodes between the given two\n    positions (relative to start of this fragment). Doesn\'t descend\n    into a node when the callback returns `false`.\n    */\n    nodesBetween(from, to, f, nodeStart = 0, parent) {\n        for (let i = 0, pos = 0; pos < to; i++) {\n            let child = this.content[i], end = pos + child.nodeSize;\n            if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n                let start = pos + 1;\n                child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n            }\n            pos = end;\n        }\n    }\n    /**\n    Call the given callback for every descendant node. `pos` will be\n    relative to the start of the fragment. The callback may return\n    `false` to prevent traversal of a given node\'s children.\n    */\n    descendants(f) {\n        this.nodesBetween(0, this.size, f);\n    }\n    /**\n    Extract the text between `from` and `to`. See the same method on\n    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).\n    */\n    textBetween(from, to, blockSeparator, leafText) {\n        let text = "", separated = true;\n        this.nodesBetween(from, to, (node, pos) => {\n            if (node.isText) {\n                text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n                separated = !blockSeparator;\n            }\n            else if (node.isLeaf) {\n                if (leafText) {\n                    text += typeof leafText === "function" ? leafText(node) : leafText;\n                }\n                else if (node.type.spec.leafText) {\n                    text += node.type.spec.leafText(node);\n                }\n                separated = !blockSeparator;\n            }\n            else if (!separated && node.isBlock) {\n                text += blockSeparator;\n                separated = true;\n            }\n        }, 0);\n        return text;\n    }\n    /**\n    Create a new fragment containing the combined content of this\n    fragment and the other.\n    */\n    append(other) {\n        if (!other.size)\n            return this;\n        if (!this.size)\n            return other;\n        let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n        if (last.isText && last.sameMarkup(first)) {\n            content[content.length - 1] = last.withText(last.text + first.text);\n            i = 1;\n        }\n        for (; i < other.content.length; i++)\n            content.push(other.content[i]);\n        return new Fragment(content, this.size + other.size);\n    }\n    /**\n    Cut out the sub-fragment between the two given positions.\n    */\n    cut(from, to = this.size) {\n        if (from == 0 && to == this.size)\n            return this;\n        let result = [], size = 0;\n        if (to > from)\n            for (let i = 0, pos = 0; pos < to; i++) {\n                let child = this.content[i], end = pos + child.nodeSize;\n                if (end > from) {\n                    if (pos < from || end > to) {\n                        if (child.isText)\n                            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));\n                        else\n                            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n                    }\n                    result.push(child);\n                    size += child.nodeSize;\n                }\n                pos = end;\n            }\n        return new Fragment(result, size);\n    }\n    /**\n    @internal\n    */\n    cutByIndex(from, to) {\n        if (from == to)\n            return Fragment.empty;\n        if (from == 0 && to == this.content.length)\n            return this;\n        return new Fragment(this.content.slice(from, to));\n    }\n    /**\n    Create a new fragment in which the node at the given index is\n    replaced by the given node.\n    */\n    replaceChild(index, node) {\n        let current = this.content[index];\n        if (current == node)\n            return this;\n        let copy = this.content.slice();\n        let size = this.size + node.nodeSize - current.nodeSize;\n        copy[index] = node;\n        return new Fragment(copy, size);\n    }\n    /**\n    Create a new fragment by prepending the given node to this\n    fragment.\n    */\n    addToStart(node) {\n        return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n    }\n    /**\n    Create a new fragment by appending the given node to this\n    fragment.\n    */\n    addToEnd(node) {\n        return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n    /**\n    Compare this fragment to another one.\n    */\n    eq(other) {\n        if (this.content.length != other.content.length)\n            return false;\n        for (let i = 0; i < this.content.length; i++)\n            if (!this.content[i].eq(other.content[i]))\n                return false;\n        return true;\n    }\n    /**\n    The first child of the fragment, or `null` if it is empty.\n    */\n    get firstChild() { return this.content.length ? this.content[0] : null; }\n    /**\n    The last child of the fragment, or `null` if it is empty.\n    */\n    get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null; }\n    /**\n    The number of child nodes in this fragment.\n    */\n    get childCount() { return this.content.length; }\n    /**\n    Get the child node at the given index. Raise an error when the\n    index is out of range.\n    */\n    child(index) {\n        let found = this.content[index];\n        if (!found)\n            throw new RangeError("Index " + index + " out of range for " + this);\n        return found;\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n    maybeChild(index) {\n        return this.content[index] || null;\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n    forEach(f) {\n        for (let i = 0, p = 0; i < this.content.length; i++) {\n            let child = this.content[i];\n            f(child, p, i);\n            p += child.nodeSize;\n        }\n    }\n    /**\n    Find the first position at which this fragment and another\n    fragment differ, or `null` if they are the same.\n    */\n    findDiffStart(other, pos = 0) {\n        return findDiffStart(this, other, pos);\n    }\n    /**\n    Find the first position, searching from the end, at which this\n    fragment and the given fragment differ, or `null` if they are\n    the same. Since this position will not be the same in both\n    nodes, an object with two separate positions is returned.\n    */\n    findDiffEnd(other, pos = this.size, otherPos = other.size) {\n        return findDiffEnd(this, other, pos, otherPos);\n    }\n    /**\n    Find the index and inner offset corresponding to a given relative\n    position in this fragment. The result object will be reused\n    (overwritten) the next time the function is called. (Not public.)\n    */\n    findIndex(pos, round = -1) {\n        if (pos == 0)\n            return retIndex(0, pos);\n        if (pos == this.size)\n            return retIndex(this.content.length, pos);\n        if (pos > this.size || pos < 0)\n            throw new RangeError(`Position ${pos} outside of fragment (${this})`);\n        for (let i = 0, curPos = 0;; i++) {\n            let cur = this.child(i), end = curPos + cur.nodeSize;\n            if (end >= pos) {\n                if (end == pos || round > 0)\n                    return retIndex(i + 1, end);\n                return retIndex(i, curPos);\n            }\n            curPos = end;\n        }\n    }\n    /**\n    Return a debugging string that describes this fragment.\n    */\n    toString() { return "<" + this.toStringInner() + ">"; }\n    /**\n    @internal\n    */\n    toStringInner() { return this.content.join(", "); }\n    /**\n    Create a JSON-serializeable representation of this fragment.\n    */\n    toJSON() {\n        return this.content.length ? this.content.map(n => n.toJSON()) : null;\n    }\n    /**\n    Deserialize a fragment from its JSON representation.\n    */\n    static fromJSON(schema, value) {\n        if (!value)\n            return Fragment.empty;\n        if (!Array.isArray(value))\n            throw new RangeError("Invalid input for Fragment.fromJSON");\n        return new Fragment(value.map(schema.nodeFromJSON));\n    }\n    /**\n    Build a fragment from an array of nodes. Ensures that adjacent\n    text nodes with the same marks are joined together.\n    */\n    static fromArray(array) {\n        if (!array.length)\n            return Fragment.empty;\n        let joined, size = 0;\n        for (let i = 0; i < array.length; i++) {\n            let node = array[i];\n            size += node.nodeSize;\n            if (i && node.isText && array[i - 1].sameMarkup(node)) {\n                if (!joined)\n                    joined = array.slice(0, i);\n                joined[joined.length - 1] = node\n                    .withText(joined[joined.length - 1].text + node.text);\n            }\n            else if (joined) {\n                joined.push(node);\n            }\n        }\n        return new Fragment(joined || array, size);\n    }\n    /**\n    Create a fragment from something that can be interpreted as a\n    set of nodes. For `null`, it returns the empty fragment. For a\n    fragment, the fragment itself. For a node or array of nodes, a\n    fragment containing those nodes.\n    */\n    static from(nodes) {\n        if (!nodes)\n            return Fragment.empty;\n        if (nodes instanceof Fragment)\n            return nodes;\n        if (Array.isArray(nodes))\n            return this.fromArray(nodes);\n        if (nodes.attrs)\n            return new Fragment([nodes], nodes.nodeSize);\n        throw new RangeError("Can not convert " + nodes + " to a Fragment" +\n            (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));\n    }\n}\n/**\nAn empty fragment. Intended to be reused whenever a node doesn\'t\ncontain anything (rather than allocating a new empty fragment for\neach leaf node).\n*/\nFragment.empty = new Fragment([], 0);\nconst found = { index: 0, offset: 0 };\nfunction retIndex(index, offset) {\n    found.index = index;\n    found.offset = offset;\n    return found;\n}\n\nfunction compareDeep(a, b) {\n    if (a === b)\n        return true;\n    if (!(a && typeof a == "object") ||\n        !(b && typeof b == "object"))\n        return false;\n    let array = Array.isArray(a);\n    if (Array.isArray(b) != array)\n        return false;\n    if (array) {\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++)\n            if (!compareDeep(a[i], b[i]))\n                return false;\n    }\n    else {\n        for (let p in a)\n            if (!(p in b) || !compareDeep(a[p], b[p]))\n                return false;\n        for (let p in b)\n            if (!(p in a))\n                return false;\n    }\n    return true;\n}\n\n/**\nA mark is a piece of information that can be attached to a node,\nsuch as it being emphasized, in code font, or a link. It has a\ntype and optionally a set of attributes that provide further\ninformation (such as the target of the link). Marks are created\nthrough a `Schema`, which controls which types exist and which\nattributes they have.\n*/\nclass Mark {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The type of this mark.\n    */\n    type, \n    /**\n    The attributes associated with this mark.\n    */\n    attrs) {\n        this.type = type;\n        this.attrs = attrs;\n    }\n    /**\n    Given a set of marks, create a new set which contains this one as\n    well, in the right position. If this mark is already in the set,\n    the set itself is returned. If any marks that are set to be\n    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,\n    those are replaced by this one.\n    */\n    addToSet(set) {\n        let copy, placed = false;\n        for (let i = 0; i < set.length; i++) {\n            let other = set[i];\n            if (this.eq(other))\n                return set;\n            if (this.type.excludes(other.type)) {\n                if (!copy)\n                    copy = set.slice(0, i);\n            }\n            else if (other.type.excludes(this.type)) {\n                return set;\n            }\n            else {\n                if (!placed && other.type.rank > this.type.rank) {\n                    if (!copy)\n                        copy = set.slice(0, i);\n                    copy.push(this);\n                    placed = true;\n                }\n                if (copy)\n                    copy.push(other);\n            }\n        }\n        if (!copy)\n            copy = set.slice();\n        if (!placed)\n            copy.push(this);\n        return copy;\n    }\n    /**\n    Remove this mark from the given set, returning a new set. If this\n    mark is not in the set, the set itself is returned.\n    */\n    removeFromSet(set) {\n        for (let i = 0; i < set.length; i++)\n            if (this.eq(set[i]))\n                return set.slice(0, i).concat(set.slice(i + 1));\n        return set;\n    }\n    /**\n    Test whether this mark is in the given set of marks.\n    */\n    isInSet(set) {\n        for (let i = 0; i < set.length; i++)\n            if (this.eq(set[i]))\n                return true;\n        return false;\n    }\n    /**\n    Test whether this mark has the same type and attributes as\n    another mark.\n    */\n    eq(other) {\n        return this == other ||\n            (this.type == other.type && compareDeep(this.attrs, other.attrs));\n    }\n    /**\n    Convert this mark to a JSON-serializeable representation.\n    */\n    toJSON() {\n        let obj = { type: this.type.name };\n        for (let _ in this.attrs) {\n            obj.attrs = this.attrs;\n            break;\n        }\n        return obj;\n    }\n    /**\n    Deserialize a mark from JSON.\n    */\n    static fromJSON(schema, json) {\n        if (!json)\n            throw new RangeError("Invalid input for Mark.fromJSON");\n        let type = schema.marks[json.type];\n        if (!type)\n            throw new RangeError(`There is no mark type ${json.type} in this schema`);\n        return type.create(json.attrs);\n    }\n    /**\n    Test whether two sets of marks are identical.\n    */\n    static sameSet(a, b) {\n        if (a == b)\n            return true;\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++)\n            if (!a[i].eq(b[i]))\n                return false;\n        return true;\n    }\n    /**\n    Create a properly sorted mark set from null, a single mark, or an\n    unsorted array of marks.\n    */\n    static setFrom(marks) {\n        if (!marks || Array.isArray(marks) && marks.length == 0)\n            return Mark.none;\n        if (marks instanceof Mark)\n            return [marks];\n        let copy = marks.slice();\n        copy.sort((a, b) => a.type.rank - b.type.rank);\n        return copy;\n    }\n}\n/**\nThe empty set of marks.\n*/\nMark.none = [];\n\n/**\nError type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when\ngiven an invalid replacement.\n*/\nclass ReplaceError extends Error {\n}\n/*\nReplaceError = function(this: any, message: string) {\n  let err = Error.call(this, message)\n  ;(err as any).__proto__ = ReplaceError.prototype\n  return err\n} as any\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = "ReplaceError"\n*/\n/**\nA slice represents a piece cut out of a larger document. It\nstores not only a fragment, but also the depth up to which nodes on\nboth side are ‘open’ (cut through).\n*/\nclass Slice {\n    /**\n    Create a slice. When specifying a non-zero open depth, you must\n    make sure that there are nodes of at least that depth at the\n    appropriate side of the fragment—i.e. if the fragment is an\n    empty paragraph node, `openStart` and `openEnd` can\'t be greater\n    than 1.\n    \n    It is not necessary for the content of open nodes to conform to\n    the schema\'s content constraints, though it should be a valid\n    start/end/middle for such a node, depending on which sides are\n    open.\n    */\n    constructor(\n    /**\n    The slice\'s content.\n    */\n    content, \n    /**\n    The open depth at the start of the fragment.\n    */\n    openStart, \n    /**\n    The open depth at the end.\n    */\n    openEnd) {\n        this.content = content;\n        this.openStart = openStart;\n        this.openEnd = openEnd;\n    }\n    /**\n    The size this slice would add when inserted into a document.\n    */\n    get size() {\n        return this.content.size - this.openStart - this.openEnd;\n    }\n    /**\n    @internal\n    */\n    insertAt(pos, fragment) {\n        let content = insertInto(this.content, pos + this.openStart, fragment);\n        return content && new Slice(content, this.openStart, this.openEnd);\n    }\n    /**\n    @internal\n    */\n    removeBetween(from, to) {\n        return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n    /**\n    Tests whether this slice is equal to another slice.\n    */\n    eq(other) {\n        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return this.content + "(" + this.openStart + "," + this.openEnd + ")";\n    }\n    /**\n    Convert a slice to a JSON-serializable representation.\n    */\n    toJSON() {\n        if (!this.content.size)\n            return null;\n        let json = { content: this.content.toJSON() };\n        if (this.openStart > 0)\n            json.openStart = this.openStart;\n        if (this.openEnd > 0)\n            json.openEnd = this.openEnd;\n        return json;\n    }\n    /**\n    Deserialize a slice from its JSON representation.\n    */\n    static fromJSON(schema, json) {\n        if (!json)\n            return Slice.empty;\n        let openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n        if (typeof openStart != "number" || typeof openEnd != "number")\n            throw new RangeError("Invalid input for Slice.fromJSON");\n        return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n    }\n    /**\n    Create a slice from a fragment by taking the maximum possible\n    open value on both side of the fragment.\n    */\n    static maxOpen(fragment, openIsolating = true) {\n        let openStart = 0, openEnd = 0;\n        for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)\n            openStart++;\n        for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)\n            openEnd++;\n        return new Slice(fragment, openStart, openEnd);\n    }\n}\n/**\nThe empty slice.\n*/\nSlice.empty = new Slice(Fragment.empty, 0, 0);\nfunction removeRange(content, from, to) {\n    let { index, offset } = content.findIndex(from), child = content.maybeChild(index);\n    let { index: indexTo, offset: offsetTo } = content.findIndex(to);\n    if (offset == from || child.isText) {\n        if (offsetTo != to && !content.child(indexTo).isText)\n            throw new RangeError("Removing non-flat range");\n        return content.cut(0, from).append(content.cut(to));\n    }\n    if (index != indexTo)\n        throw new RangeError("Removing non-flat range");\n    return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\nfunction insertInto(content, dist, insert, parent) {\n    let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);\n    if (offset == dist || child.isText) {\n        if (parent && !parent.canReplace(index, index, insert))\n            return null;\n        return content.cut(0, dist).append(insert).append(content.cut(dist));\n    }\n    let inner = insertInto(child.content, dist - offset - 1, insert);\n    return inner && content.replaceChild(index, child.copy(inner));\n}\nfunction replace($from, $to, slice) {\n    if (slice.openStart > $from.depth)\n        throw new ReplaceError("Inserted content deeper than insertion position");\n    if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n        throw new ReplaceError("Inconsistent open depths");\n    return replaceOuter($from, $to, slice, 0);\n}\nfunction replaceOuter($from, $to, slice, depth) {\n    let index = $from.index(depth), node = $from.node(depth);\n    if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n        let inner = replaceOuter($from, $to, slice, depth + 1);\n        return node.copy(node.content.replaceChild(index, inner));\n    }\n    else if (!slice.content.size) {\n        return close(node, replaceTwoWay($from, $to, depth));\n    }\n    else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n        let parent = $from.parent, content = parent.content;\n        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n    }\n    else {\n        let { start, end } = prepareSliceForReplace(slice, $from);\n        return close(node, replaceThreeWay($from, start, end, $to, depth));\n    }\n}\nfunction checkJoin(main, sub) {\n    if (!sub.type.compatibleContent(main.type))\n        throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);\n}\nfunction joinable($before, $after, depth) {\n    let node = $before.node(depth);\n    checkJoin(node, $after.node(depth));\n    return node;\n}\nfunction addNode(child, target) {\n    let last = target.length - 1;\n    if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n        target[last] = child.withText(target[last].text + child.text);\n    else\n        target.push(child);\n}\nfunction addRange($start, $end, depth, target) {\n    let node = ($end || $start).node(depth);\n    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n    if ($start) {\n        startIndex = $start.index(depth);\n        if ($start.depth > depth) {\n            startIndex++;\n        }\n        else if ($start.textOffset) {\n            addNode($start.nodeAfter, target);\n            startIndex++;\n        }\n    }\n    for (let i = startIndex; i < endIndex; i++)\n        addNode(node.child(i), target);\n    if ($end && $end.depth == depth && $end.textOffset)\n        addNode($end.nodeBefore, target);\n}\nfunction close(node, content) {\n    node.type.checkContent(content);\n    return node.copy(content);\n}\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n    let content = [];\n    addRange(null, $from, depth, content);\n    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n        checkJoin(openStart, openEnd);\n        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n    }\n    else {\n        if (openStart)\n            addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n        addRange($start, $end, depth, content);\n        if (openEnd)\n            addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction replaceTwoWay($from, $to, depth) {\n    let content = [];\n    addRange(null, $from, depth, content);\n    if ($from.depth > depth) {\n        let type = joinable($from, $to, depth + 1);\n        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction prepareSliceForReplace(slice, $along) {\n    let extra = $along.depth - slice.openStart, parent = $along.node(extra);\n    let node = parent.copy(slice.content);\n    for (let i = extra - 1; i >= 0; i--)\n        node = $along.node(i).copy(Fragment.from(node));\n    return { start: node.resolveNoCache(slice.openStart + extra),\n        end: node.resolveNoCache(node.content.size - slice.openEnd - extra) };\n}\n\n/**\nYou can [_resolve_](https://prosemirror.net/docs/ref/#model.Node.resolve) a position to get more\ninformation about it. Objects of this class represent such a\nresolved position, providing various pieces of context\ninformation, and some helper methods.\n\nThroughout this interface, methods that take an optional `depth`\nparameter will interpret undefined as `this.depth` and negative\nnumbers as `this.depth + value`.\n*/\nclass ResolvedPos {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The position that was resolved.\n    */\n    pos, \n    /**\n    @internal\n    */\n    path, \n    /**\n    The offset this position has into its parent node.\n    */\n    parentOffset) {\n        this.pos = pos;\n        this.path = path;\n        this.parentOffset = parentOffset;\n        this.depth = path.length / 3 - 1;\n    }\n    /**\n    @internal\n    */\n    resolveDepth(val) {\n        if (val == null)\n            return this.depth;\n        if (val < 0)\n            return this.depth + val;\n        return val;\n    }\n    /**\n    The parent node that the position points into. Note that even if\n    a position points into a text node, that node is not considered\n    the parent—text nodes are ‘flat’ in this model, and have no content.\n    */\n    get parent() { return this.node(this.depth); }\n    /**\n    The root node in which the position was resolved.\n    */\n    get doc() { return this.node(0); }\n    /**\n    The ancestor node at the given level. `p.node(p.depth)` is the\n    same as `p.parent`.\n    */\n    node(depth) { return this.path[this.resolveDepth(depth) * 3]; }\n    /**\n    The index into the ancestor at the given level. If this points\n    at the 3rd node in the 2nd paragraph on the top level, for\n    example, `p.index(0)` is 1 and `p.index(1)` is 2.\n    */\n    index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1]; }\n    /**\n    The index pointing after this position into the ancestor at the\n    given level.\n    */\n    indexAfter(depth) {\n        depth = this.resolveDepth(depth);\n        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n    /**\n    The (absolute) position at the start of the node at the given\n    level.\n    */\n    start(depth) {\n        depth = this.resolveDepth(depth);\n        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n    /**\n    The (absolute) position at the end of the node at the given\n    level.\n    */\n    end(depth) {\n        depth = this.resolveDepth(depth);\n        return this.start(depth) + this.node(depth).content.size;\n    }\n    /**\n    The (absolute) position directly before the wrapping node at the\n    given level, or, when `depth` is `this.depth + 1`, the original\n    position.\n    */\n    before(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth)\n            throw new RangeError("There is no position before the top-level node");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n    /**\n    The (absolute) position directly after the wrapping node at the\n    given level, or the original position when `depth` is `this.depth + 1`.\n    */\n    after(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth)\n            throw new RangeError("There is no position after the top-level node");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n    /**\n    When this position points into a text node, this returns the\n    distance between the position and the start of the text node.\n    Will be zero for positions that point between nodes.\n    */\n    get textOffset() { return this.pos - this.path[this.path.length - 1]; }\n    /**\n    Get the node directly after the position, if any. If the position\n    points into a text node, only the part of that node after the\n    position is returned.\n    */\n    get nodeAfter() {\n        let parent = this.parent, index = this.index(this.depth);\n        if (index == parent.childCount)\n            return null;\n        let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n        return dOff ? parent.child(index).cut(dOff) : child;\n    }\n    /**\n    Get the node directly before the position, if any. If the\n    position points into a text node, only the part of that node\n    before the position is returned.\n    */\n    get nodeBefore() {\n        let index = this.index(this.depth);\n        let dOff = this.pos - this.path[this.path.length - 1];\n        if (dOff)\n            return this.parent.child(index).cut(0, dOff);\n        return index == 0 ? null : this.parent.child(index - 1);\n    }\n    /**\n    Get the position at the given index in the parent node at the\n    given depth (which defaults to `this.depth`).\n    */\n    posAtIndex(index, depth) {\n        depth = this.resolveDepth(depth);\n        let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n        for (let i = 0; i < index; i++)\n            pos += node.child(i).nodeSize;\n        return pos;\n    }\n    /**\n    Get the marks at this position, factoring in the surrounding\n    marks\' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the\n    position is at the start of a non-empty node, the marks of the\n    node after it (if any) are returned.\n    */\n    marks() {\n        let parent = this.parent, index = this.index();\n        // In an empty parent, return the empty array\n        if (parent.content.size == 0)\n            return Mark.none;\n        // When inside a text node, just return the text node\'s marks\n        if (this.textOffset)\n            return parent.child(index).marks;\n        let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n        // If the `after` flag is true of there is no node before, make\n        // the node after this position the main reference.\n        if (!main) {\n            let tmp = main;\n            main = other;\n            other = tmp;\n        }\n        // Use all marks in the main node, except those that have\n        // `inclusive` set to false and are not present in the other node.\n        let marks = main.marks;\n        for (var i = 0; i < marks.length; i++)\n            if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n                marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    Get the marks after the current position, if any, except those\n    that are non-inclusive and not present at position `$end`. This\n    is mostly useful for getting the set of marks to preserve after a\n    deletion. Will return `null` if this position is at the end of\n    its parent node or its parent node isn\'t a textblock (in which\n    case no marks should be preserved).\n    */\n    marksAcross($end) {\n        let after = this.parent.maybeChild(this.index());\n        if (!after || !after.isInline)\n            return null;\n        let marks = after.marks, next = $end.parent.maybeChild($end.index());\n        for (var i = 0; i < marks.length; i++)\n            if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n                marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    The depth up to which this position and the given (non-resolved)\n    position share the same parent nodes.\n    */\n    sharedDepth(pos) {\n        for (let depth = this.depth; depth > 0; depth--)\n            if (this.start(depth) <= pos && this.end(depth) >= pos)\n                return depth;\n        return 0;\n    }\n    /**\n    Returns a range based on the place where this position and the\n    given position diverge around block content. If both point into\n    the same textblock, for example, a range around that textblock\n    will be returned. If they point into different blocks, the range\n    around those blocks in their shared ancestor is returned. You can\n    pass in an optional predicate that will be called with a parent\n    node to see if a range into that parent is acceptable.\n    */\n    blockRange(other = this, pred) {\n        if (other.pos < this.pos)\n            return other.blockRange(this);\n        for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n            if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n                return new NodeRange(this, other, d);\n        return null;\n    }\n    /**\n    Query whether the given position shares the same parent node.\n    */\n    sameParent(other) {\n        return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n    /**\n    Return the greater of this and the given position.\n    */\n    max(other) {\n        return other.pos > this.pos ? other : this;\n    }\n    /**\n    Return the smaller of this and the given position.\n    */\n    min(other) {\n        return other.pos < this.pos ? other : this;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let str = "";\n        for (let i = 1; i <= this.depth; i++)\n            str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);\n        return str + ":" + this.parentOffset;\n    }\n    /**\n    @internal\n    */\n    static resolve(doc, pos) {\n        if (!(pos >= 0 && pos <= doc.content.size))\n            throw new RangeError("Position " + pos + " out of range");\n        let path = [];\n        let start = 0, parentOffset = pos;\n        for (let node = doc;;) {\n            let { index, offset } = node.content.findIndex(parentOffset);\n            let rem = parentOffset - offset;\n            path.push(node, index, start + offset);\n            if (!rem)\n                break;\n            node = node.child(index);\n            if (node.isText)\n                break;\n            parentOffset = rem - 1;\n            start += offset + 1;\n        }\n        return new ResolvedPos(pos, path, parentOffset);\n    }\n    /**\n    @internal\n    */\n    static resolveCached(doc, pos) {\n        for (let i = 0; i < resolveCache.length; i++) {\n            let cached = resolveCache[i];\n            if (cached.pos == pos && cached.doc == doc)\n                return cached;\n        }\n        let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n        resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n        return result;\n    }\n}\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;\n/**\nRepresents a flat range of content, i.e. one that starts and\nends in the same node.\n*/\nclass NodeRange {\n    /**\n    Construct a node range. `$from` and `$to` should point into the\n    same node until at least the given `depth`, since a node range\n    denotes an adjacent set of nodes in a single parent node.\n    */\n    constructor(\n    /**\n    A resolved position along the start of the content. May have a\n    `depth` greater than this object\'s `depth` property, since\n    these are the positions that were used to compute the range,\n    not re-resolved positions directly at its boundaries.\n    */\n    $from, \n    /**\n    A position along the end of the content. See\n    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).\n    */\n    $to, \n    /**\n    The depth of the node that this range points into.\n    */\n    depth) {\n        this.$from = $from;\n        this.$to = $to;\n        this.depth = depth;\n    }\n    /**\n    The position at the start of the range.\n    */\n    get start() { return this.$from.before(this.depth + 1); }\n    /**\n    The position at the end of the range.\n    */\n    get end() { return this.$to.after(this.depth + 1); }\n    /**\n    The parent node that the range points into.\n    */\n    get parent() { return this.$from.node(this.depth); }\n    /**\n    The start index of the range in the parent node.\n    */\n    get startIndex() { return this.$from.index(this.depth); }\n    /**\n    The end index of the range in the parent node.\n    */\n    get endIndex() { return this.$to.indexAfter(this.depth); }\n}\n\nconst emptyAttrs = Object.create(null);\n/**\nThis class represents a node in the tree that makes up a\nProseMirror document. So a document is an instance of `Node`, with\nchildren that are also instances of `Node`.\n\nNodes are persistent data structures. Instead of changing them, you\ncreate new ones with the content you want. Old ones keep pointing\nat the old document shape. This is made cheaper by sharing\nstructure between the old and new data as much as possible, which a\ntree shape like this (without back pointers) makes easy.\n\n**Do not** directly mutate the properties of a `Node` object. See\n[the guide](/docs/guide/#doc) for more information.\n*/\nclass Node {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The type of node that this is.\n    */\n    type, \n    /**\n    An object mapping attribute names to values. The kind of\n    attributes allowed and required are\n    [determined](https://prosemirror.net/docs/ref/#model.NodeSpec.attrs) by the node type.\n    */\n    attrs, \n    // A fragment holding the node\'s children.\n    content, \n    /**\n    The marks (things like whether it is emphasized or part of a\n    link) applied to this node.\n    */\n    marks = Mark.none) {\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.content = content || Fragment.empty;\n    }\n    /**\n    The size of this node, as defined by the integer-based [indexing\n    scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n    amount of characters. For other leaf nodes, it is one. For\n    non-leaf nodes, it is the size of the content plus two (the\n    start and end token).\n    */\n    get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size; }\n    /**\n    The number of children that the node has.\n    */\n    get childCount() { return this.content.childCount; }\n    /**\n    Get the child node at the given index. Raises an error when the\n    index is out of range.\n    */\n    child(index) { return this.content.child(index); }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n    maybeChild(index) { return this.content.maybeChild(index); }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n    forEach(f) { this.content.forEach(f); }\n    /**\n    Invoke a callback for all descendant nodes recursively between\n    the given two positions that are relative to start of this\n    node\'s content. The callback is invoked with the node, its\n    parent-relative position, its parent node, and its child index.\n    When the callback returns false for a given node, that node\'s\n    children will not be recursed over. The last parameter can be\n    used to specify a starting position to count from.\n    */\n    nodesBetween(from, to, f, startPos = 0) {\n        this.content.nodesBetween(from, to, f, startPos, this);\n    }\n    /**\n    Call the given callback for every descendant node. Doesn\'t\n    descend into a node when the callback returns `false`.\n    */\n    descendants(f) {\n        this.nodesBetween(0, this.content.size, f);\n    }\n    /**\n    Concatenates all the text nodes found in this fragment and its\n    children.\n    */\n    get textContent() {\n        return (this.isLeaf && this.type.spec.leafText)\n            ? this.type.spec.leafText(this)\n            : this.textBetween(0, this.content.size, "");\n    }\n    /**\n    Get all text between positions `from` and `to`. When\n    `blockSeparator` is given, it will be inserted to separate text\n    from different block nodes. If `leafText` is given, it\'ll be\n    inserted for every non-text leaf node encountered, otherwise\n    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.\n    */\n    textBetween(from, to, blockSeparator, leafText) {\n        return this.content.textBetween(from, to, blockSeparator, leafText);\n    }\n    /**\n    Returns this node\'s first child, or `null` if there are no\n    children.\n    */\n    get firstChild() { return this.content.firstChild; }\n    /**\n    Returns this node\'s last child, or `null` if there are no\n    children.\n    */\n    get lastChild() { return this.content.lastChild; }\n    /**\n    Test whether two nodes represent the same piece of document.\n    */\n    eq(other) {\n        return this == other || (this.sameMarkup(other) && this.content.eq(other.content));\n    }\n    /**\n    Compare the markup (type, attributes, and marks) of this node to\n    those of another. Returns `true` if both have the same markup.\n    */\n    sameMarkup(other) {\n        return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n    /**\n    Check whether this node\'s markup correspond to the given type,\n    attributes, and marks.\n    */\n    hasMarkup(type, attrs, marks) {\n        return this.type == type &&\n            compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n            Mark.sameSet(this.marks, marks || Mark.none);\n    }\n    /**\n    Create a new node with the same markup as this node, containing\n    the given content (or empty, if no content is given).\n    */\n    copy(content = null) {\n        if (content == this.content)\n            return this;\n        return new Node(this.type, this.attrs, content, this.marks);\n    }\n    /**\n    Create a copy of this node, with the given set of marks instead\n    of the node\'s own marks.\n    */\n    mark(marks) {\n        return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n    }\n    /**\n    Create a copy of this node with only the content between the\n    given positions. If `to` is not given, it defaults to the end of\n    the node.\n    */\n    cut(from, to = this.content.size) {\n        if (from == 0 && to == this.content.size)\n            return this;\n        return this.copy(this.content.cut(from, to));\n    }\n    /**\n    Cut out the part of the document between the given positions, and\n    return it as a `Slice` object.\n    */\n    slice(from, to = this.content.size, includeParents = false) {\n        if (from == to)\n            return Slice.empty;\n        let $from = this.resolve(from), $to = this.resolve(to);\n        let depth = includeParents ? 0 : $from.sharedDepth(to);\n        let start = $from.start(depth), node = $from.node(depth);\n        let content = node.content.cut($from.pos - start, $to.pos - start);\n        return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n    /**\n    Replace the part of the document between the given positions with\n    the given slice. The slice must \'fit\', meaning its open sides\n    must be able to connect to the surrounding content, and its\n    content nodes must be valid children for the node they are placed\n    into. If any of this is violated, an error of type\n    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.\n    */\n    replace(from, to, slice) {\n        return replace(this.resolve(from), this.resolve(to), slice);\n    }\n    /**\n    Find the node directly after the given position.\n    */\n    nodeAt(pos) {\n        for (let node = this;;) {\n            let { index, offset } = node.content.findIndex(pos);\n            node = node.maybeChild(index);\n            if (!node)\n                return null;\n            if (offset == pos || node.isText)\n                return node;\n            pos -= offset + 1;\n        }\n    }\n    /**\n    Find the (direct) child node after the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n    childAfter(pos) {\n        let { index, offset } = this.content.findIndex(pos);\n        return { node: this.content.maybeChild(index), index, offset };\n    }\n    /**\n    Find the (direct) child node before the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n    childBefore(pos) {\n        if (pos == 0)\n            return { node: null, index: 0, offset: 0 };\n        let { index, offset } = this.content.findIndex(pos);\n        if (offset < pos)\n            return { node: this.content.child(index), index, offset };\n        let node = this.content.child(index - 1);\n        return { node, index: index - 1, offset: offset - node.nodeSize };\n    }\n    /**\n    Resolve the given position in the document, returning an\n    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.\n    */\n    resolve(pos) { return ResolvedPos.resolveCached(this, pos); }\n    /**\n    @internal\n    */\n    resolveNoCache(pos) { return ResolvedPos.resolve(this, pos); }\n    /**\n    Test whether a given mark or mark type occurs in this document\n    between the two given positions.\n    */\n    rangeHasMark(from, to, type) {\n        let found = false;\n        if (to > from)\n            this.nodesBetween(from, to, node => {\n                if (type.isInSet(node.marks))\n                    found = true;\n                return !found;\n            });\n        return found;\n    }\n    /**\n    True when this is a block (non-inline node)\n    */\n    get isBlock() { return this.type.isBlock; }\n    /**\n    True when this is a textblock node, a block node with inline\n    content.\n    */\n    get isTextblock() { return this.type.isTextblock; }\n    /**\n    True when this node allows inline content.\n    */\n    get inlineContent() { return this.type.inlineContent; }\n    /**\n    True when this is an inline node (a text node or a node that can\n    appear among text).\n    */\n    get isInline() { return this.type.isInline; }\n    /**\n    True when this is a text node.\n    */\n    get isText() { return this.type.isText; }\n    /**\n    True when this is a leaf node.\n    */\n    get isLeaf() { return this.type.isLeaf; }\n    /**\n    True when this is an atom, i.e. when it does not have directly\n    editable content. This is usually the same as `isLeaf`, but can\n    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)\n    on a node\'s spec (typically used when the node is displayed as\n    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).\n    */\n    get isAtom() { return this.type.isAtom; }\n    /**\n    Return a string representation of this node for debugging\n    purposes.\n    */\n    toString() {\n        if (this.type.spec.toDebugString)\n            return this.type.spec.toDebugString(this);\n        let name = this.type.name;\n        if (this.content.size)\n            name += "(" + this.content.toStringInner() + ")";\n        return wrapMarks(this.marks, name);\n    }\n    /**\n    Get the content match in this node at the given index.\n    */\n    contentMatchAt(index) {\n        let match = this.type.contentMatch.matchFragment(this.content, 0, index);\n        if (!match)\n            throw new Error("Called contentMatchAt on a node with invalid content");\n        return match;\n    }\n    /**\n    Test whether replacing the range between `from` and `to` (by\n    child index) with the given replacement fragment (which defaults\n    to the empty fragment) would leave the node\'s content valid. You\n    can optionally pass `start` and `end` indices into the\n    replacement fragment.\n    */\n    canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n        let one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n        let two = one && one.matchFragment(this.content, to);\n        if (!two || !two.validEnd)\n            return false;\n        for (let i = start; i < end; i++)\n            if (!this.type.allowsMarks(replacement.child(i).marks))\n                return false;\n        return true;\n    }\n    /**\n    Test whether replacing the range `from` to `to` (by index) with\n    a node of the given type would leave the node\'s content valid.\n    */\n    canReplaceWith(from, to, type, marks) {\n        if (marks && !this.type.allowsMarks(marks))\n            return false;\n        let start = this.contentMatchAt(from).matchType(type);\n        let end = start && start.matchFragment(this.content, to);\n        return end ? end.validEnd : false;\n    }\n    /**\n    Test whether the given node\'s content could be appended to this\n    node. If that node is empty, this will only return true if there\n    is at least one node type that can appear in both nodes (to avoid\n    merging completely incompatible nodes).\n    */\n    canAppend(other) {\n        if (other.content.size)\n            return this.canReplace(this.childCount, this.childCount, other.content);\n        else\n            return this.type.compatibleContent(other.type);\n    }\n    /**\n    Check whether this node and its descendants conform to the\n    schema, and raise error when they do not.\n    */\n    check() {\n        this.type.checkContent(this.content);\n        let copy = Mark.none;\n        for (let i = 0; i < this.marks.length; i++)\n            copy = this.marks[i].addToSet(copy);\n        if (!Mark.sameSet(copy, this.marks))\n            throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`);\n        this.content.forEach(node => node.check());\n    }\n    /**\n    Return a JSON-serializeable representation of this node.\n    */\n    toJSON() {\n        let obj = { type: this.type.name };\n        for (let _ in this.attrs) {\n            obj.attrs = this.attrs;\n            break;\n        }\n        if (this.content.size)\n            obj.content = this.content.toJSON();\n        if (this.marks.length)\n            obj.marks = this.marks.map(n => n.toJSON());\n        return obj;\n    }\n    /**\n    Deserialize a node from its JSON representation.\n    */\n    static fromJSON(schema, json) {\n        if (!json)\n            throw new RangeError("Invalid input for Node.fromJSON");\n        let marks = null;\n        if (json.marks) {\n            if (!Array.isArray(json.marks))\n                throw new RangeError("Invalid mark data for Node.fromJSON");\n            marks = json.marks.map(schema.markFromJSON);\n        }\n        if (json.type == "text") {\n            if (typeof json.text != "string")\n                throw new RangeError("Invalid text node in JSON");\n            return schema.text(json.text, marks);\n        }\n        let content = Fragment.fromJSON(schema, json.content);\n        return schema.nodeType(json.type).create(json.attrs, content, marks);\n    }\n}\nNode.prototype.text = undefined;\nclass TextNode extends Node {\n    /**\n    @internal\n    */\n    constructor(type, attrs, content, marks) {\n        super(type, attrs, null, marks);\n        if (!content)\n            throw new RangeError("Empty text nodes are not allowed");\n        this.text = content;\n    }\n    toString() {\n        if (this.type.spec.toDebugString)\n            return this.type.spec.toDebugString(this);\n        return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n    get textContent() { return this.text; }\n    textBetween(from, to) { return this.text.slice(from, to); }\n    get nodeSize() { return this.text.length; }\n    mark(marks) {\n        return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n    }\n    withText(text) {\n        if (text == this.text)\n            return this;\n        return new TextNode(this.type, this.attrs, text, this.marks);\n    }\n    cut(from = 0, to = this.text.length) {\n        if (from == 0 && to == this.text.length)\n            return this;\n        return this.withText(this.text.slice(from, to));\n    }\n    eq(other) {\n        return this.sameMarkup(other) && this.text == other.text;\n    }\n    toJSON() {\n        let base = super.toJSON();\n        base.text = this.text;\n        return base;\n    }\n}\nfunction wrapMarks(marks, str) {\n    for (let i = marks.length - 1; i >= 0; i--)\n        str = marks[i].type.name + "(" + str + ")";\n    return str;\n}\n\n/**\nInstances of this class represent a match state of a node type\'s\n[content expression](https://prosemirror.net/docs/ref/#model.NodeSpec.content), and can be used to\nfind out whether further content matches here, and whether a given\nposition is a valid end of the node.\n*/\nclass ContentMatch {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    True when this match state represents a valid end of the node.\n    */\n    validEnd) {\n        this.validEnd = validEnd;\n        /**\n        @internal\n        */\n        this.next = [];\n        /**\n        @internal\n        */\n        this.wrapCache = [];\n    }\n    /**\n    @internal\n    */\n    static parse(string, nodeTypes) {\n        let stream = new TokenStream(string, nodeTypes);\n        if (stream.next == null)\n            return ContentMatch.empty;\n        let expr = parseExpr(stream);\n        if (stream.next)\n            stream.err("Unexpected trailing text");\n        let match = dfa(nfa(expr));\n        checkForDeadEnds(match, stream);\n        return match;\n    }\n    /**\n    Match a node type, returning a match after that node if\n    successful.\n    */\n    matchType(type) {\n        for (let i = 0; i < this.next.length; i++)\n            if (this.next[i].type == type)\n                return this.next[i].next;\n        return null;\n    }\n    /**\n    Try to match a fragment. Returns the resulting match when\n    successful.\n    */\n    matchFragment(frag, start = 0, end = frag.childCount) {\n        let cur = this;\n        for (let i = start; cur && i < end; i++)\n            cur = cur.matchType(frag.child(i).type);\n        return cur;\n    }\n    /**\n    @internal\n    */\n    get inlineContent() {\n        return this.next.length != 0 && this.next[0].type.isInline;\n    }\n    /**\n    Get the first matching node type at this match position that can\n    be generated.\n    */\n    get defaultType() {\n        for (let i = 0; i < this.next.length; i++) {\n            let { type } = this.next[i];\n            if (!(type.isText || type.hasRequiredAttrs()))\n                return type;\n        }\n        return null;\n    }\n    /**\n    @internal\n    */\n    compatible(other) {\n        for (let i = 0; i < this.next.length; i++)\n            for (let j = 0; j < other.next.length; j++)\n                if (this.next[i].type == other.next[j].type)\n                    return true;\n        return false;\n    }\n    /**\n    Try to match the given fragment, and if that fails, see if it can\n    be made to match by inserting nodes in front of it. When\n    successful, return a fragment of inserted nodes (which may be\n    empty if nothing had to be inserted). When `toEnd` is true, only\n    return a fragment if the resulting match goes to the end of the\n    content expression.\n    */\n    fillBefore(after, toEnd = false, startIndex = 0) {\n        let seen = [this];\n        function search(match, types) {\n            let finished = match.matchFragment(after, startIndex);\n            if (finished && (!toEnd || finished.validEnd))\n                return Fragment.from(types.map(tp => tp.createAndFill()));\n            for (let i = 0; i < match.next.length; i++) {\n                let { type, next } = match.next[i];\n                if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n                    seen.push(next);\n                    let found = search(next, types.concat(type));\n                    if (found)\n                        return found;\n                }\n            }\n            return null;\n        }\n        return search(this, []);\n    }\n    /**\n    Find a set of wrapping node types that would allow a node of the\n    given type to appear at this position. The result may be empty\n    (when it fits directly) and will be null when no such wrapping\n    exists.\n    */\n    findWrapping(target) {\n        for (let i = 0; i < this.wrapCache.length; i += 2)\n            if (this.wrapCache[i] == target)\n                return this.wrapCache[i + 1];\n        let computed = this.computeWrapping(target);\n        this.wrapCache.push(target, computed);\n        return computed;\n    }\n    /**\n    @internal\n    */\n    computeWrapping(target) {\n        let seen = Object.create(null), active = [{ match: this, type: null, via: null }];\n        while (active.length) {\n            let current = active.shift(), match = current.match;\n            if (match.matchType(target)) {\n                let result = [];\n                for (let obj = current; obj.type; obj = obj.via)\n                    result.push(obj.type);\n                return result.reverse();\n            }\n            for (let i = 0; i < match.next.length; i++) {\n                let { type, next } = match.next[i];\n                if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n                    active.push({ match: type.contentMatch, type, via: current });\n                    seen[type.name] = true;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n    The number of outgoing edges this node has in the finite\n    automaton that describes the content expression.\n    */\n    get edgeCount() {\n        return this.next.length;\n    }\n    /**\n    Get the _n_​th outgoing edge from this node in the finite\n    automaton that describes the content expression.\n    */\n    edge(n) {\n        if (n >= this.next.length)\n            throw new RangeError(`There\'s no ${n}th edge in this content match`);\n        return this.next[n];\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let seen = [];\n        function scan(m) {\n            seen.push(m);\n            for (let i = 0; i < m.next.length; i++)\n                if (seen.indexOf(m.next[i].next) == -1)\n                    scan(m.next[i].next);\n        }\n        scan(this);\n        return seen.map((m, i) => {\n            let out = i + (m.validEnd ? "*" : " ") + " ";\n            for (let i = 0; i < m.next.length; i++)\n                out += (i ? ", " : "") + m.next[i].type.name + "->" + seen.indexOf(m.next[i].next);\n            return out;\n        }).join("\\n");\n    }\n}\n/**\n@internal\n*/\nContentMatch.empty = new ContentMatch(true);\nclass TokenStream {\n    constructor(string, nodeTypes) {\n        this.string = string;\n        this.nodeTypes = nodeTypes;\n        this.inline = null;\n        this.pos = 0;\n        this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n        if (this.tokens[this.tokens.length - 1] == "")\n            this.tokens.pop();\n        if (this.tokens[0] == "")\n            this.tokens.shift();\n    }\n    get next() { return this.tokens[this.pos]; }\n    eat(tok) { return this.next == tok && (this.pos++ || true); }\n    err(str) { throw new SyntaxError(str + " (in content expression \'" + this.string + "\')"); }\n}\nfunction parseExpr(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSeq(stream));\n    } while (stream.eat("|"));\n    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };\n}\nfunction parseExprSeq(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSubscript(stream));\n    } while (stream.next && stream.next != ")" && stream.next != "|");\n    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };\n}\nfunction parseExprSubscript(stream) {\n    let expr = parseExprAtom(stream);\n    for (;;) {\n        if (stream.eat("+"))\n            expr = { type: "plus", expr };\n        else if (stream.eat("*"))\n            expr = { type: "star", expr };\n        else if (stream.eat("?"))\n            expr = { type: "opt", expr };\n        else if (stream.eat("{"))\n            expr = parseExprRange(stream, expr);\n        else\n            break;\n    }\n    return expr;\n}\nfunction parseNum(stream) {\n    if (/\\D/.test(stream.next))\n        stream.err("Expected number, got \'" + stream.next + "\'");\n    let result = Number(stream.next);\n    stream.pos++;\n    return result;\n}\nfunction parseExprRange(stream, expr) {\n    let min = parseNum(stream), max = min;\n    if (stream.eat(",")) {\n        if (stream.next != "}")\n            max = parseNum(stream);\n        else\n            max = -1;\n    }\n    if (!stream.eat("}"))\n        stream.err("Unclosed braced range");\n    return { type: "range", min, max, expr };\n}\nfunction resolveName(stream, name) {\n    let types = stream.nodeTypes, type = types[name];\n    if (type)\n        return [type];\n    let result = [];\n    for (let typeName in types) {\n        let type = types[typeName];\n        if (type.groups.indexOf(name) > -1)\n            result.push(type);\n    }\n    if (result.length == 0)\n        stream.err("No node type or group \'" + name + "\' found");\n    return result;\n}\nfunction parseExprAtom(stream) {\n    if (stream.eat("(")) {\n        let expr = parseExpr(stream);\n        if (!stream.eat(")"))\n            stream.err("Missing closing paren");\n        return expr;\n    }\n    else if (!/\\W/.test(stream.next)) {\n        let exprs = resolveName(stream, stream.next).map(type => {\n            if (stream.inline == null)\n                stream.inline = type.isInline;\n            else if (stream.inline != type.isInline)\n                stream.err("Mixing inline and block content");\n            return { type: "name", value: type };\n        });\n        stream.pos++;\n        return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };\n    }\n    else {\n        stream.err("Unexpected token \'" + stream.next + "\'");\n    }\n}\n/**\nConstruct an NFA from an expression as returned by the parser. The\nNFA is represented as an array of states, which are themselves\narrays of edges, which are `{term, to}` objects. The first state is\nthe entry state and the last node is the success state.\n\nNote that unlike typical NFAs, the edge ordering in this one is\nsignificant, in that it is used to contruct filler content when\nnecessary.\n*/\nfunction nfa(expr) {\n    let nfa = [[]];\n    connect(compile(expr, 0), node());\n    return nfa;\n    function node() { return nfa.push([]) - 1; }\n    function edge(from, to, term) {\n        let edge = { term, to };\n        nfa[from].push(edge);\n        return edge;\n    }\n    function connect(edges, to) {\n        edges.forEach(edge => edge.to = to);\n    }\n    function compile(expr, from) {\n        if (expr.type == "choice") {\n            return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), []);\n        }\n        else if (expr.type == "seq") {\n            for (let i = 0;; i++) {\n                let next = compile(expr.exprs[i], from);\n                if (i == expr.exprs.length - 1)\n                    return next;\n                connect(next, from = node());\n            }\n        }\n        else if (expr.type == "star") {\n            let loop = node();\n            edge(from, loop);\n            connect(compile(expr.expr, loop), loop);\n            return [edge(loop)];\n        }\n        else if (expr.type == "plus") {\n            let loop = node();\n            connect(compile(expr.expr, from), loop);\n            connect(compile(expr.expr, loop), loop);\n            return [edge(loop)];\n        }\n        else if (expr.type == "opt") {\n            return [edge(from)].concat(compile(expr.expr, from));\n        }\n        else if (expr.type == "range") {\n            let cur = from;\n            for (let i = 0; i < expr.min; i++) {\n                let next = node();\n                connect(compile(expr.expr, cur), next);\n                cur = next;\n            }\n            if (expr.max == -1) {\n                connect(compile(expr.expr, cur), cur);\n            }\n            else {\n                for (let i = expr.min; i < expr.max; i++) {\n                    let next = node();\n                    edge(cur, next);\n                    connect(compile(expr.expr, cur), next);\n                    cur = next;\n                }\n            }\n            return [edge(cur)];\n        }\n        else if (expr.type == "name") {\n            return [edge(from, undefined, expr.value)];\n        }\n        else {\n            throw new Error("Unknown expr type");\n        }\n    }\n}\nfunction cmp(a, b) { return b - a; }\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n    let result = [];\n    scan(node);\n    return result.sort(cmp);\n    function scan(node) {\n        let edges = nfa[node];\n        if (edges.length == 1 && !edges[0].term)\n            return scan(edges[0].to);\n        result.push(node);\n        for (let i = 0; i < edges.length; i++) {\n            let { term, to } = edges[i];\n            if (!term && result.indexOf(to) == -1)\n                scan(to);\n        }\n    }\n}\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n    let labeled = Object.create(null);\n    return explore(nullFrom(nfa, 0));\n    function explore(states) {\n        let out = [];\n        states.forEach(node => {\n            nfa[node].forEach(({ term, to }) => {\n                if (!term)\n                    return;\n                let set;\n                for (let i = 0; i < out.length; i++)\n                    if (out[i][0] == term)\n                        set = out[i][1];\n                nullFrom(nfa, to).forEach(node => {\n                    if (!set)\n                        out.push([term, set = []]);\n                    if (set.indexOf(node) == -1)\n                        set.push(node);\n                });\n            });\n        });\n        let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n        for (let i = 0; i < out.length; i++) {\n            let states = out[i][1].sort(cmp);\n            state.next.push({ type: out[i][0], next: labeled[states.join(",")] || explore(states) });\n        }\n        return state;\n    }\n}\nfunction checkForDeadEnds(match, stream) {\n    for (let i = 0, work = [match]; i < work.length; i++) {\n        let state = work[i], dead = !state.validEnd, nodes = [];\n        for (let j = 0; j < state.next.length; j++) {\n            let { type, next } = state.next[j];\n            nodes.push(type.name);\n            if (dead && !(type.isText || type.hasRequiredAttrs()))\n                dead = false;\n            if (work.indexOf(next) == -1)\n                work.push(next);\n        }\n        if (dead)\n            stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");\n    }\n}\n\n// For node types where all attrs have a default value (or which don\'t\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don\'t specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n    let defaults = Object.create(null);\n    for (let attrName in attrs) {\n        let attr = attrs[attrName];\n        if (!attr.hasDefault)\n            return null;\n        defaults[attrName] = attr.default;\n    }\n    return defaults;\n}\nfunction computeAttrs(attrs, value) {\n    let built = Object.create(null);\n    for (let name in attrs) {\n        let given = value && value[name];\n        if (given === undefined) {\n            let attr = attrs[name];\n            if (attr.hasDefault)\n                given = attr.default;\n            else\n                throw new RangeError("No value supplied for attribute " + name);\n        }\n        built[name] = given;\n    }\n    return built;\n}\nfunction initAttrs(attrs) {\n    let result = Object.create(null);\n    if (attrs)\n        for (let name in attrs)\n            result[name] = new Attribute(attrs[name]);\n    return result;\n}\n/**\nNode types are objects allocated once per `Schema` and used to\n[tag](https://prosemirror.net/docs/ref/#model.Node.type) `Node` instances. They contain information\nabout the node type, such as its name and what kind of node it\nrepresents.\n*/\nclass NodeType {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The name the node type has in this schema.\n    */\n    name, \n    /**\n    A link back to the `Schema` the node type belongs to.\n    */\n    schema, \n    /**\n    The spec that this type is based on\n    */\n    spec) {\n        this.name = name;\n        this.schema = schema;\n        this.spec = spec;\n        /**\n        The set of marks allowed in this node. `null` means all marks\n        are allowed.\n        */\n        this.markSet = null;\n        this.groups = spec.group ? spec.group.split(" ") : [];\n        this.attrs = initAttrs(spec.attrs);\n        this.defaultAttrs = defaultAttrs(this.attrs);\n        this.contentMatch = null;\n        this.inlineContent = null;\n        this.isBlock = !(spec.inline || name == "text");\n        this.isText = name == "text";\n    }\n    /**\n    True if this is an inline type.\n    */\n    get isInline() { return !this.isBlock; }\n    /**\n    True if this is a textblock type, a block that contains inline\n    content.\n    */\n    get isTextblock() { return this.isBlock && this.inlineContent; }\n    /**\n    True for node types that allow no content.\n    */\n    get isLeaf() { return this.contentMatch == ContentMatch.empty; }\n    /**\n    True when this node is an atom, i.e. when it does not have\n    directly editable content.\n    */\n    get isAtom() { return this.isLeaf || !!this.spec.atom; }\n    /**\n    The node type\'s [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.\n    */\n    get whitespace() {\n        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");\n    }\n    /**\n    Tells you whether this node type has any required attributes.\n    */\n    hasRequiredAttrs() {\n        for (let n in this.attrs)\n            if (this.attrs[n].isRequired)\n                return true;\n        return false;\n    }\n    /**\n    Indicates whether this node allows some of the same content as\n    the given node type.\n    */\n    compatibleContent(other) {\n        return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n    /**\n    @internal\n    */\n    computeAttrs(attrs) {\n        if (!attrs && this.defaultAttrs)\n            return this.defaultAttrs;\n        else\n            return computeAttrs(this.attrs, attrs);\n    }\n    /**\n    Create a `Node` of this type. The given attributes are\n    checked and defaulted (you can pass `null` to use the type\'s\n    defaults entirely, if no required attributes exist). `content`\n    may be a `Fragment`, a node, an array of nodes, or\n    `null`. Similarly `marks` may be `null` to default to the empty\n    set of marks.\n    */\n    create(attrs = null, content, marks) {\n        if (this.isText)\n            throw new Error("NodeType.create can\'t construct text nodes");\n        return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content\n    against the node type\'s content restrictions, and throw an error\n    if it doesn\'t match.\n    */\n    createChecked(attrs = null, content, marks) {\n        content = Fragment.from(content);\n        this.checkContent(content);\n        return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is\n    necessary to add nodes to the start or end of the given fragment\n    to make it fit the node. If no fitting wrapping can be found,\n    return null. Note that, due to the fact that required nodes can\n    always be created, this will always succeed if you pass null or\n    `Fragment.empty` as content.\n    */\n    createAndFill(attrs = null, content, marks) {\n        attrs = this.computeAttrs(attrs);\n        content = Fragment.from(content);\n        if (content.size) {\n            let before = this.contentMatch.fillBefore(content);\n            if (!before)\n                return null;\n            content = before.append(content);\n        }\n        let matched = this.contentMatch.matchFragment(content);\n        let after = matched && matched.fillBefore(Fragment.empty, true);\n        if (!after)\n            return null;\n        return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n    }\n    /**\n    Returns true if the given fragment is valid content for this node\n    type with the given attributes.\n    */\n    validContent(content) {\n        let result = this.contentMatch.matchFragment(content);\n        if (!result || !result.validEnd)\n            return false;\n        for (let i = 0; i < content.childCount; i++)\n            if (!this.allowsMarks(content.child(i).marks))\n                return false;\n        return true;\n    }\n    /**\n    Throws a RangeError if the given fragment is not valid content for this\n    node type.\n    @internal\n    */\n    checkContent(content) {\n        if (!this.validContent(content))\n            throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);\n    }\n    /**\n    Check whether the given mark type is allowed in this node.\n    */\n    allowsMarkType(markType) {\n        return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n    /**\n    Test whether the given set of marks are allowed in this node.\n    */\n    allowsMarks(marks) {\n        if (this.markSet == null)\n            return true;\n        for (let i = 0; i < marks.length; i++)\n            if (!this.allowsMarkType(marks[i].type))\n                return false;\n        return true;\n    }\n    /**\n    Removes the marks that are not allowed in this node from the given set.\n    */\n    allowedMarks(marks) {\n        if (this.markSet == null)\n            return marks;\n        let copy;\n        for (let i = 0; i < marks.length; i++) {\n            if (!this.allowsMarkType(marks[i].type)) {\n                if (!copy)\n                    copy = marks.slice(0, i);\n            }\n            else if (copy) {\n                copy.push(marks[i]);\n            }\n        }\n        return !copy ? marks : copy.length ? copy : Mark.none;\n    }\n    /**\n    @internal\n    */\n    static compile(nodes, schema) {\n        let result = Object.create(null);\n        nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));\n        let topType = schema.spec.topNode || "doc";\n        if (!result[topType])\n            throw new RangeError("Schema is missing its top node type (\'" + topType + "\')");\n        if (!result.text)\n            throw new RangeError("Every schema needs a \'text\' type");\n        for (let _ in result.text.attrs)\n            throw new RangeError("The text node type should not have attributes");\n        return result;\n    }\n}\n// Attribute descriptors\nclass Attribute {\n    constructor(options) {\n        this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");\n        this.default = options.default;\n    }\n    get isRequired() {\n        return !this.hasDefault;\n    }\n}\n// Marks\n/**\nLike nodes, marks (which are associated with nodes to signify\nthings like emphasis or being part of a link) are\n[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are\ninstantiated once per `Schema`.\n*/\nclass MarkType {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The name of the mark type.\n    */\n    name, \n    /**\n    @internal\n    */\n    rank, \n    /**\n    The schema that this mark type instance is part of.\n    */\n    schema, \n    /**\n    The spec on which the type is based.\n    */\n    spec) {\n        this.name = name;\n        this.rank = rank;\n        this.schema = schema;\n        this.spec = spec;\n        this.attrs = initAttrs(spec.attrs);\n        this.excluded = null;\n        let defaults = defaultAttrs(this.attrs);\n        this.instance = defaults ? new Mark(this, defaults) : null;\n    }\n    /**\n    Create a mark of this type. `attrs` may be `null` or an object\n    containing only some of the mark\'s attributes. The others, if\n    they have defaults, will be added.\n    */\n    create(attrs = null) {\n        if (!attrs && this.instance)\n            return this.instance;\n        return new Mark(this, computeAttrs(this.attrs, attrs));\n    }\n    /**\n    @internal\n    */\n    static compile(marks, schema) {\n        let result = Object.create(null), rank = 0;\n        marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));\n        return result;\n    }\n    /**\n    When there is a mark of this type in the given set, a new set\n    without it is returned. Otherwise, the input set is returned.\n    */\n    removeFromSet(set) {\n        for (var i = 0; i < set.length; i++)\n            if (set[i].type == this) {\n                set = set.slice(0, i).concat(set.slice(i + 1));\n                i--;\n            }\n        return set;\n    }\n    /**\n    Tests whether there is a mark of this type in the given set.\n    */\n    isInSet(set) {\n        for (let i = 0; i < set.length; i++)\n            if (set[i].type == this)\n                return set[i];\n    }\n    /**\n    Queries whether a given mark type is\n    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.\n    */\n    excludes(other) {\n        return this.excluded.indexOf(other) > -1;\n    }\n}\n/**\nA document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark\ntype](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may\noccur in conforming documents, and provides functionality for\ncreating and deserializing such documents.\n\nWhen given, the type parameters provide the names of the nodes and\nmarks in this schema.\n*/\nclass Schema {\n    /**\n    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).\n    */\n    constructor(spec) {\n        /**\n        An object for storing whatever values modules may want to\n        compute and cache per schema. (If you want to store something\n        in it, try to use property names unlikely to clash.)\n        */\n        this.cached = Object.create(null);\n        let instanceSpec = this.spec = {};\n        for (let prop in spec)\n            instanceSpec[prop] = spec[prop];\n        instanceSpec.nodes = orderedmap__WEBPACK_IMPORTED_MODULE_0__["default"].from(spec.nodes),\n            instanceSpec.marks = orderedmap__WEBPACK_IMPORTED_MODULE_0__["default"].from(spec.marks || {}),\n            this.nodes = NodeType.compile(this.spec.nodes, this);\n        this.marks = MarkType.compile(this.spec.marks, this);\n        let contentExprCache = Object.create(null);\n        for (let prop in this.nodes) {\n            if (prop in this.marks)\n                throw new RangeError(prop + " can not be both a node and a mark");\n            let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;\n            type.contentMatch = contentExprCache[contentExpr] ||\n                (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n            type.inlineContent = type.contentMatch.inlineContent;\n            type.markSet = markExpr == "_" ? null :\n                markExpr ? gatherMarks(this, markExpr.split(" ")) :\n                    markExpr == "" || !type.inlineContent ? [] : null;\n        }\n        for (let prop in this.marks) {\n            let type = this.marks[prop], excl = type.spec.excludes;\n            type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));\n        }\n        this.nodeFromJSON = this.nodeFromJSON.bind(this);\n        this.markFromJSON = this.markFromJSON.bind(this);\n        this.topNodeType = this.nodes[this.spec.topNode || "doc"];\n        this.cached.wrappings = Object.create(null);\n    }\n    /**\n    Create a node in this schema. The `type` may be a string or a\n    `NodeType` instance. Attributes will be extended with defaults,\n    `content` may be a `Fragment`, `null`, a `Node`, or an array of\n    nodes.\n    */\n    node(type, attrs = null, content, marks) {\n        if (typeof type == "string")\n            type = this.nodeType(type);\n        else if (!(type instanceof NodeType))\n            throw new RangeError("Invalid node type: " + type);\n        else if (type.schema != this)\n            throw new RangeError("Node type from different schema used (" + type.name + ")");\n        return type.createChecked(attrs, content, marks);\n    }\n    /**\n    Create a text node in the schema. Empty text nodes are not\n    allowed.\n    */\n    text(text, marks) {\n        let type = this.nodes.text;\n        return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));\n    }\n    /**\n    Create a mark with the given type and attributes.\n    */\n    mark(type, attrs) {\n        if (typeof type == "string")\n            type = this.marks[type];\n        return type.create(attrs);\n    }\n    /**\n    Deserialize a node from its JSON representation. This method is\n    bound.\n    */\n    nodeFromJSON(json) {\n        return Node.fromJSON(this, json);\n    }\n    /**\n    Deserialize a mark from its JSON representation. This method is\n    bound.\n    */\n    markFromJSON(json) {\n        return Mark.fromJSON(this, json);\n    }\n    /**\n    @internal\n    */\n    nodeType(name) {\n        let found = this.nodes[name];\n        if (!found)\n            throw new RangeError("Unknown node type: " + name);\n        return found;\n    }\n}\nfunction gatherMarks(schema, marks) {\n    let found = [];\n    for (let i = 0; i < marks.length; i++) {\n        let name = marks[i], mark = schema.marks[name], ok = mark;\n        if (mark) {\n            found.push(mark);\n        }\n        else {\n            for (let prop in schema.marks) {\n                let mark = schema.marks[prop];\n                if (name == "_" || (mark.spec.group && mark.spec.group.split(" ").indexOf(name) > -1))\n                    found.push(ok = mark);\n            }\n        }\n        if (!ok)\n            throw new SyntaxError("Unknown mark type: \'" + marks[i] + "\'");\n    }\n    return found;\n}\n\n/**\nA DOM parser represents a strategy for parsing DOM content into a\nProseMirror document conforming to a given schema. Its behavior is\ndefined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).\n*/\nclass DOMParser {\n    /**\n    Create a parser that targets the given schema, using the given\n    parsing rules.\n    */\n    constructor(\n    /**\n    The schema into which the parser parses.\n    */\n    schema, \n    /**\n    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser\n    uses, in order of precedence.\n    */\n    rules) {\n        this.schema = schema;\n        this.rules = rules;\n        /**\n        @internal\n        */\n        this.tags = [];\n        /**\n        @internal\n        */\n        this.styles = [];\n        rules.forEach(rule => {\n            if (rule.tag)\n                this.tags.push(rule);\n            else if (rule.style)\n                this.styles.push(rule);\n        });\n        // Only normalize list elements when lists in the schema can\'t directly contain themselves\n        this.normalizeLists = !this.tags.some(r => {\n            if (!/^(ul|ol)\\b/.test(r.tag) || !r.node)\n                return false;\n            let node = schema.nodes[r.node];\n            return node.contentMatch.matchType(node);\n        });\n    }\n    /**\n    Parse a document from the content of a DOM node.\n    */\n    parse(dom, options = {}) {\n        let context = new ParseContext(this, options, false);\n        context.addAll(dom, options.from, options.to);\n        return context.finish();\n    }\n    /**\n    Parses the content of the given DOM node, like\n    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of\n    options. But unlike that method, which produces a whole node,\n    this one returns a slice that is open at the sides, meaning that\n    the schema constraints aren\'t applied to the start of nodes to\n    the left of the input and the end of nodes at the end.\n    */\n    parseSlice(dom, options = {}) {\n        let context = new ParseContext(this, options, true);\n        context.addAll(dom, options.from, options.to);\n        return Slice.maxOpen(context.finish());\n    }\n    /**\n    @internal\n    */\n    matchTag(dom, context, after) {\n        for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n            let rule = this.tags[i];\n            if (matches(dom, rule.tag) &&\n                (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n                (!rule.context || context.matchesContext(rule.context))) {\n                if (rule.getAttrs) {\n                    let result = rule.getAttrs(dom);\n                    if (result === false)\n                        continue;\n                    rule.attrs = result || undefined;\n                }\n                return rule;\n            }\n        }\n    }\n    /**\n    @internal\n    */\n    matchStyle(prop, value, context, after) {\n        for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n            let rule = this.styles[i], style = rule.style;\n            if (style.indexOf(prop) != 0 ||\n                rule.context && !context.matchesContext(rule.context) ||\n                // Test that the style string either precisely matches the prop,\n                // or has an \'=\' sign after the prop, followed by the given\n                // value.\n                style.length > prop.length &&\n                    (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))\n                continue;\n            if (rule.getAttrs) {\n                let result = rule.getAttrs(value);\n                if (result === false)\n                    continue;\n                rule.attrs = result || undefined;\n            }\n            return rule;\n        }\n    }\n    /**\n    @internal\n    */\n    static schemaRules(schema) {\n        let result = [];\n        function insert(rule) {\n            let priority = rule.priority == null ? 50 : rule.priority, i = 0;\n            for (; i < result.length; i++) {\n                let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n                if (nextPriority < priority)\n                    break;\n            }\n            result.splice(i, 0, rule);\n        }\n        for (let name in schema.marks) {\n            let rules = schema.marks[name].spec.parseDOM;\n            if (rules)\n                rules.forEach(rule => {\n                    insert(rule = copy(rule));\n                    if (!(rule.mark || rule.ignore || rule.clearMark))\n                        rule.mark = name;\n                });\n        }\n        for (let name in schema.nodes) {\n            let rules = schema.nodes[name].spec.parseDOM;\n            if (rules)\n                rules.forEach(rule => {\n                    insert(rule = copy(rule));\n                    if (!(rule.node || rule.ignore || rule.mark))\n                        rule.node = name;\n                });\n        }\n        return result;\n    }\n    /**\n    Construct a DOM parser using the parsing rules listed in a\n    schema\'s [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by\n    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).\n    */\n    static fromSchema(schema) {\n        return schema.cached.domParser ||\n            (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n    }\n}\nconst blockTags = {\n    address: true, article: true, aside: true, blockquote: true, canvas: true,\n    dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n    footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n    h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n    output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n};\nconst ignoreTags = {\n    head: true, noscript: true, object: true, script: true, style: true, title: true\n};\nconst listTags = { ol: true, ul: true };\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n    if (preserveWhitespace != null)\n        return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |\n            (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);\n    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\nclass NodeContext {\n    constructor(type, attrs, \n    // Marks applied to this node itself\n    marks, \n    // Marks that can\'t apply here, but will be used in children if possible\n    pendingMarks, solid, match, options) {\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.pendingMarks = pendingMarks;\n        this.solid = solid;\n        this.options = options;\n        this.content = [];\n        // Marks applied to the node\'s children\n        this.activeMarks = Mark.none;\n        // Nested Marks with same type\n        this.stashMarks = [];\n        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n    }\n    findWrapping(node) {\n        if (!this.match) {\n            if (!this.type)\n                return [];\n            let fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n            if (fill) {\n                this.match = this.type.contentMatch.matchFragment(fill);\n            }\n            else {\n                let start = this.type.contentMatch, wrap;\n                if (wrap = start.findWrapping(node.type)) {\n                    this.match = start;\n                    return wrap;\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n        return this.match.findWrapping(node.type);\n    }\n    finish(openEnd) {\n        if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n            let last = this.content[this.content.length - 1], m;\n            if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n                let text = last;\n                if (last.text.length == m[0].length)\n                    this.content.pop();\n                else\n                    this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n            }\n        }\n        let content = Fragment.from(this.content);\n        if (!openEnd && this.match)\n            content = content.append(this.match.fillBefore(Fragment.empty, true));\n        return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n    popFromStashMark(mark) {\n        for (let i = this.stashMarks.length - 1; i >= 0; i--)\n            if (mark.eq(this.stashMarks[i]))\n                return this.stashMarks.splice(i, 1)[0];\n    }\n    applyPending(nextType) {\n        for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n            let mark = pending[i];\n            if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n                !mark.isInSet(this.activeMarks)) {\n                this.activeMarks = mark.addToSet(this.activeMarks);\n                this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n            }\n        }\n    }\n    inlineContext(node) {\n        if (this.type)\n            return this.type.inlineContent;\n        if (this.content.length)\n            return this.content[0].isInline;\n        return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n}\nclass ParseContext {\n    constructor(\n    // The parser we are using.\n    parser, \n    // The options passed to this parse.\n    options, isOpen) {\n        this.parser = parser;\n        this.options = options;\n        this.isOpen = isOpen;\n        this.open = 0;\n        let topNode = options.topNode, topContext;\n        let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n        if (topNode)\n            topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n        else if (isOpen)\n            topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);\n        else\n            topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);\n        this.nodes = [topContext];\n        this.find = options.findPositions;\n        this.needsBlock = false;\n    }\n    get top() {\n        return this.nodes[this.open];\n    }\n    // Add a DOM node to the content. Text is inserted as text node,\n    // otherwise, the node is passed to `addElement` or, if it has a\n    // `style` attribute, `addElementWithStyles`.\n    addDOM(dom) {\n        if (dom.nodeType == 3) {\n            this.addTextNode(dom);\n        }\n        else if (dom.nodeType == 1) {\n            let style = dom.getAttribute("style");\n            if (!style) {\n                this.addElement(dom);\n            }\n            else {\n                let marks = this.readStyles(parseStyles(style));\n                if (!marks)\n                    return; // A style with ignore: true\n                let [addMarks, removeMarks] = marks, top = this.top;\n                for (let i = 0; i < removeMarks.length; i++)\n                    this.removePendingMark(removeMarks[i], top);\n                for (let i = 0; i < addMarks.length; i++)\n                    this.addPendingMark(addMarks[i]);\n                this.addElement(dom);\n                for (let i = 0; i < addMarks.length; i++)\n                    this.removePendingMark(addMarks[i], top);\n                for (let i = 0; i < removeMarks.length; i++)\n                    this.addPendingMark(removeMarks[i]);\n            }\n        }\n    }\n    addTextNode(dom) {\n        let value = dom.nodeValue;\n        let top = this.top;\n        if (top.options & OPT_PRESERVE_WS_FULL ||\n            top.inlineContext(dom) ||\n            /[^ \\t\\r\\n\\u000c]/.test(value)) {\n            if (!(top.options & OPT_PRESERVE_WS)) {\n                value = value.replace(/[ \\t\\r\\n\\u000c]+/g, " ");\n                // If this starts with whitespace, and there is no node before it, or\n                // a hard break, or a text node that ends with whitespace, strip the\n                // leading space.\n                if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n                    let nodeBefore = top.content[top.content.length - 1];\n                    let domNodeBefore = dom.previousSibling;\n                    if (!nodeBefore ||\n                        (domNodeBefore && domNodeBefore.nodeName == \'BR\') ||\n                        (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n                        value = value.slice(1);\n                }\n            }\n            else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n                value = value.replace(/\\r?\\n|\\r/g, " ");\n            }\n            else {\n                value = value.replace(/\\r\\n?/g, "\\n");\n            }\n            if (value)\n                this.insertNode(this.parser.schema.text(value));\n            this.findInText(dom);\n        }\n        else {\n            this.findInside(dom);\n        }\n    }\n    // Try to find a handler for the given tag and use that to parse. If\n    // none is found, the element\'s content nodes are added directly.\n    addElement(dom, matchAfter) {\n        let name = dom.nodeName.toLowerCase(), ruleID;\n        if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)\n            normalizeList(dom);\n        let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n            (ruleID = this.parser.matchTag(dom, this, matchAfter));\n        if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n            this.findInside(dom);\n            this.ignoreFallback(dom);\n        }\n        else if (!rule || rule.skip || rule.closeParent) {\n            if (rule && rule.closeParent)\n                this.open = Math.max(0, this.open - 1);\n            else if (rule && rule.skip.nodeType)\n                dom = rule.skip;\n            let sync, top = this.top, oldNeedsBlock = this.needsBlock;\n            if (blockTags.hasOwnProperty(name)) {\n                if (top.content.length && top.content[0].isInline && this.open) {\n                    this.open--;\n                    top = this.top;\n                }\n                sync = true;\n                if (!top.type)\n                    this.needsBlock = true;\n            }\n            else if (!dom.firstChild) {\n                this.leafFallback(dom);\n                return;\n            }\n            this.addAll(dom);\n            if (sync)\n                this.sync(top);\n            this.needsBlock = oldNeedsBlock;\n        }\n        else {\n            this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : undefined);\n        }\n    }\n    // Called for leaf DOM nodes that would otherwise be ignored\n    leafFallback(dom) {\n        if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)\n            this.addTextNode(dom.ownerDocument.createTextNode("\\n"));\n    }\n    // Called for ignored nodes\n    ignoreFallback(dom) {\n        // Ignored BR nodes should at least create an inline context\n        if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))\n            this.findPlace(this.parser.schema.text("-"));\n    }\n    // Run any style parser associated with the node\'s styles. Either\n    // return an array of marks, or null to indicate some of the styles\n    // had a rule with `ignore` set.\n    readStyles(styles) {\n        let add = Mark.none, remove = Mark.none;\n        style: for (let i = 0; i < styles.length; i += 2) {\n            for (let after = undefined;;) {\n                let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);\n                if (!rule)\n                    continue style;\n                if (rule.ignore)\n                    return null;\n                if (rule.clearMark) {\n                    this.top.pendingMarks.forEach(m => {\n                        if (rule.clearMark(m))\n                            remove = m.addToSet(remove);\n                    });\n                }\n                else {\n                    add = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);\n                }\n                if (rule.consuming === false)\n                    after = rule;\n                else\n                    break;\n            }\n        }\n        return [add, remove];\n    }\n    // Look up a handler for the given node. If none are found, return\n    // false. Otherwise, apply it, use its return value to drive the way\n    // the node\'s content is wrapped, and return true.\n    addElementByRule(dom, rule, continueAfter) {\n        let sync, nodeType, mark;\n        if (rule.node) {\n            nodeType = this.parser.schema.nodes[rule.node];\n            if (!nodeType.isLeaf) {\n                sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);\n            }\n            else if (!this.insertNode(nodeType.create(rule.attrs))) {\n                this.leafFallback(dom);\n            }\n        }\n        else {\n            let markType = this.parser.schema.marks[rule.mark];\n            mark = markType.create(rule.attrs);\n            this.addPendingMark(mark);\n        }\n        let startIn = this.top;\n        if (nodeType && nodeType.isLeaf) {\n            this.findInside(dom);\n        }\n        else if (continueAfter) {\n            this.addElement(dom, continueAfter);\n        }\n        else if (rule.getContent) {\n            this.findInside(dom);\n            rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node));\n        }\n        else {\n            let contentDOM = dom;\n            if (typeof rule.contentElement == "string")\n                contentDOM = dom.querySelector(rule.contentElement);\n            else if (typeof rule.contentElement == "function")\n                contentDOM = rule.contentElement(dom);\n            else if (rule.contentElement)\n                contentDOM = rule.contentElement;\n            this.findAround(dom, contentDOM, true);\n            this.addAll(contentDOM);\n        }\n        if (sync && this.sync(startIn))\n            this.open--;\n        if (mark)\n            this.removePendingMark(mark, startIn);\n    }\n    // Add all child nodes between `startIndex` and `endIndex` (or the\n    // whole node, if not given). If `sync` is passed, use it to\n    // synchronize after every block element.\n    addAll(parent, startIndex, endIndex) {\n        let index = startIndex || 0;\n        for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n            this.findAtPoint(parent, index);\n            this.addDOM(dom);\n        }\n        this.findAtPoint(parent, index);\n    }\n    // Try to find a way to fit the given node type into the current\n    // context. May add intermediate wrappers and/or leave non-solid\n    // nodes that we\'re in.\n    findPlace(node) {\n        let route, sync;\n        for (let depth = this.open; depth >= 0; depth--) {\n            let cx = this.nodes[depth];\n            let found = cx.findWrapping(node);\n            if (found && (!route || route.length > found.length)) {\n                route = found;\n                sync = cx;\n                if (!found.length)\n                    break;\n            }\n            if (cx.solid)\n                break;\n        }\n        if (!route)\n            return false;\n        this.sync(sync);\n        for (let i = 0; i < route.length; i++)\n            this.enterInner(route[i], null, false);\n        return true;\n    }\n    // Try to insert the given node, adjusting the context when needed.\n    insertNode(node) {\n        if (node.isInline && this.needsBlock && !this.top.type) {\n            let block = this.textblockFromContext();\n            if (block)\n                this.enterInner(block);\n        }\n        if (this.findPlace(node)) {\n            this.closeExtra();\n            let top = this.top;\n            top.applyPending(node.type);\n            if (top.match)\n                top.match = top.match.matchType(node.type);\n            let marks = top.activeMarks;\n            for (let i = 0; i < node.marks.length; i++)\n                if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n                    marks = node.marks[i].addToSet(marks);\n            top.content.push(node.mark(marks));\n            return true;\n        }\n        return false;\n    }\n    // Try to start a node of the given type, adjusting the context when\n    // necessary.\n    enter(type, attrs, preserveWS) {\n        let ok = this.findPlace(type.create(attrs));\n        if (ok)\n            this.enterInner(type, attrs, true, preserveWS);\n        return ok;\n    }\n    // Open a node of the given type\n    enterInner(type, attrs = null, solid = false, preserveWS) {\n        this.closeExtra();\n        let top = this.top;\n        top.applyPending(type);\n        top.match = top.match && top.match.matchType(type);\n        let options = wsOptionsFor(type, preserveWS, top.options);\n        if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0)\n            options |= OPT_OPEN_LEFT;\n        this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n        this.open++;\n    }\n    // Make sure all nodes above this.open are finished and added to\n    // their parents\n    closeExtra(openEnd = false) {\n        let i = this.nodes.length - 1;\n        if (i > this.open) {\n            for (; i > this.open; i--)\n                this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n            this.nodes.length = this.open + 1;\n        }\n    }\n    finish() {\n        this.open = 0;\n        this.closeExtra(this.isOpen);\n        return this.nodes[0].finish(this.isOpen || this.options.topOpen);\n    }\n    sync(to) {\n        for (let i = this.open; i >= 0; i--)\n            if (this.nodes[i] == to) {\n                this.open = i;\n                return true;\n            }\n        return false;\n    }\n    get currentPos() {\n        this.closeExtra();\n        let pos = 0;\n        for (let i = this.open; i >= 0; i--) {\n            let content = this.nodes[i].content;\n            for (let j = content.length - 1; j >= 0; j--)\n                pos += content[j].nodeSize;\n            if (i)\n                pos++;\n        }\n        return pos;\n    }\n    findAtPoint(parent, offset) {\n        if (this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].node == parent && this.find[i].offset == offset)\n                    this.find[i].pos = this.currentPos;\n            }\n    }\n    findInside(parent) {\n        if (this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n                    this.find[i].pos = this.currentPos;\n            }\n    }\n    findAround(parent, content, before) {\n        if (parent != content && this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n                    let pos = content.compareDocumentPosition(this.find[i].node);\n                    if (pos & (before ? 2 : 4))\n                        this.find[i].pos = this.currentPos;\n                }\n            }\n    }\n    findInText(textNode) {\n        if (this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].node == textNode)\n                    this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n            }\n    }\n    // Determines whether the given context string matches this context.\n    matchesContext(context) {\n        if (context.indexOf("|") > -1)\n            return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n        let parts = context.split("/");\n        let option = this.options.context;\n        let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n        let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n        let match = (i, depth) => {\n            for (; i >= 0; i--) {\n                let part = parts[i];\n                if (part == "") {\n                    if (i == parts.length - 1 || i == 0)\n                        continue;\n                    for (; depth >= minDepth; depth--)\n                        if (match(i - 1, depth))\n                            return true;\n                    return false;\n                }\n                else {\n                    let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n                        : option && depth >= minDepth ? option.node(depth - minDepth).type\n                            : null;\n                    if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n                        return false;\n                    depth--;\n                }\n            }\n            return true;\n        };\n        return match(parts.length - 1, this.open);\n    }\n    textblockFromContext() {\n        let $context = this.options.context;\n        if ($context)\n            for (let d = $context.depth; d >= 0; d--) {\n                let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n                if (deflt && deflt.isTextblock && deflt.defaultAttrs)\n                    return deflt;\n            }\n        for (let name in this.parser.schema.nodes) {\n            let type = this.parser.schema.nodes[name];\n            if (type.isTextblock && type.defaultAttrs)\n                return type;\n        }\n    }\n    addPendingMark(mark) {\n        let found = findSameMarkInSet(mark, this.top.pendingMarks);\n        if (found)\n            this.top.stashMarks.push(found);\n        this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n    }\n    removePendingMark(mark, upto) {\n        for (let depth = this.open; depth >= 0; depth--) {\n            let level = this.nodes[depth];\n            let found = level.pendingMarks.lastIndexOf(mark);\n            if (found > -1) {\n                level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n            }\n            else {\n                level.activeMarks = mark.removeFromSet(level.activeMarks);\n                let stashMark = level.popFromStashMark(mark);\n                if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n                    level.activeMarks = stashMark.addToSet(level.activeMarks);\n            }\n            if (level == upto)\n                break;\n        }\n    }\n}\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n        let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n        if (name && listTags.hasOwnProperty(name) && prevItem) {\n            prevItem.appendChild(child);\n            child = prevItem;\n        }\n        else if (name == "li") {\n            prevItem = child;\n        }\n        else if (name) {\n            prevItem = null;\n        }\n    }\n}\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n    let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = [];\n    while (m = re.exec(style))\n        result.push(m[1], m[2].trim());\n    return result;\n}\nfunction copy(obj) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    return copy;\n}\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n    let nodes = nodeType.schema.nodes;\n    for (let name in nodes) {\n        let parent = nodes[name];\n        if (!parent.allowsMarkType(markType))\n            continue;\n        let seen = [], scan = (match) => {\n            seen.push(match);\n            for (let i = 0; i < match.edgeCount; i++) {\n                let { type, next } = match.edge(i);\n                if (type == nodeType)\n                    return true;\n                if (seen.indexOf(next) < 0 && scan(next))\n                    return true;\n            }\n        };\n        if (scan(parent.contentMatch))\n            return true;\n    }\n}\nfunction findSameMarkInSet(mark, set) {\n    for (let i = 0; i < set.length; i++) {\n        if (mark.eq(set[i]))\n            return set[i];\n    }\n}\n\n/**\nA DOM serializer knows how to convert ProseMirror nodes and\nmarks of various types to DOM nodes.\n*/\nclass DOMSerializer {\n    /**\n    Create a serializer. `nodes` should map node names to functions\n    that take a node and return a description of the corresponding\n    DOM. `marks` does the same for mark names, but also gets an\n    argument that tells it whether the mark\'s content is block or\n    inline content (for typical use, it\'ll always be inline). A mark\n    serializer may be `null` to indicate that marks of that type\n    should not be serialized.\n    */\n    constructor(\n    /**\n    The node serialization functions.\n    */\n    nodes, \n    /**\n    The mark serialization functions.\n    */\n    marks) {\n        this.nodes = nodes;\n        this.marks = marks;\n    }\n    /**\n    Serialize the content of this fragment to a DOM fragment. When\n    not in the browser, the `document` option, containing a DOM\n    document, should be passed so that the serializer can create\n    nodes.\n    */\n    serializeFragment(fragment, options = {}, target) {\n        if (!target)\n            target = doc(options).createDocumentFragment();\n        let top = target, active = [];\n        fragment.forEach(node => {\n            if (active.length || node.marks.length) {\n                let keep = 0, rendered = 0;\n                while (keep < active.length && rendered < node.marks.length) {\n                    let next = node.marks[rendered];\n                    if (!this.marks[next.type.name]) {\n                        rendered++;\n                        continue;\n                    }\n                    if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)\n                        break;\n                    keep++;\n                    rendered++;\n                }\n                while (keep < active.length)\n                    top = active.pop()[1];\n                while (rendered < node.marks.length) {\n                    let add = node.marks[rendered++];\n                    let markDOM = this.serializeMark(add, node.isInline, options);\n                    if (markDOM) {\n                        active.push([add, top]);\n                        top.appendChild(markDOM.dom);\n                        top = markDOM.contentDOM || markDOM.dom;\n                    }\n                }\n            }\n            top.appendChild(this.serializeNodeInner(node, options));\n        });\n        return target;\n    }\n    /**\n    @internal\n    */\n    serializeNodeInner(node, options) {\n        let { dom, contentDOM } = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n        if (contentDOM) {\n            if (node.isLeaf)\n                throw new RangeError("Content hole not allowed in a leaf node spec");\n            this.serializeFragment(node.content, options, contentDOM);\n        }\n        return dom;\n    }\n    /**\n    Serialize this node to a DOM node. This can be useful when you\n    need to serialize a part of a document, as opposed to the whole\n    document. To serialize a whole document, use\n    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on\n    its [content](https://prosemirror.net/docs/ref/#model.Node.content).\n    */\n    serializeNode(node, options = {}) {\n        let dom = this.serializeNodeInner(node, options);\n        for (let i = node.marks.length - 1; i >= 0; i--) {\n            let wrap = this.serializeMark(node.marks[i], node.isInline, options);\n            if (wrap) {\n                (wrap.contentDOM || wrap.dom).appendChild(dom);\n                dom = wrap.dom;\n            }\n        }\n        return dom;\n    }\n    /**\n    @internal\n    */\n    serializeMark(mark, inline, options = {}) {\n        let toDOM = this.marks[mark.type.name];\n        return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));\n    }\n    /**\n    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If\n    the spec has a hole (zero) in it, `contentDOM` will point at the\n    node with the hole.\n    */\n    static renderSpec(doc, structure, xmlNS = null) {\n        if (typeof structure == "string")\n            return { dom: doc.createTextNode(structure) };\n        if (structure.nodeType != null)\n            return { dom: structure };\n        if (structure.dom && structure.dom.nodeType != null)\n            return structure;\n        let tagName = structure[0], space = tagName.indexOf(" ");\n        if (space > 0) {\n            xmlNS = tagName.slice(0, space);\n            tagName = tagName.slice(space + 1);\n        }\n        let contentDOM;\n        let dom = (xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName));\n        let attrs = structure[1], start = 1;\n        if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {\n            start = 2;\n            for (let name in attrs)\n                if (attrs[name] != null) {\n                    let space = name.indexOf(" ");\n                    if (space > 0)\n                        dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name]);\n                    else\n                        dom.setAttribute(name, attrs[name]);\n                }\n        }\n        for (let i = start; i < structure.length; i++) {\n            let child = structure[i];\n            if (child === 0) {\n                if (i < structure.length - 1 || i > start)\n                    throw new RangeError("Content hole must be the only child of its parent node");\n                return { dom, contentDOM: dom };\n            }\n            else {\n                let { dom: inner, contentDOM: innerContent } = DOMSerializer.renderSpec(doc, child, xmlNS);\n                dom.appendChild(inner);\n                if (innerContent) {\n                    if (contentDOM)\n                        throw new RangeError("Multiple content holes");\n                    contentDOM = innerContent;\n                }\n            }\n        }\n        return { dom, contentDOM };\n    }\n    /**\n    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)\n    properties in a schema\'s node and mark specs.\n    */\n    static fromSchema(schema) {\n        return schema.cached.domSerializer ||\n            (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n    }\n    /**\n    Gather the serializers in a schema\'s node specs into an object.\n    This can be useful as a base to build a custom serializer from.\n    */\n    static nodesFromSchema(schema) {\n        let result = gatherToDOM(schema.nodes);\n        if (!result.text)\n            result.text = node => node.text;\n        return result;\n    }\n    /**\n    Gather the serializers in a schema\'s mark specs into an object.\n    */\n    static marksFromSchema(schema) {\n        return gatherToDOM(schema.marks);\n    }\n}\nfunction gatherToDOM(obj) {\n    let result = {};\n    for (let name in obj) {\n        let toDOM = obj[name].spec.toDOM;\n        if (toDOM)\n            result[name] = toDOM;\n    }\n    return result;\n}\nfunction doc(options) {\n    return options.document || window.document;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5qcz80MjM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPcmRlcmVkTWFwIGZyb20gJ29yZGVyZWRtYXAnO1xuXG5mdW5jdGlvbiBmaW5kRGlmZlN0YXJ0KGEsIGIsIHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGlmIChpID09IGEuY2hpbGRDb3VudCB8fCBpID09IGIuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHJldHVybiBhLmNoaWxkQ291bnQgPT0gYi5jaGlsZENvdW50ID8gbnVsbCA6IHBvcztcbiAgICAgICAgbGV0IGNoaWxkQSA9IGEuY2hpbGQoaSksIGNoaWxkQiA9IGIuY2hpbGQoaSk7XG4gICAgICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBjaGlsZEEudGV4dFtqXSA9PSBjaGlsZEIudGV4dFtqXTsgaisrKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kRGlmZlN0YXJ0KGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5uZXIgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRGlmZkVuZChhLCBiLCBwb3NBLCBwb3NCKSB7XG4gICAgZm9yIChsZXQgaUEgPSBhLmNoaWxkQ291bnQsIGlCID0gYi5jaGlsZENvdW50OzspIHtcbiAgICAgICAgaWYgKGlBID09IDAgfHwgaUIgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBpQSA9PSBpQiA/IG51bGwgOiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgbGV0IGNoaWxkQSA9IGEuY2hpbGQoLS1pQSksIGNoaWxkQiA9IGIuY2hpbGQoLS1pQiksIHNpemUgPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICAgICAgICBwb3NBIC09IHNpemU7XG4gICAgICAgICAgICBwb3NCIC09IHNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpXG4gICAgICAgICAgICByZXR1cm4geyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICAgICAgICBsZXQgc2FtZSA9IDAsIG1pblNpemUgPSBNYXRoLm1pbihjaGlsZEEudGV4dC5sZW5ndGgsIGNoaWxkQi50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoc2FtZSA8IG1pblNpemUgJiYgY2hpbGRBLnRleHRbY2hpbGRBLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdID09IGNoaWxkQi50ZXh0W2NoaWxkQi50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSkge1xuICAgICAgICAgICAgICAgIHNhbWUrKztcbiAgICAgICAgICAgICAgICBwb3NBLS07XG4gICAgICAgICAgICAgICAgcG9zQi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmREaWZmRW5kKGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zQSAtIDEsIHBvc0IgLSAxKTtcbiAgICAgICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zQSAtPSBzaXplO1xuICAgICAgICBwb3NCIC09IHNpemU7XG4gICAgfVxufVxuXG4vKipcbkEgZnJhZ21lbnQgcmVwcmVzZW50cyBhIG5vZGUncyBjb2xsZWN0aW9uIG9mIGNoaWxkIG5vZGVzLlxuXG5MaWtlIG5vZGVzLCBmcmFnbWVudHMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLCBhbmQgeW91XG5zaG91bGQgbm90IG11dGF0ZSB0aGVtIG9yIHRoZWlyIGNvbnRlbnQuIFJhdGhlciwgeW91IGNyZWF0ZSBuZXdcbmluc3RhbmNlcyB3aGVuZXZlciBuZWVkZWQuIFRoZSBBUEkgdHJpZXMgdG8gbWFrZSB0aGlzIGVhc3kuXG4qL1xuY2xhc3MgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb250ZW50LCBzaXplKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemUgfHwgMDtcbiAgICAgICAgaWYgKHNpemUgPT0gbnVsbClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgKz0gY29udGVudFtpXS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIGJldHdlZW4gdGhlIGdpdmVuIHR3b1xuICAgIHBvc2l0aW9ucyAocmVsYXRpdmUgdG8gc3RhcnQgb2YgdGhpcyBmcmFnbWVudCkuIERvZXNuJ3QgZGVzY2VuZFxuICAgIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbiAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgbm9kZVN0YXJ0ID0gMCwgcGFyZW50KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20gJiYgZihjaGlsZCwgbm9kZVN0YXJ0ICsgcG9zLCBwYXJlbnQgfHwgbnVsbCwgaSkgIT09IGZhbHNlICYmIGNoaWxkLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgY2hpbGQubm9kZXNCZXR3ZWVuKE1hdGgubWF4KDAsIGZyb20gLSBzdGFydCksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBzdGFydCksIGYsIG5vZGVTdGFydCArIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZXZlcnkgZGVzY2VuZGFudCBub2RlLiBgcG9zYCB3aWxsIGJlXG4gICAgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudC4gVGhlIGNhbGxiYWNrIG1heSByZXR1cm5cbiAgICBgZmFsc2VgIHRvIHByZXZlbnQgdHJhdmVyc2FsIG9mIGEgZ2l2ZW4gbm9kZSdzIGNoaWxkcmVuLlxuICAgICovXG4gICAgZGVzY2VuZGFudHMoZikge1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLnNpemUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRyYWN0IHRoZSB0ZXh0IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLiBTZWUgdGhlIHNhbWUgbWV0aG9kIG9uXG4gICAgW2BOb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUudGV4dEJldHdlZW4pLlxuICAgICovXG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCIsIHNlcGFyYXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IG5vZGUudGV4dC5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICAgICAgICAgICAgc2VwYXJhdGVkID0gIWJsb2NrU2VwYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVhZlRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB0eXBlb2YgbGVhZlRleHQgPT09IFwiZnVuY3Rpb25cIiA/IGxlYWZUZXh0KG5vZGUpIDogbGVhZlRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gbm9kZS50eXBlLnNwZWMubGVhZlRleHQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlcGFyYXRlZCA9ICFibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFzZXBhcmF0ZWQgJiYgbm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBjb250YWluaW5nIHRoZSBjb21iaW5lZCBjb250ZW50IG9mIHRoaXNcbiAgICBmcmFnbWVudCBhbmQgdGhlIG90aGVyLlxuICAgICovXG4gICAgYXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmxhc3RDaGlsZCwgZmlyc3QgPSBvdGhlci5maXJzdENoaWxkLCBjb250ZW50ID0gdGhpcy5jb250ZW50LnNsaWNlKCksIGkgPSAwO1xuICAgICAgICBpZiAobGFzdC5pc1RleHQgJiYgbGFzdC5zYW1lTWFya3VwKGZpcnN0KSkge1xuICAgICAgICAgICAgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID0gbGFzdC53aXRoVGV4dChsYXN0LnRleHQgKyBmaXJzdC50ZXh0KTtcbiAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgb3RoZXIuY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChvdGhlci5jb250ZW50W2ldKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50LCB0aGlzLnNpemUgKyBvdGhlci5zaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3V0IG91dCB0aGUgc3ViLWZyYWdtZW50IGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLnNpemUpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBzaXplID0gMDtcbiAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zIDwgZnJvbSB8fCBlbmQgPiB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgTWF0aC5taW4oY2hpbGQudGV4dC5sZW5ndGgsIHRvIC0gcG9zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyAtIDEpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gcG9zIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHJlc3VsdCwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3V0QnlJbmRleChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBpbiB3aGljaCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXggaXNcbiAgICByZXBsYWNlZCBieSB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAqL1xuICAgIHJlcGxhY2VDaGlsZChpbmRleCwgbm9kZSkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG5vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplIC0gY3VycmVudC5ub2RlU2l6ZTtcbiAgICAgICAgY29weVtpbmRleF0gPSBub2RlO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvcHksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgcHJlcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4gICAgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBhZGRUb1N0YXJ0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZV0uY29uY2F0KHRoaXMuY29udGVudCksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgYXBwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbiAgICBmcmFnbWVudC5cbiAgICAqL1xuICAgIGFkZFRvRW5kKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuY29uY2F0KG5vZGUpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGZyYWdtZW50IHRvIGFub3RoZXIgb25lLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggIT0gb3RoZXIuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRbaV0uZXEob3RoZXIuY29udGVudFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50WzBdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBsYXN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgY2hpbGQgbm9kZXMgaW4gdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICovXG4gICAgY2hpbGQoaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggXCIgKyBpbmRleCArIFwiIG91dCBvZiByYW5nZSBmb3IgXCIgKyB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBpdCBleGlzdHMuXG4gICAgKi9cbiAgICBtYXliZUNoaWxkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbaW5kZXhdIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldO1xuICAgICAgICAgICAgZihjaGlsZCwgcCwgaSk7XG4gICAgICAgICAgICBwICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uIGF0IHdoaWNoIHRoaXMgZnJhZ21lbnQgYW5kIGFub3RoZXJcbiAgICBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZSB0aGUgc2FtZS5cbiAgICAqL1xuICAgIGZpbmREaWZmU3RhcnQob3RoZXIsIHBvcyA9IDApIHtcbiAgICAgICAgcmV0dXJuIGZpbmREaWZmU3RhcnQodGhpcywgb3RoZXIsIHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uLCBzZWFyY2hpbmcgZnJvbSB0aGUgZW5kLCBhdCB3aGljaCB0aGlzXG4gICAgZnJhZ21lbnQgYW5kIHRoZSBnaXZlbiBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZVxuICAgIHRoZSBzYW1lLiBTaW5jZSB0aGlzIHBvc2l0aW9uIHdpbGwgbm90IGJlIHRoZSBzYW1lIGluIGJvdGhcbiAgICBub2RlcywgYW4gb2JqZWN0IHdpdGggdHdvIHNlcGFyYXRlIHBvc2l0aW9ucyBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGZpbmREaWZmRW5kKG90aGVyLCBwb3MgPSB0aGlzLnNpemUsIG90aGVyUG9zID0gb3RoZXIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmluZERpZmZFbmQodGhpcywgb3RoZXIsIHBvcywgb3RoZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRleCBhbmQgaW5uZXIgb2Zmc2V0IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiByZWxhdGl2ZVxuICAgIHBvc2l0aW9uIGluIHRoaXMgZnJhZ21lbnQuIFRoZSByZXN1bHQgb2JqZWN0IHdpbGwgYmUgcmV1c2VkXG4gICAgKG92ZXJ3cml0dGVuKSB0aGUgbmV4dCB0aW1lIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQuIChOb3QgcHVibGljLilcbiAgICAqL1xuICAgIGZpbmRJbmRleChwb3MsIHJvdW5kID0gLTEpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KDAsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KHRoaXMuY29udGVudC5sZW5ndGgsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPiB0aGlzLnNpemUgfHwgcG9zIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gb3V0c2lkZSBvZiBmcmFnbWVudCAoJHt0aGlzfSlgKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1clBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkKGkpLCBlbmQgPSBjdXJQb3MgKyBjdXIubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gcG9zIHx8IHJvdW5kID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KGkgKyAxLCBlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRJbmRleChpLCBjdXJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGRlYnVnZ2luZyBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCI8XCIgKyB0aGlzLnRvU3RyaW5nSW5uZXIoKSArIFwiPlwiOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZ0lubmVyKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmpvaW4oXCIsIFwiKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudC5tYXAobiA9PiBuLnRvSlNPTigpKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgZnJhZ21lbnQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEZyYWdtZW50LmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHZhbHVlLm1hcChzY2hlbWEubm9kZUZyb21KU09OKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgZnJhZ21lbnQgZnJvbSBhbiBhcnJheSBvZiBub2Rlcy4gRW5zdXJlcyB0aGF0IGFkamFjZW50XG4gICAgdGV4dCBub2RlcyB3aXRoIHRoZSBzYW1lIG1hcmtzIGFyZSBqb2luZWQgdG9nZXRoZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgIGlmICghYXJyYXkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBsZXQgam9pbmVkLCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpICYmIG5vZGUuaXNUZXh0ICYmIGFycmF5W2kgLSAxXS5zYW1lTWFya3VwKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2luZWQpXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCA9IGFycmF5LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0gPSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC53aXRoVGV4dChqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdLnRleHQgKyBub2RlLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoam9pbmVkKSB7XG4gICAgICAgICAgICAgICAgam9pbmVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChqb2luZWQgfHwgYXJyYXksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmcmFnbWVudCBmcm9tIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBpbnRlcnByZXRlZCBhcyBhXG4gICAgc2V0IG9mIG5vZGVzLiBGb3IgYG51bGxgLCBpdCByZXR1cm5zIHRoZSBlbXB0eSBmcmFnbWVudC4gRm9yIGFcbiAgICBmcmFnbWVudCwgdGhlIGZyYWdtZW50IGl0c2VsZi4gRm9yIGEgbm9kZSBvciBhcnJheSBvZiBub2RlcywgYVxuICAgIGZyYWdtZW50IGNvbnRhaW5pbmcgdGhvc2Ugbm9kZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbShub2Rlcykge1xuICAgICAgICBpZiAoIW5vZGVzKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAobm9kZXMgaW5zdGFuY2VvZiBGcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KG5vZGVzKTtcbiAgICAgICAgaWYgKG5vZGVzLmF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZXNdLCBub2Rlcy5ub2RlU2l6ZSk7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IFwiICsgbm9kZXMgKyBcIiB0byBhIEZyYWdtZW50XCIgK1xuICAgICAgICAgICAgKG5vZGVzLm5vZGVzQmV0d2VlbiA/IFwiIChsb29rcyBsaWtlIG11bHRpcGxlIHZlcnNpb25zIG9mIHByb3NlbWlycm9yLW1vZGVsIHdlcmUgbG9hZGVkKVwiIDogXCJcIikpO1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZnJhZ21lbnQuIEludGVuZGVkIHRvIGJlIHJldXNlZCB3aGVuZXZlciBhIG5vZGUgZG9lc24ndFxuY29udGFpbiBhbnl0aGluZyAocmF0aGVyIHRoYW4gYWxsb2NhdGluZyBhIG5ldyBlbXB0eSBmcmFnbWVudCBmb3JcbmVhY2ggbGVhZiBub2RlKS5cbiovXG5GcmFnbWVudC5lbXB0eSA9IG5ldyBGcmFnbWVudChbXSwgMCk7XG5jb25zdCBmb3VuZCA9IHsgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuZnVuY3Rpb24gcmV0SW5kZXgoaW5kZXgsIG9mZnNldCkge1xuICAgIGZvdW5kLmluZGV4ID0gaW5kZXg7XG4gICAgZm91bmQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZURlZXAoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIShhICYmIHR5cGVvZiBhID09IFwib2JqZWN0XCIpIHx8XG4gICAgICAgICEoYiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYikgIT0gYXJyYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVEZWVwKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHAgaW4gYSlcbiAgICAgICAgICAgIGlmICghKHAgaW4gYikgfHwgIWNvbXBhcmVEZWVwKGFbcF0sIGJbcF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBiKVxuICAgICAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbkEgbWFyayBpcyBhIHBpZWNlIG9mIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgbm9kZSxcbnN1Y2ggYXMgaXQgYmVpbmcgZW1waGFzaXplZCwgaW4gY29kZSBmb250LCBvciBhIGxpbmsuIEl0IGhhcyBhXG50eXBlIGFuZCBvcHRpb25hbGx5IGEgc2V0IG9mIGF0dHJpYnV0ZXMgdGhhdCBwcm92aWRlIGZ1cnRoZXJcbmluZm9ybWF0aW9uIChzdWNoIGFzIHRoZSB0YXJnZXQgb2YgdGhlIGxpbmspLiBNYXJrcyBhcmUgY3JlYXRlZFxudGhyb3VnaCBhIGBTY2hlbWFgLCB3aGljaCBjb250cm9scyB3aGljaCB0eXBlcyBleGlzdCBhbmQgd2hpY2hcbmF0dHJpYnV0ZXMgdGhleSBoYXZlLlxuKi9cbmNsYXNzIE1hcmsge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdGhpcyBtYXJrLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFyay5cbiAgICAqL1xuICAgIGF0dHJzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBzZXQgb2YgbWFya3MsIGNyZWF0ZSBhIG5ldyBzZXQgd2hpY2ggY29udGFpbnMgdGhpcyBvbmUgYXNcbiAgICB3ZWxsLCBpbiB0aGUgcmlnaHQgcG9zaXRpb24uIElmIHRoaXMgbWFyayBpcyBhbHJlYWR5IGluIHRoZSBzZXQsXG4gICAgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuIElmIGFueSBtYXJrcyB0aGF0IGFyZSBzZXQgdG8gYmVcbiAgICBbZXhjbHVzaXZlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIHdpdGggdGhpcyBtYXJrIGFyZSBwcmVzZW50LFxuICAgIHRob3NlIGFyZSByZXBsYWNlZCBieSB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgY29weSwgcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBzZXRbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuZXhjbHVkZXMob3RoZXIudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlci50eXBlLmV4Y2x1ZGVzKHRoaXMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwbGFjZWQgJiYgb3RoZXIudHlwZS5yYW5rID4gdGhpcy50eXBlLnJhbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKCk7XG4gICAgICAgIGlmICghcGxhY2VkKVxuICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIHRoaXMgbWFyayBmcm9tIHRoZSBnaXZlbiBzZXQsIHJldHVybmluZyBhIG5ldyBzZXQuIElmIHRoaXNcbiAgICBtYXJrIGlzIG5vdCBpbiB0aGUgc2V0LCB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBpcyBpbiB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaGFzIHRoZSBzYW1lIHR5cGUgYW5kIGF0dHJpYnV0ZXMgYXNcbiAgICBhbm90aGVyIG1hcmsuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKHRoaXMudHlwZSA9PSBvdGhlci50eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBtYXJrIHRvIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBKU09OLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE1hcmsuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm1hcmtzW2pzb24udHlwZV07XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgJHtqc29uLnR5cGV9IGluIHRoaXMgc2NoZW1hYCk7XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShqc29uLmF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHR3byBzZXRzIG9mIG1hcmtzIGFyZSBpZGVudGljYWwuXG4gICAgKi9cbiAgICBzdGF0aWMgc2FtZVNldChhLCBiKSB7XG4gICAgICAgIGlmIChhID09IGIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWFbaV0uZXEoYltpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcHJvcGVybHkgc29ydGVkIG1hcmsgc2V0IGZyb20gbnVsbCwgYSBzaW5nbGUgbWFyaywgb3IgYW5cbiAgICB1bnNvcnRlZCBhcnJheSBvZiBtYXJrcy5cbiAgICAqL1xuICAgIHN0YXRpYyBzZXRGcm9tKG1hcmtzKSB7XG4gICAgICAgIGlmICghbWFya3MgfHwgQXJyYXkuaXNBcnJheShtYXJrcykgJiYgbWFya3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICBpZiAobWFya3MgaW5zdGFuY2VvZiBNYXJrKVxuICAgICAgICAgICAgcmV0dXJuIFttYXJrc107XG4gICAgICAgIGxldCBjb3B5ID0gbWFya3Muc2xpY2UoKTtcbiAgICAgICAgY29weS5zb3J0KChhLCBiKSA9PiBhLnR5cGUucmFuayAtIGIudHlwZS5yYW5rKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIG1hcmtzLlxuKi9cbk1hcmsubm9uZSA9IFtdO1xuXG4vKipcbkVycm9yIHR5cGUgcmFpc2VkIGJ5IFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2hlblxuZ2l2ZW4gYW4gaW52YWxpZCByZXBsYWNlbWVudC5cbiovXG5jbGFzcyBSZXBsYWNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vKlxuUmVwbGFjZUVycm9yID0gZnVuY3Rpb24odGhpczogYW55LCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSlcbiAgOyhlcnIgYXMgYW55KS5fX3Byb3RvX18gPSBSZXBsYWNlRXJyb3IucHJvdG90eXBlXG4gIHJldHVybiBlcnJcbn0gYXMgYW55XG5cblJlcGxhY2VFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcblJlcGxhY2VFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXBsYWNlRXJyb3JcblJlcGxhY2VFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiUmVwbGFjZUVycm9yXCJcbiovXG4vKipcbkEgc2xpY2UgcmVwcmVzZW50cyBhIHBpZWNlIGN1dCBvdXQgb2YgYSBsYXJnZXIgZG9jdW1lbnQuIEl0XG5zdG9yZXMgbm90IG9ubHkgYSBmcmFnbWVudCwgYnV0IGFsc28gdGhlIGRlcHRoIHVwIHRvIHdoaWNoIG5vZGVzIG9uXG5ib3RoIHNpZGUgYXJlIOKAmG9wZW7igJkgKGN1dCB0aHJvdWdoKS5cbiovXG5jbGFzcyBTbGljZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2xpY2UuIFdoZW4gc3BlY2lmeWluZyBhIG5vbi16ZXJvIG9wZW4gZGVwdGgsIHlvdSBtdXN0XG4gICAgbWFrZSBzdXJlIHRoYXQgdGhlcmUgYXJlIG5vZGVzIG9mIGF0IGxlYXN0IHRoYXQgZGVwdGggYXQgdGhlXG4gICAgYXBwcm9wcmlhdGUgc2lkZSBvZiB0aGUgZnJhZ21lbnTigJRpLmUuIGlmIHRoZSBmcmFnbWVudCBpcyBhblxuICAgIGVtcHR5IHBhcmFncmFwaCBub2RlLCBgb3BlblN0YXJ0YCBhbmQgYG9wZW5FbmRgIGNhbid0IGJlIGdyZWF0ZXJcbiAgICB0aGFuIDEuXG4gICAgXG4gICAgSXQgaXMgbm90IG5lY2Vzc2FyeSBmb3IgdGhlIGNvbnRlbnQgb2Ygb3BlbiBub2RlcyB0byBjb25mb3JtIHRvXG4gICAgdGhlIHNjaGVtYSdzIGNvbnRlbnQgY29uc3RyYWludHMsIHRob3VnaCBpdCBzaG91bGQgYmUgYSB2YWxpZFxuICAgIHN0YXJ0L2VuZC9taWRkbGUgZm9yIHN1Y2ggYSBub2RlLCBkZXBlbmRpbmcgb24gd2hpY2ggc2lkZXMgYXJlXG4gICAgb3Blbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSdzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjb250ZW50LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50LlxuICAgICovXG4gICAgb3BlblN0YXJ0LCBcbiAgICAvKipcbiAgICBUaGUgb3BlbiBkZXB0aCBhdCB0aGUgZW5kLlxuICAgICovXG4gICAgb3BlbkVuZCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICAgICAgdGhpcy5vcGVuRW5kID0gb3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgdGhpcyBzbGljZSB3b3VsZCBhZGQgd2hlbiBpbnNlcnRlZCBpbnRvIGEgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zaXplIC0gdGhpcy5vcGVuU3RhcnQgLSB0aGlzLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5zZXJ0QXQocG9zLCBmcmFnbWVudCkge1xuICAgICAgICBsZXQgY29udGVudCA9IGluc2VydEludG8odGhpcy5jb250ZW50LCBwb3MgKyB0aGlzLm9wZW5TdGFydCwgZnJhZ21lbnQpO1xuICAgICAgICByZXR1cm4gY29udGVudCAmJiBuZXcgU2xpY2UoY29udGVudCwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVtb3ZlQmV0d2Vlbihmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKHJlbW92ZVJhbmdlKHRoaXMuY29udGVudCwgZnJvbSArIHRoaXMub3BlblN0YXJ0LCB0byArIHRoaXMub3BlblN0YXJ0KSwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3RzIHdoZXRoZXIgdGhpcyBzbGljZSBpcyBlcXVhbCB0byBhbm90aGVyIHNsaWNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSAmJiB0aGlzLm9wZW5TdGFydCA9PSBvdGhlci5vcGVuU3RhcnQgJiYgdGhpcy5vcGVuRW5kID09IG90aGVyLm9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQgKyBcIihcIiArIHRoaXMub3BlblN0YXJ0ICsgXCIsXCIgKyB0aGlzLm9wZW5FbmQgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIHNsaWNlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGpzb24gPSB7IGNvbnRlbnQ6IHRoaXMuY29udGVudC50b0pTT04oKSB9O1xuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPiAwKVxuICAgICAgICAgICAganNvbi5vcGVuU3RhcnQgPSB0aGlzLm9wZW5TdGFydDtcbiAgICAgICAgaWYgKHRoaXMub3BlbkVuZCA+IDApXG4gICAgICAgICAgICBqc29uLm9wZW5FbmQgPSB0aGlzLm9wZW5FbmQ7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHNsaWNlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IGpzb24ub3BlblN0YXJ0IHx8IDAsIG9wZW5FbmQgPSBqc29uLm9wZW5FbmQgfHwgMDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcGVuU3RhcnQgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygb3BlbkVuZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTbGljZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNsaWNlIGZyb20gYSBmcmFnbWVudCBieSB0YWtpbmcgdGhlIG1heGltdW0gcG9zc2libGVcbiAgICBvcGVuIHZhbHVlIG9uIGJvdGggc2lkZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF4T3BlbihmcmFnbWVudCwgb3Blbklzb2xhdGluZyA9IHRydWUpIHtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICBmb3IgKGxldCBuID0gZnJhZ21lbnQuZmlyc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgZm9yIChsZXQgbiA9IGZyYWdtZW50Lmxhc3RDaGlsZDsgbiAmJiAhbi5pc0xlYWYgJiYgKG9wZW5Jc29sYXRpbmcgfHwgIW4udHlwZS5zcGVjLmlzb2xhdGluZyk7IG4gPSBuLmxhc3RDaGlsZClcbiAgICAgICAgICAgIG9wZW5FbmQrKztcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShmcmFnbWVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzbGljZS5cbiovXG5TbGljZS5lbXB0eSA9IG5ldyBTbGljZShGcmFnbWVudC5lbXB0eSwgMCwgMCk7XG5mdW5jdGlvbiByZW1vdmVSYW5nZShjb250ZW50LCBmcm9tLCB0bykge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGZyb20pLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgbGV0IHsgaW5kZXg6IGluZGV4VG8sIG9mZnNldDogb2Zmc2V0VG8gfSA9IGNvbnRlbnQuZmluZEluZGV4KHRvKTtcbiAgICBpZiAob2Zmc2V0ID09IGZyb20gfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgIGlmIChvZmZzZXRUbyAhPSB0byAmJiAhY29udGVudC5jaGlsZChpbmRleFRvKS5pc1RleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZnJvbSkuYXBwZW5kKGNvbnRlbnQuY3V0KHRvKSk7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPSBpbmRleFRvKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShyZW1vdmVSYW5nZShjaGlsZC5jb250ZW50LCBmcm9tIC0gb2Zmc2V0IC0gMSwgdG8gLSBvZmZzZXQgLSAxKSkpO1xufVxuZnVuY3Rpb24gaW5zZXJ0SW50byhjb250ZW50LCBkaXN0LCBpbnNlcnQsIHBhcmVudCkge1xuICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IGNvbnRlbnQuZmluZEluZGV4KGRpc3QpLCBjaGlsZCA9IGNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgaWYgKG9mZnNldCA9PSBkaXN0IHx8IGNoaWxkLmlzVGV4dCkge1xuICAgICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXgsIGluc2VydCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGRpc3QpLmFwcGVuZChpbnNlcnQpLmFwcGVuZChjb250ZW50LmN1dChkaXN0KSk7XG4gICAgfVxuICAgIGxldCBpbm5lciA9IGluc2VydEludG8oY2hpbGQuY29udGVudCwgZGlzdCAtIG9mZnNldCAtIDEsIGluc2VydCk7XG4gICAgcmV0dXJuIGlubmVyICYmIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiByZXBsYWNlKCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgaWYgKHNsaWNlLm9wZW5TdGFydCA+ICRmcm9tLmRlcHRoKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW5zZXJ0ZWQgY29udGVudCBkZWVwZXIgdGhhbiBpbnNlcnRpb24gcG9zaXRpb25cIik7XG4gICAgaWYgKCRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0ICE9ICR0by5kZXB0aCAtIHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbmNvbnNpc3RlbnQgb3BlbiBkZXB0aHNcIik7XG4gICAgcmV0dXJuIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgMCk7XG59XG5mdW5jdGlvbiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoKSB7XG4gICAgbGV0IGluZGV4ID0gJGZyb20uaW5kZXgoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgaWYgKGluZGV4ID09ICR0by5pbmRleChkZXB0aCkgJiYgZGVwdGggPCAkZnJvbS5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCkge1xuICAgICAgICBsZXQgaW5uZXIgPSByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoICsgMSk7XG4gICAgICAgIHJldHVybiBub2RlLmNvcHkobm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgaW5uZXIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLmRlcHRoID09IGRlcHRoICYmICR0by5kZXB0aCA9PSBkZXB0aCkgeyAvLyBTaW1wbGUsIGZsYXQgY2FzZVxuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ucGFyZW50LCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBjbG9zZShwYXJlbnQsIGNvbnRlbnQuY3V0KDAsICRmcm9tLnBhcmVudE9mZnNldCkuYXBwZW5kKHNsaWNlLmNvbnRlbnQpLmFwcGVuZChjb250ZW50LmN1dCgkdG8ucGFyZW50T2Zmc2V0KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGZyb20pO1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCBzdGFydCwgZW5kLCAkdG8sIGRlcHRoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tKb2luKG1haW4sIHN1Yikge1xuICAgIGlmICghc3ViLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobWFpbi50eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkNhbm5vdCBqb2luIFwiICsgc3ViLnR5cGUubmFtZSArIFwiIG9udG8gXCIgKyBtYWluLnR5cGUubmFtZSk7XG59XG5mdW5jdGlvbiBqb2luYWJsZSgkYmVmb3JlLCAkYWZ0ZXIsIGRlcHRoKSB7XG4gICAgbGV0IG5vZGUgPSAkYmVmb3JlLm5vZGUoZGVwdGgpO1xuICAgIGNoZWNrSm9pbihub2RlLCAkYWZ0ZXIubm9kZShkZXB0aCkpO1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gYWRkTm9kZShjaGlsZCwgdGFyZ2V0KSB7XG4gICAgbGV0IGxhc3QgPSB0YXJnZXQubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIGNoaWxkLmlzVGV4dCAmJiBjaGlsZC5zYW1lTWFya3VwKHRhcmdldFtsYXN0XSkpXG4gICAgICAgIHRhcmdldFtsYXN0XSA9IGNoaWxkLndpdGhUZXh0KHRhcmdldFtsYXN0XS50ZXh0ICsgY2hpbGQudGV4dCk7XG4gICAgZWxzZVxuICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCB0YXJnZXQpIHtcbiAgICBsZXQgbm9kZSA9ICgkZW5kIHx8ICRzdGFydCkubm9kZShkZXB0aCk7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCA9ICRlbmQgPyAkZW5kLmluZGV4KGRlcHRoKSA6IG5vZGUuY2hpbGRDb3VudDtcbiAgICBpZiAoJHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSAkc3RhcnQuaW5kZXgoZGVwdGgpO1xuICAgICAgICBpZiAoJHN0YXJ0LmRlcHRoID4gZGVwdGgpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgkc3RhcnQudGV4dE9mZnNldCkge1xuICAgICAgICAgICAgYWRkTm9kZSgkc3RhcnQubm9kZUFmdGVyLCB0YXJnZXQpO1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAgYWRkTm9kZShub2RlLmNoaWxkKGkpLCB0YXJnZXQpO1xuICAgIGlmICgkZW5kICYmICRlbmQuZGVwdGggPT0gZGVwdGggJiYgJGVuZC50ZXh0T2Zmc2V0KVxuICAgICAgICBhZGROb2RlKCRlbmQubm9kZUJlZm9yZSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGNsb3NlKG5vZGUsIGNvbnRlbnQpIHtcbiAgICBub2RlLnR5cGUuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgIHJldHVybiBub2RlLmNvcHkoY29udGVudCk7XG59XG5mdW5jdGlvbiByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSk7XG4gICAgbGV0IG9wZW5FbmQgPSAkdG8uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZW5kLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiAkc3RhcnQuaW5kZXgoZGVwdGgpID09ICRlbmQuaW5kZXgoZGVwdGgpKSB7XG4gICAgICAgIGNoZWNrSm9pbihvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wZW5TdGFydClcbiAgICAgICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICAgICAgYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgY29udGVudCk7XG4gICAgICAgIGlmIChvcGVuRW5kKVxuICAgICAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuRW5kLCByZXBsYWNlVHdvV2F5KCRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBjb250ZW50ID0gW107XG4gICAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgICBpZiAoJGZyb20uZGVwdGggPiBkZXB0aCkge1xuICAgICAgICBsZXQgdHlwZSA9IGpvaW5hYmxlKCRmcm9tLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgICAgIGFkZE5vZGUoY2xvc2UodHlwZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkYWxvbmcpIHtcbiAgICBsZXQgZXh0cmEgPSAkYWxvbmcuZGVwdGggLSBzbGljZS5vcGVuU3RhcnQsIHBhcmVudCA9ICRhbG9uZy5ub2RlKGV4dHJhKTtcbiAgICBsZXQgbm9kZSA9IHBhcmVudC5jb3B5KHNsaWNlLmNvbnRlbnQpO1xuICAgIGZvciAobGV0IGkgPSBleHRyYSAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBub2RlID0gJGFsb25nLm5vZGUoaSkuY29weShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4geyBzdGFydDogbm9kZS5yZXNvbHZlTm9DYWNoZShzbGljZS5vcGVuU3RhcnQgKyBleHRyYSksXG4gICAgICAgIGVuZDogbm9kZS5yZXNvbHZlTm9DYWNoZShub2RlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQgLSBleHRyYSkgfTtcbn1cblxuLyoqXG5Zb3UgY2FuIFtfcmVzb2x2ZV9dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlc29sdmUpIGEgcG9zaXRpb24gdG8gZ2V0IG1vcmVcbmluZm9ybWF0aW9uIGFib3V0IGl0LiBPYmplY3RzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IHN1Y2ggYVxucmVzb2x2ZWQgcG9zaXRpb24sIHByb3ZpZGluZyB2YXJpb3VzIHBpZWNlcyBvZiBjb250ZXh0XG5pbmZvcm1hdGlvbiwgYW5kIHNvbWUgaGVscGVyIG1ldGhvZHMuXG5cblRocm91Z2hvdXQgdGhpcyBpbnRlcmZhY2UsIG1ldGhvZHMgdGhhdCB0YWtlIGFuIG9wdGlvbmFsIGBkZXB0aGBcbnBhcmFtZXRlciB3aWxsIGludGVycHJldCB1bmRlZmluZWQgYXMgYHRoaXMuZGVwdGhgIGFuZCBuZWdhdGl2ZVxubnVtYmVycyBhcyBgdGhpcy5kZXB0aCArIHZhbHVlYC5cbiovXG5jbGFzcyBSZXNvbHZlZFBvcyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gdGhhdCB3YXMgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGF0aCwgXG4gICAgLyoqXG4gICAgVGhlIG9mZnNldCB0aGlzIHBvc2l0aW9uIGhhcyBpbnRvIGl0cyBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHBhcmVudE9mZnNldCkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5wYXJlbnRPZmZzZXQgPSBwYXJlbnRPZmZzZXQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBwYXRoLmxlbmd0aCAvIDMgLSAxO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVEZXB0aCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGg7XG4gICAgICAgIGlmICh2YWwgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGggKyB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSBwb3NpdGlvbiBwb2ludHMgaW50by4gTm90ZSB0aGF0IGV2ZW4gaWZcbiAgICBhIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCB0aGF0IG5vZGUgaXMgbm90IGNvbnNpZGVyZWRcbiAgICB0aGUgcGFyZW504oCUdGV4dCBub2RlcyBhcmUg4oCYZmxhdOKAmSBpbiB0aGlzIG1vZGVsLCBhbmQgaGF2ZSBubyBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMubm9kZSh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSByb290IG5vZGUgaW4gd2hpY2ggdGhlIHBvc2l0aW9uIHdhcyByZXNvbHZlZC5cbiAgICAqL1xuICAgIGdldCBkb2MoKSB7IHJldHVybiB0aGlzLm5vZGUoMCk7IH1cbiAgICAvKipcbiAgICBUaGUgYW5jZXN0b3Igbm9kZSBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIGBwLm5vZGUocC5kZXB0aClgIGlzIHRoZVxuICAgIHNhbWUgYXMgYHAucGFyZW50YC5cbiAgICAqL1xuICAgIG5vZGUoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzXTsgfVxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIElmIHRoaXMgcG9pbnRzXG4gICAgYXQgdGhlIDNyZCBub2RlIGluIHRoZSAybmQgcGFyYWdyYXBoIG9uIHRoZSB0b3AgbGV2ZWwsIGZvclxuICAgIGV4YW1wbGUsIGBwLmluZGV4KDApYCBpcyAxIGFuZCBgcC5pbmRleCgxKWAgaXMgMi5cbiAgICAqL1xuICAgIGluZGV4KGRlcHRoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogMyArIDFdOyB9XG4gICAgLyoqXG4gICAgVGhlIGluZGV4IHBvaW50aW5nIGFmdGVyIHRoaXMgcG9zaXRpb24gaW50byB0aGUgYW5jZXN0b3IgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwuXG4gICAgKi9cbiAgICBpbmRleEFmdGVyKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChkZXB0aCkgKyAoZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAhdGhpcy50ZXh0T2Zmc2V0ID8gMCA6IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4gICAgbGV2ZWwuXG4gICAgKi9cbiAgICBzdGFydChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW5cbiAgICBsZXZlbC5cbiAgICAqL1xuICAgIGVuZChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoZGVwdGgpICsgdGhpcy5ub2RlKGRlcHRoKS5jb250ZW50LnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGJlZm9yZSB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbCwgb3IsIHdoZW4gYGRlcHRoYCBpcyBgdGhpcy5kZXB0aCArIDFgLCB0aGUgb3JpZ2luYWxcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGJlZm9yZShkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYmVmb3JlIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLCBvciB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAuXG4gICAgKi9cbiAgICBhZnRlcihkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYWZ0ZXIgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIHRoaXMucGF0aFtkZXB0aCAqIDNdLm5vZGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHRoaXMgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoaXMgcmV0dXJucyB0aGVcbiAgICBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb3NpdGlvbiBhbmQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0IG5vZGUuXG4gICAgV2lsbCBiZSB6ZXJvIGZvciBwb3NpdGlvbnMgdGhhdCBwb2ludCBiZXR3ZWVuIG5vZGVzLlxuICAgICovXG4gICAgZ2V0IHRleHRPZmZzZXQoKSB7IHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZSBwb3NpdGlvblxuICAgIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZSBhZnRlciB0aGVcbiAgICBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGdldCBub2RlQWZ0ZXIoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCwgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0sIGNoaWxkID0gcGFyZW50LmNoaWxkKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGRPZmYgPyBwYXJlbnQuY2hpbGQoaW5kZXgpLmN1dChkT2ZmKSA6IGNoaWxkO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYmVmb3JlIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGVcbiAgICBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgb25seSB0aGUgcGFydCBvZiB0aGF0IG5vZGVcbiAgICBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZ2V0IG5vZGVCZWZvcmUoKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICAgIGxldCBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZE9mZilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCkuY3V0KDAsIGRPZmYpO1xuICAgICAgICByZXR1cm4gaW5kZXggPT0gMCA/IG51bGwgOiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgcGFyZW50IG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gZGVwdGggKHdoaWNoIGRlZmF1bHRzIHRvIGB0aGlzLmRlcHRoYCkuXG4gICAgKi9cbiAgICBwb3NBdEluZGV4KGluZGV4LCBkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnBhdGhbZGVwdGggKiAzXSwgcG9zID0gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICBwb3MgKz0gbm9kZS5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhdCB0aGlzIHBvc2l0aW9uLCBmYWN0b3JpbmcgaW4gdGhlIHN1cnJvdW5kaW5nXG4gICAgbWFya3MnIFtgaW5jbHVzaXZlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmluY2x1c2l2ZSkgcHJvcGVydHkuIElmIHRoZVxuICAgIHBvc2l0aW9uIGlzIGF0IHRoZSBzdGFydCBvZiBhIG5vbi1lbXB0eSBub2RlLCB0aGUgbWFya3Mgb2YgdGhlXG4gICAgbm9kZSBhZnRlciBpdCAoaWYgYW55KSBhcmUgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBtYXJrcygpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgLy8gSW4gYW4gZW1wdHkgcGFyZW50LCByZXR1cm4gdGhlIGVtcHR5IGFycmF5XG4gICAgICAgIGlmIChwYXJlbnQuY29udGVudC5zaXplID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICAvLyBXaGVuIGluc2lkZSBhIHRleHQgbm9kZSwganVzdCByZXR1cm4gdGhlIHRleHQgbm9kZSdzIG1hcmtzXG4gICAgICAgIGlmICh0aGlzLnRleHRPZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkKGluZGV4KS5tYXJrcztcbiAgICAgICAgbGV0IG1haW4gPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCAtIDEpLCBvdGhlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgLy8gSWYgdGhlIGBhZnRlcmAgZmxhZyBpcyB0cnVlIG9mIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlLCBtYWtlXG4gICAgICAgIC8vIHRoZSBub2RlIGFmdGVyIHRoaXMgcG9zaXRpb24gdGhlIG1haW4gcmVmZXJlbmNlLlxuICAgICAgICBpZiAoIW1haW4pIHtcbiAgICAgICAgICAgIGxldCB0bXAgPSBtYWluO1xuICAgICAgICAgICAgbWFpbiA9IG90aGVyO1xuICAgICAgICAgICAgb3RoZXIgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGFsbCBtYXJrcyBpbiB0aGUgbWFpbiBub2RlLCBleGNlcHQgdGhvc2UgdGhhdCBoYXZlXG4gICAgICAgIC8vIGBpbmNsdXNpdmVgIHNldCB0byBmYWxzZSBhbmQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBvdGhlciBub2RlLlxuICAgICAgICBsZXQgbWFya3MgPSBtYWluLm1hcmtzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghb3RoZXIgfHwgIW1hcmtzW2ldLmlzSW5TZXQob3RoZXIubWFya3MpKSlcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgaWYgYW55LCBleGNlcHQgdGhvc2VcbiAgICB0aGF0IGFyZSBub24taW5jbHVzaXZlIGFuZCBub3QgcHJlc2VudCBhdCBwb3NpdGlvbiBgJGVuZGAuIFRoaXNcbiAgICBpcyBtb3N0bHkgdXNlZnVsIGZvciBnZXR0aW5nIHRoZSBzZXQgb2YgbWFya3MgdG8gcHJlc2VydmUgYWZ0ZXIgYVxuICAgIGRlbGV0aW9uLiBXaWxsIHJldHVybiBgbnVsbGAgaWYgdGhpcyBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mXG4gICAgaXRzIHBhcmVudCBub2RlIG9yIGl0cyBwYXJlbnQgbm9kZSBpc24ndCBhIHRleHRibG9jayAoaW4gd2hpY2hcbiAgICBjYXNlIG5vIG1hcmtzIHNob3VsZCBiZSBwcmVzZXJ2ZWQpLlxuICAgICovXG4gICAgbWFya3NBY3Jvc3MoJGVuZCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLnBhcmVudC5tYXliZUNoaWxkKHRoaXMuaW5kZXgoKSk7XG4gICAgICAgIGlmICghYWZ0ZXIgfHwgIWFmdGVyLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBtYXJrcyA9IGFmdGVyLm1hcmtzLCBuZXh0ID0gJGVuZC5wYXJlbnQubWF5YmVDaGlsZCgkZW5kLmluZGV4KCkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghbmV4dCB8fCAhbWFya3NbaV0uaXNJblNldChuZXh0Lm1hcmtzKSkpXG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCB1cCB0byB3aGljaCB0aGlzIHBvc2l0aW9uIGFuZCB0aGUgZ2l2ZW4gKG5vbi1yZXNvbHZlZClcbiAgICBwb3NpdGlvbiBzaGFyZSB0aGUgc2FtZSBwYXJlbnQgbm9kZXMuXG4gICAgKi9cbiAgICBzaGFyZWREZXB0aChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoLS0pXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydChkZXB0aCkgPD0gcG9zICYmIHRoaXMuZW5kKGRlcHRoKSA+PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJhbmdlIGJhc2VkIG9uIHRoZSBwbGFjZSB3aGVyZSB0aGlzIHBvc2l0aW9uIGFuZCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbiBkaXZlcmdlIGFyb3VuZCBibG9jayBjb250ZW50LiBJZiBib3RoIHBvaW50IGludG9cbiAgICB0aGUgc2FtZSB0ZXh0YmxvY2ssIGZvciBleGFtcGxlLCBhIHJhbmdlIGFyb3VuZCB0aGF0IHRleHRibG9ja1xuICAgIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZXkgcG9pbnQgaW50byBkaWZmZXJlbnQgYmxvY2tzLCB0aGUgcmFuZ2VcbiAgICBhcm91bmQgdGhvc2UgYmxvY2tzIGluIHRoZWlyIHNoYXJlZCBhbmNlc3RvciBpcyByZXR1cm5lZC4gWW91IGNhblxuICAgIHBhc3MgaW4gYW4gb3B0aW9uYWwgcHJlZGljYXRlIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHBhcmVudFxuICAgIG5vZGUgdG8gc2VlIGlmIGEgcmFuZ2UgaW50byB0aGF0IHBhcmVudCBpcyBhY2NlcHRhYmxlLlxuICAgICovXG4gICAgYmxvY2tSYW5nZShvdGhlciA9IHRoaXMsIHByZWQpIHtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA8IHRoaXMucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyLmJsb2NrUmFuZ2UodGhpcyk7XG4gICAgICAgIGZvciAobGV0IGQgPSB0aGlzLmRlcHRoIC0gKHRoaXMucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdGhpcy5wb3MgPT0gb3RoZXIucG9zID8gMSA6IDApOyBkID49IDA7IGQtLSlcbiAgICAgICAgICAgIGlmIChvdGhlci5wb3MgPD0gdGhpcy5lbmQoZCkgJiYgKCFwcmVkIHx8IHByZWQodGhpcy5ub2RlKGQpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlUmFuZ2UodGhpcywgb3RoZXIsIGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gc2hhcmVzIHRoZSBzYW1lIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgc2FtZVBhcmVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhcmVudE9mZnNldCA9PSBvdGhlci5wb3MgLSBvdGhlci5wYXJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ3JlYXRlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBtYXgob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnBvcyA+IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbWluKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5wb3MgPCB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMuZGVwdGg7IGkrKylcbiAgICAgICAgICAgIHN0ciArPSAoc3RyID8gXCIvXCIgOiBcIlwiKSArIHRoaXMubm9kZShpKS50eXBlLm5hbWUgKyBcIl9cIiArIHRoaXMuaW5kZXgoaSAtIDEpO1xuICAgICAgICByZXR1cm4gc3RyICsgXCI6XCIgKyB0aGlzLnBhcmVudE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZShkb2MsIHBvcykge1xuICAgICAgICBpZiAoIShwb3MgPj0gMCAmJiBwb3MgPD0gZG9jLmNvbnRlbnQuc2l6ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBvc2l0aW9uIFwiICsgcG9zICsgXCIgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICBsZXQgcGF0aCA9IFtdO1xuICAgICAgICBsZXQgc3RhcnQgPSAwLCBwYXJlbnRPZmZzZXQgPSBwb3M7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBkb2M7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IHJlbSA9IHBhcmVudE9mZnNldCAtIG9mZnNldDtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlLCBpbmRleCwgc3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFyZW0pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSByZW0gLSAxO1xuICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkUG9zKHBvcywgcGF0aCwgcGFyZW50T2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUNhY2hlZChkb2MsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVDYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNhY2hlZCA9IHJlc29sdmVDYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQucG9zID09IHBvcyAmJiBjYWNoZWQuZG9jID09IGRvYylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSByZXNvbHZlQ2FjaGVbcmVzb2x2ZUNhY2hlUG9zXSA9IFJlc29sdmVkUG9zLnJlc29sdmUoZG9jLCBwb3MpO1xuICAgICAgICByZXNvbHZlQ2FjaGVQb3MgPSAocmVzb2x2ZUNhY2hlUG9zICsgMSkgJSByZXNvbHZlQ2FjaGVTaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmxldCByZXNvbHZlQ2FjaGUgPSBbXSwgcmVzb2x2ZUNhY2hlUG9zID0gMCwgcmVzb2x2ZUNhY2hlU2l6ZSA9IDEyO1xuLyoqXG5SZXByZXNlbnRzIGEgZmxhdCByYW5nZSBvZiBjb250ZW50LCBpLmUuIG9uZSB0aGF0IHN0YXJ0cyBhbmRcbmVuZHMgaW4gdGhlIHNhbWUgbm9kZS5cbiovXG5jbGFzcyBOb2RlUmFuZ2Uge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5vZGUgcmFuZ2UuIGAkZnJvbWAgYW5kIGAkdG9gIHNob3VsZCBwb2ludCBpbnRvIHRoZVxuICAgIHNhbWUgbm9kZSB1bnRpbCBhdCBsZWFzdCB0aGUgZ2l2ZW4gYGRlcHRoYCwgc2luY2UgYSBub2RlIHJhbmdlXG4gICAgZGVub3RlcyBhbiBhZGphY2VudCBzZXQgb2Ygbm9kZXMgaW4gYSBzaW5nbGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBBIHJlc29sdmVkIHBvc2l0aW9uIGFsb25nIHRoZSBzdGFydCBvZiB0aGUgY29udGVudC4gTWF5IGhhdmUgYVxuICAgIGBkZXB0aGAgZ3JlYXRlciB0aGFuIHRoaXMgb2JqZWN0J3MgYGRlcHRoYCBwcm9wZXJ0eSwgc2luY2VcbiAgICB0aGVzZSBhcmUgdGhlIHBvc2l0aW9ucyB0aGF0IHdlcmUgdXNlZCB0byBjb21wdXRlIHRoZSByYW5nZSxcbiAgICBub3QgcmUtcmVzb2x2ZWQgcG9zaXRpb25zIGRpcmVjdGx5IGF0IGl0cyBib3VuZGFyaWVzLlxuICAgICovXG4gICAgJGZyb20sIFxuICAgIC8qKlxuICAgIEEgcG9zaXRpb24gYWxvbmcgdGhlIGVuZCBvZiB0aGUgY29udGVudC4gU2VlXG4gICAgY2F2ZWF0IGZvciBbYCRmcm9tYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZS4kZnJvbSkuXG4gICAgKi9cbiAgICAkdG8sIFxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCBvZiB0aGUgbm9kZSB0aGF0IHRoaXMgcmFuZ2UgcG9pbnRzIGludG8uXG4gICAgKi9cbiAgICBkZXB0aCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5iZWZvcmUodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuJHRvLmFmdGVyKHRoaXMuZGVwdGggKyAxKTsgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLm5vZGUodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBzdGFydEluZGV4KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5pbmRleCh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBlbmRJbmRleCgpIHsgcmV0dXJuIHRoaXMuJHRvLmluZGV4QWZ0ZXIodGhpcy5kZXB0aCk7IH1cbn1cblxuY29uc3QgZW1wdHlBdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcblRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIHRyZWUgdGhhdCBtYWtlcyB1cCBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudC4gU28gYSBkb2N1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBgTm9kZWAsIHdpdGhcbmNoaWxkcmVuIHRoYXQgYXJlIGFsc28gaW5zdGFuY2VzIG9mIGBOb2RlYC5cblxuTm9kZXMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLiBJbnN0ZWFkIG9mIGNoYW5naW5nIHRoZW0sIHlvdVxuY3JlYXRlIG5ldyBvbmVzIHdpdGggdGhlIGNvbnRlbnQgeW91IHdhbnQuIE9sZCBvbmVzIGtlZXAgcG9pbnRpbmdcbmF0IHRoZSBvbGQgZG9jdW1lbnQgc2hhcGUuIFRoaXMgaXMgbWFkZSBjaGVhcGVyIGJ5IHNoYXJpbmdcbnN0cnVjdHVyZSBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ldyBkYXRhIGFzIG11Y2ggYXMgcG9zc2libGUsIHdoaWNoIGFcbnRyZWUgc2hhcGUgbGlrZSB0aGlzICh3aXRob3V0IGJhY2sgcG9pbnRlcnMpIG1ha2VzIGVhc3kuXG5cbioqRG8gbm90KiogZGlyZWN0bHkgbXV0YXRlIHRoZSBwcm9wZXJ0aWVzIG9mIGEgYE5vZGVgIG9iamVjdC4gU2VlXG5bdGhlIGd1aWRlXSgvZG9jcy9ndWlkZS8jZG9jKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiovXG5jbGFzcyBOb2RlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGlzLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgQW4gb2JqZWN0IG1hcHBpbmcgYXR0cmlidXRlIG5hbWVzIHRvIHZhbHVlcy4gVGhlIGtpbmQgb2ZcbiAgICBhdHRyaWJ1dGVzIGFsbG93ZWQgYW5kIHJlcXVpcmVkIGFyZVxuICAgIFtkZXRlcm1pbmVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXR0cnMpIGJ5IHRoZSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBhdHRycywgXG4gICAgLy8gQSBmcmFnbWVudCBob2xkaW5nIHRoZSBub2RlJ3MgY2hpbGRyZW4uXG4gICAgY29udGVudCwgXG4gICAgLyoqXG4gICAgVGhlIG1hcmtzICh0aGluZ3MgbGlrZSB3aGV0aGVyIGl0IGlzIGVtcGhhc2l6ZWQgb3IgcGFydCBvZiBhXG4gICAgbGluaykgYXBwbGllZCB0byB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBtYXJrcyA9IE1hcmsubm9uZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudCB8fCBGcmFnbWVudC5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgb2YgdGhpcyBub2RlLCBhcyBkZWZpbmVkIGJ5IHRoZSBpbnRlZ2VyLWJhc2VkIFtpbmRleGluZ1xuICAgIHNjaGVtZV0oL2RvY3MvZ3VpZGUvI2RvYy5pbmRleGluZykuIEZvciB0ZXh0IG5vZGVzLCB0aGlzIGlzIHRoZVxuICAgIGFtb3VudCBvZiBjaGFyYWN0ZXJzLiBGb3Igb3RoZXIgbGVhZiBub2RlcywgaXQgaXMgb25lLiBGb3JcbiAgICBub24tbGVhZiBub2RlcywgaXQgaXMgdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcGx1cyB0d28gKHRoZVxuICAgIHN0YXJ0IGFuZCBlbmQgdG9rZW4pLlxuICAgICovXG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgPyAxIDogMiArIHRoaXMuY29udGVudC5zaXplOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IHRoZSBub2RlIGhhcy5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkQ291bnQ7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LiBSYWlzZXMgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7IHRoaXMuY29udGVudC5mb3JFYWNoKGYpOyB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIHJlY3Vyc2l2ZWx5IGJldHdlZW5cbiAgICB0aGUgZ2l2ZW4gdHdvIHBvc2l0aW9ucyB0aGF0IGFyZSByZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzXG4gICAgbm9kZSdzIGNvbnRlbnQuIFRoZSBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGggdGhlIG5vZGUsIGl0c1xuICAgIHBhcmVudC1yZWxhdGl2ZSBwb3NpdGlvbiwgaXRzIHBhcmVudCBub2RlLCBhbmQgaXRzIGNoaWxkIGluZGV4LlxuICAgIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgZmFsc2UgZm9yIGEgZ2l2ZW4gbm9kZSwgdGhhdCBub2RlJ3NcbiAgICBjaGlsZHJlbiB3aWxsIG5vdCBiZSByZWN1cnNlZCBvdmVyLiBUaGUgbGFzdCBwYXJhbWV0ZXIgY2FuIGJlXG4gICAgdXNlZCB0byBzcGVjaWZ5IGEgc3RhcnRpbmcgcG9zaXRpb24gdG8gY291bnQgZnJvbS5cbiAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgc3RhcnRQb3MgPSAwKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gRG9lc24ndFxuICAgIGRlc2NlbmQgaW50byBhIG5vZGUgd2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICovXG4gICAgZGVzY2VuZGFudHMoZikge1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbmNhdGVuYXRlcyBhbGwgdGhlIHRleHQgbm9kZXMgZm91bmQgaW4gdGhpcyBmcmFnbWVudCBhbmQgaXRzXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc0xlYWYgJiYgdGhpcy50eXBlLnNwZWMubGVhZlRleHQpXG4gICAgICAgICAgICA/IHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KHRoaXMpXG4gICAgICAgICAgICA6IHRoaXMudGV4dEJldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYWxsIHRleHQgYmV0d2VlbiBwb3NpdGlvbnMgYGZyb21gIGFuZCBgdG9gLiBXaGVuXG4gICAgYGJsb2NrU2VwYXJhdG9yYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBpbnNlcnRlZCB0byBzZXBhcmF0ZSB0ZXh0XG4gICAgZnJvbSBkaWZmZXJlbnQgYmxvY2sgbm9kZXMuIElmIGBsZWFmVGV4dGAgaXMgZ2l2ZW4sIGl0J2xsIGJlXG4gICAgaW5zZXJ0ZWQgZm9yIGV2ZXJ5IG5vbi10ZXh0IGxlYWYgbm9kZSBlbmNvdW50ZXJlZCwgb3RoZXJ3aXNlXG4gICAgW2BsZWFmVGV4dGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlY15sZWFmVGV4dCkgd2lsbCBiZSB1c2VkLlxuICAgICovXG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5maXJzdENoaWxkOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxhc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0d28gbm9kZXMgcmVwcmVzZW50IHRoZSBzYW1lIHBpZWNlIG9mIGRvY3VtZW50LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgKHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgbWFya3VwICh0eXBlLCBhdHRyaWJ1dGVzLCBhbmQgbWFya3MpIG9mIHRoaXMgbm9kZSB0b1xuICAgIHRob3NlIG9mIGFub3RoZXIuIFJldHVybnMgYHRydWVgIGlmIGJvdGggaGF2ZSB0aGUgc2FtZSBtYXJrdXAuXG4gICAgKi9cbiAgICBzYW1lTWFya3VwKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcmt1cChvdGhlci50eXBlLCBvdGhlci5hdHRycywgb3RoZXIubWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSdzIG1hcmt1cCBjb3JyZXNwb25kIHRvIHRoZSBnaXZlbiB0eXBlLFxuICAgIGF0dHJpYnV0ZXMsIGFuZCBtYXJrcy5cbiAgICAqL1xuICAgIGhhc01hcmt1cCh0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlICYmXG4gICAgICAgICAgICBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBhdHRycyB8fCB0eXBlLmRlZmF1bHRBdHRycyB8fCBlbXB0eUF0dHJzKSAmJlxuICAgICAgICAgICAgTWFyay5zYW1lU2V0KHRoaXMubWFya3MsIG1hcmtzIHx8IE1hcmsubm9uZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBub2RlIHdpdGggdGhlIHNhbWUgbWFya3VwIGFzIHRoaXMgbm9kZSwgY29udGFpbmluZ1xuICAgIHRoZSBnaXZlbiBjb250ZW50IChvciBlbXB0eSwgaWYgbm8gY29udGVudCBpcyBnaXZlbikuXG4gICAgKi9cbiAgICBjb3B5KGNvbnRlbnQgPSBudWxsKSB7XG4gICAgICAgIGlmIChjb250ZW50ID09IHRoaXMuY29udGVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUsIHdpdGggdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBpbnN0ZWFkXG4gICAgb2YgdGhlIG5vZGUncyBvd24gbWFya3MuXG4gICAgKi9cbiAgICBtYXJrKG1hcmtzKSB7XG4gICAgICAgIHJldHVybiBtYXJrcyA9PSB0aGlzLm1hcmtzID8gdGhpcyA6IG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy5jb250ZW50LCBtYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlIHdpdGggb25seSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9ucy4gSWYgYHRvYCBpcyBub3QgZ2l2ZW4sIGl0IGRlZmF1bHRzIHRvIHRoZSBlbmQgb2ZcbiAgICB0aGUgbm9kZS5cbiAgICAqL1xuICAgIGN1dChmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmNvbnRlbnQuY3V0KGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEN1dCBvdXQgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucywgYW5kXG4gICAgcmV0dXJuIGl0IGFzIGEgYFNsaWNlYCBvYmplY3QuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplLCBpbmNsdWRlUGFyZW50cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChmcm9tID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgJGZyb20gPSB0aGlzLnJlc29sdmUoZnJvbSksICR0byA9IHRoaXMucmVzb2x2ZSh0byk7XG4gICAgICAgIGxldCBkZXB0aCA9IGluY2x1ZGVQYXJlbnRzID8gMCA6ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uc3RhcnQoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBjb250ZW50ID0gbm9kZS5jb250ZW50LmN1dCgkZnJvbS5wb3MgLSBzdGFydCwgJHRvLnBvcyAtIHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCAkZnJvbS5kZXB0aCAtIGRlcHRoLCAkdG8uZGVwdGggLSBkZXB0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucyB3aXRoXG4gICAgdGhlIGdpdmVuIHNsaWNlLiBUaGUgc2xpY2UgbXVzdCAnZml0JywgbWVhbmluZyBpdHMgb3BlbiBzaWRlc1xuICAgIG11c3QgYmUgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzdXJyb3VuZGluZyBjb250ZW50LCBhbmQgaXRzXG4gICAgY29udGVudCBub2RlcyBtdXN0IGJlIHZhbGlkIGNoaWxkcmVuIGZvciB0aGUgbm9kZSB0aGV5IGFyZSBwbGFjZWRcbiAgICBpbnRvLiBJZiBhbnkgb2YgdGhpcyBpcyB2aW9sYXRlZCwgYW4gZXJyb3Igb2YgdHlwZVxuICAgIFtgUmVwbGFjZUVycm9yYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlcGxhY2VFcnJvcikgaXMgdGhyb3duLlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2UodGhpcy5yZXNvbHZlKGZyb20pLCB0aGlzLnJlc29sdmUodG8pLCBzbGljZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gcG9zIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcG9zIC09IG9mZnNldCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBhZnRlciB0aGUgZ2l2ZW4gb2Zmc2V0LCBpZiBhbnksXG4gICAgYW5kIHJldHVybiBpdCBhbG9uZyB3aXRoIGl0cyBpbmRleCBhbmQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoaXNcbiAgICBub2RlLlxuICAgICovXG4gICAgY2hpbGRBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQubWF5YmVDaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBiZWZvcmUgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQmVmb3JlKHBvcykge1xuICAgICAgICBpZiAocG9zID09IDApXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBudWxsLCBpbmRleDogMCwgb2Zmc2V0OiAwIH07XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IHBvcylcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudC5jaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgaW5kZXg6IGluZGV4IC0gMSwgb2Zmc2V0OiBvZmZzZXQgLSBub2RlLm5vZGVTaXplIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc29sdmUgdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcmV0dXJuaW5nIGFuXG4gICAgW29iamVjdF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlc29sdmVkUG9zKSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGl0cyBjb250ZXh0LlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MpIHsgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmVDYWNoZWQodGhpcywgcG9zKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZU5vQ2FjaGUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgYSBnaXZlbiBtYXJrIG9yIG1hcmsgdHlwZSBvY2N1cnMgaW4gdGhpcyBkb2N1bWVudFxuICAgIGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICByYW5nZUhhc01hcmsoZnJvbSwgdG8sIHR5cGUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIGJsb2NrIChub24taW5saW5lIG5vZGUpXG4gICAgKi9cbiAgICBnZXQgaXNCbG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0Jsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0YmxvY2sgbm9kZSwgYSBibG9jayBub2RlIHdpdGggaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc1RleHRibG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgYWxsb3dzIGlubGluZSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7IHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGlubGluZSBub2RlIChhIHRleHQgbm9kZSBvciBhIG5vZGUgdGhhdCBjYW5cbiAgICBhcHBlYXIgYW1vbmcgdGV4dCkuXG4gICAgKi9cbiAgICBnZXQgaXNJbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNJbmxpbmU7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIHRleHQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc1RleHQoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBsZWFmIG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNMZWFmKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzTGVhZjsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlIGRpcmVjdGx5XG4gICAgZWRpdGFibGUgY29udGVudC4gVGhpcyBpcyB1c3VhbGx5IHRoZSBzYW1lIGFzIGBpc0xlYWZgLCBidXQgY2FuXG4gICAgYmUgY29uZmlndXJlZCB3aXRoIHRoZSBbYGF0b21gIHByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXRvbSlcbiAgICBvbiBhIG5vZGUncyBzcGVjICh0eXBpY2FsbHkgdXNlZCB3aGVuIHRoZSBub2RlIGlzIGRpc3BsYXllZCBhc1xuICAgIGFuIHVuZWRpdGFibGUgW25vZGUgdmlld10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuTm9kZVZpZXcpKS5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLnR5cGUuaXNBdG9tOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSBmb3IgZGVidWdnaW5nXG4gICAgcHVycG9zZXMuXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLnR5cGUubmFtZTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgbmFtZSArPSBcIihcIiArIHRoaXMuY29udGVudC50b1N0cmluZ0lubmVyKCkgKyBcIilcIjtcbiAgICAgICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZW50IG1hdGNoIGluIHRoaXMgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgKi9cbiAgICBjb250ZW50TWF0Y2hBdChpbmRleCkge1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCAwLCBpbmRleCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgY29udGVudE1hdGNoQXQgb24gYSBub2RlIHdpdGggaW52YWxpZCBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIChieVxuICAgIGNoaWxkIGluZGV4KSB3aXRoIHRoZSBnaXZlbiByZXBsYWNlbWVudCBmcmFnbWVudCAod2hpY2ggZGVmYXVsdHNcbiAgICB0byB0aGUgZW1wdHkgZnJhZ21lbnQpIHdvdWxkIGxlYXZlIHRoZSBub2RlJ3MgY29udGVudCB2YWxpZC4gWW91XG4gICAgY2FuIG9wdGlvbmFsbHkgcGFzcyBgc3RhcnRgIGFuZCBgZW5kYCBpbmRpY2VzIGludG8gdGhlXG4gICAgcmVwbGFjZW1lbnQgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlKGZyb20sIHRvLCByZXBsYWNlbWVudCA9IEZyYWdtZW50LmVtcHR5LCBzdGFydCA9IDAsIGVuZCA9IHJlcGxhY2VtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgbGV0IG9uZSA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hGcmFnbWVudChyZXBsYWNlbWVudCwgc3RhcnQsIGVuZCk7XG4gICAgICAgIGxldCB0d28gPSBvbmUgJiYgb25lLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIGlmICghdHdvIHx8ICF0d28udmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuYWxsb3dzTWFya3MocmVwbGFjZW1lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGBmcm9tYCB0byBgdG9gIChieSBpbmRleCkgd2l0aFxuICAgIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlV2l0aChmcm9tLCB0bywgdHlwZSwgbWFya3MpIHtcbiAgICAgICAgaWYgKG1hcmtzICYmICF0aGlzLnR5cGUuYWxsb3dzTWFya3MobWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICYmIHN0YXJ0Lm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIHJldHVybiBlbmQgPyBlbmQudmFsaWRFbmQgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBub2RlJ3MgY29udGVudCBjb3VsZCBiZSBhcHBlbmRlZCB0byB0aGlzXG4gICAgbm9kZS4gSWYgdGhhdCBub2RlIGlzIGVtcHR5LCB0aGlzIHdpbGwgb25seSByZXR1cm4gdHJ1ZSBpZiB0aGVyZVxuICAgIGlzIGF0IGxlYXN0IG9uZSBub2RlIHR5cGUgdGhhdCBjYW4gYXBwZWFyIGluIGJvdGggbm9kZXMgKHRvIGF2b2lkXG4gICAgbWVyZ2luZyBjb21wbGV0ZWx5IGluY29tcGF0aWJsZSBub2RlcykuXG4gICAgKi9cbiAgICBjYW5BcHBlbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhblJlcGxhY2UodGhpcy5jaGlsZENvdW50LCB0aGlzLmNoaWxkQ291bnQsIG90aGVyLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmNvbXBhdGlibGVDb250ZW50KG90aGVyLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzIGNvbmZvcm0gdG8gdGhlXG4gICAgc2NoZW1hLCBhbmQgcmFpc2UgZXJyb3Igd2hlbiB0aGV5IGRvIG5vdC5cbiAgICAqL1xuICAgIGNoZWNrKCkge1xuICAgICAgICB0aGlzLnR5cGUuY2hlY2tDb250ZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgIGxldCBjb3B5ID0gTWFyay5ub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjb3B5ID0gdGhpcy5tYXJrc1tpXS5hZGRUb1NldChjb3B5KTtcbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQoY29weSwgdGhpcy5tYXJrcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjb2xsZWN0aW9uIG9mIG1hcmtzIGZvciBub2RlICR7dGhpcy50eXBlLm5hbWV9OiAke3RoaXMubWFya3MubWFwKG0gPT4gbS50eXBlLm5hbWUpfWApO1xuICAgICAgICB0aGlzLmNvbnRlbnQuZm9yRWFjaChub2RlID0+IG5vZGUuY2hlY2soKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBvYmogPSB7IHR5cGU6IHRoaXMudHlwZS5uYW1lIH07XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG9iai5jb250ZW50ID0gdGhpcy5jb250ZW50LnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5tYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICBvYmoubWFya3MgPSB0aGlzLm1hcmtzLm1hcChuID0+IG4udG9KU09OKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgbWFya3MgPSBudWxsO1xuICAgICAgICBpZiAoanNvbi5tYXJrcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24ubWFya3MpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtYXJrIGRhdGEgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgICAgICBtYXJrcyA9IGpzb24ubWFya3MubWFwKHNjaGVtYS5tYXJrRnJvbUpTT04pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbi50ZXh0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRleHQgbm9kZSBpbiBKU09OXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS50ZXh0KGpzb24udGV4dCwgbWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gc2NoZW1hLm5vZGVUeXBlKGpzb24udHlwZSkuY3JlYXRlKGpzb24uYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG59XG5Ob2RlLnByb3RvdHlwZS50ZXh0ID0gdW5kZWZpbmVkO1xuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBzdXBlcih0eXBlLCBhdHRycywgbnVsbCwgbWFya3MpO1xuICAgICAgICBpZiAoIWNvbnRlbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICB0aGlzLnRleHQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBKU09OLnN0cmluZ2lmeSh0aGlzLnRleHQpKTtcbiAgICB9XG4gICAgZ2V0IHRleHRDb250ZW50KCkgeyByZXR1cm4gdGhpcy50ZXh0OyB9XG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMudGV4dC5zbGljZShmcm9tLCB0byk7IH1cbiAgICBnZXQgbm9kZVNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbWFyayhtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0aGlzLnRleHQsIG1hcmtzKTtcbiAgICB9XG4gICAgd2l0aFRleHQodGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PSB0aGlzLnRleHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRleHQsIHRoaXMubWFya3MpO1xuICAgIH1cbiAgICBjdXQoZnJvbSA9IDAsIHRvID0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aFRleHQodGhpcy50ZXh0LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMudGV4dCA9PSBvdGhlci50ZXh0O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBiYXNlID0gc3VwZXIudG9KU09OKCk7XG4gICAgICAgIGJhc2UudGV4dCA9IHRoaXMudGV4dDtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcE1hcmtzKG1hcmtzLCBzdHIpIHtcbiAgICBmb3IgKGxldCBpID0gbWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHN0ciA9IG1hcmtzW2ldLnR5cGUubmFtZSArIFwiKFwiICsgc3RyICsgXCIpXCI7XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG5JbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgYSBtYXRjaCBzdGF0ZSBvZiBhIG5vZGUgdHlwZSdzXG5bY29udGVudCBleHByZXNzaW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29udGVudCksIGFuZCBjYW4gYmUgdXNlZCB0b1xuZmluZCBvdXQgd2hldGhlciBmdXJ0aGVyIGNvbnRlbnQgbWF0Y2hlcyBoZXJlLCBhbmQgd2hldGhlciBhIGdpdmVuXG5wb3NpdGlvbiBpcyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbiovXG5jbGFzcyBDb250ZW50TWF0Y2gge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbWF0Y2ggc3RhdGUgcmVwcmVzZW50cyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbiAgICAqL1xuICAgIHZhbGlkRW5kKSB7XG4gICAgICAgIHRoaXMudmFsaWRFbmQgPSB2YWxpZEVuZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBDYWNoZSA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBwYXJzZShzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKHN0cmluZywgbm9kZVR5cGVzKTtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gQ29udGVudE1hdGNoLmVtcHR5O1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiVW5leHBlY3RlZCB0cmFpbGluZyB0ZXh0XCIpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBkZmEobmZhKGV4cHIpKTtcbiAgICAgICAgY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCBhIG5vZGUgdHlwZSwgcmV0dXJuaW5nIGEgbWF0Y2ggYWZ0ZXIgdGhhdCBub2RlIGlmXG4gICAgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIG1hdGNoVHlwZSh0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMubmV4dFtpXS50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFtpXS5uZXh0O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1hdGNoIGEgZnJhZ21lbnQuIFJldHVybnMgdGhlIHJlc3VsdGluZyBtYXRjaCB3aGVuXG4gICAgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIG1hdGNoRnJhZ21lbnQoZnJhZywgc3RhcnQgPSAwLCBlbmQgPSBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgbGV0IGN1ciA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgY3VyICYmIGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIGN1ciA9IGN1ci5tYXRjaFR5cGUoZnJhZy5jaGlsZChpKS50eXBlKTtcbiAgICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaW5saW5lQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGggIT0gMCAmJiB0aGlzLm5leHRbMF0udHlwZS5pc0lubGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBmaXJzdCBtYXRjaGluZyBub2RlIHR5cGUgYXQgdGhpcyBtYXRjaCBwb3NpdGlvbiB0aGF0IGNhblxuICAgIGJlIGdlbmVyYXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0VHlwZSgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IHR5cGUgfSA9IHRoaXMubmV4dFtpXTtcbiAgICAgICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXRpYmxlKG90aGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdGhlci5uZXh0Lmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSBvdGhlci5uZXh0W2pdLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtYXRjaCB0aGUgZ2l2ZW4gZnJhZ21lbnQsIGFuZCBpZiB0aGF0IGZhaWxzLCBzZWUgaWYgaXQgY2FuXG4gICAgYmUgbWFkZSB0byBtYXRjaCBieSBpbnNlcnRpbmcgbm9kZXMgaW4gZnJvbnQgb2YgaXQuIFdoZW5cbiAgICBzdWNjZXNzZnVsLCByZXR1cm4gYSBmcmFnbWVudCBvZiBpbnNlcnRlZCBub2RlcyAod2hpY2ggbWF5IGJlXG4gICAgZW1wdHkgaWYgbm90aGluZyBoYWQgdG8gYmUgaW5zZXJ0ZWQpLiBXaGVuIGB0b0VuZGAgaXMgdHJ1ZSwgb25seVxuICAgIHJldHVybiBhIGZyYWdtZW50IGlmIHRoZSByZXN1bHRpbmcgbWF0Y2ggZ29lcyB0byB0aGUgZW5kIG9mIHRoZVxuICAgIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGZpbGxCZWZvcmUoYWZ0ZXIsIHRvRW5kID0gZmFsc2UsIHN0YXJ0SW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBzZWVuID0gW3RoaXNdO1xuICAgICAgICBmdW5jdGlvbiBzZWFyY2gobWF0Y2gsIHR5cGVzKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBtYXRjaC5tYXRjaEZyYWdtZW50KGFmdGVyLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCAmJiAoIXRvRW5kIHx8IGZpbmlzaGVkLnZhbGlkRW5kKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbSh0eXBlcy5tYXAodHAgPT4gdHAuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5uZXh0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSAmJiBzZWVuLmluZGV4T2YobmV4dCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBzZWFyY2gobmV4dCwgdHlwZXMuY29uY2F0KHR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWFyY2godGhpcywgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgc2V0IG9mIHdyYXBwaW5nIG5vZGUgdHlwZXMgdGhhdCB3b3VsZCBhbGxvdyBhIG5vZGUgb2YgdGhlXG4gICAgZ2l2ZW4gdHlwZSB0byBhcHBlYXIgYXQgdGhpcyBwb3NpdGlvbi4gVGhlIHJlc3VsdCBtYXkgYmUgZW1wdHlcbiAgICAod2hlbiBpdCBmaXRzIGRpcmVjdGx5KSBhbmQgd2lsbCBiZSBudWxsIHdoZW4gbm8gc3VjaCB3cmFwcGluZ1xuICAgIGV4aXN0cy5cbiAgICAqL1xuICAgIGZpbmRXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndyYXBDYWNoZS5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICh0aGlzLndyYXBDYWNoZVtpXSA9PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcENhY2hlW2kgKyAxXTtcbiAgICAgICAgbGV0IGNvbXB1dGVkID0gdGhpcy5jb21wdXRlV3JhcHBpbmcodGFyZ2V0KTtcbiAgICAgICAgdGhpcy53cmFwQ2FjaGUucHVzaCh0YXJnZXQsIGNvbXB1dGVkKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXB1dGVXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpLCBhY3RpdmUgPSBbeyBtYXRjaDogdGhpcywgdHlwZTogbnVsbCwgdmlhOiBudWxsIH1dO1xuICAgICAgICB3aGlsZSAoYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBhY3RpdmUuc2hpZnQoKSwgbWF0Y2ggPSBjdXJyZW50Lm1hdGNoO1xuICAgICAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9iaiA9IGN1cnJlbnQ7IG9iai50eXBlOyBvYmogPSBvYmoudmlhKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmoudHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5uZXh0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghdHlwZS5pc0xlYWYgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpICYmICEodHlwZS5uYW1lIGluIHNlZW4pICYmICghY3VycmVudC50eXBlIHx8IG5leHQudmFsaWRFbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHsgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoLCB0eXBlLCB2aWE6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5bdHlwZS5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIHRoaXMgbm9kZSBoYXMgaW4gdGhlIGZpbml0ZVxuICAgIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZ2V0IGVkZ2VDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgX25f4oCLdGggb3V0Z29pbmcgZWRnZSBmcm9tIHRoaXMgbm9kZSBpbiB0aGUgZmluaXRlXG4gICAgYXV0b21hdG9uIHRoYXQgZGVzY3JpYmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBlZGdlKG4pIHtcbiAgICAgICAgaWYgKG4gPj0gdGhpcy5uZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSdzIG5vICR7bn10aCBlZGdlIGluIHRoaXMgY29udGVudCBtYXRjaGApO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0W25dO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc2VlbiA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBzY2FuKG0pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChtKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzY2FuKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBzY2FuKHRoaXMpO1xuICAgICAgICByZXR1cm4gc2Vlbi5tYXAoKG0sIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBvdXQgPSBpICsgKG0udmFsaWRFbmQgPyBcIipcIiA6IFwiIFwiKSArIFwiIFwiO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgb3V0ICs9IChpID8gXCIsIFwiIDogXCJcIikgKyBtLm5leHRbaV0udHlwZS5uYW1lICsgXCItPlwiICsgc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5Db250ZW50TWF0Y2guZW1wdHkgPSBuZXcgQ29udGVudE1hdGNoKHRydWUpO1xuY2xhc3MgVG9rZW5TdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLm5vZGVUeXBlcyA9IG5vZGVUeXBlcztcbiAgICAgICAgdGhpcy5pbmxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMudG9rZW5zID0gc3RyaW5nLnNwbGl0KC9cXHMqKD89XFxifFxcV3wkKS8pO1xuICAgICAgICBpZiAodGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gPT0gXCJcIilcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAodGhpcy50b2tlbnNbMF0gPT0gXCJcIilcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnNoaWZ0KCk7XG4gICAgfVxuICAgIGdldCBuZXh0KCkgeyByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NdOyB9XG4gICAgZWF0KHRvaykgeyByZXR1cm4gdGhpcy5uZXh0ID09IHRvayAmJiAodGhpcy5wb3MrKyB8fCB0cnVlKTsgfVxuICAgIGVycihzdHIpIHsgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN0ciArIFwiIChpbiBjb250ZW50IGV4cHJlc3Npb24gJ1wiICsgdGhpcy5zdHJpbmcgKyBcIicpXCIpOyB9XG59XG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHJzID0gW107XG4gICAgZG8ge1xuICAgICAgICBleHBycy5wdXNoKHBhcnNlRXhwclNlcShzdHJlYW0pKTtcbiAgICB9IHdoaWxlIChzdHJlYW0uZWF0KFwifFwiKSk7XG4gICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwiY2hvaWNlXCIsIGV4cHJzIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTZXEoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHJzID0gW107XG4gICAgZG8ge1xuICAgICAgICBleHBycy5wdXNoKHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pKTtcbiAgICB9IHdoaWxlIChzdHJlYW0ubmV4dCAmJiBzdHJlYW0ubmV4dCAhPSBcIilcIiAmJiBzdHJlYW0ubmV4dCAhPSBcInxcIik7XG4gICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwic2VxXCIsIGV4cHJzIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHIgPSBwYXJzZUV4cHJBdG9tKHN0cmVhbSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIitcIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcInBsdXNcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwic3RhclwiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCI/XCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJvcHRcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwie1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG59XG5mdW5jdGlvbiBwYXJzZU51bShzdHJlYW0pIHtcbiAgICBpZiAoL1xcRC8udGVzdChzdHJlYW0ubmV4dCkpXG4gICAgICAgIHN0cmVhbS5lcnIoXCJFeHBlY3RlZCBudW1iZXIsIGdvdCAnXCIgKyBzdHJlYW0ubmV4dCArIFwiJ1wiKTtcbiAgICBsZXQgcmVzdWx0ID0gTnVtYmVyKHN0cmVhbS5uZXh0KTtcbiAgICBzdHJlYW0ucG9zKys7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclJhbmdlKHN0cmVhbSwgZXhwcikge1xuICAgIGxldCBtaW4gPSBwYXJzZU51bShzdHJlYW0pLCBtYXggPSBtaW47XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIsXCIpKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCAhPSBcIn1cIilcbiAgICAgICAgICAgIG1heCA9IHBhcnNlTnVtKHN0cmVhbSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heCA9IC0xO1xuICAgIH1cbiAgICBpZiAoIXN0cmVhbS5lYXQoXCJ9XCIpKVxuICAgICAgICBzdHJlYW0uZXJyKFwiVW5jbG9zZWQgYnJhY2VkIHJhbmdlXCIpO1xuICAgIHJldHVybiB7IHR5cGU6IFwicmFuZ2VcIiwgbWluLCBtYXgsIGV4cHIgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVOYW1lKHN0cmVhbSwgbmFtZSkge1xuICAgIGxldCB0eXBlcyA9IHN0cmVhbS5ub2RlVHlwZXMsIHR5cGUgPSB0eXBlc1tuYW1lXTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgcmV0dXJuIFt0eXBlXTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgdHlwZU5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1t0eXBlTmFtZV07XG4gICAgICAgIGlmICh0eXBlLmdyb3Vwcy5pbmRleE9mKG5hbWUpID4gLTEpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0eXBlKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT0gMClcbiAgICAgICAgc3RyZWFtLmVycihcIk5vIG5vZGUgdHlwZSBvciBncm91cCAnXCIgKyBuYW1lICsgXCInIGZvdW5kXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJBdG9tKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKFwiKSkge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgICAgICBpZiAoIXN0cmVhbS5lYXQoXCIpXCIpKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk1pc3NpbmcgY2xvc2luZyBwYXJlblwiKTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEvXFxXLy50ZXN0KHN0cmVhbS5uZXh0KSkge1xuICAgICAgICBsZXQgZXhwcnMgPSByZXNvbHZlTmFtZShzdHJlYW0sIHN0cmVhbS5uZXh0KS5tYXAodHlwZSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmlubGluZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5pbmxpbmUgPSB0eXBlLmlzSW5saW5lO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmlubGluZSAhPSB0eXBlLmlzSW5saW5lKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXhpbmcgaW5saW5lIGFuZCBibG9jayBjb250ZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0eXBlIH07XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ucG9zKys7XG4gICAgICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgfVxufVxuLyoqXG5Db25zdHJ1Y3QgYW4gTkZBIGZyb20gYW4gZXhwcmVzc2lvbiBhcyByZXR1cm5lZCBieSB0aGUgcGFyc2VyLiBUaGVcbk5GQSBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBzdGF0ZXMsIHdoaWNoIGFyZSB0aGVtc2VsdmVzXG5hcnJheXMgb2YgZWRnZXMsIHdoaWNoIGFyZSBge3Rlcm0sIHRvfWAgb2JqZWN0cy4gVGhlIGZpcnN0IHN0YXRlIGlzXG50aGUgZW50cnkgc3RhdGUgYW5kIHRoZSBsYXN0IG5vZGUgaXMgdGhlIHN1Y2Nlc3Mgc3RhdGUuXG5cbk5vdGUgdGhhdCB1bmxpa2UgdHlwaWNhbCBORkFzLCB0aGUgZWRnZSBvcmRlcmluZyBpbiB0aGlzIG9uZSBpc1xuc2lnbmlmaWNhbnQsIGluIHRoYXQgaXQgaXMgdXNlZCB0byBjb250cnVjdCBmaWxsZXIgY29udGVudCB3aGVuXG5uZWNlc3NhcnkuXG4qL1xuZnVuY3Rpb24gbmZhKGV4cHIpIHtcbiAgICBsZXQgbmZhID0gW1tdXTtcbiAgICBjb25uZWN0KGNvbXBpbGUoZXhwciwgMCksIG5vZGUoKSk7XG4gICAgcmV0dXJuIG5mYTtcbiAgICBmdW5jdGlvbiBub2RlKCkgeyByZXR1cm4gbmZhLnB1c2goW10pIC0gMTsgfVxuICAgIGZ1bmN0aW9uIGVkZ2UoZnJvbSwgdG8sIHRlcm0pIHtcbiAgICAgICAgbGV0IGVkZ2UgPSB7IHRlcm0sIHRvIH07XG4gICAgICAgIG5mYVtmcm9tXS5wdXNoKGVkZ2UpO1xuICAgICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29ubmVjdChlZGdlcywgdG8pIHtcbiAgICAgICAgZWRnZXMuZm9yRWFjaChlZGdlID0+IGVkZ2UudG8gPSB0byk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBpbGUoZXhwciwgZnJvbSkge1xuICAgICAgICBpZiAoZXhwci50eXBlID09IFwiY2hvaWNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByLmV4cHJzLnJlZHVjZSgob3V0LCBleHByKSA9PiBvdXQuY29uY2F0KGNvbXBpbGUoZXhwciwgZnJvbSkpLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwic2VxXCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjb21waWxlKGV4cHIuZXhwcnNbaV0sIGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChpID09IGV4cHIuZXhwcnMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgY29ubmVjdChuZXh0LCBmcm9tID0gbm9kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzdGFyXCIpIHtcbiAgICAgICAgICAgIGxldCBsb29wID0gbm9kZSgpO1xuICAgICAgICAgICAgZWRnZShmcm9tLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicGx1c1wiKSB7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IG5vZGUoKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGZyb20pLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwib3B0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShmcm9tKV0uY29uY2F0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgbGV0IGN1ciA9IGZyb207XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHIubWluOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIubWF4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBleHByLm1pbjsgaSA8IGV4cHIubWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UoY3VyLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGN1cildO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGZyb20sIHVuZGVmaW5lZCwgZXhwci52YWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBleHByIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYiAtIGE7IH1cbi8vIEdldCB0aGUgc2V0IG9mIG5vZGVzIHJlYWNoYWJsZSBieSBudWxsIGVkZ2VzIGZyb20gYG5vZGVgLiBPbWl0XG4vLyBub2RlcyB3aXRoIG9ubHkgYSBzaW5nbGUgbnVsbC1vdXQtZWRnZSwgc2luY2UgdGhleSBtYXkgbGVhZCB0b1xuLy8gbmVlZGxlc3MgZHVwbGljYXRlZCBub2Rlcy5cbmZ1bmN0aW9uIG51bGxGcm9tKG5mYSwgbm9kZSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBzY2FuKG5vZGUpO1xuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApO1xuICAgIGZ1bmN0aW9uIHNjYW4obm9kZSkge1xuICAgICAgICBsZXQgZWRnZXMgPSBuZmFbbm9kZV07XG4gICAgICAgIGlmIChlZGdlcy5sZW5ndGggPT0gMSAmJiAhZWRnZXNbMF0udGVybSlcbiAgICAgICAgICAgIHJldHVybiBzY2FuKGVkZ2VzWzBdLnRvKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IHRlcm0sIHRvIH0gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIGlmICghdGVybSAmJiByZXN1bHQuaW5kZXhPZih0bykgPT0gLTEpXG4gICAgICAgICAgICAgICAgc2Nhbih0byk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBDb21waWxlcyBhbiBORkEgYXMgcHJvZHVjZWQgYnkgYG5mYWAgaW50byBhIERGQSwgbW9kZWxlZCBhcyBhIHNldFxuLy8gb2Ygc3RhdGUgb2JqZWN0cyAoYENvbnRlbnRNYXRjaGAgaW5zdGFuY2VzKSB3aXRoIHRyYW5zaXRpb25zXG4vLyBiZXR3ZWVuIHRoZW0uXG5mdW5jdGlvbiBkZmEobmZhKSB7XG4gICAgbGV0IGxhYmVsZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBleHBsb3JlKG51bGxGcm9tKG5mYSwgMCkpO1xuICAgIGZ1bmN0aW9uIGV4cGxvcmUoc3RhdGVzKSB7XG4gICAgICAgIGxldCBvdXQgPSBbXTtcbiAgICAgICAgc3RhdGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBuZmFbbm9kZV0uZm9yRWFjaCgoeyB0ZXJtLCB0byB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXJtKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dFtpXVswXSA9PSB0ZXJtKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0ID0gb3V0W2ldWzFdO1xuICAgICAgICAgICAgICAgIG51bGxGcm9tKG5mYSwgdG8pLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goW3Rlcm0sIHNldCA9IFtdXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXQuaW5kZXhPZihub2RlKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgc3RhdGUgPSBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gPSBuZXcgQ29udGVudE1hdGNoKHN0YXRlcy5pbmRleE9mKG5mYS5sZW5ndGggLSAxKSA+IC0xKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZXMgPSBvdXRbaV1bMV0uc29ydChjbXApO1xuICAgICAgICAgICAgc3RhdGUubmV4dC5wdXNoKHsgdHlwZTogb3V0W2ldWzBdLCBuZXh0OiBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gfHwgZXhwbG9yZShzdGF0ZXMpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgd29yayA9IFttYXRjaF07IGkgPCB3b3JrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHdvcmtbaV0sIGRlYWQgPSAhc3RhdGUudmFsaWRFbmQsIG5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUubmV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gc3RhdGUubmV4dFtqXTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godHlwZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChkZWFkICYmICEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKVxuICAgICAgICAgICAgICAgIGRlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh3b3JrLmluZGV4T2YobmV4dCkgPT0gLTEpXG4gICAgICAgICAgICAgICAgd29yay5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWFkKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk9ubHkgbm9uLWdlbmVyYXRhYmxlIG5vZGVzIChcIiArIG5vZGVzLmpvaW4oXCIsIFwiKSArIFwiKSBpbiBhIHJlcXVpcmVkIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jZ2VuZXJhdGFibGUpXCIpO1xuICAgIH1cbn1cblxuLy8gRm9yIG5vZGUgdHlwZXMgd2hlcmUgYWxsIGF0dHJzIGhhdmUgYSBkZWZhdWx0IHZhbHVlIChvciB3aGljaCBkb24ndFxuLy8gaGF2ZSBhbnkgYXR0cmlidXRlcyksIGJ1aWxkIHVwIGEgc2luZ2xlIHJldXNhYmxlIGRlZmF1bHQgYXR0cmlidXRlXG4vLyBvYmplY3QsIGFuZCB1c2UgaXQgZm9yIGFsbCBub2RlcyB0aGF0IGRvbid0IHNwZWNpZnkgc3BlY2lmaWNcbi8vIGF0dHJpYnV0ZXMuXG5mdW5jdGlvbiBkZWZhdWx0QXR0cnMoYXR0cnMpIHtcbiAgICBsZXQgZGVmYXVsdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICBpZiAoIWF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBkZWZhdWx0c1thdHRyTmFtZV0gPSBhdHRyLmRlZmF1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVBdHRycyhhdHRycywgdmFsdWUpIHtcbiAgICBsZXQgYnVpbHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGdpdmVuID0gdmFsdWUgJiYgdmFsdWVbbmFtZV07XG4gICAgICAgIGlmIChnaXZlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgICAgICBnaXZlbiA9IGF0dHIuZGVmYXVsdDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHZhbHVlIHN1cHBsaWVkIGZvciBhdHRyaWJ1dGUgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsdFtuYW1lXSA9IGdpdmVuO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbHQ7XG59XG5mdW5jdGlvbiBpbml0QXR0cnMoYXR0cnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSBuZXcgQXR0cmlidXRlKGF0dHJzW25hbWVdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5Ob2RlIHR5cGVzIGFyZSBvYmplY3RzIGFsbG9jYXRlZCBvbmNlIHBlciBgU2NoZW1hYCBhbmQgdXNlZCB0b1xuW3RhZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUudHlwZSkgYE5vZGVgIGluc3RhbmNlcy4gVGhleSBjb250YWluIGluZm9ybWF0aW9uXG5hYm91dCB0aGUgbm9kZSB0eXBlLCBzdWNoIGFzIGl0cyBuYW1lIGFuZCB3aGF0IGtpbmQgb2Ygbm9kZSBpdFxucmVwcmVzZW50cy5cbiovXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSB0aGUgbm9kZSB0eXBlIGhhcyBpbiB0aGlzIHNjaGVtYS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEEgbGluayBiYWNrIHRvIHRoZSBgU2NoZW1hYCB0aGUgbm9kZSB0eXBlIGJlbG9uZ3MgdG8uXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHRoYXQgdGhpcyB0eXBlIGlzIGJhc2VkIG9uXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHNldCBvZiBtYXJrcyBhbGxvd2VkIGluIHRoaXMgbm9kZS4gYG51bGxgIG1lYW5zIGFsbCBtYXJrc1xuICAgICAgICBhcmUgYWxsb3dlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrU2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBzcGVjLmdyb3VwID8gc3BlYy5ncm91cC5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhzcGVjLmF0dHJzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0QXR0cnMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMuY29udGVudE1hdGNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmxpbmVDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0Jsb2NrID0gIShzcGVjLmlubGluZSB8fCBuYW1lID09IFwidGV4dFwiKTtcbiAgICAgICAgdGhpcy5pc1RleHQgPSBuYW1lID09IFwidGV4dFwiO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHRoaXMgaXMgYW4gaW5saW5lIHR5cGUuXG4gICAgKi9cbiAgICBnZXQgaXNJbmxpbmUoKSB7IHJldHVybiAhdGhpcy5pc0Jsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB0aGlzIGlzIGEgdGV4dGJsb2NrIHR5cGUsIGEgYmxvY2sgdGhhdCBjb250YWlucyBpbmxpbmVcbiAgICBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzVGV4dGJsb2NrKCkgeyByZXR1cm4gdGhpcy5pc0Jsb2NrICYmIHRoaXMuaW5saW5lQ29udGVudDsgfVxuICAgIC8qKlxuICAgIFRydWUgZm9yIG5vZGUgdHlwZXMgdGhhdCBhbGxvdyBubyBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzTGVhZigpIHsgcmV0dXJuIHRoaXMuY29udGVudE1hdGNoID09IENvbnRlbnRNYXRjaC5lbXB0eTsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgYW4gYXRvbSwgaS5lLiB3aGVuIGl0IGRvZXMgbm90IGhhdmVcbiAgICBkaXJlY3RseSBlZGl0YWJsZSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzQXRvbSgpIHsgcmV0dXJuIHRoaXMuaXNMZWFmIHx8ICEhdGhpcy5zcGVjLmF0b207IH1cbiAgICAvKipcbiAgICBUaGUgbm9kZSB0eXBlJ3MgW3doaXRlc3BhY2VdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy53aGl0ZXNwYWNlKSBvcHRpb24uXG4gICAgKi9cbiAgICBnZXQgd2hpdGVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy53aGl0ZXNwYWNlIHx8ICh0aGlzLnNwZWMuY29kZSA/IFwicHJlXCIgOiBcIm5vcm1hbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBub2RlIHR5cGUgaGFzIGFueSByZXF1aXJlZCBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgaGFzUmVxdWlyZWRBdHRycygpIHtcbiAgICAgICAgZm9yIChsZXQgbiBpbiB0aGlzLmF0dHJzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnNbbl0uaXNSZXF1aXJlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIG5vZGUgYWxsb3dzIHNvbWUgb2YgdGhlIHNhbWUgY29udGVudCBhc1xuICAgIHRoZSBnaXZlbiBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBjb21wYXRpYmxlQ29udGVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnRlbnRNYXRjaC5jb21wYXRpYmxlKG90aGVyLmNvbnRlbnRNYXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcHV0ZUF0dHJzKGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0QXR0cnM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgTm9kZWAgb2YgdGhpcyB0eXBlLiBUaGUgZ2l2ZW4gYXR0cmlidXRlcyBhcmVcbiAgICBjaGVja2VkIGFuZCBkZWZhdWx0ZWQgKHlvdSBjYW4gcGFzcyBgbnVsbGAgdG8gdXNlIHRoZSB0eXBlJ3NcbiAgICBkZWZhdWx0cyBlbnRpcmVseSwgaWYgbm8gcmVxdWlyZWQgYXR0cmlidXRlcyBleGlzdCkuIGBjb250ZW50YFxuICAgIG1heSBiZSBhIGBGcmFnbWVudGAsIGEgbm9kZSwgYW4gYXJyYXkgb2Ygbm9kZXMsIG9yXG4gICAgYG51bGxgLiBTaW1pbGFybHkgYG1hcmtzYCBtYXkgYmUgYG51bGxgIHRvIGRlZmF1bHQgdG8gdGhlIGVtcHR5XG4gICAgc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgY3JlYXRlKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZVR5cGUuY3JlYXRlIGNhbid0IGNvbnN0cnVjdCB0ZXh0IG5vZGVzXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYGNyZWF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgY2hlY2sgdGhlIGdpdmVuIGNvbnRlbnRcbiAgICBhZ2FpbnN0IHRoZSBub2RlIHR5cGUncyBjb250ZW50IHJlc3RyaWN0aW9ucywgYW5kIHRocm93IGFuIGVycm9yXG4gICAgaWYgaXQgZG9lc24ndCBtYXRjaC5cbiAgICAqL1xuICAgIGNyZWF0ZUNoZWNrZWQoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgICAgICAgdGhpcy5jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIGNvbnRlbnQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgY3JlYXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlLmNyZWF0ZSksIGJ1dCBzZWUgaWYgaXQgaXNcbiAgICBuZWNlc3NhcnkgdG8gYWRkIG5vZGVzIHRvIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGdpdmVuIGZyYWdtZW50XG4gICAgdG8gbWFrZSBpdCBmaXQgdGhlIG5vZGUuIElmIG5vIGZpdHRpbmcgd3JhcHBpbmcgY2FuIGJlIGZvdW5kLFxuICAgIHJldHVybiBudWxsLiBOb3RlIHRoYXQsIGR1ZSB0byB0aGUgZmFjdCB0aGF0IHJlcXVpcmVkIG5vZGVzIGNhblxuICAgIGFsd2F5cyBiZSBjcmVhdGVkLCB0aGlzIHdpbGwgYWx3YXlzIHN1Y2NlZWQgaWYgeW91IHBhc3MgbnVsbCBvclxuICAgIGBGcmFnbWVudC5lbXB0eWAgYXMgY29udGVudC5cbiAgICAqL1xuICAgIGNyZWF0ZUFuZEZpbGwoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBhdHRycyA9IHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKTtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFiZWZvcmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb250ZW50ID0gYmVmb3JlLmFwcGVuZChjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF0Y2hlZCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgIGxldCBhZnRlciA9IG1hdGNoZWQgJiYgbWF0Y2hlZC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgYXR0cnMsIGNvbnRlbnQuYXBwZW5kKGFmdGVyKSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZnJhZ21lbnQgaXMgdmFsaWQgY29udGVudCBmb3IgdGhpcyBub2RlXG4gICAgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgdmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya3MoY29udGVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhyb3dzIGEgUmFuZ2VFcnJvciBpZiB0aGUgZ2l2ZW4gZnJhZ21lbnQgaXMgbm90IHZhbGlkIGNvbnRlbnQgZm9yIHRoaXNcbiAgICBub2RlIHR5cGUuXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGVja0NvbnRlbnQoY29udGVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRDb250ZW50KGNvbnRlbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY29udGVudCBmb3Igbm9kZSAke3RoaXMubmFtZX06ICR7Y29udGVudC50b1N0cmluZygpLnNsaWNlKDAsIDUwKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbWFyayB0eXBlIGlzIGFsbG93ZWQgaW4gdGhpcyBub2RlLlxuICAgICovXG4gICAgYWxsb3dzTWFya1R5cGUobWFya1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya1NldCA9PSBudWxsIHx8IHRoaXMubWFya1NldC5pbmRleE9mKG1hcmtUeXBlKSA+IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBhcmUgYWxsb3dlZCBpbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBhbGxvd3NNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIHRoZSBtYXJrcyB0aGF0IGFyZSBub3QgYWxsb3dlZCBpbiB0aGlzIG5vZGUgZnJvbSB0aGUgZ2l2ZW4gc2V0LlxuICAgICovXG4gICAgYWxsb3dlZE1hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBtYXJrcztcbiAgICAgICAgbGV0IGNvcHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IG1hcmtzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29weSkge1xuICAgICAgICAgICAgICAgIGNvcHkucHVzaChtYXJrc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFjb3B5ID8gbWFya3MgOiBjb3B5Lmxlbmd0aCA/IGNvcHkgOiBNYXJrLm5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNvbXBpbGUobm9kZXMsIHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgobmFtZSwgc3BlYykgPT4gcmVzdWx0W25hbWVdID0gbmV3IE5vZGVUeXBlKG5hbWUsIHNjaGVtYSwgc3BlYykpO1xuICAgICAgICBsZXQgdG9wVHlwZSA9IHNjaGVtYS5zcGVjLnRvcE5vZGUgfHwgXCJkb2NcIjtcbiAgICAgICAgaWYgKCFyZXN1bHRbdG9wVHlwZV0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNjaGVtYSBpcyBtaXNzaW5nIGl0cyB0b3Agbm9kZSB0eXBlICgnXCIgKyB0b3BUeXBlICsgXCInKVwiKTtcbiAgICAgICAgaWYgKCFyZXN1bHQudGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRXZlcnkgc2NoZW1hIG5lZWRzIGEgJ3RleHQnIHR5cGVcIik7XG4gICAgICAgIGZvciAobGV0IF8gaW4gcmVzdWx0LnRleHQuYXR0cnMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB0ZXh0IG5vZGUgdHlwZSBzaG91bGQgbm90IGhhdmUgYXR0cmlidXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyBBdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbmNsYXNzIEF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLmhhc0RlZmF1bHQgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJkZWZhdWx0XCIpO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBvcHRpb25zLmRlZmF1bHQ7XG4gICAgfVxuICAgIGdldCBpc1JlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaGFzRGVmYXVsdDtcbiAgICB9XG59XG4vLyBNYXJrc1xuLyoqXG5MaWtlIG5vZGVzLCBtYXJrcyAod2hpY2ggYXJlIGFzc29jaWF0ZWQgd2l0aCBub2RlcyB0byBzaWduaWZ5XG50aGluZ3MgbGlrZSBlbXBoYXNpcyBvciBiZWluZyBwYXJ0IG9mIGEgbGluaykgYXJlXG5bdGFnZ2VkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFyay50eXBlKSB3aXRoIHR5cGUgb2JqZWN0cywgd2hpY2ggYXJlXG5pbnN0YW50aWF0ZWQgb25jZSBwZXIgYFNjaGVtYWAuXG4qL1xuY2xhc3MgTWFya1R5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgb2YgdGhlIG1hcmsgdHlwZS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuaywgXG4gICAgLyoqXG4gICAgVGhlIHNjaGVtYSB0aGF0IHRoaXMgbWFyayB0eXBlIGluc3RhbmNlIGlzIHBhcnQgb2YuXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzcGVjIG9uIHdoaWNoIHRoZSB0eXBlIGlzIGJhc2VkLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhzcGVjLmF0dHJzKTtcbiAgICAgICAgdGhpcy5leGNsdWRlZCA9IG51bGw7XG4gICAgICAgIGxldCBkZWZhdWx0cyA9IGRlZmF1bHRBdHRycyh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGRlZmF1bHRzID8gbmV3IE1hcmsodGhpcywgZGVmYXVsdHMpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBvZiB0aGlzIHR5cGUuIGBhdHRyc2AgbWF5IGJlIGBudWxsYCBvciBhbiBvYmplY3RcbiAgICBjb250YWluaW5nIG9ubHkgc29tZSBvZiB0aGUgbWFyaydzIGF0dHJpYnV0ZXMuIFRoZSBvdGhlcnMsIGlmXG4gICAgdGhleSBoYXZlIGRlZmF1bHRzLCB3aWxsIGJlIGFkZGVkLlxuICAgICovXG4gICAgY3JlYXRlKGF0dHJzID0gbnVsbCkge1xuICAgICAgICBpZiAoIWF0dHJzICYmIHRoaXMuaW5zdGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrKHRoaXMsIGNvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycykpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKG1hcmtzLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCksIHJhbmsgPSAwO1xuICAgICAgICBtYXJrcy5mb3JFYWNoKChuYW1lLCBzcGVjKSA9PiByZXN1bHRbbmFtZV0gPSBuZXcgTWFya1R5cGUobmFtZSwgcmFuaysrLCBzY2hlbWEsIHNwZWMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGVyZSBpcyBhIG1hcmsgb2YgdGhpcyB0eXBlIGluIHRoZSBnaXZlbiBzZXQsIGEgbmV3IHNldFxuICAgIHdpdGhvdXQgaXQgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIGlucHV0IHNldCBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldFtpXS50eXBlID09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBzZXQgPSBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdHMgd2hldGhlciB0aGVyZSBpcyBhIG1hcmsgb2YgdGhpcyB0eXBlIGluIHRoZSBnaXZlbiBzZXQuXG4gICAgKi9cbiAgICBpc0luU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRbaV07XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJpZXMgd2hldGhlciBhIGdpdmVuIG1hcmsgdHlwZSBpc1xuICAgIFtleGNsdWRlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmV4Y2x1ZGVzKSBieSB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGV4Y2x1ZGVzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4Y2x1ZGVkLmluZGV4T2Yob3RoZXIpID4gLTE7XG4gICAgfVxufVxuLyoqXG5BIGRvY3VtZW50IHNjaGVtYS4gSG9sZHMgW25vZGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZSkgYW5kIFttYXJrXG50eXBlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1R5cGUpIG9iamVjdHMgZm9yIHRoZSBub2RlcyBhbmQgbWFya3MgdGhhdCBtYXlcbm9jY3VyIGluIGNvbmZvcm1pbmcgZG9jdW1lbnRzLCBhbmQgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3JcbmNyZWF0aW5nIGFuZCBkZXNlcmlhbGl6aW5nIHN1Y2ggZG9jdW1lbnRzLlxuXG5XaGVuIGdpdmVuLCB0aGUgdHlwZSBwYXJhbWV0ZXJzIHByb3ZpZGUgdGhlIG5hbWVzIG9mIHRoZSBub2RlcyBhbmRcbm1hcmtzIGluIHRoaXMgc2NoZW1hLlxuKi9cbmNsYXNzIFNjaGVtYSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgc2NoZW1hIGZyb20gYSBzY2hlbWEgW3NwZWNpZmljYXRpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5TY2hlbWFTcGVjKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEFuIG9iamVjdCBmb3Igc3RvcmluZyB3aGF0ZXZlciB2YWx1ZXMgbW9kdWxlcyBtYXkgd2FudCB0b1xuICAgICAgICBjb21wdXRlIGFuZCBjYWNoZSBwZXIgc2NoZW1hLiAoSWYgeW91IHdhbnQgdG8gc3RvcmUgc29tZXRoaW5nXG4gICAgICAgIGluIGl0LCB0cnkgdG8gdXNlIHByb3BlcnR5IG5hbWVzIHVubGlrZWx5IHRvIGNsYXNoLilcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWNoZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgaW5zdGFuY2VTcGVjID0gdGhpcy5zcGVjID0ge307XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gc3BlYylcbiAgICAgICAgICAgIGluc3RhbmNlU3BlY1twcm9wXSA9IHNwZWNbcHJvcF07XG4gICAgICAgIGluc3RhbmNlU3BlYy5ub2RlcyA9IE9yZGVyZWRNYXAuZnJvbShzcGVjLm5vZGVzKSxcbiAgICAgICAgICAgIGluc3RhbmNlU3BlYy5tYXJrcyA9IE9yZGVyZWRNYXAuZnJvbShzcGVjLm1hcmtzIHx8IHt9KSxcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSBOb2RlVHlwZS5jb21waWxlKHRoaXMuc3BlYy5ub2RlcywgdGhpcyk7XG4gICAgICAgIHRoaXMubWFya3MgPSBNYXJrVHlwZS5jb21waWxlKHRoaXMuc3BlYy5tYXJrcywgdGhpcyk7XG4gICAgICAgIGxldCBjb250ZW50RXhwckNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiB0aGlzLm1hcmtzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHByb3AgKyBcIiBjYW4gbm90IGJlIGJvdGggYSBub2RlIGFuZCBhIG1hcmtcIik7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMubm9kZXNbcHJvcF0sIGNvbnRlbnRFeHByID0gdHlwZS5zcGVjLmNvbnRlbnQgfHwgXCJcIiwgbWFya0V4cHIgPSB0eXBlLnNwZWMubWFya3M7XG4gICAgICAgICAgICB0eXBlLmNvbnRlbnRNYXRjaCA9IGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdIHx8XG4gICAgICAgICAgICAgICAgKGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdID0gQ29udGVudE1hdGNoLnBhcnNlKGNvbnRlbnRFeHByLCB0aGlzLm5vZGVzKSk7XG4gICAgICAgICAgICB0eXBlLmlubGluZUNvbnRlbnQgPSB0eXBlLmNvbnRlbnRNYXRjaC5pbmxpbmVDb250ZW50O1xuICAgICAgICAgICAgdHlwZS5tYXJrU2V0ID0gbWFya0V4cHIgPT0gXCJfXCIgPyBudWxsIDpcbiAgICAgICAgICAgICAgICBtYXJrRXhwciA/IGdhdGhlck1hcmtzKHRoaXMsIG1hcmtFeHByLnNwbGl0KFwiIFwiKSkgOlxuICAgICAgICAgICAgICAgICAgICBtYXJrRXhwciA9PSBcIlwiIHx8ICF0eXBlLmlubGluZUNvbnRlbnQgPyBbXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLm1hcmtzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMubWFya3NbcHJvcF0sIGV4Y2wgPSB0eXBlLnNwZWMuZXhjbHVkZXM7XG4gICAgICAgICAgICB0eXBlLmV4Y2x1ZGVkID0gZXhjbCA9PSBudWxsID8gW3R5cGVdIDogZXhjbCA9PSBcIlwiID8gW10gOiBnYXRoZXJNYXJrcyh0aGlzLCBleGNsLnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlRnJvbUpTT04gPSB0aGlzLm5vZGVGcm9tSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1hcmtGcm9tSlNPTiA9IHRoaXMubWFya0Zyb21KU09OLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9wTm9kZVR5cGUgPSB0aGlzLm5vZGVzW3RoaXMuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCJdO1xuICAgICAgICB0aGlzLmNhY2hlZC53cmFwcGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIGluIHRoaXMgc2NoZW1hLiBUaGUgYHR5cGVgIG1heSBiZSBhIHN0cmluZyBvciBhXG4gICAgYE5vZGVUeXBlYCBpbnN0YW5jZS4gQXR0cmlidXRlcyB3aWxsIGJlIGV4dGVuZGVkIHdpdGggZGVmYXVsdHMsXG4gICAgYGNvbnRlbnRgIG1heSBiZSBhIGBGcmFnbWVudGAsIGBudWxsYCwgYSBgTm9kZWAsIG9yIGFuIGFycmF5IG9mXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBub2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5ub2RlVHlwZSh0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAoISh0eXBlIGluc3RhbmNlb2YgTm9kZVR5cGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG5vZGUgdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZS5zY2hlbWEgIT0gdGhpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGZyb20gZGlmZmVyZW50IHNjaGVtYSB1c2VkIChcIiArIHR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlQ2hlY2tlZChhdHRycywgY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IG5vZGUgaW4gdGhlIHNjaGVtYS4gRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90XG4gICAgYWxsb3dlZC5cbiAgICAqL1xuICAgIHRleHQodGV4dCwgbWFya3MpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzLnRleHQ7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodHlwZSwgdHlwZS5kZWZhdWx0QXR0cnMsIHRleHQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBtYXJrKHR5cGUsIGF0dHJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubWFya3NbdHlwZV07XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShhdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbm9kZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuICAgIGJvdW5kLlxuICAgICovXG4gICAgbm9kZUZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIE5vZGUuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbWFyayBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuICAgIGJvdW5kLlxuICAgICovXG4gICAgbWFya0Zyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIE1hcmsuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbm9kZVR5cGUobmFtZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBuYW1lKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlck1hcmtzKHNjaGVtYSwgbWFya3MpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuYW1lID0gbWFya3NbaV0sIG1hcmsgPSBzY2hlbWEubWFya3NbbmFtZV0sIG9rID0gbWFyaztcbiAgICAgICAgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2gobWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrID0gc2NoZW1hLm1hcmtzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiX1wiIHx8IChtYXJrLnNwZWMuZ3JvdXAgJiYgbWFyay5zcGVjLmdyb3VwLnNwbGl0KFwiIFwiKS5pbmRleE9mKG5hbWUpID4gLTEpKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKG9rID0gbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvaylcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVua25vd24gbWFyayB0eXBlOiAnXCIgKyBtYXJrc1tpXSArIFwiJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG4vKipcbkEgRE9NIHBhcnNlciByZXByZXNlbnRzIGEgc3RyYXRlZ3kgZm9yIHBhcnNpbmcgRE9NIGNvbnRlbnQgaW50byBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudCBjb25mb3JtaW5nIHRvIGEgZ2l2ZW4gc2NoZW1hLiBJdHMgYmVoYXZpb3IgaXNcbmRlZmluZWQgYnkgYW4gYXJyYXkgb2YgW3J1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKS5cbiovXG5jbGFzcyBET01QYXJzZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBhcnNlciB0aGF0IHRhcmdldHMgdGhlIGdpdmVuIHNjaGVtYSwgdXNpbmcgdGhlIGdpdmVuXG4gICAgcGFyc2luZyBydWxlcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgaW50byB3aGljaCB0aGUgcGFyc2VyIHBhcnNlcy5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNldCBvZiBbcGFyc2UgcnVsZXNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUpIHRoYXQgdGhlIHBhcnNlclxuICAgIHVzZXMsIGluIG9yZGVyIG9mIHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBydWxlcykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGFncyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICBpZiAocnVsZS50YWcpXG4gICAgICAgICAgICAgICAgdGhpcy50YWdzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLnN0eWxlKVxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPbmx5IG5vcm1hbGl6ZSBsaXN0IGVsZW1lbnRzIHdoZW4gbGlzdHMgaW4gdGhlIHNjaGVtYSBjYW4ndCBkaXJlY3RseSBjb250YWluIHRoZW1zZWx2ZXNcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaXN0cyA9ICF0aGlzLnRhZ3Muc29tZShyID0+IHtcbiAgICAgICAgICAgIGlmICghL14odWx8b2wpXFxiLy50ZXN0KHIudGFnKSB8fCAhci5ub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlID0gc2NoZW1hLm5vZGVzW3Iubm9kZV07XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2UgYSBkb2N1bWVudCBmcm9tIHRoZSBjb250ZW50IG9mIGEgRE9NIG5vZGUuXG4gICAgKi9cbiAgICBwYXJzZShkb20sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgICBjb250ZXh0LmFkZEFsbChkb20sIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBQYXJzZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGdpdmVuIERPTSBub2RlLCBsaWtlXG4gICAgW2BwYXJzZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01QYXJzZXIucGFyc2UpLCBhbmQgdGFrZXMgdGhlIHNhbWUgc2V0IG9mXG4gICAgb3B0aW9ucy4gQnV0IHVubGlrZSB0aGF0IG1ldGhvZCwgd2hpY2ggcHJvZHVjZXMgYSB3aG9sZSBub2RlLFxuICAgIHRoaXMgb25lIHJldHVybnMgYSBzbGljZSB0aGF0IGlzIG9wZW4gYXQgdGhlIHNpZGVzLCBtZWFuaW5nIHRoYXRcbiAgICB0aGUgc2NoZW1hIGNvbnN0cmFpbnRzIGFyZW4ndCBhcHBsaWVkIHRvIHRoZSBzdGFydCBvZiBub2RlcyB0b1xuICAgIHRoZSBsZWZ0IG9mIHRoZSBpbnB1dCBhbmQgdGhlIGVuZCBvZiBub2RlcyBhdCB0aGUgZW5kLlxuICAgICovXG4gICAgcGFyc2VTbGljZShkb20sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgICAgcmV0dXJuIFNsaWNlLm1heE9wZW4oY29udGV4dC5maW5pc2goKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF0Y2hUYWcoZG9tLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gYWZ0ZXIgPyB0aGlzLnRhZ3MuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnRhZ3NbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlcyhkb20sIHJ1bGUudGFnKSAmJlxuICAgICAgICAgICAgICAgIChydWxlLm5hbWVzcGFjZSA9PT0gdW5kZWZpbmVkIHx8IGRvbS5uYW1lc3BhY2VVUkkgPT0gcnVsZS5uYW1lc3BhY2UpICYmXG4gICAgICAgICAgICAgICAgKCFydWxlLmNvbnRleHQgfHwgY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBydWxlLmdldEF0dHJzKGRvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hdGNoU3R5bGUocHJvcCwgdmFsdWUsIGNvbnRleHQsIGFmdGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZnRlciA/IHRoaXMuc3R5bGVzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnN0eWxlc1tpXSwgc3R5bGUgPSBydWxlLnN0eWxlO1xuICAgICAgICAgICAgaWYgKHN0eWxlLmluZGV4T2YocHJvcCkgIT0gMCB8fFxuICAgICAgICAgICAgICAgIHJ1bGUuY29udGV4dCAmJiAhY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpIHx8XG4gICAgICAgICAgICAgICAgLy8gVGVzdCB0aGF0IHRoZSBzdHlsZSBzdHJpbmcgZWl0aGVyIHByZWNpc2VseSBtYXRjaGVzIHRoZSBwcm9wLFxuICAgICAgICAgICAgICAgIC8vIG9yIGhhcyBhbiAnPScgc2lnbiBhZnRlciB0aGUgcHJvcCwgZm9sbG93ZWQgYnkgdGhlIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgc3R5bGUubGVuZ3RoID4gcHJvcC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0eWxlLmNoYXJDb2RlQXQocHJvcC5sZW5ndGgpICE9IDYxIHx8IHN0eWxlLnNsaWNlKHByb3AubGVuZ3RoICsgMSkgIT0gdmFsdWUpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgc2NoZW1hUnVsZXMoc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAgICAgICAgIGxldCBwcmlvcml0eSA9IHJ1bGUucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogcnVsZS5wcmlvcml0eSwgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcmVzdWx0W2ldLCBuZXh0UHJpb3JpdHkgPSBuZXh0LnByaW9yaXR5ID09IG51bGwgPyA1MCA6IG5leHQucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRQcmlvcml0eSA8IHByaW9yaXR5KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgIGxldCBydWxlcyA9IHNjaGVtYS5tYXJrc1tuYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICAgICAgaWYgKHJ1bGVzKVxuICAgICAgICAgICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJ1bGUubWFyayB8fCBydWxlLmlnbm9yZSB8fCBydWxlLmNsZWFyTWFyaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm1hcmsgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBzY2hlbWEubm9kZXNbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgICAgIGlmIChydWxlcylcbiAgICAgICAgICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShydWxlLm5vZGUgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5tYXJrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubm9kZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgRE9NIHBhcnNlciB1c2luZyB0aGUgcGFyc2luZyBydWxlcyBsaXN0ZWQgaW4gYVxuICAgIHNjaGVtYSdzIFtub2RlIHNwZWNzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMucGFyc2VET00pLCByZW9yZGVyZWQgYnlcbiAgICBbcHJpb3JpdHldKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUucHJpb3JpdHkpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciB8fFxuICAgICAgICAgICAgKHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyID0gbmV3IERPTVBhcnNlcihzY2hlbWEsIERPTVBhcnNlci5zY2hlbWFSdWxlcyhzY2hlbWEpKSk7XG4gICAgfVxufVxuY29uc3QgYmxvY2tUYWdzID0ge1xuICAgIGFkZHJlc3M6IHRydWUsIGFydGljbGU6IHRydWUsIGFzaWRlOiB0cnVlLCBibG9ja3F1b3RlOiB0cnVlLCBjYW52YXM6IHRydWUsXG4gICAgZGQ6IHRydWUsIGRpdjogdHJ1ZSwgZGw6IHRydWUsIGZpZWxkc2V0OiB0cnVlLCBmaWdjYXB0aW9uOiB0cnVlLCBmaWd1cmU6IHRydWUsXG4gICAgZm9vdGVyOiB0cnVlLCBmb3JtOiB0cnVlLCBoMTogdHJ1ZSwgaDI6IHRydWUsIGgzOiB0cnVlLCBoNDogdHJ1ZSwgaDU6IHRydWUsXG4gICAgaDY6IHRydWUsIGhlYWRlcjogdHJ1ZSwgaGdyb3VwOiB0cnVlLCBocjogdHJ1ZSwgbGk6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvbDogdHJ1ZSxcbiAgICBvdXRwdXQ6IHRydWUsIHA6IHRydWUsIHByZTogdHJ1ZSwgc2VjdGlvbjogdHJ1ZSwgdGFibGU6IHRydWUsIHRmb290OiB0cnVlLCB1bDogdHJ1ZVxufTtcbmNvbnN0IGlnbm9yZVRhZ3MgPSB7XG4gICAgaGVhZDogdHJ1ZSwgbm9zY3JpcHQ6IHRydWUsIG9iamVjdDogdHJ1ZSwgc2NyaXB0OiB0cnVlLCBzdHlsZTogdHJ1ZSwgdGl0bGU6IHRydWVcbn07XG5jb25zdCBsaXN0VGFncyA9IHsgb2w6IHRydWUsIHVsOiB0cnVlIH07XG4vLyBVc2luZyBhIGJpdGZpZWxkIGZvciBub2RlIGNvbnRleHQgb3B0aW9uc1xuY29uc3QgT1BUX1BSRVNFUlZFX1dTID0gMSwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgPSAyLCBPUFRfT1BFTl9MRUZUID0gNDtcbmZ1bmN0aW9uIHdzT3B0aW9uc0Zvcih0eXBlLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIGJhc2UpIHtcbiAgICBpZiAocHJlc2VydmVXaGl0ZXNwYWNlICE9IG51bGwpXG4gICAgICAgIHJldHVybiAocHJlc2VydmVXaGl0ZXNwYWNlID8gT1BUX1BSRVNFUlZFX1dTIDogMCkgfFxuICAgICAgICAgICAgKHByZXNlcnZlV2hpdGVzcGFjZSA9PT0gXCJmdWxsXCIgPyBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IDApO1xuICAgIHJldHVybiB0eXBlICYmIHR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiID8gT1BUX1BSRVNFUlZFX1dTIHwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiBiYXNlICYgfk9QVF9PUEVOX0xFRlQ7XG59XG5jbGFzcyBOb2RlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYXR0cnMsIFxuICAgIC8vIE1hcmtzIGFwcGxpZWQgdG8gdGhpcyBub2RlIGl0c2VsZlxuICAgIG1hcmtzLCBcbiAgICAvLyBNYXJrcyB0aGF0IGNhbid0IGFwcGx5IGhlcmUsIGJ1dCB3aWxsIGJlIHVzZWQgaW4gY2hpbGRyZW4gaWYgcG9zc2libGVcbiAgICBwZW5kaW5nTWFya3MsIHNvbGlkLCBtYXRjaCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5wZW5kaW5nTWFya3MgPSBwZW5kaW5nTWFya3M7XG4gICAgICAgIHRoaXMuc29saWQgPSBzb2xpZDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIC8vIE1hcmtzIGFwcGxpZWQgdG8gdGhlIG5vZGUncyBjaGlsZHJlblxuICAgICAgICB0aGlzLmFjdGl2ZU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgICAvLyBOZXN0ZWQgTWFya3Mgd2l0aCBzYW1lIHR5cGVcbiAgICAgICAgdGhpcy5zdGFzaE1hcmtzID0gW107XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaCB8fCAob3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQgPyBudWxsIDogdHlwZS5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgICBmaW5kV3JhcHBpbmcobm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2gpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGxldCBmaWxsID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgICAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZpbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaCwgd3JhcDtcbiAgICAgICAgICAgICAgICBpZiAod3JhcCA9IHN0YXJ0LmZpbmRXcmFwcGluZyhub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSk7XG4gICAgfVxuICAgIGZpbmlzaChvcGVuRW5kKSB7XG4gICAgICAgIGlmICghKHRoaXMub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XUykpIHsgLy8gU3RyaXAgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLCBtO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5pc1RleHQgJiYgKG0gPSAvWyBcXHRcXHJcXG5cXHUwMDBjXSskLy5leGVjKGxhc3QudGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsYXN0LnRleHQubGVuZ3RoID09IG1bMF0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdID0gdGV4dC53aXRoVGV4dCh0ZXh0LnRleHQuc2xpY2UoMCwgdGV4dC50ZXh0Lmxlbmd0aCAtIG1bMF0ubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmICghb3BlbkVuZCAmJiB0aGlzLm1hdGNoKVxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuYXBwZW5kKHRoaXMubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID8gdGhpcy50eXBlLmNyZWF0ZSh0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKSA6IGNvbnRlbnQ7XG4gICAgfVxuICAgIHBvcEZyb21TdGFzaE1hcmsobWFyaykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGFzaE1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaWYgKG1hcmsuZXEodGhpcy5zdGFzaE1hcmtzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFzaE1hcmtzLnNwbGljZShpLCAxKVswXTtcbiAgICB9XG4gICAgYXBwbHlQZW5kaW5nKG5leHRUeXBlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nTWFya3M7IGkgPCBwZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFyayA9IHBlbmRpbmdbaV07XG4gICAgICAgICAgICBpZiAoKHRoaXMudHlwZSA/IHRoaXMudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpIDogbWFya01heUFwcGx5KG1hcmsudHlwZSwgbmV4dFR5cGUpKSAmJlxuICAgICAgICAgICAgICAgICFtYXJrLmlzSW5TZXQodGhpcy5hY3RpdmVNYXJrcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZU1hcmtzID0gbWFyay5hZGRUb1NldCh0aGlzLmFjdGl2ZU1hcmtzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldCh0aGlzLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5saW5lQ29udGV4dChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFswXS5pc0lubGluZTtcbiAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSAmJiAhYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG59XG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBwYXJzZXIgd2UgYXJlIHVzaW5nLlxuICAgIHBhcnNlciwgXG4gICAgLy8gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoaXMgcGFyc2UuXG4gICAgb3B0aW9ucywgaXNPcGVuKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGlzT3BlbjtcbiAgICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBvcHRpb25zLnRvcE5vZGUsIHRvcENvbnRleHQ7XG4gICAgICAgIGxldCB0b3BPcHRpb25zID0gd3NPcHRpb25zRm9yKG51bGwsIG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCAwKSB8IChpc09wZW4gPyBPUFRfT1BFTl9MRUZUIDogMCk7XG4gICAgICAgIGlmICh0b3BOb2RlKVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dCh0b3BOb2RlLnR5cGUsIHRvcE5vZGUuYXR0cnMsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBvcHRpb25zLnRvcE1hdGNoIHx8IHRvcE5vZGUudHlwZS5jb250ZW50TWF0Y2gsIHRvcE9wdGlvbnMpO1xuICAgICAgICBlbHNlIGlmIChpc09wZW4pXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KG51bGwsIG51bGwsIE1hcmsubm9uZSwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dChwYXJzZXIuc2NoZW1hLnRvcE5vZGVUeXBlLCBudWxsLCBNYXJrLm5vbmUsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbdG9wQ29udGV4dF07XG4gICAgICAgIHRoaXMuZmluZCA9IG9wdGlvbnMuZmluZFBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzW3RoaXMub3Blbl07XG4gICAgfVxuICAgIC8vIEFkZCBhIERPTSBub2RlIHRvIHRoZSBjb250ZW50LiBUZXh0IGlzIGluc2VydGVkIGFzIHRleHQgbm9kZSxcbiAgICAvLyBvdGhlcndpc2UsIHRoZSBub2RlIGlzIHBhc3NlZCB0byBgYWRkRWxlbWVudGAgb3IsIGlmIGl0IGhhcyBhXG4gICAgLy8gYHN0eWxlYCBhdHRyaWJ1dGUsIGBhZGRFbGVtZW50V2l0aFN0eWxlc2AuXG4gICAgYWRkRE9NKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gZG9tLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmtzID0gdGhpcy5yZWFkU3R5bGVzKHBhcnNlU3R5bGVzKHN0eWxlKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXJrcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBBIHN0eWxlIHdpdGggaWdub3JlOiB0cnVlXG4gICAgICAgICAgICAgICAgbGV0IFthZGRNYXJrcywgcmVtb3ZlTWFya3NdID0gbWFya3MsIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUGVuZGluZ01hcmsocmVtb3ZlTWFya3NbaV0sIHRvcCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhhZGRNYXJrc1tpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRNYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVQZW5kaW5nTWFyayhhZGRNYXJrc1tpXSwgdG9wKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZU1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdNYXJrKHJlbW92ZU1hcmtzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRUZXh0Tm9kZShkb20pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZG9tLm5vZGVWYWx1ZTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICBpZiAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCB8fFxuICAgICAgICAgICAgdG9wLmlubGluZUNvbnRleHQoZG9tKSB8fFxuICAgICAgICAgICAgL1teIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCEodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bIFxcdFxcclxcblxcdTAwMGNdKy9nLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBzdGFydHMgd2l0aCB3aGl0ZXNwYWNlLCBhbmQgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgaXQsIG9yXG4gICAgICAgICAgICAgICAgLy8gYSBoYXJkIGJyZWFrLCBvciBhIHRleHQgbm9kZSB0aGF0IGVuZHMgd2l0aCB3aGl0ZXNwYWNlLCBzdHJpcCB0aGVcbiAgICAgICAgICAgICAgICAvLyBsZWFkaW5nIHNwYWNlLlxuICAgICAgICAgICAgICAgIGlmICgvXlsgXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpICYmIHRoaXMub3BlbiA9PSB0aGlzLm5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVCZWZvcmUgPSB0b3AuY29udGVudFt0b3AuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvbU5vZGVCZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVCZWZvcmUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkb21Ob2RlQmVmb3JlICYmIGRvbU5vZGVCZWZvcmUubm9kZU5hbWUgPT0gJ0JSJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlQmVmb3JlLmlzVGV4dCAmJiAvWyBcXHRcXHJcXG5cXHUwMDBjXSQvLnRlc3Qobm9kZUJlZm9yZS50ZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csIFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydE5vZGUodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQodmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMuZmluZEluVGV4dChkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gdGFnIGFuZCB1c2UgdGhhdCB0byBwYXJzZS4gSWZcbiAgICAvLyBub25lIGlzIGZvdW5kLCB0aGUgZWxlbWVudCdzIGNvbnRlbnQgbm9kZXMgYXJlIGFkZGVkIGRpcmVjdGx5LlxuICAgIGFkZEVsZW1lbnQoZG9tLCBtYXRjaEFmdGVyKSB7XG4gICAgICAgIGxldCBuYW1lID0gZG9tLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHJ1bGVJRDtcbiAgICAgICAgaWYgKGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHRoaXMucGFyc2VyLm5vcm1hbGl6ZUxpc3RzKVxuICAgICAgICAgICAgbm9ybWFsaXplTGlzdChkb20pO1xuICAgICAgICBsZXQgcnVsZSA9ICh0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlICYmIHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUoZG9tKSkgfHxcbiAgICAgICAgICAgIChydWxlSUQgPSB0aGlzLnBhcnNlci5tYXRjaFRhZyhkb20sIHRoaXMsIG1hdGNoQWZ0ZXIpKTtcbiAgICAgICAgaWYgKHJ1bGUgPyBydWxlLmlnbm9yZSA6IGlnbm9yZVRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVGYWxsYmFjayhkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFydWxlIHx8IHJ1bGUuc2tpcCB8fCBydWxlLmNsb3NlUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocnVsZSAmJiBydWxlLmNsb3NlUGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9IE1hdGgubWF4KDAsIHRoaXMub3BlbiAtIDEpO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZSAmJiBydWxlLnNraXAubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgZG9tID0gcnVsZS5za2lwO1xuICAgICAgICAgICAgbGV0IHN5bmMsIHRvcCA9IHRoaXMudG9wLCBvbGROZWVkc0Jsb2NrID0gdGhpcy5uZWVkc0Jsb2NrO1xuICAgICAgICAgICAgaWYgKGJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3AuY29udGVudC5sZW5ndGggJiYgdG9wLmNvbnRlbnRbMF0uaXNJbmxpbmUgJiYgdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3Blbi0tO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0b3AudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRBbGwoZG9tKTtcbiAgICAgICAgICAgIGlmIChzeW5jKVxuICAgICAgICAgICAgICAgIHRoaXMuc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gb2xkTmVlZHNCbG9jaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSA/IHJ1bGVJRCA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FsbGVkIGZvciBsZWFmIERPTSBub2RlcyB0aGF0IHdvdWxkIG90aGVyd2lzZSBiZSBpZ25vcmVkXG4gICAgbGVhZkZhbGxiYWNrKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiB0aGlzLnRvcC50eXBlICYmIHRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIikpO1xuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGlnbm9yZWQgbm9kZXNcbiAgICBpZ25vcmVGYWxsYmFjayhkb20pIHtcbiAgICAgICAgLy8gSWdub3JlZCBCUiBub2RlcyBzaG91bGQgYXQgbGVhc3QgY3JlYXRlIGFuIGlubGluZSBjb250ZXh0XG4gICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmICghdGhpcy50b3AudHlwZSB8fCAhdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KSlcbiAgICAgICAgICAgIHRoaXMuZmluZFBsYWNlKHRoaXMucGFyc2VyLnNjaGVtYS50ZXh0KFwiLVwiKSk7XG4gICAgfVxuICAgIC8vIFJ1biBhbnkgc3R5bGUgcGFyc2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZSdzIHN0eWxlcy4gRWl0aGVyXG4gICAgLy8gcmV0dXJuIGFuIGFycmF5IG9mIG1hcmtzLCBvciBudWxsIHRvIGluZGljYXRlIHNvbWUgb2YgdGhlIHN0eWxlc1xuICAgIC8vIGhhZCBhIHJ1bGUgd2l0aCBgaWdub3JlYCBzZXQuXG4gICAgcmVhZFN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgbGV0IGFkZCA9IE1hcmsubm9uZSwgcmVtb3ZlID0gTWFyay5ub25lO1xuICAgICAgICBzdHlsZTogZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGFmdGVyID0gdW5kZWZpbmVkOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMucGFyc2VyLm1hdGNoU3R5bGUoc3R5bGVzW2ldLCBzdHlsZXNbaSArIDFdLCB0aGlzLCBhZnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKCFydWxlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzdHlsZTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5pZ25vcmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmNsZWFyTWFyaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcC5wZW5kaW5nTWFya3MuZm9yRWFjaChtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmNsZWFyTWFyayhtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSBtLmFkZFRvU2V0KHJlbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya10uY3JlYXRlKHJ1bGUuYXR0cnMpLmFkZFRvU2V0KGFkZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gcnVsZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYWRkLCByZW1vdmVdO1xuICAgIH1cbiAgICAvLyBMb29rIHVwIGEgaGFuZGxlciBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIG5vbmUgYXJlIGZvdW5kLCByZXR1cm5cbiAgICAvLyBmYWxzZS4gT3RoZXJ3aXNlLCBhcHBseSBpdCwgdXNlIGl0cyByZXR1cm4gdmFsdWUgdG8gZHJpdmUgdGhlIHdheVxuICAgIC8vIHRoZSBub2RlJ3MgY29udGVudCBpcyB3cmFwcGVkLCBhbmQgcmV0dXJuIHRydWUuXG4gICAgYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgbGV0IHN5bmMsIG5vZGVUeXBlLCBtYXJrO1xuICAgICAgICBpZiAocnVsZS5ub2RlKSB7XG4gICAgICAgICAgICBub2RlVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tydWxlLm5vZGVdO1xuICAgICAgICAgICAgaWYgKCFub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBzeW5jID0gdGhpcy5lbnRlcihub2RlVHlwZSwgcnVsZS5hdHRycyB8fCBudWxsLCBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5pbnNlcnROb2RlKG5vZGVUeXBlLmNyZWF0ZShydWxlLmF0dHJzKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hcmtUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm1hcmtzW3J1bGUubWFya107XG4gICAgICAgICAgICBtYXJrID0gbWFya1R5cGUuY3JlYXRlKHJ1bGUuYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nTWFyayhtYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRJbiA9IHRoaXMudG9wO1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250aW51ZUFmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tLCBjb250aW51ZUFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydWxlLmdldENvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50KGRvbSwgdGhpcy5wYXJzZXIuc2NoZW1hKS5mb3JFYWNoKG5vZGUgPT4gdGhpcy5pbnNlcnROb2RlKG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50RE9NID0gZG9tO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IGRvbS5xdWVyeVNlbGVjdG9yKHJ1bGUuY29udGVudEVsZW1lbnQpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50KGRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLmNvbnRlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmFkZEFsbChjb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3luYyAmJiB0aGlzLnN5bmMoc3RhcnRJbikpXG4gICAgICAgICAgICB0aGlzLm9wZW4tLTtcbiAgICAgICAgaWYgKG1hcmspXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBlbmRpbmdNYXJrKG1hcmssIHN0YXJ0SW4pO1xuICAgIH1cbiAgICAvLyBBZGQgYWxsIGNoaWxkIG5vZGVzIGJldHdlZW4gYHN0YXJ0SW5kZXhgIGFuZCBgZW5kSW5kZXhgIChvciB0aGVcbiAgICAvLyB3aG9sZSBub2RlLCBpZiBub3QgZ2l2ZW4pLiBJZiBgc3luY2AgaXMgcGFzc2VkLCB1c2UgaXQgdG9cbiAgICAvLyBzeW5jaHJvbml6ZSBhZnRlciBldmVyeSBibG9jayBlbGVtZW50LlxuICAgIGFkZEFsbChwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgICAgICAgZm9yIChsZXQgZG9tID0gc3RhcnRJbmRleCA/IHBhcmVudC5jaGlsZE5vZGVzW3N0YXJ0SW5kZXhdIDogcGFyZW50LmZpcnN0Q2hpbGQsIGVuZCA9IGVuZEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50LmNoaWxkTm9kZXNbZW5kSW5kZXhdOyBkb20gIT0gZW5kOyBkb20gPSBkb20ubmV4dFNpYmxpbmcsICsraW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmFkZERPTShkb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaW5kIGEgd2F5IHRvIGZpdCB0aGUgZ2l2ZW4gbm9kZSB0eXBlIGludG8gdGhlIGN1cnJlbnRcbiAgICAvLyBjb250ZXh0LiBNYXkgYWRkIGludGVybWVkaWF0ZSB3cmFwcGVycyBhbmQvb3IgbGVhdmUgbm9uLXNvbGlkXG4gICAgLy8gbm9kZXMgdGhhdCB3ZSdyZSBpbi5cbiAgICBmaW5kUGxhY2Uobm9kZSkge1xuICAgICAgICBsZXQgcm91dGUsIHN5bmM7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5vcGVuOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgY3ggPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGN4LmZpbmRXcmFwcGluZyhub2RlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAmJiAoIXJvdXRlIHx8IHJvdXRlLmxlbmd0aCA+IGZvdW5kLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByb3V0ZSA9IGZvdW5kO1xuICAgICAgICAgICAgICAgIHN5bmMgPSBjeDtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3guc29saWQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyb3V0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jKHN5bmMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5lbnRlcklubmVyKHJvdXRlW2ldLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gaW5zZXJ0IHRoZSBnaXZlbiBub2RlLCBhZGp1c3RpbmcgdGhlIGNvbnRleHQgd2hlbiBuZWVkZWQuXG4gICAgaW5zZXJ0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmlzSW5saW5lICYmIHRoaXMubmVlZHNCbG9jayAmJiAhdGhpcy50b3AudHlwZSkge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdGhpcy50ZXh0YmxvY2tGcm9tQ29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJJbm5lcihibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmluZFBsYWNlKG5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgIHRvcC5hcHBseVBlbmRpbmcobm9kZS50eXBlKTtcbiAgICAgICAgICAgIGlmICh0b3AubWF0Y2gpXG4gICAgICAgICAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gdG9wLmFjdGl2ZU1hcmtzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICghdG9wLnR5cGUgfHwgdG9wLnR5cGUuYWxsb3dzTWFya1R5cGUobm9kZS5tYXJrc1tpXS50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBub2RlLm1hcmtzW2ldLmFkZFRvU2V0KG1hcmtzKTtcbiAgICAgICAgICAgIHRvcC5jb250ZW50LnB1c2gobm9kZS5tYXJrKG1hcmtzKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRyeSB0byBzdGFydCBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUsIGFkanVzdGluZyB0aGUgY29udGV4dCB3aGVuXG4gICAgLy8gbmVjZXNzYXJ5LlxuICAgIGVudGVyKHR5cGUsIGF0dHJzLCBwcmVzZXJ2ZVdTKSB7XG4gICAgICAgIGxldCBvayA9IHRoaXMuZmluZFBsYWNlKHR5cGUuY3JlYXRlKGF0dHJzKSk7XG4gICAgICAgIGlmIChvaylcbiAgICAgICAgICAgIHRoaXMuZW50ZXJJbm5lcih0eXBlLCBhdHRycywgdHJ1ZSwgcHJlc2VydmVXUyk7XG4gICAgICAgIHJldHVybiBvaztcbiAgICB9XG4gICAgLy8gT3BlbiBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGVcbiAgICBlbnRlcklubmVyKHR5cGUsIGF0dHJzID0gbnVsbCwgc29saWQgPSBmYWxzZSwgcHJlc2VydmVXUykge1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICB0b3AuYXBwbHlQZW5kaW5nKHR5cGUpO1xuICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2ggJiYgdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXUywgdG9wLm9wdGlvbnMpO1xuICAgICAgICBpZiAoKHRvcC5vcHRpb25zICYgT1BUX09QRU5fTEVGVCkgJiYgdG9wLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICBvcHRpb25zIHw9IE9QVF9PUEVOX0xFRlQ7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgTm9kZUNvbnRleHQodHlwZSwgYXR0cnMsIHRvcC5hY3RpdmVNYXJrcywgdG9wLnBlbmRpbmdNYXJrcywgc29saWQsIG51bGwsIG9wdGlvbnMpKTtcbiAgICAgICAgdGhpcy5vcGVuKys7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhbGwgbm9kZXMgYWJvdmUgdGhpcy5vcGVuIGFyZSBmaW5pc2hlZCBhbmQgYWRkZWQgdG9cbiAgICAvLyB0aGVpciBwYXJlbnRzXG4gICAgY2xvc2VFeHRyYShvcGVuRW5kID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpID4gdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+IHRoaXMub3BlbjsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbaSAtIDFdLmNvbnRlbnQucHVzaCh0aGlzLm5vZGVzW2ldLmZpbmlzaChvcGVuRW5kKSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmxlbmd0aCA9IHRoaXMub3BlbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLm9wZW4gPSAwO1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEodGhpcy5pc09wZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5maW5pc2godGhpcy5pc09wZW4gfHwgdGhpcy5vcHRpb25zLnRvcE9wZW4pO1xuICAgIH1cbiAgICBzeW5jKHRvKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbaV0gPT0gdG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBjdXJyZW50UG9zKCkge1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHRoaXMubm9kZXNbaV0uY29udGVudDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBjb250ZW50Lmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgICAgIHBvcyArPSBjb250ZW50W2pdLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgZmluZEF0UG9pbnQocGFyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHBhcmVudCAmJiB0aGlzLmZpbmRbaV0ub2Zmc2V0ID09IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEluc2lkZShwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kQXJvdW5kKHBhcmVudCwgY29udGVudCwgYmVmb3JlKSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gY29udGVudCAmJiB0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gY29udGVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLmZpbmRbaV0ubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgJiAoYmVmb3JlID8gMiA6IDQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJblRleHQodGV4dE5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHRleHROb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zIC0gKHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSB0aGlzLmZpbmRbaV0ub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBjb250ZXh0IHN0cmluZyBtYXRjaGVzIHRoaXMgY29udGV4dC5cbiAgICBtYXRjaGVzQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmluZGV4T2YoXCJ8XCIpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5zcGxpdCgvXFxzKlxcfFxccyovKS5zb21lKHRoaXMubWF0Y2hlc0NvbnRleHQsIHRoaXMpO1xuICAgICAgICBsZXQgcGFydHMgPSBjb250ZXh0LnNwbGl0KFwiL1wiKTtcbiAgICAgICAgbGV0IG9wdGlvbiA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgICBsZXQgdXNlUm9vdCA9ICF0aGlzLmlzT3BlbiAmJiAoIW9wdGlvbiB8fCBvcHRpb24ucGFyZW50LnR5cGUgPT0gdGhpcy5ub2Rlc1swXS50eXBlKTtcbiAgICAgICAgbGV0IG1pbkRlcHRoID0gLShvcHRpb24gPyBvcHRpb24uZGVwdGggKyAxIDogMCkgKyAodXNlUm9vdCA/IDAgOiAxKTtcbiAgICAgICAgbGV0IG1hdGNoID0gKGksIGRlcHRoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gcGFydHMubGVuZ3RoIC0gMSB8fCBpID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGRlcHRoID49IG1pbkRlcHRoOyBkZXB0aC0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKGkgLSAxLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gZGVwdGggPiAwIHx8IChkZXB0aCA9PSAwICYmIHVzZVJvb3QpID8gdGhpcy5ub2Rlc1tkZXB0aF0udHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb24gJiYgZGVwdGggPj0gbWluRGVwdGggPyBvcHRpb24ubm9kZShkZXB0aCAtIG1pbkRlcHRoKS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgKG5leHQubmFtZSAhPSBwYXJ0ICYmIG5leHQuZ3JvdXBzLmluZGV4T2YocGFydCkgPT0gLTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWF0Y2gocGFydHMubGVuZ3RoIC0gMSwgdGhpcy5vcGVuKTtcbiAgICB9XG4gICAgdGV4dGJsb2NrRnJvbUNvbnRleHQoKSB7XG4gICAgICAgIGxldCAkY29udGV4dCA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgICBpZiAoJGNvbnRleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlZmx0ID0gJGNvbnRleHQubm9kZShkKS5jb250ZW50TWF0Y2hBdCgkY29udGV4dC5pbmRleEFmdGVyKGQpKS5kZWZhdWx0VHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2sgJiYgZGVmbHQuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmbHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmIHR5cGUuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFBlbmRpbmdNYXJrKG1hcmspIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmluZFNhbWVNYXJrSW5TZXQobWFyaywgdGhpcy50b3AucGVuZGluZ01hcmtzKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgdGhpcy50b3Auc3Rhc2hNYXJrcy5wdXNoKGZvdW5kKTtcbiAgICAgICAgdGhpcy50b3AucGVuZGluZ01hcmtzID0gbWFyay5hZGRUb1NldCh0aGlzLnRvcC5wZW5kaW5nTWFya3MpO1xuICAgIH1cbiAgICByZW1vdmVQZW5kaW5nTWFyayhtYXJrLCB1cHRvKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5vcGVuOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSB0aGlzLm5vZGVzW2RlcHRoXTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGxldmVsLnBlbmRpbmdNYXJrcy5sYXN0SW5kZXhPZihtYXJrKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwucGVuZGluZ01hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KGxldmVsLnBlbmRpbmdNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5hY3RpdmVNYXJrcyA9IG1hcmsucmVtb3ZlRnJvbVNldChsZXZlbC5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXNoTWFyayA9IGxldmVsLnBvcEZyb21TdGFzaE1hcmsobWFyayk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXNoTWFyayAmJiBsZXZlbC50eXBlICYmIGxldmVsLnR5cGUuYWxsb3dzTWFya1R5cGUoc3Rhc2hNYXJrLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBsZXZlbC5hY3RpdmVNYXJrcyA9IHN0YXNoTWFyay5hZGRUb1NldChsZXZlbC5hY3RpdmVNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGV2ZWwgPT0gdXB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBkaXJlY3RseSBuZXN0ZWQgbGlzdCBub2RlcyBwcm9kdWNlZCBieSBzb21lXG4vLyB0b29scyBhbmQgYWxsb3dlZCBieSBicm93c2VycyB0byBtZWFuIHRoYXQgdGhlIG5lc3RlZCBsaXN0IGlzXG4vLyBhY3R1YWxseSBwYXJ0IG9mIHRoZSBsaXN0IGl0ZW0gYWJvdmUgaXQuXG5mdW5jdGlvbiBub3JtYWxpemVMaXN0KGRvbSkge1xuICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQsIHByZXZJdGVtID0gbnVsbDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBjaGlsZC5ub2RlVHlwZSA9PSAxID8gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICAgIGlmIChuYW1lICYmIGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHByZXZJdGVtKSB7XG4gICAgICAgICAgICBwcmV2SXRlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICBjaGlsZCA9IHByZXZJdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJsaVwiKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEFwcGx5IGEgQ1NTIHNlbGVjdG9yLlxuZnVuY3Rpb24gbWF0Y2hlcyhkb20sIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIChkb20ubWF0Y2hlcyB8fCBkb20ubXNNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBkb20ubW96TWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGRvbSwgc2VsZWN0b3IpO1xufVxuLy8gVG9rZW5pemUgYSBzdHlsZSBhdHRyaWJ1dGUgaW50byBwcm9wZXJ0eS92YWx1ZSBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlU3R5bGVzKHN0eWxlKSB7XG4gICAgbGV0IHJlID0gL1xccyooW1xcdy1dKylcXHMqOlxccyooW147XSspL2csIG0sIHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChtID0gcmUuZXhlYyhzdHlsZSkpXG4gICAgICAgIHJlc3VsdC5wdXNoKG1bMV0sIG1bMl0udHJpbSgpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuLy8gVXNlZCB3aGVuIGZpbmRpbmcgYSBtYXJrIGF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmcmFnbWVudCBwYXJzZS5cbi8vIENoZWNrcyB3aGV0aGVyIGl0IHdvdWxkIGJlIHJlYXNvbmFibGUgdG8gYXBwbHkgYSBnaXZlbiBtYXJrIHR5cGUgdG9cbi8vIGEgZ2l2ZW4gbm9kZSwgYnkgbG9va2luZyBhdCB0aGUgd2F5IHRoZSBtYXJrIG9jY3VycyBpbiB0aGUgc2NoZW1hLlxuZnVuY3Rpb24gbWFya01heUFwcGx5KG1hcmtUeXBlLCBub2RlVHlwZSkge1xuICAgIGxldCBub2RlcyA9IG5vZGVUeXBlLnNjaGVtYS5ub2RlcztcbiAgICBmb3IgKGxldCBuYW1lIGluIG5vZGVzKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFwYXJlbnQuYWxsb3dzTWFya1R5cGUobWFya1R5cGUpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBzZWVuID0gW10sIHNjYW4gPSAobWF0Y2gpID0+IHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChtYXRjaCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBub2RlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihuZXh0KSA8IDAgJiYgc2NhbihuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzY2FuKHBhcmVudC5jb250ZW50TWF0Y2gpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZFNhbWVNYXJrSW5TZXQobWFyaywgc2V0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1hcmsuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgIHJldHVybiBzZXRbaV07XG4gICAgfVxufVxuXG4vKipcbkEgRE9NIHNlcmlhbGl6ZXIga25vd3MgaG93IHRvIGNvbnZlcnQgUHJvc2VNaXJyb3Igbm9kZXMgYW5kXG5tYXJrcyBvZiB2YXJpb3VzIHR5cGVzIHRvIERPTSBub2Rlcy5cbiovXG5jbGFzcyBET01TZXJpYWxpemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXJpYWxpemVyLiBgbm9kZXNgIHNob3VsZCBtYXAgbm9kZSBuYW1lcyB0byBmdW5jdGlvbnNcbiAgICB0aGF0IHRha2UgYSBub2RlIGFuZCByZXR1cm4gYSBkZXNjcmlwdGlvbiBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICAgIERPTS4gYG1hcmtzYCBkb2VzIHRoZSBzYW1lIGZvciBtYXJrIG5hbWVzLCBidXQgYWxzbyBnZXRzIGFuXG4gICAgYXJndW1lbnQgdGhhdCB0ZWxscyBpdCB3aGV0aGVyIHRoZSBtYXJrJ3MgY29udGVudCBpcyBibG9jayBvclxuICAgIGlubGluZSBjb250ZW50IChmb3IgdHlwaWNhbCB1c2UsIGl0J2xsIGFsd2F5cyBiZSBpbmxpbmUpLiBBIG1hcmtcbiAgICBzZXJpYWxpemVyIG1heSBiZSBgbnVsbGAgdG8gaW5kaWNhdGUgdGhhdCBtYXJrcyBvZiB0aGF0IHR5cGVcbiAgICBzaG91bGQgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbm9kZSBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG5vZGVzLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG1hcmtzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhlIGNvbnRlbnQgb2YgdGhpcyBmcmFnbWVudCB0byBhIERPTSBmcmFnbWVudC4gV2hlblxuICAgIG5vdCBpbiB0aGUgYnJvd3NlciwgdGhlIGBkb2N1bWVudGAgb3B0aW9uLCBjb250YWluaW5nIGEgRE9NXG4gICAgZG9jdW1lbnQsIHNob3VsZCBiZSBwYXNzZWQgc28gdGhhdCB0aGUgc2VyaWFsaXplciBjYW4gY3JlYXRlXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBzZXJpYWxpemVGcmFnbWVudChmcmFnbWVudCwgb3B0aW9ucyA9IHt9LCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSBkb2Mob3B0aW9ucykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgdG9wID0gdGFyZ2V0LCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoIHx8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtlZXAgPSAwLCByZW5kZXJlZCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoICYmIHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLm1hcmtzW3JlbmRlcmVkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hcmtzW25leHQudHlwZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5lcShhY3RpdmVba2VlcF1bMF0pIHx8IG5leHQudHlwZS5zcGVjLnNwYW5uaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwKys7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gYWN0aXZlLnBvcCgpWzFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGQgPSBub2RlLm1hcmtzW3JlbmRlcmVkKytdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFya0RPTSA9IHRoaXMuc2VyaWFsaXplTWFyayhhZGQsIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFya0RPTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2goW2FkZCwgdG9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQobWFya0RPTS5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gbWFya0RPTS5jb250ZW50RE9NIHx8IG1hcmtET00uZG9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wLmFwcGVuZENoaWxkKHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHsgZG9tLCBjb250ZW50RE9NIH0gPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0aGlzLm5vZGVzW25vZGUudHlwZS5uYW1lXShub2RlKSk7XG4gICAgICAgIGlmIChjb250ZW50RE9NKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbm90IGFsbG93ZWQgaW4gYSBsZWFmIG5vZGUgc3BlY1wiKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplRnJhZ21lbnQobm9kZS5jb250ZW50LCBvcHRpb25zLCBjb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBub2RlIHRvIGEgRE9NIG5vZGUuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdVxuICAgIG5lZWQgdG8gc2VyaWFsaXplIGEgcGFydCBvZiBhIGRvY3VtZW50LCBhcyBvcHBvc2VkIHRvIHRoZSB3aG9sZVxuICAgIGRvY3VtZW50LiBUbyBzZXJpYWxpemUgYSB3aG9sZSBkb2N1bWVudCwgdXNlXG4gICAgW2BzZXJpYWxpemVGcmFnbWVudGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01TZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KSBvblxuICAgIGl0cyBbY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUuY29udGVudCkuXG4gICAgKi9cbiAgICBzZXJpYWxpemVOb2RlKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5zZXJpYWxpemVOb2RlSW5uZXIobm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBub2RlLm1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcCA9IHRoaXMuc2VyaWFsaXplTWFyayhub2RlLm1hcmtzW2ldLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh3cmFwKSB7XG4gICAgICAgICAgICAgICAgKHdyYXAuY29udGVudERPTSB8fCB3cmFwLmRvbSkuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwLmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlcmlhbGl6ZU1hcmsobWFyaywgaW5saW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHRvRE9NID0gdGhpcy5tYXJrc1ttYXJrLnR5cGUubmFtZV07XG4gICAgICAgIHJldHVybiB0b0RPTSAmJiBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0b0RPTShtYXJrLCBpbmxpbmUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVuZGVyIGFuIFtvdXRwdXQgc3BlY10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTU91dHB1dFNwZWMpIHRvIGEgRE9NIG5vZGUuIElmXG4gICAgdGhlIHNwZWMgaGFzIGEgaG9sZSAoemVybykgaW4gaXQsIGBjb250ZW50RE9NYCB3aWxsIHBvaW50IGF0IHRoZVxuICAgIG5vZGUgd2l0aCB0aGUgaG9sZS5cbiAgICAqL1xuICAgIHN0YXRpYyByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUyA9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJ1Y3R1cmUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiB7IGRvbTogZG9jLmNyZWF0ZVRleHROb2RlKHN0cnVjdHVyZSkgfTtcbiAgICAgICAgaWYgKHN0cnVjdHVyZS5ub2RlVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBzdHJ1Y3R1cmUgfTtcbiAgICAgICAgaWYgKHN0cnVjdHVyZS5kb20gJiYgc3RydWN0dXJlLmRvbS5ub2RlVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZTtcbiAgICAgICAgbGV0IHRhZ05hbWUgPSBzdHJ1Y3R1cmVbMF0sIHNwYWNlID0gdGFnTmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgICAgICAgaWYgKHNwYWNlID4gMCkge1xuICAgICAgICAgICAgeG1sTlMgPSB0YWdOYW1lLnNsaWNlKDAsIHNwYWNlKTtcbiAgICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnNsaWNlKHNwYWNlICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnRET007XG4gICAgICAgIGxldCBkb20gPSAoeG1sTlMgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHhtbE5TLCB0YWdOYW1lKSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpKTtcbiAgICAgICAgbGV0IGF0dHJzID0gc3RydWN0dXJlWzFdLCBzdGFydCA9IDE7XG4gICAgICAgIGlmIChhdHRycyAmJiB0eXBlb2YgYXR0cnMgPT0gXCJvYmplY3RcIiAmJiBhdHRycy5ub2RlVHlwZSA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgICAgICAgICAgc3RhcnQgPSAyO1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycylcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2UgPSBuYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BhY2UgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZU5TKG5hbWUuc2xpY2UoMCwgc3BhY2UpLCBuYW1lLnNsaWNlKHNwYWNlICsgMSksIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0cnVjdHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gc3RydWN0dXJlW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBzdHJ1Y3R1cmUubGVuZ3RoIC0gMSB8fCBpID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG11c3QgYmUgdGhlIG9ubHkgY2hpbGQgb2YgaXRzIHBhcmVudCBub2RlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbSwgY29udGVudERPTTogZG9tIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBkb206IGlubmVyLCBjb250ZW50RE9NOiBpbm5lckNvbnRlbnQgfSA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2MsIGNoaWxkLCB4bWxOUyk7XG4gICAgICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdWx0aXBsZSBjb250ZW50IGhvbGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gaW5uZXJDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb20sIGNvbnRlbnRET00gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBzZXJpYWxpemVyIHVzaW5nIHRoZSBbYHRvRE9NYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnRvRE9NKVxuICAgIHByb3BlcnRpZXMgaW4gYSBzY2hlbWEncyBub2RlIGFuZCBtYXJrIHNwZWNzLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgfHxcbiAgICAgICAgICAgIChzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgPSBuZXcgRE9NU2VyaWFsaXplcih0aGlzLm5vZGVzRnJvbVNjaGVtYShzY2hlbWEpLCB0aGlzLm1hcmtzRnJvbVNjaGVtYShzY2hlbWEpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdhdGhlciB0aGUgc2VyaWFsaXplcnMgaW4gYSBzY2hlbWEncyBub2RlIHNwZWNzIGludG8gYW4gb2JqZWN0LlxuICAgIFRoaXMgY2FuIGJlIHVzZWZ1bCBhcyBhIGJhc2UgdG8gYnVpbGQgYSBjdXN0b20gc2VyaWFsaXplciBmcm9tLlxuICAgICovXG4gICAgc3RhdGljIG5vZGVzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGdhdGhlclRvRE9NKHNjaGVtYS5ub2Rlcyk7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICByZXN1bHQudGV4dCA9IG5vZGUgPT4gbm9kZS50ZXh0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3MgbWFyayBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBnYXRoZXJUb0RPTShzY2hlbWEubWFya3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlclRvRE9NKG9iaikge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBuYW1lIGluIG9iaikge1xuICAgICAgICBsZXQgdG9ET00gPSBvYmpbbmFtZV0uc3BlYy50b0RPTTtcbiAgICAgICAgaWYgKHRvRE9NKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdG9ET007XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkb2Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudDtcbn1cblxuZXhwb3J0IHsgQ29udGVudE1hdGNoLCBET01QYXJzZXIsIERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBNYXJrVHlwZSwgTm9kZSwgTm9kZVJhbmdlLCBOb2RlVHlwZSwgUmVwbGFjZUVycm9yLCBSZXNvbHZlZFBvcywgU2NoZW1hLCBTbGljZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-model/dist/index.js\n')},"./node_modules/prosemirror-state/dist/index.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: function() { return /* binding */ AllSelection; },\n/* harmony export */   EditorState: function() { return /* binding */ EditorState; },\n/* harmony export */   NodeSelection: function() { return /* binding */ NodeSelection; },\n/* harmony export */   Plugin: function() { return /* binding */ Plugin; },\n/* harmony export */   PluginKey: function() { return /* binding */ PluginKey; },\n/* harmony export */   Selection: function() { return /* binding */ Selection; },\n/* harmony export */   SelectionRange: function() { return /* binding */ SelectionRange; },\n/* harmony export */   TextSelection: function() { return /* binding */ TextSelection; },\n/* harmony export */   Transaction: function() { return /* binding */ Transaction; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");\n\n\n\nconst classesById = Object.create(null);\n/**\nSuperclass for editor selections. Every selection type should\nextend this. Should not be instantiated directly.\n*/\nclass Selection {\n    /**\n    Initialize a selection with the head and anchor and ranges. If no\n    ranges are given, constructs a single range across `$anchor` and\n    `$head`.\n    */\n    constructor(\n    /**\n    The resolved anchor of the selection (the side that stays in\n    place when the selection is modified).\n    */\n    $anchor, \n    /**\n    The resolved head of the selection (the side that moves when\n    the selection is modified).\n    */\n    $head, ranges) {\n        this.$anchor = $anchor;\n        this.$head = $head;\n        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n    }\n    /**\n    The selection\'s anchor, as an unresolved position.\n    */\n    get anchor() { return this.$anchor.pos; }\n    /**\n    The selection\'s head.\n    */\n    get head() { return this.$head.pos; }\n    /**\n    The lower bound of the selection\'s main range.\n    */\n    get from() { return this.$from.pos; }\n    /**\n    The upper bound of the selection\'s main range.\n    */\n    get to() { return this.$to.pos; }\n    /**\n    The resolved lower  bound of the selection\'s main range.\n    */\n    get $from() {\n        return this.ranges[0].$from;\n    }\n    /**\n    The resolved upper bound of the selection\'s main range.\n    */\n    get $to() {\n        return this.ranges[0].$to;\n    }\n    /**\n    Indicates whether the selection contains any content.\n    */\n    get empty() {\n        let ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++)\n            if (ranges[i].$from.pos != ranges[i].$to.pos)\n                return false;\n        return true;\n    }\n    /**\n    Get the content of this selection as a slice.\n    */\n    content() {\n        return this.$from.doc.slice(this.from, this.to, true);\n    }\n    /**\n    Replace the selection with a slice or, if no slice is given,\n    delete the selection. Will append to the given transaction.\n    */\n    replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        // Put the new selection at the position after the inserted\n        // content. When that ended in an inline node, search backwards,\n        // to get the position after that node. If not, search forward.\n        let lastNode = content.content.lastChild, lastParent = null;\n        for (let i = 0; i < content.openEnd; i++) {\n            lastParent = lastNode;\n            lastNode = lastNode.lastChild;\n        }\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : content);\n            if (i == 0)\n                selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n        }\n    }\n    /**\n    Replace the selection with the given node, appending the changes\n    to the given transaction.\n    */\n    replaceWith(tr, node) {\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            let from = mapping.map($from.pos), to = mapping.map($to.pos);\n            if (i) {\n                tr.deleteRange(from, to);\n            }\n            else {\n                tr.replaceRangeWith(from, to, node);\n                selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n            }\n        }\n    }\n    /**\n    Find a valid cursor or leaf node selection starting at the given\n    position and searching back if `dir` is negative, and forward if\n    positive. When `textOnly` is true, only consider cursor\n    selections. Will return null when no valid selection position is\n    found.\n    */\n    static findFrom($pos, dir, textOnly = false) {\n        let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n            : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n        if (inner)\n            return inner;\n        for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n            let found = dir < 0\n                ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n                : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n            if (found)\n                return found;\n        }\n        return null;\n    }\n    /**\n    Find a valid cursor or leaf node selection near the given\n    position. Searches forward first by default, but if `bias` is\n    negative, it will search backwards first.\n    */\n    static near($pos, bias = 1) {\n        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n    }\n    /**\n    Find the cursor or leaf node selection closest to the start of\n    the given document. Will return an\n    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n    exists.\n    */\n    static atStart(doc) {\n        return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n    }\n    /**\n    Find the cursor or leaf node selection closest to the end of the\n    given document.\n    */\n    static atEnd(doc) {\n        return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n    }\n    /**\n    Deserialize the JSON representation of a selection. Must be\n    implemented for custom classes (as a static class method).\n    */\n    static fromJSON(doc, json) {\n        if (!json || !json.type)\n            throw new RangeError("Invalid input for Selection.fromJSON");\n        let cls = classesById[json.type];\n        if (!cls)\n            throw new RangeError(`No selection type ${json.type} defined`);\n        return cls.fromJSON(doc, json);\n    }\n    /**\n    To be able to deserialize selections from JSON, custom selection\n    classes must register themselves with an ID string, so that they\n    can be disambiguated. Try to pick something that\'s unlikely to\n    clash with classes from other modules.\n    */\n    static jsonID(id, selectionClass) {\n        if (id in classesById)\n            throw new RangeError("Duplicate use of selection JSON ID " + id);\n        classesById[id] = selectionClass;\n        selectionClass.prototype.jsonID = id;\n        return selectionClass;\n    }\n    /**\n    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n    which is a value that can be mapped without having access to a\n    current document, and later resolved to a real selection for a\n    given document again. (This is used mostly by the history to\n    track and restore old selections.) The default implementation of\n    this method just converts the selection to a text selection and\n    returns the bookmark for that.\n    */\n    getBookmark() {\n        return TextSelection.between(this.$anchor, this.$head).getBookmark();\n    }\n}\nSelection.prototype.visible = true;\n/**\nRepresents a selected range in a document.\n*/\nclass SelectionRange {\n    /**\n    Create a range.\n    */\n    constructor(\n    /**\n    The lower bound of the range.\n    */\n    $from, \n    /**\n    The upper bound of the range.\n    */\n    $to) {\n        this.$from = $from;\n        this.$to = $to;\n    }\n}\nlet warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n        warnedAboutTextSelection = true;\n        console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");\n    }\n}\n/**\nA text selection represents a classical editor selection, with a\nhead (the moving side) and anchor (immobile side), both of which\npoint into textblock nodes. It can be empty (a regular cursor\nposition).\n*/\nclass TextSelection extends Selection {\n    /**\n    Construct a text selection between the given points.\n    */\n    constructor($anchor, $head = $anchor) {\n        checkTextSelection($anchor);\n        checkTextSelection($head);\n        super($anchor, $head);\n    }\n    /**\n    Returns a resolved position if this is a cursor selection (an\n    empty text selection), and null otherwise.\n    */\n    get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null; }\n    map(doc, mapping) {\n        let $head = doc.resolve(mapping.map(this.head));\n        if (!$head.parent.inlineContent)\n            return Selection.near($head);\n        let $anchor = doc.resolve(mapping.map(this.anchor));\n        return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n    }\n    replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        super.replace(tr, content);\n        if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n            let marks = this.$from.marksAcross(this.$to);\n            if (marks)\n                tr.ensureMarks(marks);\n        }\n    }\n    eq(other) {\n        return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n    }\n    getBookmark() {\n        return new TextBookmark(this.anchor, this.head);\n    }\n    toJSON() {\n        return { type: "text", anchor: this.anchor, head: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != "number" || typeof json.head != "number")\n            throw new RangeError("Invalid input for TextSelection.fromJSON");\n        return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n    }\n    /**\n    Create a text selection from non-resolved positions.\n    */\n    static create(doc, anchor, head = anchor) {\n        let $anchor = doc.resolve(anchor);\n        return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n    }\n    /**\n    Return a text selection that spans the given positions or, if\n    they aren\'t text positions, find a text selection near them.\n    `bias` determines whether the method searches forward (default)\n    or backwards (negative number) first. Will fall back to calling\n    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n    doesn\'t contain a valid text position.\n    */\n    static between($anchor, $head, bias) {\n        let dPos = $anchor.pos - $head.pos;\n        if (!bias || dPos)\n            bias = dPos >= 0 ? 1 : -1;\n        if (!$head.parent.inlineContent) {\n            let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n            if (found)\n                $head = found.$head;\n            else\n                return Selection.near($head, bias);\n        }\n        if (!$anchor.parent.inlineContent) {\n            if (dPos == 0) {\n                $anchor = $head;\n            }\n            else {\n                $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n                if (($anchor.pos < $head.pos) != (dPos < 0))\n                    $anchor = $head;\n            }\n        }\n        return new TextSelection($anchor, $head);\n    }\n}\nSelection.jsonID("text", TextSelection);\nclass TextBookmark {\n    constructor(anchor, head) {\n        this.anchor = anchor;\n        this.head = head;\n    }\n    map(mapping) {\n        return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n    resolve(doc) {\n        return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n    }\n}\n/**\nA node selection is a selection that points at a single node. All\nnodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the\ntarget of a node selection. In such a selection, `from` and `to`\npoint directly before and after the selected node, `anchor` equals\n`from`, and `head` equals `to`..\n*/\nclass NodeSelection extends Selection {\n    /**\n    Create a node selection. Does not verify the validity of its\n    argument.\n    */\n    constructor($pos) {\n        let node = $pos.nodeAfter;\n        let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n        super($pos, $end);\n        this.node = node;\n    }\n    map(doc, mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        let $pos = doc.resolve(pos);\n        if (deleted)\n            return Selection.near($pos);\n        return new NodeSelection($pos);\n    }\n    content() {\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(this.node), 0, 0);\n    }\n    eq(other) {\n        return other instanceof NodeSelection && other.anchor == this.anchor;\n    }\n    toJSON() {\n        return { type: "node", anchor: this.anchor };\n    }\n    getBookmark() { return new NodeBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != "number")\n            throw new RangeError("Invalid input for NodeSelection.fromJSON");\n        return new NodeSelection(doc.resolve(json.anchor));\n    }\n    /**\n    Create a node selection from non-resolved positions.\n    */\n    static create(doc, from) {\n        return new NodeSelection(doc.resolve(from));\n    }\n    /**\n    Determines whether the given node may be selected as a node\n    selection.\n    */\n    static isSelectable(node) {\n        return !node.isText && node.type.spec.selectable !== false;\n    }\n}\nNodeSelection.prototype.visible = false;\nSelection.jsonID("node", NodeSelection);\nclass NodeBookmark {\n    constructor(anchor) {\n        this.anchor = anchor;\n    }\n    map(mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n        if (node && NodeSelection.isSelectable(node))\n            return new NodeSelection($pos);\n        return Selection.near($pos);\n    }\n}\n/**\nA selection type that represents selecting the whole document\n(which can not necessarily be expressed with a text selection, when\nthere are for example leaf block nodes at the start or end of the\ndocument).\n*/\nclass AllSelection extends Selection {\n    /**\n    Create an all-selection over the given document.\n    */\n    constructor(doc) {\n        super(doc.resolve(0), doc.resolve(doc.content.size));\n    }\n    replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n            tr.delete(0, tr.doc.content.size);\n            let sel = Selection.atStart(tr.doc);\n            if (!sel.eq(tr.selection))\n                tr.setSelection(sel);\n        }\n        else {\n            super.replace(tr, content);\n        }\n    }\n    toJSON() { return { type: "all" }; }\n    /**\n    @internal\n    */\n    static fromJSON(doc) { return new AllSelection(doc); }\n    map(doc) { return new AllSelection(doc); }\n    eq(other) { return other instanceof AllSelection; }\n    getBookmark() { return AllBookmark; }\n}\nSelection.jsonID("all", AllSelection);\nconst AllBookmark = {\n    map() { return this; },\n    resolve(doc) { return new AllSelection(doc); }\n};\n// FIXME we\'ll need some awareness of text direction when scanning for selections\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text = false) {\n    if (node.inlineContent)\n        return TextSelection.create(doc, pos);\n    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n        let child = node.child(i);\n        if (!child.isAtom) {\n            let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n            if (inner)\n                return inner;\n        }\n        else if (!text && NodeSelection.isSelectable(child)) {\n            return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n        }\n        pos += child.nodeSize * dir;\n    }\n    return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    let last = tr.steps.length - 1;\n    if (last < startLen)\n        return;\n    let step = tr.steps[last];\n    if (!(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceStep || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep))\n        return;\n    let map = tr.mapping.maps[last], end;\n    map.forEach((_from, _to, _newFrom, newTo) => { if (end == null)\n        end = newTo; });\n    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;\n/**\nAn editor state transaction, which can be applied to a state to\ncreate an updated state. Use\n[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.\n\nTransactions track changes to the document (they are a subclass of\n[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,\nlike selection updates and adjustments of the set of [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store\nmetadata properties in a transaction, which are extra pieces of\ninformation that client code or plugins can use to describe what a\ntransaction represents, so that they can update their [own\nstate](https://prosemirror.net/docs/ref/#state.StateField) accordingly.\n\nThe [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata properties:\nit will attach a property `"pointer"` with the value `true` to\nselection transactions directly caused by mouse or touch input, and\na `"uiEvent"` property of that may be `"paste"`, `"cut"`, or `"drop"`.\n*/\nclass Transaction extends prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Transform {\n    /**\n    @internal\n    */\n    constructor(state) {\n        super(state.doc);\n        // The step count for which the current selection is valid.\n        this.curSelectionFor = 0;\n        // Bitfield to track which aspects of the state were updated by\n        // this transaction.\n        this.updated = 0;\n        // Object used to store metadata properties for the transaction.\n        this.meta = Object.create(null);\n        this.time = Date.now();\n        this.curSelection = state.selection;\n        this.storedMarks = state.storedMarks;\n    }\n    /**\n    The transaction\'s current selection. This defaults to the editor\n    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the\n    transaction, but can be overwritten with\n    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).\n    */\n    get selection() {\n        if (this.curSelectionFor < this.steps.length) {\n            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n            this.curSelectionFor = this.steps.length;\n        }\n        return this.curSelection;\n    }\n    /**\n    Update the transaction\'s current selection. Will determine the\n    selection that the editor gets when the transaction is applied.\n    */\n    setSelection(selection) {\n        if (selection.$from.doc != this.doc)\n            throw new RangeError("Selection passed to setSelection must point at the current document");\n        this.curSelection = selection;\n        this.curSelectionFor = this.steps.length;\n        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n        this.storedMarks = null;\n        return this;\n    }\n    /**\n    Whether the selection was explicitly updated by this transaction.\n    */\n    get selectionSet() {\n        return (this.updated & UPDATED_SEL) > 0;\n    }\n    /**\n    Set the current stored marks.\n    */\n    setStoredMarks(marks) {\n        this.storedMarks = marks;\n        this.updated |= UPDATED_MARKS;\n        return this;\n    }\n    /**\n    Make sure the current stored marks or, if that is null, the marks\n    at the selection, match the given set of marks. Does nothing if\n    this is already the case.\n    */\n    ensureMarks(marks) {\n        if (!prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n            this.setStoredMarks(marks);\n        return this;\n    }\n    /**\n    Add a mark to the set of stored marks.\n    */\n    addStoredMark(mark) {\n        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Remove a mark or mark type from the set of stored marks.\n    */\n    removeStoredMark(mark) {\n        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Whether the stored marks were explicitly set for this transaction.\n    */\n    get storedMarksSet() {\n        return (this.updated & UPDATED_MARKS) > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        super.addStep(step, doc);\n        this.updated = this.updated & ~UPDATED_MARKS;\n        this.storedMarks = null;\n    }\n    /**\n    Update the timestamp for the transaction.\n    */\n    setTime(time) {\n        this.time = time;\n        return this;\n    }\n    /**\n    Replace the current selection with the given slice.\n    */\n    replaceSelection(slice) {\n        this.selection.replace(this, slice);\n        return this;\n    }\n    /**\n    Replace the selection with the given node. When `inheritMarks` is\n    true and the content is inline, it inherits the marks from the\n    place where it is inserted.\n    */\n    replaceSelectionWith(node, inheritMarks = true) {\n        let selection = this.selection;\n        if (inheritMarks)\n            node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none)));\n        selection.replaceWith(this, node);\n        return this;\n    }\n    /**\n    Delete the selection.\n    */\n    deleteSelection() {\n        this.selection.replace(this);\n        return this;\n    }\n    /**\n    Replace the given range, or the selection if no range is given,\n    with a text node containing the given string.\n    */\n    insertText(text, from, to) {\n        let schema = this.doc.type.schema;\n        if (from == null) {\n            if (!text)\n                return this.deleteSelection();\n            return this.replaceSelectionWith(schema.text(text), true);\n        }\n        else {\n            if (to == null)\n                to = from;\n            to = to == null ? from : to;\n            if (!text)\n                return this.deleteRange(from, to);\n            let marks = this.storedMarks;\n            if (!marks) {\n                let $from = this.doc.resolve(from);\n                marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n            }\n            this.replaceRangeWith(from, to, schema.text(text, marks));\n            if (!this.selection.empty)\n                this.setSelection(Selection.near(this.selection.$to));\n            return this;\n        }\n    }\n    /**\n    Store a metadata property in this transaction, keyed either by\n    name or by plugin.\n    */\n    setMeta(key, value) {\n        this.meta[typeof key == "string" ? key : key.key] = value;\n        return this;\n    }\n    /**\n    Retrieve a metadata property for a given name or plugin.\n    */\n    getMeta(key) {\n        return this.meta[typeof key == "string" ? key : key.key];\n    }\n    /**\n    Returns true if this transaction doesn\'t contain any metadata,\n    and can thus safely be extended.\n    */\n    get isGeneric() {\n        for (let _ in this.meta)\n            return false;\n        return true;\n    }\n    /**\n    Indicate that the editor should scroll the selection into view\n    when updated to the state produced by this transaction.\n    */\n    scrollIntoView() {\n        this.updated |= UPDATED_SCROLL;\n        return this;\n    }\n    /**\n    True when this transaction has had `scrollIntoView` called on it.\n    */\n    get scrolledIntoView() {\n        return (this.updated & UPDATED_SCROLL) > 0;\n    }\n}\n\nfunction bind(f, self) {\n    return !self || !f ? f : f.bind(self);\n}\nclass FieldDesc {\n    constructor(name, desc, self) {\n        this.name = name;\n        this.init = bind(desc.init, self);\n        this.apply = bind(desc.apply, self);\n    }\n}\nconst baseFields = [\n    new FieldDesc("doc", {\n        init(config) { return config.doc || config.schema.topNodeType.createAndFill(); },\n        apply(tr) { return tr.doc; }\n    }),\n    new FieldDesc("selection", {\n        init(config, instance) { return config.selection || Selection.atStart(instance.doc); },\n        apply(tr) { return tr.selection; }\n    }),\n    new FieldDesc("storedMarks", {\n        init(config) { return config.storedMarks || null; },\n        apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null; }\n    }),\n    new FieldDesc("scrollToSelection", {\n        init() { return 0; },\n        apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev; }\n    })\n];\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state\'s `config` property.\nclass Configuration {\n    constructor(schema, plugins) {\n        this.schema = schema;\n        this.plugins = [];\n        this.pluginsByKey = Object.create(null);\n        this.fields = baseFields.slice();\n        if (plugins)\n            plugins.forEach(plugin => {\n                if (this.pluginsByKey[plugin.key])\n                    throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");\n                this.plugins.push(plugin);\n                this.pluginsByKey[plugin.key] = plugin;\n                if (plugin.spec.state)\n                    this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n            });\n    }\n}\n/**\nThe state of a ProseMirror editor is represented by an object of\nthis type. A state is a persistent data structure—it isn\'t\nupdated, but rather a new state value is computed from an old one\nusing the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.\n\nA state holds a number of built-in fields, and plugins can\n[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.\n*/\nclass EditorState {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    config) {\n        this.config = config;\n    }\n    /**\n    The schema of the state\'s document.\n    */\n    get schema() {\n        return this.config.schema;\n    }\n    /**\n    The plugins that are active in this state.\n    */\n    get plugins() {\n        return this.config.plugins;\n    }\n    /**\n    Apply the given transaction to produce a new state.\n    */\n    apply(tr) {\n        return this.applyTransaction(tr).state;\n    }\n    /**\n    @internal\n    */\n    filterTransaction(tr, ignore = -1) {\n        for (let i = 0; i < this.config.plugins.length; i++)\n            if (i != ignore) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n                    return false;\n            }\n        return true;\n    }\n    /**\n    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that\n    returns the precise transactions that were applied (which might\n    be influenced by the [transaction\n    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of\n    plugins) along with the new state.\n    */\n    applyTransaction(rootTr) {\n        if (!this.filterTransaction(rootTr))\n            return { state: this, transactions: [] };\n        let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n        // This loop repeatedly gives plugins a chance to respond to\n        // transactions as new transactions are added, making sure to only\n        // pass the transactions the plugin did not see before.\n        for (;;) {\n            let haveNew = false;\n            for (let i = 0; i < this.config.plugins.length; i++) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.appendTransaction) {\n                    let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n                    let tr = n < trs.length &&\n                        plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n                    if (tr && newState.filterTransaction(tr, i)) {\n                        tr.setMeta("appendedTransaction", rootTr);\n                        if (!seen) {\n                            seen = [];\n                            for (let j = 0; j < this.config.plugins.length; j++)\n                                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });\n                        }\n                        trs.push(tr);\n                        newState = newState.applyInner(tr);\n                        haveNew = true;\n                    }\n                    if (seen)\n                        seen[i] = { state: newState, n: trs.length };\n                }\n            }\n            if (!haveNew)\n                return { state: newState, transactions: trs };\n        }\n    }\n    /**\n    @internal\n    */\n    applyInner(tr) {\n        if (!tr.before.eq(this.doc))\n            throw new RangeError("Applying a mismatched transaction");\n        let newInstance = new EditorState(this.config), fields = this.config.fields;\n        for (let i = 0; i < fields.length; i++) {\n            let field = fields[i];\n            newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n        }\n        return newInstance;\n    }\n    /**\n    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.\n    */\n    get tr() { return new Transaction(this); }\n    /**\n    Create a new state.\n    */\n    static create(config) {\n        let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n        let instance = new EditorState($config);\n        for (let i = 0; i < $config.fields.length; i++)\n            instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n        return instance;\n    }\n    /**\n    Create a new state based on this one, but with an adjusted set\n    of active plugins. State fields that exist in both sets of\n    plugins are kept unchanged. Those that no longer exist are\n    dropped, and those that are new are initialized using their\n    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new\n    configuration object..\n    */\n    reconfigure(config) {\n        let $config = new Configuration(this.schema, config.plugins);\n        let fields = $config.fields, instance = new EditorState($config);\n        for (let i = 0; i < fields.length; i++) {\n            let name = fields[i].name;\n            instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n        }\n        return instance;\n    }\n    /**\n    Serialize this state to JSON. If you want to serialize the state\n    of plugins, pass an object mapping property names to use in the\n    resulting JSON object to plugin objects. The argument may also be\n    a string or number, in which case it is ignored, to support the\n    way `JSON.stringify` calls `toString` methods.\n    */\n    toJSON(pluginFields) {\n        let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };\n        if (this.storedMarks)\n            result.storedMarks = this.storedMarks.map(m => m.toJSON());\n        if (pluginFields && typeof pluginFields == \'object\')\n            for (let prop in pluginFields) {\n                if (prop == "doc" || prop == "selection")\n                    throw new RangeError("The JSON fields `doc` and `selection` are reserved");\n                let plugin = pluginFields[prop], state = plugin.spec.state;\n                if (state && state.toJSON)\n                    result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n            }\n        return result;\n    }\n    /**\n    Deserialize a JSON representation of a state. `config` should\n    have at least a `schema` field, and should contain array of\n    plugins to initialize the state with. `pluginFields` can be used\n    to deserialize the state of plugins, by associating plugin\n    instances with the property names they use in the JSON object.\n    */\n    static fromJSON(config, json, pluginFields) {\n        if (!json)\n            throw new RangeError("Invalid input for EditorState.fromJSON");\n        if (!config.schema)\n            throw new RangeError("Required config field \'schema\' missing");\n        let $config = new Configuration(config.schema, config.plugins);\n        let instance = new EditorState($config);\n        $config.fields.forEach(field => {\n            if (field.name == "doc") {\n                instance.doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node.fromJSON(config.schema, json.doc);\n            }\n            else if (field.name == "selection") {\n                instance.selection = Selection.fromJSON(instance.doc, json.selection);\n            }\n            else if (field.name == "storedMarks") {\n                if (json.storedMarks)\n                    instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n            }\n            else {\n                if (pluginFields)\n                    for (let prop in pluginFields) {\n                        let plugin = pluginFields[prop], state = plugin.spec.state;\n                        if (plugin.key == field.name && state && state.fromJSON &&\n                            Object.prototype.hasOwnProperty.call(json, prop)) {\n                            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n                            return;\n                        }\n                    }\n                instance[field.name] = field.init(config, instance);\n            }\n        });\n        return instance;\n    }\n}\n\nfunction bindProps(obj, self, target) {\n    for (let prop in obj) {\n        let val = obj[prop];\n        if (val instanceof Function)\n            val = val.bind(self);\n        else if (prop == "handleDOMEvents")\n            val = bindProps(val, self, {});\n        target[prop] = val;\n    }\n    return target;\n}\n/**\nPlugins bundle functionality that can be added to an editor.\nThey are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and\nmay influence that state and the view that contains it.\n*/\nclass Plugin {\n    /**\n    Create a plugin.\n    */\n    constructor(\n    /**\n    The plugin\'s [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).\n    */\n    spec) {\n        this.spec = spec;\n        /**\n        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.\n        */\n        this.props = {};\n        if (spec.props)\n            bindProps(spec.props, this, this.props);\n        this.key = spec.key ? spec.key.key : createKey("plugin");\n    }\n    /**\n    Extract the plugin\'s state field from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\nconst keys = Object.create(null);\nfunction createKey(name) {\n    if (name in keys)\n        return name + "$" + ++keys[name];\n    keys[name] = 0;\n    return name + "$";\n}\n/**\nA key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way\nthat makes it possible to find them, given an editor state.\nAssigning a key does mean only one plugin of that type can be\nactive in a state.\n*/\nclass PluginKey {\n    /**\n    Create a plugin key.\n    */\n    constructor(name = "key") { this.key = createKey(name); }\n    /**\n    Get the active plugin with this key, if any, from an editor\n    state.\n    */\n    get(state) { return state.config.pluginsByKey[this.key]; }\n    /**\n    Get the plugin\'s state from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc3RhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXN0YXRlL2Rpc3QvaW5kZXguanM/YzZmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQsIE1hcmssIE5vZGUgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFRyYW5zZm9ybSB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbmNvbnN0IGNsYXNzZXNCeUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuU3VwZXJjbGFzcyBmb3IgZWRpdG9yIHNlbGVjdGlvbnMuIEV2ZXJ5IHNlbGVjdGlvbiB0eXBlIHNob3VsZFxuZXh0ZW5kIHRoaXMuIFNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuKi9cbmNsYXNzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgSW5pdGlhbGl6ZSBhIHNlbGVjdGlvbiB3aXRoIHRoZSBoZWFkIGFuZCBhbmNob3IgYW5kIHJhbmdlcy4gSWYgbm9cbiAgICByYW5nZXMgYXJlIGdpdmVuLCBjb25zdHJ1Y3RzIGEgc2luZ2xlIHJhbmdlIGFjcm9zcyBgJGFuY2hvcmAgYW5kXG4gICAgYCRoZWFkYC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBhbmNob3Igb2YgdGhlIHNlbGVjdGlvbiAodGhlIHNpZGUgdGhhdCBzdGF5cyBpblxuICAgIHBsYWNlIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBtb2RpZmllZCkuXG4gICAgKi9cbiAgICAkYW5jaG9yLCBcbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgaGVhZCBvZiB0aGUgc2VsZWN0aW9uICh0aGUgc2lkZSB0aGF0IG1vdmVzIHdoZW5cbiAgICB0aGUgc2VsZWN0aW9uIGlzIG1vZGlmaWVkKS5cbiAgICAqL1xuICAgICRoZWFkLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy4kYW5jaG9yID0gJGFuY2hvcjtcbiAgICAgICAgdGhpcy4kaGVhZCA9ICRoZWFkO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcyB8fCBbbmV3IFNlbGVjdGlvblJhbmdlKCRhbmNob3IubWluKCRoZWFkKSwgJGFuY2hvci5tYXgoJGhlYWQpKV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBhbmNob3IsIGFzIGFuIHVucmVzb2x2ZWQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy4kYW5jaG9yLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBoZWFkLlxuICAgICovXG4gICAgZ2V0IGhlYWQoKSB7IHJldHVybiB0aGlzLiRoZWFkLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy4kZnJvbS5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLiR0by5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgbG93ZXIgIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0ICRmcm9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbMF0uJGZyb207XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCB1cHBlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCAkdG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS4kdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gY29udGFpbnMgYW55IGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAocmFuZ2VzW2ldLiRmcm9tLnBvcyAhPSByYW5nZXNbaV0uJHRvLnBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRlbnQgb2YgdGhpcyBzZWxlY3Rpb24gYXMgYSBzbGljZS5cbiAgICAqL1xuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmcm9tLmRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8sIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIHNsaWNlIG9yLCBpZiBubyBzbGljZSBpcyBnaXZlbixcbiAgICBkZWxldGUgdGhlIHNlbGVjdGlvbi4gV2lsbCBhcHBlbmQgdG8gdGhlIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIC8vIFB1dCB0aGUgbmV3IHNlbGVjdGlvbiBhdCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIGluc2VydGVkXG4gICAgICAgIC8vIGNvbnRlbnQuIFdoZW4gdGhhdCBlbmRlZCBpbiBhbiBpbmxpbmUgbm9kZSwgc2VhcmNoIGJhY2t3YXJkcyxcbiAgICAgICAgLy8gdG8gZ2V0IHRoZSBwb3NpdGlvbiBhZnRlciB0aGF0IG5vZGUuIElmIG5vdCwgc2VhcmNoIGZvcndhcmQuXG4gICAgICAgIGxldCBsYXN0Tm9kZSA9IGNvbnRlbnQuY29udGVudC5sYXN0Q2hpbGQsIGxhc3RQYXJlbnQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQub3BlbkVuZDsgaSsrKSB7XG4gICAgICAgICAgICBsYXN0UGFyZW50ID0gbGFzdE5vZGU7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgdHIucmVwbGFjZVJhbmdlKG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIG1hcHBpbmcubWFwKCR0by5wb3MpLCBpID8gU2xpY2UuZW1wdHkgOiBjb250ZW50KTtcbiAgICAgICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIChsYXN0Tm9kZSA/IGxhc3ROb2RlLmlzSW5saW5lIDogbGFzdFBhcmVudCAmJiBsYXN0UGFyZW50LmlzVGV4dGJsb2NrKSA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUsIGFwcGVuZGluZyB0aGUgY2hhbmdlc1xuICAgIHRvIHRoZSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHJlcGxhY2VXaXRoKHRyLCBub2RlKSB7XG4gICAgICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXSwgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIHRvID0gbWFwcGluZy5tYXAoJHRvLnBvcyk7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBtYXBGcm9tLCBub2RlLmlzSW5saW5lID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gc3RhcnRpbmcgYXQgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24gYW5kIHNlYXJjaGluZyBiYWNrIGlmIGBkaXJgIGlzIG5lZ2F0aXZlLCBhbmQgZm9yd2FyZCBpZlxuICAgIHBvc2l0aXZlLiBXaGVuIGB0ZXh0T25seWAgaXMgdHJ1ZSwgb25seSBjb25zaWRlciBjdXJzb3JcbiAgICBzZWxlY3Rpb25zLiBXaWxsIHJldHVybiBudWxsIHdoZW4gbm8gdmFsaWQgc2VsZWN0aW9uIHBvc2l0aW9uIGlzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb20oJHBvcywgZGlyLCB0ZXh0T25seSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpbm5lciA9ICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQgPyBuZXcgVGV4dFNlbGVjdGlvbigkcG9zKVxuICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLnBhcmVudCwgJHBvcy5wb3MsICRwb3MuaW5kZXgoKSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoIC0gMTsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyIDwgMFxuICAgICAgICAgICAgICAgID8gZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5iZWZvcmUoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCksIGRpciwgdGV4dE9ubHkpXG4gICAgICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLm5vZGUoZGVwdGgpLCAkcG9zLmFmdGVyKGRlcHRoICsgMSksICRwb3MuaW5kZXgoZGVwdGgpICsgMSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gbmVhciB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi4gU2VhcmNoZXMgZm9yd2FyZCBmaXJzdCBieSBkZWZhdWx0LCBidXQgaWYgYGJpYXNgIGlzXG4gICAgbmVnYXRpdmUsIGl0IHdpbGwgc2VhcmNoIGJhY2t3YXJkcyBmaXJzdC5cbiAgICAqL1xuICAgIHN0YXRpYyBuZWFyKCRwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRGcm9tKCRwb3MsIGJpYXMpIHx8IHRoaXMuZmluZEZyb20oJHBvcywgLWJpYXMpIHx8IG5ldyBBbGxTZWxlY3Rpb24oJHBvcy5ub2RlKDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gY2xvc2VzdCB0byB0aGUgc3RhcnQgb2ZcbiAgICB0aGUgZ2l2ZW4gZG9jdW1lbnQuIFdpbGwgcmV0dXJuIGFuXG4gICAgW2BBbGxTZWxlY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuQWxsU2VsZWN0aW9uKSBpZiBubyB2YWxpZCBwb3NpdGlvblxuICAgIGV4aXN0cy5cbiAgICAqL1xuICAgIHN0YXRpYyBhdFN0YXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gZmluZFNlbGVjdGlvbkluKGRvYywgZG9jLCAwLCAwLCAxKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBhdEVuZChkb2MpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTZWxlY3Rpb25Jbihkb2MsIGRvYywgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jLmNoaWxkQ291bnQsIC0xKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc2VsZWN0aW9uLiBNdXN0IGJlXG4gICAgaW1wbGVtZW50ZWQgZm9yIGN1c3RvbSBjbGFzc2VzIChhcyBhIHN0YXRpYyBjbGFzcyBtZXRob2QpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24udHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgY2xzID0gY2xhc3Nlc0J5SWRbanNvbi50eXBlXTtcbiAgICAgICAgaWYgKCFjbHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc2VsZWN0aW9uIHR5cGUgJHtqc29uLnR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIGNscy5mcm9tSlNPTihkb2MsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIGRlc2VyaWFsaXplIHNlbGVjdGlvbnMgZnJvbSBKU09OLCBjdXN0b20gc2VsZWN0aW9uXG4gICAgY2xhc3NlcyBtdXN0IHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCBhbiBJRCBzdHJpbmcsIHNvIHRoYXQgdGhleVxuICAgIGNhbiBiZSBkaXNhbWJpZ3VhdGVkLiBUcnkgdG8gcGljayBzb21ldGhpbmcgdGhhdCdzIHVubGlrZWx5IHRvXG4gICAgY2xhc2ggd2l0aCBjbGFzc2VzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHNlbGVjdGlvbkNsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBjbGFzc2VzQnlJZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzZWxlY3Rpb24gSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgY2xhc3Nlc0J5SWRbaWRdID0gc2VsZWN0aW9uQ2xhc3M7XG4gICAgICAgIHNlbGVjdGlvbkNsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkNsYXNzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbYm9va21hcmtdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25Cb29rbWFyaykgZm9yIHRoaXMgc2VsZWN0aW9uLFxuICAgIHdoaWNoIGlzIGEgdmFsdWUgdGhhdCBjYW4gYmUgbWFwcGVkIHdpdGhvdXQgaGF2aW5nIGFjY2VzcyB0byBhXG4gICAgY3VycmVudCBkb2N1bWVudCwgYW5kIGxhdGVyIHJlc29sdmVkIHRvIGEgcmVhbCBzZWxlY3Rpb24gZm9yIGFcbiAgICBnaXZlbiBkb2N1bWVudCBhZ2Fpbi4gKFRoaXMgaXMgdXNlZCBtb3N0bHkgYnkgdGhlIGhpc3RvcnkgdG9cbiAgICB0cmFjayBhbmQgcmVzdG9yZSBvbGQgc2VsZWN0aW9ucy4pIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mXG4gICAgdGhpcyBtZXRob2QganVzdCBjb252ZXJ0cyB0aGUgc2VsZWN0aW9uIHRvIGEgdGV4dCBzZWxlY3Rpb24gYW5kXG4gICAgcmV0dXJucyB0aGUgYm9va21hcmsgZm9yIHRoYXQuXG4gICAgKi9cbiAgICBnZXRCb29rbWFyaygpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbih0aGlzLiRhbmNob3IsIHRoaXMuJGhlYWQpLmdldEJvb2ttYXJrKCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gdHJ1ZTtcbi8qKlxuUmVwcmVzZW50cyBhIHNlbGVjdGVkIHJhbmdlIGluIGEgZG9jdW1lbnQuXG4qL1xuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgICRmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgJHRvKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgfVxufVxubGV0IHdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tUZXh0U2VsZWN0aW9uKCRwb3MpIHtcbiAgICBpZiAoIXdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiAmJiAhJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICB3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlRleHRTZWxlY3Rpb24gZW5kcG9pbnQgbm90IHBvaW50aW5nIGludG8gYSBub2RlIHdpdGggaW5saW5lIGNvbnRlbnQgKFwiICsgJHBvcy5wYXJlbnQudHlwZS5uYW1lICsgXCIpXCIpO1xuICAgIH1cbn1cbi8qKlxuQSB0ZXh0IHNlbGVjdGlvbiByZXByZXNlbnRzIGEgY2xhc3NpY2FsIGVkaXRvciBzZWxlY3Rpb24sIHdpdGggYVxuaGVhZCAodGhlIG1vdmluZyBzaWRlKSBhbmQgYW5jaG9yIChpbW1vYmlsZSBzaWRlKSwgYm90aCBvZiB3aGljaFxucG9pbnQgaW50byB0ZXh0YmxvY2sgbm9kZXMuIEl0IGNhbiBiZSBlbXB0eSAoYSByZWd1bGFyIGN1cnNvclxucG9zaXRpb24pLlxuKi9cbmNsYXNzIFRleHRTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHRleHQgc2VsZWN0aW9uIGJldHdlZW4gdGhlIGdpdmVuIHBvaW50cy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRhbmNob3IsICRoZWFkID0gJGFuY2hvcikge1xuICAgICAgICBjaGVja1RleHRTZWxlY3Rpb24oJGFuY2hvcik7XG4gICAgICAgIGNoZWNrVGV4dFNlbGVjdGlvbigkaGVhZCk7XG4gICAgICAgIHN1cGVyKCRhbmNob3IsICRoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJlc29sdmVkIHBvc2l0aW9uIGlmIHRoaXMgaXMgYSBjdXJzb3Igc2VsZWN0aW9uIChhblxuICAgIGVtcHR5IHRleHQgc2VsZWN0aW9uKSwgYW5kIG51bGwgb3RoZXJ3aXNlLlxuICAgICovXG4gICAgZ2V0ICRjdXJzb3IoKSB7IHJldHVybiB0aGlzLiRhbmNob3IucG9zID09IHRoaXMuJGhlYWQucG9zID8gdGhpcy4kaGVhZCA6IG51bGw7IH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkKTtcbiAgICAgICAgbGV0ICRhbmNob3IgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmFuY2hvcikpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRhbmNob3IgOiAkaGVhZCwgJGhlYWQpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgc3VwZXIucmVwbGFjZSh0ciwgY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50ID09IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0aGlzLiRmcm9tLm1hcmtzQWNyb3NzKHRoaXMuJHRvKTtcbiAgICAgICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRCb29rbWFyayh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBUZXh0U2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpLCBkb2MucmVzb2x2ZShqc29uLmhlYWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGFuY2hvciwgaGVhZCA9IGFuY2hvcikge1xuICAgICAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcygkYW5jaG9yLCBoZWFkID09IGFuY2hvciA/ICRhbmNob3IgOiBkb2MucmVzb2x2ZShoZWFkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHRleHQgc2VsZWN0aW9uIHRoYXQgc3BhbnMgdGhlIGdpdmVuIHBvc2l0aW9ucyBvciwgaWZcbiAgICB0aGV5IGFyZW4ndCB0ZXh0IHBvc2l0aW9ucywgZmluZCBhIHRleHQgc2VsZWN0aW9uIG5lYXIgdGhlbS5cbiAgICBgYmlhc2AgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtZXRob2Qgc2VhcmNoZXMgZm9yd2FyZCAoZGVmYXVsdClcbiAgICBvciBiYWNrd2FyZHMgKG5lZ2F0aXZlIG51bWJlcikgZmlyc3QuIFdpbGwgZmFsbCBiYWNrIHRvIGNhbGxpbmdcbiAgICBbYFNlbGVjdGlvbi5uZWFyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbl5uZWFyKSB3aGVuIHRoZSBkb2N1bWVudFxuICAgIGRvZXNuJ3QgY29udGFpbiBhIHZhbGlkIHRleHQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICAgICAgICBsZXQgZFBvcyA9ICRhbmNob3IucG9zIC0gJGhlYWQucG9zO1xuICAgICAgICBpZiAoIWJpYXMgfHwgZFBvcylcbiAgICAgICAgICAgIGJpYXMgPSBkUG9zID49IDAgPyAxIDogLTE7XG4gICAgICAgIGlmICghJGhlYWQucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IFNlbGVjdGlvbi5maW5kRnJvbSgkaGVhZCwgYmlhcywgdHJ1ZSkgfHwgU2VsZWN0aW9uLmZpbmRGcm9tKCRoZWFkLCAtYmlhcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgJGhlYWQgPSBmb3VuZC4kaGVhZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgaWYgKGRQb3MgPT0gMCkge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAoU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIC1iaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGFuY2hvciwgYmlhcywgdHJ1ZSkpLiRhbmNob3I7XG4gICAgICAgICAgICAgICAgaWYgKCgkYW5jaG9yLnBvcyA8ICRoZWFkLnBvcykgIT0gKGRQb3MgPCAwKSlcbiAgICAgICAgICAgICAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLCAkaGVhZCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLmpzb25JRChcInRleHRcIiwgVGV4dFNlbGVjdGlvbik7XG5jbGFzcyBUZXh0Qm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKGFuY2hvciwgaGVhZCkge1xuICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsobWFwcGluZy5tYXAodGhpcy5hbmNob3IpLCBtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbihkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIGRvYy5yZXNvbHZlKHRoaXMuaGVhZCkpO1xuICAgIH1cbn1cbi8qKlxuQSBub2RlIHNlbGVjdGlvbiBpcyBhIHNlbGVjdGlvbiB0aGF0IHBvaW50cyBhdCBhIHNpbmdsZSBub2RlLiBBbGxcbm5vZGVzIG1hcmtlZCBbc2VsZWN0YWJsZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnNlbGVjdGFibGUpIGNhbiBiZSB0aGVcbnRhcmdldCBvZiBhIG5vZGUgc2VsZWN0aW9uLiBJbiBzdWNoIGEgc2VsZWN0aW9uLCBgZnJvbWAgYW5kIGB0b2BcbnBvaW50IGRpcmVjdGx5IGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHNlbGVjdGVkIG5vZGUsIGBhbmNob3JgIGVxdWFsc1xuYGZyb21gLCBhbmQgYGhlYWRgIGVxdWFscyBgdG9gLi5cbiovXG5jbGFzcyBOb2RlU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIHNlbGVjdGlvbi4gRG9lcyBub3QgdmVyaWZ5IHRoZSB2YWxpZGl0eSBvZiBpdHNcbiAgICBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRwb3MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgbGV0ICRlbmQgPSAkcG9zLm5vZGUoMCkucmVzb2x2ZSgkcG9zLnBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgICBzdXBlcigkcG9zLCAkZW5kKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICBpZiAoZGVsZXRlZClcbiAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odGhpcy5ub2RlKSwgMCwgMCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibm9kZVwiLCBhbmNob3I6IHRoaXMuYW5jaG9yIH07XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IE5vZGVCb29rbWFyayh0aGlzLmFuY2hvcik7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGZyb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGZyb20pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIG1heSBiZSBzZWxlY3RlZCBhcyBhIG5vZGVcbiAgICBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgaXNTZWxlY3RhYmxlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFub2RlLmlzVGV4dCAmJiBub2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZTtcbiAgICB9XG59XG5Ob2RlU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5TZWxlY3Rpb24uanNvbklEKFwibm9kZVwiLCBOb2RlU2VsZWN0aW9uKTtcbmNsYXNzIE5vZGVCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBuZXcgVGV4dEJvb2ttYXJrKHBvcywgcG9zKSA6IG5ldyBOb2RlQm9va21hcmsocG9zKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyk7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG59XG4vKipcbkEgc2VsZWN0aW9uIHR5cGUgdGhhdCByZXByZXNlbnRzIHNlbGVjdGluZyB0aGUgd2hvbGUgZG9jdW1lbnRcbih3aGljaCBjYW4gbm90IG5lY2Vzc2FyaWx5IGJlIGV4cHJlc3NlZCB3aXRoIGEgdGV4dCBzZWxlY3Rpb24sIHdoZW5cbnRoZXJlIGFyZSBmb3IgZXhhbXBsZSBsZWFmIGJsb2NrIG5vZGVzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlXG5kb2N1bWVudCkuXG4qL1xuY2xhc3MgQWxsU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gYWxsLXNlbGVjdGlvbiBvdmVyIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICBzdXBlcihkb2MucmVzb2x2ZSgwKSwgZG9jLnJlc29sdmUoZG9jLmNvbnRlbnQuc2l6ZSkpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgwLCB0ci5kb2MuY29udGVudC5zaXplKTtcbiAgICAgICAgICAgIGxldCBzZWwgPSBTZWxlY3Rpb24uYXRTdGFydCh0ci5kb2MpO1xuICAgICAgICAgICAgaWYgKCFzZWwuZXEodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLnJlcGxhY2UodHIsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHsgcmV0dXJuIHsgdHlwZTogXCJhbGxcIiB9OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBtYXAoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb247IH1cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIEFsbEJvb2ttYXJrOyB9XG59XG5TZWxlY3Rpb24uanNvbklEKFwiYWxsXCIsIEFsbFNlbGVjdGlvbik7XG5jb25zdCBBbGxCb29rbWFyayA9IHtcbiAgICBtYXAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgIHJlc29sdmUoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbn07XG4vLyBGSVhNRSB3ZSdsbCBuZWVkIHNvbWUgYXdhcmVuZXNzIG9mIHRleHQgZGlyZWN0aW9uIHdoZW4gc2Nhbm5pbmcgZm9yIHNlbGVjdGlvbnNcbi8vIFRyeSB0byBmaW5kIGEgc2VsZWN0aW9uIGluc2lkZSB0aGUgZ2l2ZW4gbm9kZS4gYHBvc2AgcG9pbnRzIGF0IHRoZVxuLy8gcG9zaXRpb24gd2hlcmUgdGhlIHNlYXJjaCBzdGFydHMuIFdoZW4gYHRleHRgIGlzIHRydWUsIG9ubHkgcmV0dXJuXG4vLyB0ZXh0IHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBub2RlLCBwb3MsIGluZGV4LCBkaXIsIHRleHQgPSBmYWxzZSkge1xuICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gKGRpciA+IDAgPyAwIDogMSk7IGRpciA+IDAgPyBpIDwgbm9kZS5jaGlsZENvdW50IDogaSA+PSAwOyBpICs9IGRpcikge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpO1xuICAgICAgICBpZiAoIWNoaWxkLmlzQXRvbSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZFNlbGVjdGlvbkluKGRvYywgY2hpbGQsIHBvcyArIGRpciwgZGlyIDwgMCA/IGNoaWxkLmNoaWxkQ291bnQgOiAwLCBkaXIsIHRleHQpO1xuICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGV4dCAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyAtIChkaXIgPCAwID8gY2hpbGQubm9kZVNpemUgOiAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplICogZGlyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICAgIGxldCBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA8IHN0YXJ0TGVuKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcbiAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF0sIGVuZDtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiB7IGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gbmV3VG87IH0pO1xuICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSk7XG59XG5cbmNvbnN0IFVQREFURURfU0VMID0gMSwgVVBEQVRFRF9NQVJLUyA9IDIsIFVQREFURURfU0NST0xMID0gNDtcbi8qKlxuQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uLCB3aGljaCBjYW4gYmUgYXBwbGllZCB0byBhIHN0YXRlIHRvXG5jcmVhdGUgYW4gdXBkYXRlZCBzdGF0ZS4gVXNlXG5bYEVkaXRvclN0YXRlLnRyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRyKSB0byBjcmVhdGUgYW4gaW5zdGFuY2UuXG5cblRyYW5zYWN0aW9ucyB0cmFjayBjaGFuZ2VzIHRvIHRoZSBkb2N1bWVudCAodGhleSBhcmUgYSBzdWJjbGFzcyBvZlxuW2BUcmFuc2Zvcm1gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlRyYW5zZm9ybSkpLCBidXQgYWxzbyBvdGhlciBzdGF0ZSBjaGFuZ2VzLFxubGlrZSBzZWxlY3Rpb24gdXBkYXRlcyBhbmQgYWRqdXN0bWVudHMgb2YgdGhlIHNldCBvZiBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKS4gSW4gYWRkaXRpb24sIHlvdSBjYW4gc3RvcmVcbm1ldGFkYXRhIHByb3BlcnRpZXMgaW4gYSB0cmFuc2FjdGlvbiwgd2hpY2ggYXJlIGV4dHJhIHBpZWNlcyBvZlxuaW5mb3JtYXRpb24gdGhhdCBjbGllbnQgY29kZSBvciBwbHVnaW5zIGNhbiB1c2UgdG8gZGVzY3JpYmUgd2hhdCBhXG50cmFuc2FjdGlvbiByZXByZXNlbnRzLCBzbyB0aGF0IHRoZXkgY2FuIHVwZGF0ZSB0aGVpciBbb3duXG5zdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQpIGFjY29yZGluZ2x5LlxuXG5UaGUgW2VkaXRvciB2aWV3XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3KSB1c2VzIGEgZmV3IG1ldGFkYXRhIHByb3BlcnRpZXM6XG5pdCB3aWxsIGF0dGFjaCBhIHByb3BlcnR5IGBcInBvaW50ZXJcImAgd2l0aCB0aGUgdmFsdWUgYHRydWVgIHRvXG5zZWxlY3Rpb24gdHJhbnNhY3Rpb25zIGRpcmVjdGx5IGNhdXNlZCBieSBtb3VzZSBvciB0b3VjaCBpbnB1dCwgYW5kXG5hIGBcInVpRXZlbnRcImAgcHJvcGVydHkgb2YgdGhhdCBtYXkgYmUgYFwicGFzdGVcImAsIGBcImN1dFwiYCwgb3IgYFwiZHJvcFwiYC5cbiovXG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICBzdXBlcihzdGF0ZS5kb2MpO1xuICAgICAgICAvLyBUaGUgc3RlcCBjb3VudCBmb3Igd2hpY2ggdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIHZhbGlkLlxuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IDA7XG4gICAgICAgIC8vIEJpdGZpZWxkIHRvIHRyYWNrIHdoaWNoIGFzcGVjdHMgb2YgdGhlIHN0YXRlIHdlcmUgdXBkYXRlZCBieVxuICAgICAgICAvLyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICB0aGlzLnVwZGF0ZWQgPSAwO1xuICAgICAgICAvLyBPYmplY3QgdXNlZCB0byBzdG9yZSBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMubWV0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbidzIGN1cnJlbnQgc2VsZWN0aW9uLiBUaGlzIGRlZmF1bHRzIHRvIHRoZSBlZGl0b3JcbiAgICBzZWxlY3Rpb24gW21hcHBlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbi5tYXApIHRocm91Z2ggdGhlIHN0ZXBzIGluIHRoZVxuICAgIHRyYW5zYWN0aW9uLCBidXQgY2FuIGJlIG92ZXJ3cml0dGVuIHdpdGhcbiAgICBbYHNldFNlbGVjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZXRTZWxlY3Rpb24pLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyU2VsZWN0aW9uRm9yIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gdGhpcy5jdXJTZWxlY3Rpb24ubWFwKHRoaXMuZG9jLCB0aGlzLm1hcHBpbmcuc2xpY2UodGhpcy5jdXJTZWxlY3Rpb25Gb3IpKTtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyU2VsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHRyYW5zYWN0aW9uJ3MgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgZGV0ZXJtaW5lIHRoZVxuICAgIHNlbGVjdGlvbiB0aGF0IHRoZSBlZGl0b3IgZ2V0cyB3aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhcHBsaWVkLlxuICAgICovXG4gICAgc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLmRvYyAhPSB0aGlzLmRvYylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBhc3NlZCB0byBzZXRTZWxlY3Rpb24gbXVzdCBwb2ludCBhdCB0aGUgY3VycmVudCBkb2N1bWVudFwiKTtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9ICh0aGlzLnVwZGF0ZWQgfCBVUERBVEVEX1NFTCkgJiB+VVBEQVRFRF9NQVJLUztcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgdXBkYXRlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX1NFTCkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIGN1cnJlbnQgc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgc2V0U3RvcmVkTWFya3MobWFya3MpIHtcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9NQVJLUztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIE1ha2Ugc3VyZSB0aGUgY3VycmVudCBzdG9yZWQgbWFya3Mgb3IsIGlmIHRoYXQgaXMgbnVsbCwgdGhlIG1hcmtzXG4gICAgYXQgdGhlIHNlbGVjdGlvbiwgbWF0Y2ggdGhlIGdpdmVuIHNldCBvZiBtYXJrcy4gRG9lcyBub3RoaW5nIGlmXG4gICAgdGhpcyBpcyBhbHJlYWR5IHRoZSBjYXNlLlxuICAgICovXG4gICAgZW5zdXJlTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpLCBtYXJrcykpXG4gICAgICAgICAgICB0aGlzLnNldFN0b3JlZE1hcmtzKG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIHNldCBvZiBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICBhZGRTdG9yZWRNYXJrKG1hcmspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTWFya3MobWFyay5hZGRUb1NldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIGEgbWFyayBvciBtYXJrIHR5cGUgZnJvbSB0aGUgc2V0IG9mIHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIHJlbW92ZVN0b3JlZE1hcmsobWFyaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVNYXJrcyhtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHN0b3JlZCBtYXJrcyB3ZXJlIGV4cGxpY2l0bHkgc2V0IGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHN0b3JlZE1hcmtzU2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfTUFSS1MpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICBzdXBlci5hZGRTdGVwKHN0ZXAsIGRvYyk7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHRoaXMudXBkYXRlZCAmIH5VUERBVEVEX01BUktTO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB0aW1lc3RhbXAgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNldFRpbWUodGltZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gc2xpY2UuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uKHNsaWNlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUuIFdoZW4gYGluaGVyaXRNYXJrc2AgaXNcbiAgICB0cnVlIGFuZCB0aGUgY29udGVudCBpcyBpbmxpbmUsIGl0IGluaGVyaXRzIHRoZSBtYXJrcyBmcm9tIHRoZVxuICAgIHBsYWNlIHdoZXJlIGl0IGlzIGluc2VydGVkLlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbldpdGgobm9kZSwgaW5oZXJpdE1hcmtzID0gdHJ1ZSkge1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGlmIChpbmhlcml0TWFya3MpXG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXJrKHRoaXMuc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi5lbXB0eSA/IHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpIDogKHNlbGVjdGlvbi4kZnJvbS5tYXJrc0Fjcm9zcyhzZWxlY3Rpb24uJHRvKSB8fCBNYXJrLm5vbmUpKSk7XG4gICAgICAgIHNlbGVjdGlvbi5yZXBsYWNlV2l0aCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICovXG4gICAgZGVsZXRlU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2UsIG9yIHRoZSBzZWxlY3Rpb24gaWYgbm8gcmFuZ2UgaXMgZ2l2ZW4sXG4gICAgd2l0aCBhIHRleHQgbm9kZSBjb250YWluaW5nIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBpbnNlcnRUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmRvYy50eXBlLnNjaGVtYTtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVNlbGVjdGlvbldpdGgoc2NoZW1hLnRleHQodGV4dCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tO1xuICAgICAgICAgICAgdG8gPSB0byA9PSBudWxsID8gZnJvbSA6IHRvO1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRoaXMuc3RvcmVkTWFya3M7XG4gICAgICAgICAgICBpZiAoIW1hcmtzKSB7XG4gICAgICAgICAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IHRvID09IGZyb20gPyAkZnJvbS5tYXJrcygpIDogJGZyb20ubWFya3NBY3Jvc3ModGhpcy5kb2MucmVzb2x2ZSh0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBzY2hlbWEudGV4dCh0ZXh0LCBtYXJrcykpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5lbXB0eSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0aGlzLnNlbGVjdGlvbi4kdG8pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFN0b3JlIGEgbWV0YWRhdGEgcHJvcGVydHkgaW4gdGhpcyB0cmFuc2FjdGlvbiwga2V5ZWQgZWl0aGVyIGJ5XG4gICAgbmFtZSBvciBieSBwbHVnaW4uXG4gICAgKi9cbiAgICBzZXRNZXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhIG1ldGFkYXRhIHByb3BlcnR5IGZvciBhIGdpdmVuIG5hbWUgb3IgcGx1Z2luLlxuICAgICovXG4gICAgZ2V0TWV0YShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YVt0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgPyBrZXkgOiBrZXkua2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gZG9lc24ndCBjb250YWluIGFueSBtZXRhZGF0YSxcbiAgICBhbmQgY2FuIHRodXMgc2FmZWx5IGJlIGV4dGVuZGVkLlxuICAgICovXG4gICAgZ2V0IGlzR2VuZXJpYygpIHtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLm1ldGEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkIHNjcm9sbCB0aGUgc2VsZWN0aW9uIGludG8gdmlld1xuICAgIHdoZW4gdXBkYXRlZCB0byB0aGUgc3RhdGUgcHJvZHVjZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9TQ1JPTEw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyB0cmFuc2FjdGlvbiBoYXMgaGFkIGBzY3JvbGxJbnRvVmlld2AgY2FsbGVkIG9uIGl0LlxuICAgICovXG4gICAgZ2V0IHNjcm9sbGVkSW50b1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TQ1JPTEwpID4gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmQoZiwgc2VsZikge1xuICAgIHJldHVybiAhc2VsZiB8fCAhZiA/IGYgOiBmLmJpbmQoc2VsZik7XG59XG5jbGFzcyBGaWVsZERlc2Mge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlc2MsIHNlbGYpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbml0ID0gYmluZChkZXNjLmluaXQsIHNlbGYpO1xuICAgICAgICB0aGlzLmFwcGx5ID0gYmluZChkZXNjLmFwcGx5LCBzZWxmKTtcbiAgICB9XG59XG5jb25zdCBiYXNlRmllbGRzID0gW1xuICAgIG5ldyBGaWVsZERlc2MoXCJkb2NcIiwge1xuICAgICAgICBpbml0KGNvbmZpZykgeyByZXR1cm4gY29uZmlnLmRvYyB8fCBjb25maWcuc2NoZW1hLnRvcE5vZGVUeXBlLmNyZWF0ZUFuZEZpbGwoKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLmRvYzsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzZWxlY3Rpb25cIiwge1xuICAgICAgICBpbml0KGNvbmZpZywgaW5zdGFuY2UpIHsgcmV0dXJuIGNvbmZpZy5zZWxlY3Rpb24gfHwgU2VsZWN0aW9uLmF0U3RhcnQoaW5zdGFuY2UuZG9jKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLnNlbGVjdGlvbjsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzdG9yZWRNYXJrc1wiLCB7XG4gICAgICAgIGluaXQoY29uZmlnKSB7IHJldHVybiBjb25maWcuc3RvcmVkTWFya3MgfHwgbnVsbDsgfSxcbiAgICAgICAgYXBwbHkodHIsIF9tYXJrcywgX29sZCwgc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yID8gdHIuc3RvcmVkTWFya3MgOiBudWxsOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInNjcm9sbFRvU2VsZWN0aW9uXCIsIHtcbiAgICAgICAgaW5pdCgpIHsgcmV0dXJuIDA7IH0sXG4gICAgICAgIGFwcGx5KHRyLCBwcmV2KSB7IHJldHVybiB0ci5zY3JvbGxlZEludG9WaWV3ID8gcHJldiArIDEgOiBwcmV2OyB9XG4gICAgfSlcbl07XG4vLyBPYmplY3Qgd3JhcHBpbmcgdGhlIHBhcnQgb2YgYSBzdGF0ZSBvYmplY3QgdGhhdCBzdGF5cyB0aGUgc2FtZVxuLy8gYWNyb3NzIHRyYW5zYWN0aW9ucy4gU3RvcmVkIGluIHRoZSBzdGF0ZSdzIGBjb25maWdgIHByb3BlcnR5LlxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBwbHVnaW5zKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5zQnlLZXkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGJhc2VGaWVsZHMuc2xpY2UoKTtcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbHVnaW5zQnlLZXlbcGx1Z2luLmtleV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQWRkaW5nIGRpZmZlcmVudCBpbnN0YW5jZXMgb2YgYSBrZXllZCBwbHVnaW4gKFwiICsgcGx1Z2luLmtleSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luc0J5S2V5W3BsdWdpbi5rZXldID0gcGx1Z2luO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWVsZHMucHVzaChuZXcgRmllbGREZXNjKHBsdWdpbi5rZXksIHBsdWdpbi5zcGVjLnN0YXRlLCBwbHVnaW4pKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuVGhlIHN0YXRlIG9mIGEgUHJvc2VNaXJyb3IgZWRpdG9yIGlzIHJlcHJlc2VudGVkIGJ5IGFuIG9iamVjdCBvZlxudGhpcyB0eXBlLiBBIHN0YXRlIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZeKAlGl0IGlzbid0XG51cGRhdGVkLCBidXQgcmF0aGVyIGEgbmV3IHN0YXRlIHZhbHVlIGlzIGNvbXB1dGVkIGZyb20gYW4gb2xkIG9uZVxudXNpbmcgdGhlIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIG1ldGhvZC5cblxuQSBzdGF0ZSBob2xkcyBhIG51bWJlciBvZiBidWlsdC1pbiBmaWVsZHMsIGFuZCBwbHVnaW5zIGNhblxuW2RlZmluZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuc3RhdGUpIGFkZGl0aW9uYWwgZmllbGRzLlxuKi9cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIG9mIHRoZSBzdGF0ZSdzIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBsdWdpbnMgdGhhdCBhcmUgYWN0aXZlIGluIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsdWdpbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0byBwcm9kdWNlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmlsdGVyVHJhbnNhY3Rpb24odHIsIGlnbm9yZSA9IC0xKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChpICE9IGlnbm9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiAmJiAhcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIHRyLCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVmVyYm9zZSB2YXJpYW50IG9mIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIHRoYXRcbiAgICByZXR1cm5zIHRoZSBwcmVjaXNlIHRyYW5zYWN0aW9ucyB0aGF0IHdlcmUgYXBwbGllZCAod2hpY2ggbWlnaHRcbiAgICBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBbdHJhbnNhY3Rpb25cbiAgICBob29rc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuZmlsdGVyVHJhbnNhY3Rpb24pIG9mXG4gICAgcGx1Z2lucykgYWxvbmcgd2l0aCB0aGUgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbihyb290VHIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlclRyYW5zYWN0aW9uKHJvb3RUcikpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogdGhpcywgdHJhbnNhY3Rpb25zOiBbXSB9O1xuICAgICAgICBsZXQgdHJzID0gW3Jvb3RUcl0sIG5ld1N0YXRlID0gdGhpcy5hcHBseUlubmVyKHJvb3RUciksIHNlZW4gPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGxvb3AgcmVwZWF0ZWRseSBnaXZlcyBwbHVnaW5zIGEgY2hhbmNlIHRvIHJlc3BvbmQgdG9cbiAgICAgICAgLy8gdHJhbnNhY3Rpb25zIGFzIG5ldyB0cmFuc2FjdGlvbnMgYXJlIGFkZGVkLCBtYWtpbmcgc3VyZSB0byBvbmx5XG4gICAgICAgIC8vIHBhc3MgdGhlIHRyYW5zYWN0aW9ucyB0aGUgcGx1Z2luIGRpZCBub3Qgc2VlIGJlZm9yZS5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGhhdmVOZXcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IHNlZW4gPyBzZWVuW2ldLm4gOiAwLCBvbGRTdGF0ZSA9IHNlZW4gPyBzZWVuW2ldLnN0YXRlIDogdGhpcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyID0gbiA8IHRycy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uLmNhbGwocGx1Z2luLCBuID8gdHJzLnNsaWNlKG4pIDogdHJzLCBvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHIgJiYgbmV3U3RhdGUuZmlsdGVyVHJhbnNhY3Rpb24odHIsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiLCByb290VHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGogPCBpID8geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfSA6IHsgc3RhdGU6IHRoaXMsIG46IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnMucHVzaCh0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLmFwcGx5SW5uZXIodHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZU5ldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2ldID0geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhdmVOZXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IG5ld1N0YXRlLCB0cmFuc2FjdGlvbnM6IHRycyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlJbm5lcih0cikge1xuICAgICAgICBpZiAoIXRyLmJlZm9yZS5lcSh0aGlzLmRvYykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGEgbWlzbWF0Y2hlZCB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0luc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKHRoaXMuY29uZmlnKSwgZmllbGRzID0gdGhpcy5jb25maWcuZmllbGRzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgbmV3SW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5hcHBseSh0ciwgdGhpc1tmaWVsZC5uYW1lXSwgdGhpcywgbmV3SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdJbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgZnJvbSB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHRyKCkgeyByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcpIHtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbihjb25maWcuZG9jID8gY29uZmlnLmRvYy50eXBlLnNjaGVtYSA6IGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRjb25maWcuZmllbGRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaW5zdGFuY2VbJGNvbmZpZy5maWVsZHNbaV0ubmFtZV0gPSAkY29uZmlnLmZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZSBiYXNlZCBvbiB0aGlzIG9uZSwgYnV0IHdpdGggYW4gYWRqdXN0ZWQgc2V0XG4gICAgb2YgYWN0aXZlIHBsdWdpbnMuIFN0YXRlIGZpZWxkcyB0aGF0IGV4aXN0IGluIGJvdGggc2V0cyBvZlxuICAgIHBsdWdpbnMgYXJlIGtlcHQgdW5jaGFuZ2VkLiBUaG9zZSB0aGF0IG5vIGxvbmdlciBleGlzdCBhcmVcbiAgICBkcm9wcGVkLCBhbmQgdGhvc2UgdGhhdCBhcmUgbmV3IGFyZSBpbml0aWFsaXplZCB1c2luZyB0aGVpclxuICAgIFtgaW5pdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkLmluaXQpIG1ldGhvZCwgcGFzc2luZyBpbiB0aGUgbmV3XG4gICAgY29uZmlndXJhdGlvbiBvYmplY3QuLlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24odGhpcy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9ICRjb25maWcuZmllbGRzLCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gZmllbGRzW2ldLm5hbWU7XG4gICAgICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB0aGlzW25hbWVdIDogZmllbGRzW2ldLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBzdGF0ZSB0byBKU09OLiBJZiB5b3Ugd2FudCB0byBzZXJpYWxpemUgdGhlIHN0YXRlXG4gICAgb2YgcGx1Z2lucywgcGFzcyBhbiBvYmplY3QgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyB0byB1c2UgaW4gdGhlXG4gICAgcmVzdWx0aW5nIEpTT04gb2JqZWN0IHRvIHBsdWdpbiBvYmplY3RzLiBUaGUgYXJndW1lbnQgbWF5IGFsc28gYmVcbiAgICBhIHN0cmluZyBvciBudW1iZXIsIGluIHdoaWNoIGNhc2UgaXQgaXMgaWdub3JlZCwgdG8gc3VwcG9ydCB0aGVcbiAgICB3YXkgYEpTT04uc3RyaW5naWZ5YCBjYWxscyBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gICAgKi9cbiAgICB0b0pTT04ocGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IGRvYzogdGhpcy5kb2MudG9KU09OKCksIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKCkgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmVkTWFya3MpXG4gICAgICAgICAgICByZXN1bHQuc3RvcmVkTWFya3MgPSB0aGlzLnN0b3JlZE1hcmtzLm1hcChtID0+IG0udG9KU09OKCkpO1xuICAgICAgICBpZiAocGx1Z2luRmllbGRzICYmIHR5cGVvZiBwbHVnaW5GaWVsZHMgPT0gJ29iamVjdCcpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09IFwiZG9jXCIgfHwgcHJvcCA9PSBcInNlbGVjdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBKU09OIGZpZWxkcyBgZG9jYCBhbmQgYHNlbGVjdGlvbmAgYXJlIHJlc2VydmVkXCIpO1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSBwbHVnaW5GaWVsZHNbcHJvcF0sIHN0YXRlID0gcGx1Z2luLnNwZWMuc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvSlNPTilcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gc3RhdGUudG9KU09OLmNhbGwocGx1Z2luLCB0aGlzW3BsdWdpbi5rZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc3RhdGUuIGBjb25maWdgIHNob3VsZFxuICAgIGhhdmUgYXQgbGVhc3QgYSBgc2NoZW1hYCBmaWVsZCwgYW5kIHNob3VsZCBjb250YWluIGFycmF5IG9mXG4gICAgcGx1Z2lucyB0byBpbml0aWFsaXplIHRoZSBzdGF0ZSB3aXRoLiBgcGx1Z2luRmllbGRzYCBjYW4gYmUgdXNlZFxuICAgIHRvIGRlc2VyaWFsaXplIHRoZSBzdGF0ZSBvZiBwbHVnaW5zLCBieSBhc3NvY2lhdGluZyBwbHVnaW5cbiAgICBpbnN0YW5jZXMgd2l0aCB0aGUgcHJvcGVydHkgbmFtZXMgdGhleSB1c2UgaW4gdGhlIEpTT04gb2JqZWN0LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGNvbmZpZywganNvbiwgcGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRWRpdG9yU3RhdGUuZnJvbUpTT05cIik7XG4gICAgICAgIGlmICghY29uZmlnLnNjaGVtYSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVxdWlyZWQgY29uZmlnIGZpZWxkICdzY2hlbWEnIG1pc3NpbmdcIik7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgICRjb25maWcuZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT0gXCJkb2NcIikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRvYyA9IE5vZGUuZnJvbUpTT04oY29uZmlnLnNjaGVtYSwganNvbi5kb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uID0gU2VsZWN0aW9uLmZyb21KU09OKGluc3RhbmNlLmRvYywganNvbi5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInN0b3JlZE1hcmtzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5zdG9yZWRNYXJrcylcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RvcmVkTWFya3MgPSBqc29uLnN0b3JlZE1hcmtzLm1hcChjb25maWcuc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luRmllbGRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHBsdWdpbkZpZWxkc1twcm9wXSwgc3RhdGUgPSBwbHVnaW4uc3BlYy5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ua2V5ID09IGZpZWxkLm5hbWUgJiYgc3RhdGUgJiYgc3RhdGUuZnJvbUpTT04gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IHN0YXRlLmZyb21KU09OLmNhbGwocGx1Z2luLCBjb25maWcsIGpzb25bcHJvcF0sIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IGZpZWxkLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kUHJvcHMob2JqLCBzZWxmLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iaikge1xuICAgICAgICBsZXQgdmFsID0gb2JqW3Byb3BdO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICB2YWwgPSB2YWwuYmluZChzZWxmKTtcbiAgICAgICAgZWxzZSBpZiAocHJvcCA9PSBcImhhbmRsZURPTUV2ZW50c1wiKVxuICAgICAgICAgICAgdmFsID0gYmluZFByb3BzKHZhbCwgc2VsZiwge30pO1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG4vKipcblBsdWdpbnMgYnVuZGxlIGZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgYWRkZWQgdG8gYW4gZWRpdG9yLlxuVGhleSBhcmUgcGFydCBvZiB0aGUgW2VkaXRvciBzdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlKSBhbmRcbm1heSBpbmZsdWVuY2UgdGhhdCBzdGF0ZSBhbmQgdGhlIHZpZXcgdGhhdCBjb250YWlucyBpdC5cbiovXG5jbGFzcyBQbHVnaW4ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwbHVnaW4ncyBbc3BlYyBvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjKS5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBbcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzKSBleHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGJpbmRQcm9wcyhzcGVjLnByb3BzLCB0aGlzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgdGhpcy5rZXkgPSBzcGVjLmtleSA/IHNwZWMua2V5LmtleSA6IGNyZWF0ZUtleShcInBsdWdpblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0cmFjdCB0aGUgcGx1Z2luJ3Mgc3RhdGUgZmllbGQgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXRTdGF0ZShzdGF0ZSkgeyByZXR1cm4gc3RhdGVbdGhpcy5rZXldOyB9XG59XG5jb25zdCBrZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGNyZWF0ZUtleShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4ga2V5cylcbiAgICAgICAgcmV0dXJuIG5hbWUgKyBcIiRcIiArICsra2V5c1tuYW1lXTtcbiAgICBrZXlzW25hbWVdID0gMDtcbiAgICByZXR1cm4gbmFtZSArIFwiJFwiO1xufVxuLyoqXG5BIGtleSBpcyB1c2VkIHRvIFt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLmtleSkgcGx1Z2lucyBpbiBhIHdheVxudGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0byBmaW5kIHRoZW0sIGdpdmVuIGFuIGVkaXRvciBzdGF0ZS5cbkFzc2lnbmluZyBhIGtleSBkb2VzIG1lYW4gb25seSBvbmUgcGx1Z2luIG9mIHRoYXQgdHlwZSBjYW4gYmVcbmFjdGl2ZSBpbiBhIHN0YXRlLlxuKi9cbmNsYXNzIFBsdWdpbktleSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGtleS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUgPSBcImtleVwiKSB7IHRoaXMua2V5ID0gY3JlYXRlS2V5KG5hbWUpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBhY3RpdmUgcGx1Z2luIHdpdGggdGhpcyBrZXksIGlmIGFueSwgZnJvbSBhbiBlZGl0b3JcbiAgICBzdGF0ZS5cbiAgICAqL1xuICAgIGdldChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY29uZmlnLnBsdWdpbnNCeUtleVt0aGlzLmtleV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBsdWdpbidzIHN0YXRlIGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0U3RhdGUoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW3RoaXMua2V5XTsgfVxufVxuXG5leHBvcnQgeyBBbGxTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBOb2RlU2VsZWN0aW9uLCBQbHVnaW4sIFBsdWdpbktleSwgU2VsZWN0aW9uLCBTZWxlY3Rpb25SYW5nZSwgVGV4dFNlbGVjdGlvbiwgVHJhbnNhY3Rpb24gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-state/dist/index.js\n')},"./node_modules/prosemirror-transform/dist/index.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: function() { return /* binding */ AddMarkStep; },\n/* harmony export */   AddNodeMarkStep: function() { return /* binding */ AddNodeMarkStep; },\n/* harmony export */   AttrStep: function() { return /* binding */ AttrStep; },\n/* harmony export */   MapResult: function() { return /* binding */ MapResult; },\n/* harmony export */   Mapping: function() { return /* binding */ Mapping; },\n/* harmony export */   RemoveMarkStep: function() { return /* binding */ RemoveMarkStep; },\n/* harmony export */   RemoveNodeMarkStep: function() { return /* binding */ RemoveNodeMarkStep; },\n/* harmony export */   ReplaceAroundStep: function() { return /* binding */ ReplaceAroundStep; },\n/* harmony export */   ReplaceStep: function() { return /* binding */ ReplaceStep; },\n/* harmony export */   Step: function() { return /* binding */ Step; },\n/* harmony export */   StepMap: function() { return /* binding */ StepMap; },\n/* harmony export */   StepResult: function() { return /* binding */ StepResult; },\n/* harmony export */   Transform: function() { return /* binding */ Transform; },\n/* harmony export */   TransformError: function() { return /* binding */ TransformError; },\n/* harmony export */   canJoin: function() { return /* binding */ canJoin; },\n/* harmony export */   canSplit: function() { return /* binding */ canSplit; },\n/* harmony export */   dropPoint: function() { return /* binding */ dropPoint; },\n/* harmony export */   findWrapping: function() { return /* binding */ findWrapping; },\n/* harmony export */   insertPoint: function() { return /* binding */ insertPoint; },\n/* harmony export */   joinPoint: function() { return /* binding */ joinPoint; },\n/* harmony export */   liftTarget: function() { return /* binding */ liftTarget; },\n/* harmony export */   replaceStep: function() { return /* binding */ replaceStep; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");\n\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number\'s\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don\'t use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\nconst lower16 = 0xffff;\nconst factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) { return index + offset * factor16; }\nfunction recoverIndex(value) { return value & lower16; }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16; }\nconst DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;\n/**\nAn object representing a mapped position with extra\ninformation.\n*/\nclass MapResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The mapped version of the position.\n    */\n    pos, \n    /**\n    @internal\n    */\n    delInfo, \n    /**\n    @internal\n    */\n    recover) {\n        this.pos = pos;\n        this.delInfo = delInfo;\n        this.recover = recover;\n    }\n    /**\n    Tells you whether the position was deleted, that is, whether the\n    step removed the token on the side queried (via the `assoc`)\n    argument from the document.\n    */\n    get deleted() { return (this.delInfo & DEL_SIDE) > 0; }\n    /**\n    Tells you whether the token before the mapped position was deleted.\n    */\n    get deletedBefore() { return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0; }\n    /**\n    True when the token after the mapped position was deleted.\n    */\n    get deletedAfter() { return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0; }\n    /**\n    Tells whether any of the steps mapped through deletes across the\n    position (including both the token before and after the\n    position).\n    */\n    get deletedAcross() { return (this.delInfo & DEL_ACROSS) > 0; }\n}\n/**\nA map describing the deletions and insertions made by a step, which\ncan be used to find the correspondence between positions in the\npre-step version of a document and the same position in the\npost-step version.\n*/\nclass StepMap {\n    /**\n    Create a position map. The modifications to the document are\n    represented as an array of numbers, in which each group of three\n    represents a modified chunk as `[start, oldSize, newSize]`.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    ranges, \n    /**\n    @internal\n    */\n    inverted = false) {\n        this.ranges = ranges;\n        this.inverted = inverted;\n        if (!ranges.length && StepMap.empty)\n            return StepMap.empty;\n    }\n    /**\n    @internal\n    */\n    recover(value) {\n        let diff = 0, index = recoverIndex(value);\n        if (!this.inverted)\n            for (let i = 0; i < index; i++)\n                diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n        return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    map(pos, assoc = 1) { return this._map(pos, assoc, true); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n            if (pos <= end) {\n                let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n                let result = start + diff + (side < 0 ? 0 : newSize);\n                if (simple)\n                    return result;\n                let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n                let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n                if (assoc < 0 ? pos != start : pos != end)\n                    del |= DEL_SIDE;\n                return new MapResult(result, del, recover);\n            }\n            diff += newSize - oldSize;\n        }\n        return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n    /**\n    @internal\n    */\n    touches(pos, recover) {\n        let diff = 0, index = recoverIndex(recover);\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n            if (pos <= end && i == index * 3)\n                return true;\n            diff += this.ranges[i + newIndex] - oldSize;\n        }\n        return false;\n    }\n    /**\n    Calls the given function on each of the changed ranges included in\n    this map.\n    */\n    forEach(f) {\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n            diff += newSize - oldSize;\n        }\n    }\n    /**\n    Create an inverted version of this map. The result can be used to\n    map positions in the post-step document to the pre-step document.\n    */\n    invert() {\n        return new StepMap(this.ranges, !this.inverted);\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);\n    }\n    /**\n    Create a map that moves all positions by offset `n` (which may be\n    negative). This can be useful when applying steps meant for a\n    sub-document to a larger document, or vice-versa.\n    */\n    static offset(n) {\n        return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n    }\n}\n/**\nA StepMap that contains no changed ranges.\n*/\nStepMap.empty = new StepMap([]);\n/**\nA mapping represents a pipeline of zero or more [step\nmaps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly\nhandling mapping positions through a series of steps in which some\nsteps are inverted versions of earlier steps. (This comes up when\n‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\ncollaboration or history management.)\n*/\nclass Mapping {\n    /**\n    Create a new mapping with the given position maps.\n    */\n    constructor(\n    /**\n    The step maps in this mapping.\n    */\n    maps = [], \n    /**\n    @internal\n    */\n    mirror, \n    /**\n    The starting position in the `maps` array, used when `map` or\n    `mapResult` is called.\n    */\n    from = 0, \n    /**\n    The end position in the `maps` array.\n    */\n    to = maps.length) {\n        this.maps = maps;\n        this.mirror = mirror;\n        this.from = from;\n        this.to = to;\n    }\n    /**\n    Create a mapping that maps only through a part of this one.\n    */\n    slice(from = 0, to = this.maps.length) {\n        return new Mapping(this.maps, this.mirror, from, to);\n    }\n    /**\n    @internal\n    */\n    copy() {\n        return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);\n    }\n    /**\n    Add a step map to the end of this mapping. If `mirrors` is\n    given, it should be the index of the step map that is the mirror\n    image of this one.\n    */\n    appendMap(map, mirrors) {\n        this.to = this.maps.push(map);\n        if (mirrors != null)\n            this.setMirror(this.maps.length - 1, mirrors);\n    }\n    /**\n    Add all the step maps in a given mapping to this one (preserving\n    mirroring information).\n    */\n    appendMapping(mapping) {\n        for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n        }\n    }\n    /**\n    Finds the offset of the step map that mirrors the map at the\n    given offset, in this mapping (as per the second argument to\n    `appendMap`).\n    */\n    getMirror(n) {\n        if (this.mirror)\n            for (let i = 0; i < this.mirror.length; i++)\n                if (this.mirror[i] == n)\n                    return this.mirror[i + (i % 2 ? -1 : 1)];\n    }\n    /**\n    @internal\n    */\n    setMirror(n, m) {\n        if (!this.mirror)\n            this.mirror = [];\n        this.mirror.push(n, m);\n    }\n    /**\n    Append the inverse of the given mapping to this one.\n    */\n    appendMappingInverted(mapping) {\n        for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n        }\n    }\n    /**\n    Create an inverted version of this mapping.\n    */\n    invert() {\n        let inverse = new Mapping;\n        inverse.appendMappingInverted(this);\n        return inverse;\n    }\n    /**\n    Map a position through this mapping.\n    */\n    map(pos, assoc = 1) {\n        if (this.mirror)\n            return this._map(pos, assoc, true);\n        for (let i = this.from; i < this.to; i++)\n            pos = this.maps[i].map(pos, assoc);\n        return pos;\n    }\n    /**\n    Map a position through this mapping, returning a mapping\n    result.\n    */\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let delInfo = 0;\n        for (let i = this.from; i < this.to; i++) {\n            let map = this.maps[i], result = map.mapResult(pos, assoc);\n            if (result.recover != null) {\n                let corr = this.getMirror(i);\n                if (corr != null && corr > i && corr < this.to) {\n                    i = corr;\n                    pos = this.maps[corr].recover(result.recover);\n                    continue;\n                }\n            }\n            delInfo |= result.delInfo;\n            pos = result.pos;\n        }\n        return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n}\n\nconst stepsByID = Object.create(null);\n/**\nA step object represents an atomic change. It generally applies\nonly to the document it was created for, since the positions\nstored in it will only make sense for that document.\n\nNew steps are defined by creating classes that extend `Step`,\noverriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\nmethods, and registering your class with a unique\nJSON-serialization identifier using\n[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).\n*/\nclass Step {\n    /**\n    Get the step map that represents the changes made by this step,\n    and which can be used to transform between positions in the old\n    and the new document.\n    */\n    getMap() { return StepMap.empty; }\n    /**\n    Try to merge this step with another one, to be applied directly\n    after it. Returns the merged step when possible, null if the\n    steps can\'t be merged.\n    */\n    merge(other) { return null; }\n    /**\n    Deserialize a step from its JSON representation. Will call\n    through to the step class\' own implementation of this method.\n    */\n    static fromJSON(schema, json) {\n        if (!json || !json.stepType)\n            throw new RangeError("Invalid input for Step.fromJSON");\n        let type = stepsByID[json.stepType];\n        if (!type)\n            throw new RangeError(`No step type ${json.stepType} defined`);\n        return type.fromJSON(schema, json);\n    }\n    /**\n    To be able to serialize steps to JSON, each step needs a string\n    ID to attach to its JSON representation. Use this method to\n    register an ID for your step classes. Try to pick something\n    that\'s unlikely to clash with steps from other modules.\n    */\n    static jsonID(id, stepClass) {\n        if (id in stepsByID)\n            throw new RangeError("Duplicate use of step JSON ID " + id);\n        stepsByID[id] = stepClass;\n        stepClass.prototype.jsonID = id;\n        return stepClass;\n    }\n}\n/**\nThe result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a\nnew document or a failure value.\n*/\nclass StepResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The transformed document, if successful.\n    */\n    doc, \n    /**\n    The failure message, if unsuccessful.\n    */\n    failed) {\n        this.doc = doc;\n        this.failed = failed;\n    }\n    /**\n    Create a successful step result.\n    */\n    static ok(doc) { return new StepResult(doc, null); }\n    /**\n    Create a failed step result.\n    */\n    static fail(message) { return new StepResult(null, message); }\n    /**\n    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n    arguments. Create a successful result if it succeeds, and a\n    failed one if it throws a `ReplaceError`.\n    */\n    static fromReplace(doc, from, to, slice) {\n        try {\n            return StepResult.ok(doc.replace(from, to, slice));\n        }\n        catch (e) {\n            if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError)\n                return StepResult.fail(e.message);\n            throw e;\n        }\n    }\n}\n\nfunction mapFragment(fragment, f, parent) {\n    let mapped = [];\n    for (let i = 0; i < fragment.childCount; i++) {\n        let child = fragment.child(i);\n        if (child.content.size)\n            child = child.copy(mapFragment(child.content, f, child));\n        if (child.isInline)\n            child = f(child, parent, i);\n        mapped.push(child);\n    }\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped);\n}\n/**\nAdd a mark to all inline content between two positions.\n*/\nclass AddMarkStep extends Step {\n    /**\n    Create a mark step.\n    */\n    constructor(\n    /**\n    The start of the marked range.\n    */\n    from, \n    /**\n    The end of the marked range.\n    */\n    to, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n        let parent = $from.node($from.sharedDepth(this.to));\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, (node, parent) => {\n            if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type))\n                return node;\n            return node.mark(this.mark.addToSet(node.marks));\n        }, parent), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof AddMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: "addMark", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != "number" || typeof json.to != "number")\n            throw new RangeError("Invalid input for AddMarkStep.fromJSON");\n        return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID("addMark", AddMarkStep);\n/**\nRemove a mark from all inline content between two positions.\n*/\nclass RemoveMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The start of the unmarked range.\n    */\n    from, \n    /**\n    The end of the unmarked range.\n    */\n    to, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to);\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, node => {\n            return node.mark(this.mark.removeFromSet(node.marks));\n        }, doc), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new AddMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof RemoveMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: "removeMark", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != "number" || typeof json.to != "number")\n            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");\n        return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID("removeMark", RemoveMarkStep);\n/**\nAdd a mark to a specific node.\n*/\nclass AddNodeMarkStep extends Step {\n    /**\n    Create a node mark step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail("No node at mark step\'s position");\n        let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (node) {\n            let newSet = this.mark.addToSet(node.marks);\n            if (newSet.length == node.marks.length) {\n                for (let i = 0; i < node.marks.length; i++)\n                    if (!node.marks[i].isInSet(newSet))\n                        return new AddNodeMarkStep(this.pos, node.marks[i]);\n                return new AddNodeMarkStep(this.pos, this.mark);\n            }\n        }\n        return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != "number")\n            throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");\n        return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID("addNodeMark", AddNodeMarkStep);\n/**\nRemove a mark from a specific node.\n*/\nclass RemoveNodeMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail("No node at mark step\'s position");\n        let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node || !this.mark.isInSet(node.marks))\n            return this;\n        return new AddNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != "number")\n            throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");\n        return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID("removeNodeMark", RemoveNodeMarkStep);\n\n/**\nReplace a part of the document with a slice of new content.\n*/\nclass ReplaceStep extends Step {\n    /**\n    The given `slice` should fit the \'gap\' between `from` and\n    `to`—the depths must line up, and the surrounding nodes must be\n    able to be joined with the open sides of the slice. When\n    `structure` is true, the step will fail if the content between\n    from and to is not just a sequence of closing and then opening\n    tokens (this is to guard against rebased replace steps\n    overwriting something they weren\'t supposed to).\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.slice = slice;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && contentBetween(doc, this.from, this.to))\n            return StepResult.fail("Structure replace would overwrite content");\n        return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n    getMap() {\n        return new StepMap([this.from, this.to - this.from, this.slice.size]);\n    }\n    invert(doc) {\n        return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deletedAcross && to.deletedAcross)\n            return null;\n        return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n    }\n    merge(other) {\n        if (!(other instanceof ReplaceStep) || other.structure || this.structure)\n            return null;\n        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n            return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n        }\n        else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n            return new ReplaceStep(other.from, this.to, slice, this.structure);\n        }\n        else {\n            return null;\n        }\n    }\n    toJSON() {\n        let json = { stepType: "replace", from: this.from, to: this.to };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != "number" || typeof json.to != "number")\n            throw new RangeError("Invalid input for ReplaceStep.fromJSON");\n        return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure);\n    }\n}\nStep.jsonID("replace", ReplaceStep);\n/**\nReplace a part of the document with a slice of content, but\npreserve a range of the replaced content by moving it into the\nslice.\n*/\nclass ReplaceAroundStep extends Step {\n    /**\n    Create a replace-around step with the given range and gap.\n    `insert` should be the point in the slice into which the content\n    of the gap should be moved. `structure` has the same meaning as\n    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The start of preserved range.\n    */\n    gapFrom, \n    /**\n    The end of preserved range.\n    */\n    gapTo, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    The position in the slice where the preserved range should be\n    inserted.\n    */\n    insert, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.gapFrom = gapFrom;\n        this.gapTo = gapTo;\n        this.slice = slice;\n        this.insert = insert;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n            contentBetween(doc, this.gapTo, this.to)))\n            return StepResult.fail("Structure gap-replace would overwrite content");\n        let gap = doc.slice(this.gapFrom, this.gapTo);\n        if (gap.openStart || gap.openEnd)\n            return StepResult.fail("Gap is not a flat range");\n        let inserted = this.slice.insertAt(this.insert, gap.content);\n        if (!inserted)\n            return StepResult.fail("Content does not fit in gap");\n        return StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n    getMap() {\n        return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n            this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n    }\n    invert(doc) {\n        let gap = this.gapTo - this.gapFrom;\n        return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);\n        if ((from.deletedAcross && to.deletedAcross) || gapFrom < from.pos || gapTo > to.pos)\n            return null;\n        return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n    toJSON() {\n        let json = { stepType: "replaceAround", from: this.from, to: this.to,\n            gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != "number" || typeof json.to != "number" ||\n            typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")\n            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");\n        return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n    }\n}\nStep.jsonID("replaceAround", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n    let $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n        depth--;\n        dist--;\n    }\n    if (dist > 0) {\n        let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n        while (dist > 0) {\n            if (!next || next.isLeaf)\n                return true;\n            next = next.firstChild;\n            dist--;\n        }\n    }\n    return false;\n}\n\nfunction addMark(tr, from, to, mark) {\n    let removed = [], added = [];\n    let removing, adding;\n    tr.doc.nodesBetween(from, to, (node, pos, parent) => {\n        if (!node.isInline)\n            return;\n        let marks = node.marks;\n        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n            let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n            let newSet = mark.addToSet(marks);\n            for (let i = 0; i < marks.length; i++) {\n                if (!marks[i].isInSet(newSet)) {\n                    if (removing && removing.to == start && removing.mark.eq(marks[i]))\n                        removing.to = end;\n                    else\n                        removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n                }\n            }\n            if (adding && adding.to == start)\n                adding.to = end;\n            else\n                added.push(adding = new AddMarkStep(start, end, mark));\n        }\n    });\n    removed.forEach(s => tr.step(s));\n    added.forEach(s => tr.step(s));\n}\nfunction removeMark(tr, from, to, mark) {\n    let matched = [], step = 0;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (!node.isInline)\n            return;\n        step++;\n        let toRemove = null;\n        if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {\n            let set = node.marks, found;\n            while (found = mark.isInSet(set)) {\n                (toRemove || (toRemove = [])).push(found);\n                set = found.removeFromSet(set);\n            }\n        }\n        else if (mark) {\n            if (mark.isInSet(node.marks))\n                toRemove = [mark];\n        }\n        else {\n            toRemove = node.marks;\n        }\n        if (toRemove && toRemove.length) {\n            let end = Math.min(pos + node.nodeSize, to);\n            for (let i = 0; i < toRemove.length; i++) {\n                let style = toRemove[i], found;\n                for (let j = 0; j < matched.length; j++) {\n                    let m = matched[j];\n                    if (m.step == step - 1 && style.eq(matched[j].style))\n                        found = m;\n                }\n                if (found) {\n                    found.to = end;\n                    found.step = step;\n                }\n                else {\n                    matched.push({ style, from: Math.max(pos, from), to: end, step });\n                }\n            }\n        }\n    });\n    matched.forEach(m => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n}\nfunction clearIncompatible(tr, pos, parentType, match = parentType.contentMatch) {\n    let node = tr.doc.nodeAt(pos);\n    let delSteps = [], cur = pos + 1;\n    for (let i = 0; i < node.childCount; i++) {\n        let child = node.child(i), end = cur + child.nodeSize;\n        let allowed = match.matchType(child.type);\n        if (!allowed) {\n            delSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));\n        }\n        else {\n            match = allowed;\n            for (let j = 0; j < child.marks.length; j++)\n                if (!parentType.allowsMarkType(child.marks[j].type))\n                    tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n        }\n        cur = end;\n    }\n    if (!match.validEnd) {\n        let fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        tr.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));\n    }\n    for (let i = delSteps.length - 1; i >= 0; i--)\n        tr.step(delSteps[i]);\n}\n\nfunction canCut(node, start, end) {\n    return (start == 0 || node.canReplace(start, node.childCount)) &&\n        (end == node.childCount || node.canReplace(0, end));\n}\n/**\nTry to find a target depth to which the content in the given range\ncan be lifted. Will not go across\n[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.\n*/\nfunction liftTarget(range) {\n    let parent = range.parent;\n    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n    for (let depth = range.depth;; --depth) {\n        let node = range.$from.node(depth);\n        let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n        if (depth < range.depth && node.canReplace(index, endIndex, content))\n            return depth;\n        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))\n            break;\n    }\n    return null;\n}\nfunction lift(tr, range, target) {\n    let { $from, $to, depth } = range;\n    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n    let start = gapStart, end = gapEnd;\n    let before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openStart = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $from.index(d) > 0) {\n            splitting = true;\n            before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));\n            openStart++;\n        }\n        else {\n            start--;\n        }\n    let after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openEnd = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $to.after(d + 1) < $to.end(d)) {\n            splitting = true;\n            after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(d).copy(after));\n            openEnd++;\n        }\n        else {\n            end++;\n        }\n    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\n/**\nTry to find a valid way to wrap the content in the given range in a\nnode of the given type. May introduce extra nodes around and inside\nthe wrapper node, if necessary. Returns null if no valid wrapping\ncould be found. When `innerRange` is given, that range\'s content is\nused as the content to fit into the wrapping, instead of the\ncontent of `range`.\n*/\nfunction findWrapping(range, nodeType, attrs = null, innerRange = range) {\n    let around = findWrappingOutside(range, nodeType);\n    let inner = around && findWrappingInside(innerRange, nodeType);\n    if (!inner)\n        return null;\n    return around.map(withAttrs)\n        .concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));\n}\nfunction withAttrs(type) { return { type, attrs: null }; }\nfunction findWrappingOutside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let around = parent.contentMatchAt(startIndex).findWrapping(type);\n    if (!around)\n        return null;\n    let outer = around.length ? around[0] : type;\n    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\nfunction findWrappingInside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let inner = parent.child(startIndex);\n    let inside = type.contentMatch.findWrapping(inner.type);\n    if (!inside)\n        return null;\n    let lastType = inside.length ? inside[inside.length - 1] : type;\n    let innerMatch = lastType.contentMatch;\n    for (let i = startIndex; innerMatch && i < endIndex; i++)\n        innerMatch = innerMatch.matchType(parent.child(i).type);\n    if (!innerMatch || !innerMatch.validEnd)\n        return null;\n    return inside;\n}\nfunction wrap(tr, range, wrappers) {\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--) {\n        if (content.size) {\n            let match = wrappers[i].type.contentMatch.matchFragment(content);\n            if (!match || !match.validEnd)\n                throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");\n        }\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    let start = range.start, end = range.end;\n    tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n}\nfunction setBlockType(tr, from, to, type, attrs) {\n    if (!type.isTextblock)\n        throw new RangeError("Type given to setBlockType should be a textblock");\n    let mapFrom = tr.steps.length;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n            // Ensure all markup that isn\'t allowed in the new node type is cleared\n            tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);\n            let mapping = tr.mapping.slice(mapFrom);\n            let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n            tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n            return false;\n        }\n    });\n}\nfunction canChangeType(doc, pos, type) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n}\n/**\nChange the type, attributes, and/or marks of the node at `pos`.\nWhen `type` isn\'t given, the existing node type is preserved,\n*/\nfunction setNodeMarkup(tr, pos, type, attrs, marks) {\n    let node = tr.doc.nodeAt(pos);\n    if (!node)\n        throw new RangeError("No node at given position");\n    if (!type)\n        type = node.type;\n    let newNode = type.create(attrs, null, marks || node.marks);\n    if (node.isLeaf)\n        return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n    if (!type.validContent(node.content))\n        throw new RangeError("Invalid content for node type " + type.name);\n    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true));\n}\n/**\nCheck whether splitting at the given position is allowed.\n*/\nfunction canSplit(doc, pos, depth = 1, typesAfter) {\n    let $pos = doc.resolve(pos), base = $pos.depth - depth;\n    let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;\n    if (base < 0 || $pos.parent.type.spec.isolating ||\n        !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n        !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n        return false;\n    for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n        let node = $pos.node(d), index = $pos.index(d);\n        if (node.type.spec.isolating)\n            return false;\n        let rest = node.content.cutByIndex(index, node.childCount);\n        let after = (typesAfter && typesAfter[i]) || node;\n        if (after != node)\n            rest = rest.replaceChild(0, after.type.create(after.attrs));\n        if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n            return false;\n    }\n    let index = $pos.indexAfter(base);\n    let baseType = typesAfter && typesAfter[0];\n    return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\nfunction split(tr, pos, depth = 1, typesAfter) {\n    let $pos = tr.doc.resolve(pos), before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n        before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));\n        let typeAfter = typesAfter && typesAfter[i];\n        after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n    }\n    tr.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true));\n}\n/**\nTest whether the blocks before and after a given position can be\njoined.\n*/\nfunction canJoin(doc, pos) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n        $pos.parent.canReplace(index, index + 1);\n}\nfunction joinable(a, b) {\n    return !!(a && b && !a.isLeaf && a.canAppend(b));\n}\n/**\nFind an ancestor of the given position that can be joined to the\nblock before (or after if `dir` is positive). Returns the joinable\npoint, if any.\n*/\nfunction joinPoint(doc, pos, dir = -1) {\n    let $pos = doc.resolve(pos);\n    for (let d = $pos.depth;; d--) {\n        let before, after, index = $pos.index(d);\n        if (d == $pos.depth) {\n            before = $pos.nodeBefore;\n            after = $pos.nodeAfter;\n        }\n        else if (dir > 0) {\n            before = $pos.node(d + 1);\n            index++;\n            after = $pos.node(d).maybeChild(index);\n        }\n        else {\n            before = $pos.node(d).maybeChild(index - 1);\n            after = $pos.node(d + 1);\n        }\n        if (before && !before.isTextblock && joinable(before, after) &&\n            $pos.node(d).canReplace(index, index + 1))\n            return pos;\n        if (d == 0)\n            break;\n        pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n    }\n}\nfunction join(tr, pos, depth) {\n    let step = new ReplaceStep(pos - depth, pos + depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true);\n    tr.step(step);\n}\n/**\nTry to find a point where a node of the given type can be inserted\nnear `pos`, by searching up the node hierarchy when `pos` itself\nisn\'t a valid place but is at the start or end of a node. Return\nnull if no position was found.\n*/\nfunction insertPoint(doc, pos, nodeType) {\n    let $pos = doc.resolve(pos);\n    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))\n        return pos;\n    if ($pos.parentOffset == 0)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.index(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.before(d + 1);\n            if (index > 0)\n                return null;\n        }\n    if ($pos.parentOffset == $pos.parent.content.size)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.indexAfter(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.after(d + 1);\n            if (index < $pos.node(d).childCount)\n                return null;\n        }\n    return null;\n}\n/**\nFinds a position at or around the given position where the given\nslice can be inserted. Will look at parent nodes\' nearest boundary\nand try there, even if the original position wasn\'t directly at the\nstart or end of that node. Returns null when no position was found.\n*/\nfunction dropPoint(doc, pos, slice) {\n    let $pos = doc.resolve(pos);\n    if (!slice.content.size)\n        return pos;\n    let content = slice.content;\n    for (let i = 0; i < slice.openStart; i++)\n        content = content.firstChild.content;\n    for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n        for (let d = $pos.depth; d >= 0; d--) {\n            let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n            let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n            let parent = $pos.node(d), fits = false;\n            if (pass == 1) {\n                fits = parent.canReplace(insertPos, insertPos, content);\n            }\n            else {\n                let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n                fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n            }\n            if (fits)\n                return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n        }\n    }\n    return null;\n}\n\n/**\n‘Fit’ a slice into a given position in the document, producing a\n[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if\nthere\'s no meaningful way to insert the slice here, or inserting it\nwould be a no-op (an empty slice over an empty range).\n*/\nfunction replaceStep(doc, from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n    if (from == to && !slice.size)\n        return null;\n    let $from = doc.resolve(from), $to = doc.resolve(to);\n    // Optimization -- avoid work if it\'s obvious that it\'s not needed.\n    if (fitsTrivially($from, $to, slice))\n        return new ReplaceStep(from, to, slice);\n    return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n        $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\n// Algorithm for \'placing\' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p("foo"), p("bar")>, when the\n// paragraph on the left is open, "foo" can be placed (somewhere on\n// the left side of the replacement gap) independently from p("bar").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn\'t\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n    constructor($from, $to, unplaced) {\n        this.$from = $from;\n        this.$to = $to;\n        this.unplaced = unplaced;\n        this.frontier = [];\n        this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        for (let i = 0; i <= $from.depth; i++) {\n            let node = $from.node(i);\n            this.frontier.push({\n                type: node.type,\n                match: node.contentMatchAt($from.indexAfter(i))\n            });\n        }\n        for (let i = $from.depth; i > 0; i--)\n            this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(i).copy(this.placed));\n    }\n    get depth() { return this.frontier.length - 1; }\n    fit() {\n        // As long as there\'s unplaced content, try to place some of it.\n        // If that fails, either increase the open score of the unplaced\n        // slice, or drop nodes from it, and then try again.\n        while (this.unplaced.size) {\n            let fit = this.findFittable();\n            if (fit)\n                this.placeNodes(fit);\n            else\n                this.openMore() || this.dropNode();\n        }\n        // When there\'s inline content directly after the frontier _and_\n        // directly after `this.$to`, we must generate a `ReplaceAround`\n        // step that pulls that content into the node after the frontier.\n        // That means the fitting must be done to the end of the textblock\n        // node after `this.$to`, not `this.$to` itself.\n        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n        if (!$to)\n            return null;\n        // If closing to `$to` succeeded, create a step\n        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n        while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n            content = content.firstChild.content;\n            openStart--;\n            openEnd--;\n        }\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n        if (moveInline > -1)\n            return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n        if (slice.size || $from.pos != this.$to.pos) // Don\'t generate no-op steps\n            return new ReplaceStep($from.pos, $to.pos, slice);\n        return null;\n    }\n    // Find a position on the start spine of `this.unplaced` that has\n    // content that can be moved somewhere on the frontier. Returns two\n    // depths, one for the slice and one for the frontier.\n    findFittable() {\n        let startDepth = this.unplaced.openStart;\n        for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {\n            let node = cur.firstChild;\n            if (cur.childCount > 1)\n                openEnd = 0;\n            if (node.type.spec.isolating && openEnd <= d) {\n                startDepth = d;\n                break;\n            }\n            cur = node.content;\n        }\n        // Only try wrapping nodes (pass 2) after finding a place without\n        // wrapping failed.\n        for (let pass = 1; pass <= 2; pass++) {\n            for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n                let fragment, parent = null;\n                if (sliceDepth) {\n                    parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n                    fragment = parent.content;\n                }\n                else {\n                    fragment = this.unplaced.content;\n                }\n                let first = fragment.firstChild;\n                for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n                    let { type, match } = this.frontier[frontierDepth], wrap, inject = null;\n                    // In pass 1, if the next node matches, or there is no next\n                    // node but the parents look compatible, we\'ve found a\n                    // place.\n                    if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false))\n                        : parent && type.compatibleContent(parent.type)))\n                        return { sliceDepth, frontierDepth, parent, inject };\n                    // In pass 2, look for a set of wrapping nodes that make\n                    // `first` fit here.\n                    else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n                        return { sliceDepth, frontierDepth, parent, wrap };\n                    // Don\'t continue looking further up if the parent node\n                    // would fit here.\n                    if (parent && match.matchType(parent.type))\n                        break;\n                }\n            }\n        }\n    }\n    openMore() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (!inner.childCount || inner.firstChild.isLeaf)\n            return false;\n        this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n        return true;\n    }\n    dropNode() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (inner.childCount <= 1 && openStart > 0) {\n            let openAtEnd = content.size - openStart <= openStart + inner.size;\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n        }\n        else {\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n        }\n    }\n    // Move content from the unplaced slice at `sliceDepth` to the\n    // frontier node at `frontierDepth`. Close that frontier node when\n    // applicable.\n    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap }) {\n        while (this.depth > frontierDepth)\n            this.closeFrontierNode();\n        if (wrap)\n            for (let i = 0; i < wrap.length; i++)\n                this.openFrontierNode(wrap[i]);\n        let slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n        let openStart = slice.openStart - sliceDepth;\n        let taken = 0, add = [];\n        let { match, type } = this.frontier[frontierDepth];\n        if (inject) {\n            for (let i = 0; i < inject.childCount; i++)\n                add.push(inject.child(i));\n            match = match.matchFragment(inject);\n        }\n        // Computes the amount of (end) open nodes at the end of the\n        // fragment. When 0, the parent is open, but no more. When\n        // negative, nothing is open.\n        let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);\n        // Scan over the fragment, fitting as many child nodes as\n        // possible.\n        while (taken < fragment.childCount) {\n            let next = fragment.child(taken), matches = match.matchType(next.type);\n            if (!matches)\n                break;\n            taken++;\n            if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n                match = matches;\n                add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n            }\n        }\n        let toEnd = taken == fragment.childCount;\n        if (!toEnd)\n            openEndCount = -1;\n        this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));\n        this.frontier[frontierDepth].match = match;\n        // If the parent types match, and the entire node was moved, and\n        // it\'s not open, close this frontier node right away.\n        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n            this.closeFrontierNode();\n        // Add new frontier nodes for any open nodes at the end.\n        for (let i = 0, cur = fragment; i < openEndCount; i++) {\n            let node = cur.lastChild;\n            this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });\n            cur = node.content;\n        }\n        // Update `this.unplaced`. Drop the entire node from which we\n        // placed it we got to its end, otherwise just drop the placed\n        // nodes.\n        this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n            : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n    }\n    mustMoveInline() {\n        if (!this.$to.parent.isTextblock)\n            return -1;\n        let top = this.frontier[this.depth], level;\n        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n            (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth))\n            return -1;\n        let { depth } = this.$to, after = this.$to.after(depth);\n        while (depth > 1 && after == this.$to.end(--depth))\n            ++after;\n        return after;\n    }\n    findCloseLevel($to) {\n        scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n            let { match, type } = this.frontier[i];\n            let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n            let fit = contentAfterFits($to, i, type, match, dropInner);\n            if (!fit)\n                continue;\n            for (let d = i - 1; d >= 0; d--) {\n                let { match, type } = this.frontier[d];\n                let matches = contentAfterFits($to, d, type, match, true);\n                if (!matches || matches.childCount)\n                    continue scan;\n            }\n            return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };\n        }\n    }\n    close($to) {\n        let close = this.findCloseLevel($to);\n        if (!close)\n            return null;\n        while (this.depth > close.depth)\n            this.closeFrontierNode();\n        if (close.fit.childCount)\n            this.placed = addToFragment(this.placed, close.depth, close.fit);\n        $to = close.move;\n        for (let d = close.depth + 1; d <= $to.depth; d++) {\n            let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n            this.openFrontierNode(node.type, node.attrs, add);\n        }\n        return $to;\n    }\n    openFrontierNode(type, attrs = null, content) {\n        let top = this.frontier[this.depth];\n        top.match = top.match.matchType(type);\n        this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));\n        this.frontier.push({ type, match: type.contentMatch });\n    }\n    closeFrontierNode() {\n        let open = this.frontier.pop();\n        let add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        if (add.childCount)\n            this.placed = addToFragment(this.placed, this.frontier.length, add);\n    }\n}\nfunction dropFromFragment(fragment, depth, count) {\n    if (depth == 0)\n        return fragment.cutByIndex(count, fragment.childCount);\n    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n    if (depth == 0)\n        return fragment.append(content);\n    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n    for (let i = 0; i < depth; i++)\n        fragment = fragment.firstChild.content;\n    return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n    if (openStart <= 0)\n        return node;\n    let frag = node.content;\n    if (openStart > 1)\n        frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n    if (openStart > 0) {\n        frag = node.type.contentMatch.fillBefore(frag).append(frag);\n        if (openEnd <= 0)\n            frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n    if (index == node.childCount && !type.compatibleContent(node.type))\n        return null;\n    let fit = match.fillBefore(node.content, true, index);\n    return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n    for (let i = start; i < fragment.childCount; i++)\n        if (!type.allowsMarks(fragment.child(i).marks))\n            return true;\n    return false;\n}\nfunction definesContent(type) {\n    return type.spec.defining || type.spec.definingForContent;\n}\nfunction replaceRange(tr, from, to, slice) {\n    if (!slice.size)\n        return tr.deleteRange(from, to);\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    if (fitsTrivially($from, $to, slice))\n        return tr.step(new ReplaceStep(from, to, slice));\n    let targetDepths = coveredDepths($from, tr.doc.resolve(to));\n    // Can\'t replace the whole document, so remove 0 if it\'s present\n    if (targetDepths[targetDepths.length - 1] == 0)\n        targetDepths.pop();\n    // Negative numbers represent not expansion over the whole node at\n    // that depth, but replacing from $from.before(-D) to $to.pos.\n    let preferredTarget = -($from.depth + 1);\n    targetDepths.unshift(preferredTarget);\n    // This loop picks a preferred target depth, if one of the covering\n    // depths is not outside of a defining node, and adds negative\n    // depths for any depth that has $from at its start and does not\n    // cross a defining node.\n    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n        let spec = $from.node(d).type.spec;\n        if (spec.defining || spec.definingAsContext || spec.isolating)\n            break;\n        if (targetDepths.indexOf(d) > -1)\n            preferredTarget = d;\n        else if ($from.before(d) == pos)\n            targetDepths.splice(1, 0, -d);\n    }\n    // Try to fit each possible depth of the slice into each possible\n    // target depth, starting with the preferred depths.\n    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n    let leftNodes = [], preferredDepth = slice.openStart;\n    for (let content = slice.content, i = 0;; i++) {\n        let node = content.firstChild;\n        leftNodes.push(node);\n        if (i == slice.openStart)\n            break;\n        content = node.content;\n    }\n    // Back up preferredDepth to cover defining textblocks directly\n    // above it, possibly skipping a non-defining textblock.\n    for (let d = preferredDepth - 1; d >= 0; d--) {\n        let type = leftNodes[d].type, def = definesContent(type);\n        if (def && $from.node(preferredTargetIndex).type != type)\n            preferredDepth = d;\n        else if (def || !type.isTextblock)\n            break;\n    }\n    for (let j = slice.openStart; j >= 0; j--) {\n        let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n        let insert = leftNodes[openDepth];\n        if (!insert)\n            continue;\n        for (let i = 0; i < targetDepths.length; i++) {\n            // Loop over possible expansion levels, starting with the\n            // preferred one\n            let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n            if (targetDepth < 0) {\n                expand = false;\n                targetDepth = -targetDepth;\n            }\n            let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n            if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n                return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n        }\n    }\n    let startSteps = tr.steps.length;\n    for (let i = targetDepths.length - 1; i >= 0; i--) {\n        tr.replace(from, to, slice);\n        if (tr.steps.length > startSteps)\n            break;\n        let depth = targetDepths[i];\n        if (depth < 0)\n            continue;\n        from = $from.before(depth);\n        to = $to.after(depth);\n    }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n    if (depth < oldOpen) {\n        let first = fragment.firstChild;\n        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n    }\n    if (depth > newOpen) {\n        let match = parent.contentMatchAt(0);\n        let start = match.fillBefore(fragment).append(fragment);\n        fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return fragment;\n}\nfunction replaceRangeWith(tr, from, to, node) {\n    if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n        let point = insertPoint(tr.doc, from, node.type);\n        if (point != null)\n            from = to = point;\n    }\n    tr.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0));\n}\nfunction deleteRange(tr, from, to) {\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    let covered = coveredDepths($from, $to);\n    for (let i = 0; i < covered.length; i++) {\n        let depth = covered[i], last = i == covered.length - 1;\n        if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n            return tr.delete($from.start(depth), $to.end(depth));\n        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n            return tr.delete($from.before(depth), $to.after(depth));\n    }\n    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n            return tr.delete($from.before(d), to);\n    }\n    tr.delete(from, to);\n}\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n    let result = [], minDepth = Math.min($from.depth, $to.depth);\n    for (let d = minDepth; d >= 0; d--) {\n        let start = $from.start(d);\n        if (start < $from.pos - ($from.depth - d) ||\n            $to.end(d) > $to.pos + ($to.depth - d) ||\n            $from.node(d).type.spec.isolating ||\n            $to.node(d).type.spec.isolating)\n            break;\n        if (start == $to.start(d) ||\n            (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n                d && $to.start(d - 1) == start - 1))\n            result.push(d);\n    }\n    return result;\n}\n\n/**\nUpdate an attribute in a specific node.\n*/\nclass AttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The attribute to set.\n    */\n    attr, \n    // The attribute\'s new value.\n    value) {\n        super();\n        this.pos = pos;\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail("No node at attribute step\'s position");\n        let attrs = Object.create(null);\n        for (let name in node.attrs)\n            attrs[name] = node.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = node.type.create(attrs, null, node.marks);\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n    }\n    toJSON() {\n        return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.pos != "number" || typeof json.attr != "string")\n            throw new RangeError("Invalid input for AttrStep.fromJSON");\n        return new AttrStep(json.pos, json.attr, json.value);\n    }\n}\nStep.jsonID("attr", AttrStep);\n\n/**\n@internal\n*/\nlet TransformError = class extends Error {\n};\nTransformError = function TransformError(message) {\n    let err = Error.call(this, message);\n    err.__proto__ = TransformError.prototype;\n    return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = "TransformError";\n/**\nAbstraction to build up and track an array of\n[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.\n\nMost transforming methods return the `Transform` object itself, so\nthat they can be chained.\n*/\nclass Transform {\n    /**\n    Create a transform that starts with the given document.\n    */\n    constructor(\n    /**\n    The current document (the result of applying the steps in the\n    transform).\n    */\n    doc) {\n        this.doc = doc;\n        /**\n        The steps in this transform.\n        */\n        this.steps = [];\n        /**\n        The documents before each of the steps.\n        */\n        this.docs = [];\n        /**\n        A mapping with the maps for each of the steps in this transform.\n        */\n        this.mapping = new Mapping;\n    }\n    /**\n    The starting document.\n    */\n    get before() { return this.docs.length ? this.docs[0] : this.doc; }\n    /**\n    Apply a new step in this transform, saving the result. Throws an\n    error when the step fails.\n    */\n    step(step) {\n        let result = this.maybeStep(step);\n        if (result.failed)\n            throw new TransformError(result.failed);\n        return this;\n    }\n    /**\n    Try to apply a step in this transformation, ignoring it if it\n    fails. Returns the step result.\n    */\n    maybeStep(step) {\n        let result = step.apply(this.doc);\n        if (!result.failed)\n            this.addStep(step, result.doc);\n        return result;\n    }\n    /**\n    True when the document has been changed (when there are any\n    steps).\n    */\n    get docChanged() {\n        return this.steps.length > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        this.docs.push(this.doc);\n        this.steps.push(step);\n        this.mapping.appendMap(step.getMap());\n        this.doc = doc;\n    }\n    /**\n    Replace the part of the document between `from` and `to` with the\n    given `slice`.\n    */\n    replace(from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        let step = replaceStep(this.doc, from, to, slice);\n        if (step)\n            this.step(step);\n        return this;\n    }\n    /**\n    Replace the given range with the given content, which may be a\n    fragment, node, or array of nodes.\n    */\n    replaceWith(from, to, content) {\n        return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0));\n    }\n    /**\n    Delete the content between the given positions.\n    */\n    delete(from, to) {\n        return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty);\n    }\n    /**\n    Insert the given content at the given position.\n    */\n    insert(pos, content) {\n        return this.replaceWith(pos, pos, content);\n    }\n    /**\n    Replace a range of the document with a given slice, using\n    `from`, `to`, and the slice\'s\n    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather\n    than fixed start and end points. This method may grow the\n    replaced area or close open nodes in the slice in order to get a\n    fit that is more in line with WYSIWYG expectations, by dropping\n    fully covered parent nodes of the replaced region when they are\n    marked [non-defining as\n    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an\n    open parent node from the slice that _is_ marked as [defining\n    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n    \n    This is the method, for example, to handle paste. The similar\n    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more\n    primitive tool which will _not_ move the start and end of its given\n    range, and is useful in situations where you need more precise\n    control over what happens.\n    */\n    replaceRange(from, to, slice) {\n        replaceRange(this, from, to, slice);\n        return this;\n    }\n    /**\n    Replace the given range with a node, but use `from` and `to` as\n    hints, rather than precise positions. When from and to are the same\n    and are at the start or end of a parent node in which the given\n    node doesn\'t fit, this method may _move_ them out towards a parent\n    that does allow the given node to be placed. When the given range\n    completely covers a parent node, this method may completely replace\n    that parent node.\n    */\n    replaceRangeWith(from, to, node) {\n        replaceRangeWith(this, from, to, node);\n        return this;\n    }\n    /**\n    Delete the given range, expanding it to cover fully covered\n    parent nodes until a valid replace is found.\n    */\n    deleteRange(from, to) {\n        deleteRange(this, from, to);\n        return this;\n    }\n    /**\n    Split the content in the given range off from its parent, if there\n    is sibling content before or after it, and move it up the tree to\n    the depth specified by `target`. You\'ll probably want to use\n    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make\n    sure the lift is valid.\n    */\n    lift(range, target) {\n        lift(this, range, target);\n        return this;\n    }\n    /**\n    Join the blocks around the given position. If depth is 2, their\n    last and first siblings are also joined, and so on.\n    */\n    join(pos, depth = 1) {\n        join(this, pos, depth);\n        return this;\n    }\n    /**\n    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.\n    The wrappers are assumed to be valid in this position, and should\n    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).\n    */\n    wrap(range, wrappers) {\n        wrap(this, range, wrappers);\n        return this;\n    }\n    /**\n    Set the type of all textblocks (partly) between `from` and `to` to\n    the given node type with the given attributes.\n    */\n    setBlockType(from, to = from, type, attrs = null) {\n        setBlockType(this, from, to, type, attrs);\n        return this;\n    }\n    /**\n    Change the type, attributes, and/or marks of the node at `pos`.\n    When `type` isn\'t given, the existing node type is preserved,\n    */\n    setNodeMarkup(pos, type, attrs = null, marks) {\n        setNodeMarkup(this, pos, type, attrs, marks);\n        return this;\n    }\n    /**\n    Set a single attribute on a given node to a new value.\n    */\n    setNodeAttribute(pos, attr, value) {\n        this.step(new AttrStep(pos, attr, value));\n        return this;\n    }\n    /**\n    Add a mark to the node at position `pos`.\n    */\n    addNodeMark(pos, mark) {\n        this.step(new AddNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Remove a mark (or a mark of the given type) from the node at\n    position `pos`.\n    */\n    removeNodeMark(pos, mark) {\n        if (!(mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark)) {\n            let node = this.doc.nodeAt(pos);\n            if (!node)\n                throw new RangeError("No node at position " + pos);\n            mark = mark.isInSet(node.marks);\n            if (!mark)\n                return this;\n        }\n        this.step(new RemoveNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Split the node at the given position, and optionally, if `depth` is\n    greater than one, any number of nodes above that. By default, the\n    parts split off will inherit the node type of the original node.\n    This can be changed by passing an array of types and attributes to\n    use after the split.\n    */\n    split(pos, depth = 1, typesAfter) {\n        split(this, pos, depth, typesAfter);\n        return this;\n    }\n    /**\n    Add the given mark to the inline content between `from` and `to`.\n    */\n    addMark(from, to, mark) {\n        addMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Remove marks from inline nodes between `from` and `to`. When\n    `mark` is a single mark, remove precisely that mark. When it is\n    a mark type, remove all marks of that type. When it is null,\n    remove all marks of any type.\n    */\n    removeMark(from, to, mark) {\n        removeMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Removes all marks and nodes from the content of the node at\n    `pos` that don\'t match the given new parent node type. Accepts\n    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as\n    third argument.\n    */\n    clearIncompatible(pos, parentType, match) {\n        clearIncompatible(this, pos, parentType, match);\n        return this;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdHJhbnNmb3JtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXRyYW5zZm9ybS9kaXN0L2luZGV4LmpzPzM4NDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVwbGFjZUVycm9yLCBTbGljZSwgRnJhZ21lbnQsIE1hcmtUeXBlLCBNYXJrIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG4vLyBSZWNvdmVyeSB2YWx1ZXMgZW5jb2RlIGEgcmFuZ2UgaW5kZXggYW5kIGFuIG9mZnNldC4gVGhleSBhcmVcbi8vIHJlcHJlc2VudGVkIGFzIG51bWJlcnMsIGJlY2F1c2UgdG9ucyBvZiB0aGVtIHdpbGwgYmUgY3JlYXRlZCB3aGVuXG4vLyBtYXBwaW5nLCBmb3IgZXhhbXBsZSwgYSBsYXJnZSBudW1iZXIgb2YgZGVjb3JhdGlvbnMuIFRoZSBudW1iZXInc1xuLy8gbG93ZXIgMTYgYml0cyBwcm92aWRlIHRoZSBpbmRleCwgdGhlIHJlbWFpbmluZyBiaXRzIHRoZSBvZmZzZXQuXG4vL1xuLy8gTm90ZTogV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYml0IHNoaWZ0IG9wZXJhdG9ycyB0byBlbi0gYW5kXG4vLyBkZWNvZGUgdGhlc2UsIHNpbmNlIHRob3NlIGNsaXAgdG8gMzIgYml0cywgd2hpY2ggd2UgbWlnaHQgaW4gcmFyZVxuLy8gY2FzZXMgd2FudCB0byBvdmVyZmxvdy4gQSA2NC1iaXQgZmxvYXQgY2FuIHJlcHJlc2VudCA0OC1iaXRcbi8vIGludGVnZXJzIHByZWNpc2VseS5cbmNvbnN0IGxvd2VyMTYgPSAweGZmZmY7XG5jb25zdCBmYWN0b3IxNiA9IE1hdGgucG93KDIsIDE2KTtcbmZ1bmN0aW9uIG1ha2VSZWNvdmVyKGluZGV4LCBvZmZzZXQpIHsgcmV0dXJuIGluZGV4ICsgb2Zmc2V0ICogZmFjdG9yMTY7IH1cbmZ1bmN0aW9uIHJlY292ZXJJbmRleCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgJiBsb3dlcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVyT2Zmc2V0KHZhbHVlKSB7IHJldHVybiAodmFsdWUgLSAodmFsdWUgJiBsb3dlcjE2KSkgLyBmYWN0b3IxNjsgfVxuY29uc3QgREVMX0JFRk9SRSA9IDEsIERFTF9BRlRFUiA9IDIsIERFTF9BQ1JPU1MgPSA0LCBERUxfU0lERSA9IDg7XG4vKipcbkFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBtYXBwZWQgcG9zaXRpb24gd2l0aCBleHRyYVxuaW5mb3JtYXRpb24uXG4qL1xuY2xhc3MgTWFwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBtYXBwZWQgdmVyc2lvbiBvZiB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZGVsSW5mbywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmRlbEluZm8gPSBkZWxJbmZvO1xuICAgICAgICB0aGlzLnJlY292ZXIgPSByZWNvdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgcG9zaXRpb24gd2FzIGRlbGV0ZWQsIHRoYXQgaXMsIHdoZXRoZXIgdGhlXG4gICAgc3RlcCByZW1vdmVkIHRoZSB0b2tlbiBvbiB0aGUgc2lkZSBxdWVyaWVkICh2aWEgdGhlIGBhc3NvY2ApXG4gICAgYXJndW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZCgpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfU0lERSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHRva2VuIGJlZm9yZSB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRCZWZvcmUoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9CRUZPUkUgfCBERUxfQUNST1NTKSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSB0b2tlbiBhZnRlciB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBZnRlcigpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0FGVEVSIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHdoZXRoZXIgYW55IG9mIHRoZSBzdGVwcyBtYXBwZWQgdGhyb3VnaCBkZWxldGVzIGFjcm9zcyB0aGVcbiAgICBwb3NpdGlvbiAoaW5jbHVkaW5nIGJvdGggdGhlIHRva2VuIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlXG4gICAgcG9zaXRpb24pLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBY3Jvc3MoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX0FDUk9TUykgPiAwOyB9XG59XG4vKipcbkEgbWFwIGRlc2NyaWJpbmcgdGhlIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucyBtYWRlIGJ5IGEgc3RlcCwgd2hpY2hcbmNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZVxucHJlLXN0ZXAgdmVyc2lvbiBvZiBhIGRvY3VtZW50IGFuZCB0aGUgc2FtZSBwb3NpdGlvbiBpbiB0aGVcbnBvc3Qtc3RlcCB2ZXJzaW9uLlxuKi9cbmNsYXNzIFN0ZXBNYXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBvc2l0aW9uIG1hcC4gVGhlIG1vZGlmaWNhdGlvbnMgdG8gdGhlIGRvY3VtZW50IGFyZVxuICAgIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsIGluIHdoaWNoIGVhY2ggZ3JvdXAgb2YgdGhyZWVcbiAgICByZXByZXNlbnRzIGEgbW9kaWZpZWQgY2h1bmsgYXMgYFtzdGFydCwgb2xkU2l6ZSwgbmV3U2l6ZV1gLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW52ZXJ0ZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbnZlcnRlZCA9IGludmVydGVkO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgU3RlcE1hcC5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pbnZlcnRlZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKiAzICsgMl0gLSB0aGlzLnJhbmdlc1tpICogMyArIDFdO1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbaW5kZXggKiAzXSArIGRpZmYgKyByZWNvdmVyT2Zmc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgbWFwUmVzdWx0KHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpOyB9XG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2lkZSA9ICFvbGRTaXplID8gYXNzb2MgOiBwb3MgPT0gc3RhcnQgPyAtMSA6IHBvcyA9PSBlbmQgPyAxIDogYXNzb2M7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXJ0ICsgZGlmZiArIChzaWRlIDwgMCA/IDAgOiBuZXdTaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGxldCByZWNvdmVyID0gcG9zID09IChhc3NvYyA8IDAgPyBzdGFydCA6IGVuZCkgPyBudWxsIDogbWFrZVJlY292ZXIoaSAvIDMsIHBvcyAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsID0gcG9zID09IHN0YXJ0ID8gREVMX0FGVEVSIDogcG9zID09IGVuZCA/IERFTF9CRUZPUkUgOiBERUxfQUNST1NTO1xuICAgICAgICAgICAgICAgIGlmIChhc3NvYyA8IDAgPyBwb3MgIT0gc3RhcnQgOiBwb3MgIT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICBkZWwgfD0gREVMX1NJREU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXBSZXN1bHQocmVzdWx0LCBkZWwsIHJlY292ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2ltcGxlID8gcG9zICsgZGlmZiA6IG5ldyBNYXBSZXN1bHQocG9zICsgZGlmZiwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG91Y2hlcyhwb3MsIHJlY292ZXIpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleChyZWNvdmVyKTtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQgJiYgaSA9PSBpbmRleCAqIDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0gLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGVhY2ggb2YgdGhlIGNoYW5nZWQgcmFuZ2VzIGluY2x1ZGVkIGluXG4gICAgdGhpcyBtYXAuXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGRpZmYgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldLCBvbGRTdGFydCA9IHN0YXJ0IC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCksIG5ld1N0YXJ0ID0gc3RhcnQgKyAodGhpcy5pbnZlcnRlZCA/IDAgOiBkaWZmKTtcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF07XG4gICAgICAgICAgICBmKG9sZFN0YXJ0LCBvbGRTdGFydCArIG9sZFNpemUsIG5ld1N0YXJ0LCBuZXdTdGFydCArIG5ld1NpemUpO1xuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGlzIG1hcC4gVGhlIHJlc3VsdCBjYW4gYmUgdXNlZCB0b1xuICAgIG1hcCBwb3NpdGlvbnMgaW4gdGhlIHBvc3Qtc3RlcCBkb2N1bWVudCB0byB0aGUgcHJlLXN0ZXAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcCh0aGlzLnJhbmdlcywgIXRoaXMuaW52ZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW52ZXJ0ZWQgPyBcIi1cIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodGhpcy5yYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXAgdGhhdCBtb3ZlcyBhbGwgcG9zaXRpb25zIGJ5IG9mZnNldCBgbmAgKHdoaWNoIG1heSBiZVxuICAgIG5lZ2F0aXZlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gYXBwbHlpbmcgc3RlcHMgbWVhbnQgZm9yIGFcbiAgICBzdWItZG9jdW1lbnQgdG8gYSBsYXJnZXIgZG9jdW1lbnQsIG9yIHZpY2UtdmVyc2EuXG4gICAgKi9cbiAgICBzdGF0aWMgb2Zmc2V0KG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT0gMCA/IFN0ZXBNYXAuZW1wdHkgOiBuZXcgU3RlcE1hcChuIDwgMCA/IFswLCAtbiwgMF0gOiBbMCwgMCwgbl0pO1xuICAgIH1cbn1cbi8qKlxuQSBTdGVwTWFwIHRoYXQgY29udGFpbnMgbm8gY2hhbmdlZCByYW5nZXMuXG4qL1xuU3RlcE1hcC5lbXB0eSA9IG5ldyBTdGVwTWFwKFtdKTtcbi8qKlxuQSBtYXBwaW5nIHJlcHJlc2VudHMgYSBwaXBlbGluZSBvZiB6ZXJvIG9yIG1vcmUgW3N0ZXBcbm1hcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcE1hcCkuIEl0IGhhcyBzcGVjaWFsIHByb3Zpc2lvbnMgZm9yIGxvc3NsZXNzbHlcbmhhbmRsaW5nIG1hcHBpbmcgcG9zaXRpb25zIHRocm91Z2ggYSBzZXJpZXMgb2Ygc3RlcHMgaW4gd2hpY2ggc29tZVxuc3RlcHMgYXJlIGludmVydGVkIHZlcnNpb25zIG9mIGVhcmxpZXIgc3RlcHMuIChUaGlzIGNvbWVzIHVwIHdoZW5cbuKAmFtyZWJhc2luZ10oL2RvY3MvZ3VpZGUvI3RyYW5zZm9ybS5yZWJhc2luZynigJkgc3RlcHMgZm9yXG5jb2xsYWJvcmF0aW9uIG9yIGhpc3RvcnkgbWFuYWdlbWVudC4pXG4qL1xuY2xhc3MgTWFwcGluZyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG1hcHBpbmcgd2l0aCB0aGUgZ2l2ZW4gcG9zaXRpb24gbWFwcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGVwIG1hcHMgaW4gdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgbWFwcyA9IFtdLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1pcnJvciwgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXksIHVzZWQgd2hlbiBgbWFwYCBvclxuICAgIGBtYXBSZXN1bHRgIGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIGZyb20gPSAwLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXkuXG4gICAgKi9cbiAgICB0byA9IG1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWFwcyA9IG1hcHM7XG4gICAgICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcHBpbmcgdGhhdCBtYXBzIG9ubHkgdGhyb3VnaCBhIHBhcnQgb2YgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBzbGljZShmcm9tID0gMCwgdG8gPSB0aGlzLm1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMsIHRoaXMubWlycm9yLCBmcm9tLCB0byk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcy5zbGljZSgpLCB0aGlzLm1pcnJvciAmJiB0aGlzLm1pcnJvci5zbGljZSgpLCB0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBzdGVwIG1hcCB0byB0aGUgZW5kIG9mIHRoaXMgbWFwcGluZy4gSWYgYG1pcnJvcnNgIGlzXG4gICAgZ2l2ZW4sIGl0IHNob3VsZCBiZSB0aGUgaW5kZXggb2YgdGhlIHN0ZXAgbWFwIHRoYXQgaXMgdGhlIG1pcnJvclxuICAgIGltYWdlIG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgYXBwZW5kTWFwKG1hcCwgbWlycm9ycykge1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5tYXBzLnB1c2gobWFwKTtcbiAgICAgICAgaWYgKG1pcnJvcnMgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0TWlycm9yKHRoaXMubWFwcy5sZW5ndGggLSAxLCBtaXJyb3JzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGFsbCB0aGUgc3RlcCBtYXBzIGluIGEgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZSAocHJlc2VydmluZ1xuICAgIG1pcnJvcmluZyBpbmZvcm1hdGlvbikuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0U2l6ZSA9IHRoaXMubWFwcy5sZW5ndGg7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLm1hcHNbaV0sIG1pcnIgIT0gbnVsbCAmJiBtaXJyIDwgaSA/IHN0YXJ0U2l6ZSArIG1pcnIgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmRzIHRoZSBvZmZzZXQgb2YgdGhlIHN0ZXAgbWFwIHRoYXQgbWlycm9ycyB0aGUgbWFwIGF0IHRoZVxuICAgIGdpdmVuIG9mZnNldCwgaW4gdGhpcyBtYXBwaW5nIChhcyBwZXIgdGhlIHNlY29uZCBhcmd1bWVudCB0b1xuICAgIGBhcHBlbmRNYXBgKS5cbiAgICAqL1xuICAgIGdldE1pcnJvcihuKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5taXJyb3IubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yW2ldID09IG4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pcnJvcltpICsgKGkgJSAyID8gLTEgOiAxKV07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2V0TWlycm9yKG4sIG0pIHtcbiAgICAgICAgaWYgKCF0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHRoaXMubWlycm9yID0gW107XG4gICAgICAgIHRoaXMubWlycm9yLnB1c2gobiwgbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGVuZCB0aGUgaW52ZXJzZSBvZiB0aGUgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcHBpbmdJbnZlcnRlZChtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBtYXBwaW5nLm1hcHMubGVuZ3RoIC0gMSwgdG90YWxTaXplID0gdGhpcy5tYXBzLmxlbmd0aCArIG1hcHBpbmcubWFwcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLmludmVydCgpLCBtaXJyICE9IG51bGwgJiYgbWlyciA+IGkgPyB0b3RhbFNpemUgLSBtaXJyIC0gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICBsZXQgaW52ZXJzZSA9IG5ldyBNYXBwaW5nO1xuICAgICAgICBpbnZlcnNlLmFwcGVuZE1hcHBpbmdJbnZlcnRlZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGludmVyc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspXG4gICAgICAgICAgICBwb3MgPSB0aGlzLm1hcHNbaV0ubWFwKHBvcywgYXNzb2MpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZywgcmV0dXJuaW5nIGEgbWFwcGluZ1xuICAgIHJlc3VsdC5cbiAgICAqL1xuICAgIG1hcFJlc3VsdChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgX21hcChwb3MsIGFzc29jLCBzaW1wbGUpIHtcbiAgICAgICAgbGV0IGRlbEluZm8gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdGhpcy5tYXBzW2ldLCByZXN1bHQgPSBtYXAubWFwUmVzdWx0KHBvcywgYXNzb2MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29yciA9IHRoaXMuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JyICE9IG51bGwgJiYgY29yciA+IGkgJiYgY29yciA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNvcnI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMubWFwc1tjb3JyXS5yZWNvdmVyKHJlc3VsdC5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsSW5mbyB8PSByZXN1bHQuZGVsSW5mbztcbiAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyA6IG5ldyBNYXBSZXN1bHQocG9zLCBkZWxJbmZvLCBudWxsKTtcbiAgICB9XG59XG5cbmNvbnN0IHN0ZXBzQnlJRCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcbkEgc3RlcCBvYmplY3QgcmVwcmVzZW50cyBhbiBhdG9taWMgY2hhbmdlLiBJdCBnZW5lcmFsbHkgYXBwbGllc1xub25seSB0byB0aGUgZG9jdW1lbnQgaXQgd2FzIGNyZWF0ZWQgZm9yLCBzaW5jZSB0aGUgcG9zaXRpb25zXG5zdG9yZWQgaW4gaXQgd2lsbCBvbmx5IG1ha2Ugc2Vuc2UgZm9yIHRoYXQgZG9jdW1lbnQuXG5cbk5ldyBzdGVwcyBhcmUgZGVmaW5lZCBieSBjcmVhdGluZyBjbGFzc2VzIHRoYXQgZXh0ZW5kIGBTdGVwYCxcbm92ZXJyaWRpbmcgdGhlIGBhcHBseWAsIGBpbnZlcnRgLCBgbWFwYCwgYGdldE1hcGAgYW5kIGBmcm9tSlNPTmBcbm1ldGhvZHMsIGFuZCByZWdpc3RlcmluZyB5b3VyIGNsYXNzIHdpdGggYSB1bmlxdWVcbkpTT04tc2VyaWFsaXphdGlvbiBpZGVudGlmaWVyIHVzaW5nXG5bYFN0ZXAuanNvbklEYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwXmpzb25JRCkuXG4qL1xuY2xhc3MgU3RlcCB7XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzdGVwIG1hcCB0aGF0IHJlcHJlc2VudHMgdGhlIGNoYW5nZXMgbWFkZSBieSB0aGlzIHN0ZXAsXG4gICAgYW5kIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGUgb2xkXG4gICAgYW5kIHRoZSBuZXcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXRNYXAoKSB7IHJldHVybiBTdGVwTWFwLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1lcmdlIHRoaXMgc3RlcCB3aXRoIGFub3RoZXIgb25lLCB0byBiZSBhcHBsaWVkIGRpcmVjdGx5XG4gICAgYWZ0ZXIgaXQuIFJldHVybnMgdGhlIG1lcmdlZCBzdGVwIHdoZW4gcG9zc2libGUsIG51bGwgaWYgdGhlXG4gICAgc3RlcHMgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICovXG4gICAgbWVyZ2Uob3RoZXIpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHN0ZXAgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2lsbCBjYWxsXG4gICAgdGhyb3VnaCB0byB0aGUgc3RlcCBjbGFzcycgb3duIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24uc3RlcFR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc3RlcHNCeUlEW2pzb24uc3RlcFR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc3RlcCB0eXBlICR7anNvbi5zdGVwVHlwZX0gZGVmaW5lZGApO1xuICAgICAgICByZXR1cm4gdHlwZS5mcm9tSlNPTihzY2hlbWEsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIHNlcmlhbGl6ZSBzdGVwcyB0byBKU09OLCBlYWNoIHN0ZXAgbmVlZHMgYSBzdHJpbmdcbiAgICBJRCB0byBhdHRhY2ggdG8gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFVzZSB0aGlzIG1ldGhvZCB0b1xuICAgIHJlZ2lzdGVyIGFuIElEIGZvciB5b3VyIHN0ZXAgY2xhc3Nlcy4gVHJ5IHRvIHBpY2sgc29tZXRoaW5nXG4gICAgdGhhdCdzIHVubGlrZWx5IHRvIGNsYXNoIHdpdGggc3RlcHMgZnJvbSBvdGhlciBtb2R1bGVzLlxuICAgICovXG4gICAgc3RhdGljIGpzb25JRChpZCwgc3RlcENsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBzdGVwc0J5SUQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc3RlcCBKU09OIElEIFwiICsgaWQpO1xuICAgICAgICBzdGVwc0J5SURbaWRdID0gc3RlcENsYXNzO1xuICAgICAgICBzdGVwQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICAgICAgICByZXR1cm4gc3RlcENsYXNzO1xuICAgIH1cbn1cbi8qKlxuVGhlIHJlc3VsdCBvZiBbYXBwbHlpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcC5hcHBseSkgYSBzdGVwLiBDb250YWlucyBlaXRoZXIgYVxubmV3IGRvY3VtZW50IG9yIGEgZmFpbHVyZSB2YWx1ZS5cbiovXG5jbGFzcyBTdGVwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2Zvcm1lZCBkb2N1bWVudCwgaWYgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGZhaWx1cmUgbWVzc2FnZSwgaWYgdW5zdWNjZXNzZnVsLlxuICAgICovXG4gICAgZmFpbGVkKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLmZhaWxlZCA9IGZhaWxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc3VjY2Vzc2Z1bCBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIHN0YXRpYyBvayhkb2MpIHsgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KGRvYywgbnVsbCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmYWlsZWQgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmFpbChtZXNzYWdlKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChudWxsLCBtZXNzYWdlKTsgfVxuICAgIC8qKlxuICAgIENhbGwgW2BOb2RlLnJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXBsYWNlKSB3aXRoIHRoZSBnaXZlblxuICAgIGFyZ3VtZW50cy4gQ3JlYXRlIGEgc3VjY2Vzc2Z1bCByZXN1bHQgaWYgaXQgc3VjY2VlZHMsIGFuZCBhXG4gICAgZmFpbGVkIG9uZSBpZiBpdCB0aHJvd3MgYSBgUmVwbGFjZUVycm9yYC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmVwbGFjZShkb2MsIGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQub2soZG9jLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmVwbGFjZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1hcEZyYWdtZW50KGZyYWdtZW50LCBmLCBwYXJlbnQpIHtcbiAgICBsZXQgbWFwcGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZnJhZ21lbnQuY2hpbGQoaSk7XG4gICAgICAgIGlmIChjaGlsZC5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmNvcHkobWFwRnJhZ21lbnQoY2hpbGQuY29udGVudCwgZiwgY2hpbGQpKTtcbiAgICAgICAgaWYgKGNoaWxkLmlzSW5saW5lKVxuICAgICAgICAgICAgY2hpbGQgPSBmKGNoaWxkLCBwYXJlbnQsIGkpO1xuICAgICAgICBtYXBwZWQucHVzaChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkobWFwcGVkKTtcbn1cbi8qKlxuQWRkIGEgbWFyayB0byBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIEFkZE1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSwgJGZyb20gPSBkb2MucmVzb2x2ZSh0aGlzLmZyb20pO1xuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ubm9kZSgkZnJvbS5zaGFyZWREZXB0aCh0aGlzLnRvKSk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCAobm9kZSwgcGFyZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuaXNBdG9tIHx8ICFwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZSh0aGlzLm1hcmsudHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5tYXJrKHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIHBhcmVudCksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBBZGRNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGRNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhZGRNYXJrXCIsIEFkZE1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGFsbCBpbmxpbmUgY29udGVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgUmVtb3ZlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5tYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIG5vZGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIGRvYyksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBSZW1vdmVNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVNYXJrXCIsIFJlbW92ZU1hcmtTdGVwKTtcbi8qKlxuQWRkIGEgbWFyayB0byBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgQWRkTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBtYXJrIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byBhZGQuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGxldCBuZXdTZXQgPSB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgICAgICBpZiAobmV3U2V0Lmxlbmd0aCA9PSBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLm1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCBub2RlLm1hcmtzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IEFkZE5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGROb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTm9kZU1hcmtcIiwgQWRkTm9kZU1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBSZW1vdmVOb2RlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byByZW1vdmUuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIXRoaXMubWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwicmVtb3ZlTm9kZU1hcmtcIiwgcG9zOiB0aGlzLnBvcywgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlbW92ZU5vZGVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAoanNvbi5wb3MsIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVOb2RlTWFya1wiLCBSZW1vdmVOb2RlTWFya1N0ZXApO1xuXG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgbmV3IGNvbnRlbnQuXG4qL1xuY2xhc3MgUmVwbGFjZVN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBUaGUgZ2l2ZW4gYHNsaWNlYCBzaG91bGQgZml0IHRoZSAnZ2FwJyBiZXR3ZWVuIGBmcm9tYCBhbmRcbiAgICBgdG9g4oCUdGhlIGRlcHRocyBtdXN0IGxpbmUgdXAsIGFuZCB0aGUgc3Vycm91bmRpbmcgbm9kZXMgbXVzdCBiZVxuICAgIGFibGUgdG8gYmUgam9pbmVkIHdpdGggdGhlIG9wZW4gc2lkZXMgb2YgdGhlIHNsaWNlLiBXaGVuXG4gICAgYHN0cnVjdHVyZWAgaXMgdHJ1ZSwgdGhlIHN0ZXAgd2lsbCBmYWlsIGlmIHRoZSBjb250ZW50IGJldHdlZW5cbiAgICBmcm9tIGFuZCB0byBpcyBub3QganVzdCBhIHNlcXVlbmNlIG9mIGNsb3NpbmcgYW5kIHRoZW4gb3BlbmluZ1xuICAgIHRva2VucyAodGhpcyBpcyB0byBndWFyZCBhZ2FpbnN0IHJlYmFzZWQgcmVwbGFjZSBzdGVwc1xuICAgIG92ZXJ3cml0aW5nIHNvbWV0aGluZyB0aGV5IHdlcmVuJ3Qgc3VwcG9zZWQgdG8pLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMudG8pKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSByZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5zbGljZSk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMudG8gLSB0aGlzLmZyb20sIHRoaXMuc2xpY2Uuc2l6ZV0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbS5wb3MsIE1hdGgubWF4KGZyb20ucG9zLCB0by5wb3MpLCB0aGlzLnNsaWNlKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCkgfHwgb3RoZXIuc3RydWN0dXJlIHx8IHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUgPT0gb3RoZXIuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuRW5kICYmICFvdGhlci5zbGljZS5vcGVuU3RhcnQpIHtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2UodGhpcy5zbGljZS5jb250ZW50LmFwcGVuZChvdGhlci5zbGljZS5jb250ZW50KSwgdGhpcy5zbGljZS5vcGVuU3RhcnQsIG90aGVyLnNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMudG8gKyAob3RoZXIudG8gLSBvdGhlci5mcm9tKSwgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlci50byA9PSB0aGlzLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlblN0YXJ0ICYmICFvdGhlci5zbGljZS5vcGVuRW5kKSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKG90aGVyLnNsaWNlLmNvbnRlbnQuYXBwZW5kKHRoaXMuc2xpY2UuY29udGVudCksIG90aGVyLnNsaWNlLm9wZW5TdGFydCwgdGhpcy5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAob3RoZXIuZnJvbSwgdGhpcy50bywgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGpzb24gPSB7IHN0ZXBUeXBlOiBcInJlcGxhY2VcIiwgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgICAgICBpZiAodGhpcy5zbGljZS5zaXplKVxuICAgICAgICAgICAganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGpzb24uZnJvbSwganNvbi50bywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlXCIsIFJlcGxhY2VTdGVwKTtcbi8qKlxuUmVwbGFjZSBhIHBhcnQgb2YgdGhlIGRvY3VtZW50IHdpdGggYSBzbGljZSBvZiBjb250ZW50LCBidXRcbnByZXNlcnZlIGEgcmFuZ2Ugb2YgdGhlIHJlcGxhY2VkIGNvbnRlbnQgYnkgbW92aW5nIGl0IGludG8gdGhlXG5zbGljZS5cbiovXG5jbGFzcyBSZXBsYWNlQXJvdW5kU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJlcGxhY2UtYXJvdW5kIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2UgYW5kIGdhcC5cbiAgICBgaW5zZXJ0YCBzaG91bGQgYmUgdGhlIHBvaW50IGluIHRoZSBzbGljZSBpbnRvIHdoaWNoIHRoZSBjb250ZW50XG4gICAgb2YgdGhlIGdhcCBzaG91bGQgYmUgbW92ZWQuIGBzdHJ1Y3R1cmVgIGhhcyB0aGUgc2FtZSBtZWFuaW5nIGFzXG4gICAgaXQgaGFzIGluIHRoZSBbYFJlcGxhY2VTdGVwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5SZXBsYWNlU3RlcCkgY2xhc3MuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcEZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgcHJlc2VydmVkIHJhbmdlLlxuICAgICovXG4gICAgZ2FwVG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGluIHRoZSBzbGljZSB3aGVyZSB0aGUgcHJlc2VydmVkIHJhbmdlIHNob3VsZCBiZVxuICAgIGluc2VydGVkLlxuICAgICovXG4gICAgaW5zZXJ0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0cnVjdHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5nYXBGcm9tID0gZ2FwRnJvbTtcbiAgICAgICAgdGhpcy5nYXBUbyA9IGdhcFRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgICAgICB0aGlzLnN0cnVjdHVyZSA9IHN0cnVjdHVyZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiAoY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSkgfHxcbiAgICAgICAgICAgIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5nYXBUbywgdGhpcy50bykpKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSBnYXAtcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgbGV0IGdhcCA9IGRvYy5zbGljZSh0aGlzLmdhcEZyb20sIHRoaXMuZ2FwVG8pO1xuICAgICAgICBpZiAoZ2FwLm9wZW5TdGFydCB8fCBnYXAub3BlbkVuZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJHYXAgaXMgbm90IGEgZmxhdCByYW5nZVwiKTtcbiAgICAgICAgbGV0IGluc2VydGVkID0gdGhpcy5zbGljZS5pbnNlcnRBdCh0aGlzLmluc2VydCwgZ2FwLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkNvbnRlbnQgZG9lcyBub3QgZml0IGluIGdhcFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIGluc2VydGVkKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmluc2VydCxcbiAgICAgICAgICAgIHRoaXMuZ2FwVG8sIHRoaXMudG8gLSB0aGlzLmdhcFRvLCB0aGlzLnNsaWNlLnNpemUgLSB0aGlzLmluc2VydF0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBnYXAgPSB0aGlzLmdhcFRvIC0gdGhpcy5nYXBGcm9tO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplICsgZ2FwLCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQgKyBnYXAsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLnJlbW92ZUJldHdlZW4odGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmdhcFRvIC0gdGhpcy5mcm9tKSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGxldCBnYXBGcm9tID0gbWFwcGluZy5tYXAodGhpcy5nYXBGcm9tLCAtMSksIGdhcFRvID0gbWFwcGluZy5tYXAodGhpcy5nYXBUbywgMSk7XG4gICAgICAgIGlmICgoZnJvbS5kZWxldGVkQWNyb3NzICYmIHRvLmRlbGV0ZWRBY3Jvc3MpIHx8IGdhcEZyb20gPCBmcm9tLnBvcyB8fCBnYXBUbyA+IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGZyb20ucG9zLCB0by5wb3MsIGdhcEZyb20sIGdhcFRvLCB0aGlzLnNsaWNlLCB0aGlzLmluc2VydCwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlQXJvdW5kXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8sXG4gICAgICAgICAgICBnYXBGcm9tOiB0aGlzLmdhcEZyb20sIGdhcFRvOiB0aGlzLmdhcFRvLCBpbnNlcnQ6IHRoaXMuaW5zZXJ0IH07XG4gICAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpXG4gICAgICAgICAgICBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAganNvbi5zdHJ1Y3R1cmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIGpzb24uZ2FwRnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmdhcFRvICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaW5zZXJ0ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VBcm91bmRTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGpzb24uZnJvbSwganNvbi50bywganNvbi5nYXBGcm9tLCBqc29uLmdhcFRvLCBTbGljZS5mcm9tSlNPTihzY2hlbWEsIGpzb24uc2xpY2UpLCBqc29uLmluc2VydCwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlQXJvdW5kXCIsIFJlcGxhY2VBcm91bmRTdGVwKTtcbmZ1bmN0aW9uIGNvbnRlbnRCZXR3ZWVuKGRvYywgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgZGlzdCA9IHRvIC0gZnJvbSwgZGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgICB3aGlsZSAoZGlzdCA+IDAgJiYgZGVwdGggPiAwICYmICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRmcm9tLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpIHtcbiAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgZGlzdC0tO1xuICAgIH1cbiAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgbGV0IG5leHQgPSAkZnJvbS5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICAgICAgd2hpbGUgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5pc0xlYWYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZGlzdC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkTWFyayh0ciwgZnJvbSwgdG8sIG1hcmspIHtcbiAgICBsZXQgcmVtb3ZlZCA9IFtdLCBhZGRlZCA9IFtdO1xuICAgIGxldCByZW1vdmluZywgYWRkaW5nO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtYXJrcyA9IG5vZGUubWFya3M7XG4gICAgICAgIGlmICghbWFyay5pc0luU2V0KG1hcmtzKSAmJiBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gbWFyay5hZGRUb1NldChtYXJrcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92aW5nICYmIHJlbW92aW5nLnRvID09IHN0YXJ0ICYmIHJlbW92aW5nLm1hcmsuZXEobWFya3NbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZpbmcudG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChyZW1vdmluZyA9IG5ldyBSZW1vdmVNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRpbmcgJiYgYWRkaW5nLnRvID09IHN0YXJ0KVxuICAgICAgICAgICAgICAgIGFkZGluZy50byA9IGVuZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKGFkZGluZyA9IG5ldyBBZGRNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZW1vdmVkLmZvckVhY2gocyA9PiB0ci5zdGVwKHMpKTtcbiAgICBhZGRlZC5mb3JFYWNoKHMgPT4gdHIuc3RlcChzKSk7XG59XG5mdW5jdGlvbiByZW1vdmVNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICAgIGxldCBtYXRjaGVkID0gW10sIHN0ZXAgPSAwO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGVwKys7XG4gICAgICAgIGxldCB0b1JlbW92ZSA9IG51bGw7XG4gICAgICAgIGlmIChtYXJrIGluc3RhbmNlb2YgTWFya1R5cGUpIHtcbiAgICAgICAgICAgIGxldCBzZXQgPSBub2RlLm1hcmtzLCBmb3VuZDtcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZCA9IG1hcmsuaXNJblNldChzZXQpKSB7XG4gICAgICAgICAgICAgICAgKHRvUmVtb3ZlIHx8ICh0b1JlbW92ZSA9IFtdKSkucHVzaChmb3VuZCk7XG4gICAgICAgICAgICAgICAgc2V0ID0gZm91bmQucmVtb3ZlRnJvbVNldChzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGlmIChtYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgdG9SZW1vdmUgPSBbbWFya107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b1JlbW92ZSA9IG5vZGUubWFya3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvUmVtb3ZlICYmIHRvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB0b1JlbW92ZVtpXSwgZm91bmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gbWF0Y2hlZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uc3RlcCA9PSBzdGVwIC0gMSAmJiBzdHlsZS5lcShtYXRjaGVkW2pdLnN0eWxlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC5zdGVwID0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCh7IHN0eWxlLCBmcm9tOiBNYXRoLm1heChwb3MsIGZyb20pLCB0bzogZW5kLCBzdGVwIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1hdGNoZWQuZm9yRWFjaChtID0+IHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKG0uZnJvbSwgbS50bywgbS5zdHlsZSkpKTtcbn1cbmZ1bmN0aW9uIGNsZWFySW5jb21wYXRpYmxlKHRyLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoID0gcGFyZW50VHlwZS5jb250ZW50TWF0Y2gpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBsZXQgZGVsU3RlcHMgPSBbXSwgY3VyID0gcG9zICsgMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGQoaSksIGVuZCA9IGN1ciArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBsZXQgYWxsb3dlZCA9IG1hdGNoLm1hdGNoVHlwZShjaGlsZC50eXBlKTtcbiAgICAgICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICAgICAgICBkZWxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIsIGVuZCwgU2xpY2UuZW1wdHkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gYWxsb3dlZDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGQubWFya3MubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRUeXBlLmFsbG93c01hcmtUeXBlKGNoaWxkLm1hcmtzW2pdLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChjdXIsIGVuZCwgY2hpbGQubWFya3Nbal0pKTtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBlbmQ7XG4gICAgfVxuICAgIGlmICghbWF0Y2gudmFsaWRFbmQpIHtcbiAgICAgICAgbGV0IGZpbGwgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgdHIucmVwbGFjZShjdXIsIGN1ciwgbmV3IFNsaWNlKGZpbGwsIDAsIDApKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGRlbFN0ZXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB0ci5zdGVwKGRlbFN0ZXBzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2FuQ3V0KG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKHN0YXJ0ID09IDAgfHwgbm9kZS5jYW5SZXBsYWNlKHN0YXJ0LCBub2RlLmNoaWxkQ291bnQpKSAmJlxuICAgICAgICAoZW5kID09IG5vZGUuY2hpbGRDb3VudCB8fCBub2RlLmNhblJlcGxhY2UoMCwgZW5kKSk7XG59XG4vKipcblRyeSB0byBmaW5kIGEgdGFyZ2V0IGRlcHRoIHRvIHdoaWNoIHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZVxuY2FuIGJlIGxpZnRlZC4gV2lsbCBub3QgZ28gYWNyb3NzXG5baXNvbGF0aW5nXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuaXNvbGF0aW5nKSBwYXJlbnQgbm9kZXMuXG4qL1xuZnVuY3Rpb24gbGlmdFRhcmdldChyYW5nZSkge1xuICAgIGxldCBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gICAgbGV0IGNvbnRlbnQgPSBwYXJlbnQuY29udGVudC5jdXRCeUluZGV4KHJhbmdlLnN0YXJ0SW5kZXgsIHJhbmdlLmVuZEluZGV4KTtcbiAgICBmb3IgKGxldCBkZXB0aCA9IHJhbmdlLmRlcHRoOzsgLS1kZXB0aCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJhbmdlLiRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICBsZXQgaW5kZXggPSByYW5nZS4kZnJvbS5pbmRleChkZXB0aCksIGVuZEluZGV4ID0gcmFuZ2UuJHRvLmluZGV4QWZ0ZXIoZGVwdGgpO1xuICAgICAgICBpZiAoZGVwdGggPCByYW5nZS5kZXB0aCAmJiBub2RlLmNhblJlcGxhY2UoaW5kZXgsIGVuZEluZGV4LCBjb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgaWYgKGRlcHRoID09IDAgfHwgbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8ICFjYW5DdXQobm9kZSwgaW5kZXgsIGVuZEluZGV4KSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGxpZnQodHIsIHJhbmdlLCB0YXJnZXQpIHtcbiAgICBsZXQgeyAkZnJvbSwgJHRvLCBkZXB0aCB9ID0gcmFuZ2U7XG4gICAgbGV0IGdhcFN0YXJ0ID0gJGZyb20uYmVmb3JlKGRlcHRoICsgMSksIGdhcEVuZCA9ICR0by5hZnRlcihkZXB0aCArIDEpO1xuICAgIGxldCBzdGFydCA9IGdhcFN0YXJ0LCBlbmQgPSBnYXBFbmQ7XG4gICAgbGV0IGJlZm9yZSA9IEZyYWdtZW50LmVtcHR5LCBvcGVuU3RhcnQgPSAwO1xuICAgIGZvciAobGV0IGQgPSBkZXB0aCwgc3BsaXR0aW5nID0gZmFsc2U7IGQgPiB0YXJnZXQ7IGQtLSlcbiAgICAgICAgaWYgKHNwbGl0dGluZyB8fCAkZnJvbS5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICAgIHNwbGl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICBiZWZvcmUgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weShiZWZvcmUpKTtcbiAgICAgICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQtLTtcbiAgICAgICAgfVxuICAgIGxldCBhZnRlciA9IEZyYWdtZW50LmVtcHR5LCBvcGVuRW5kID0gMDtcbiAgICBmb3IgKGxldCBkID0gZGVwdGgsIHNwbGl0dGluZyA9IGZhbHNlOyBkID4gdGFyZ2V0OyBkLS0pXG4gICAgICAgIGlmIChzcGxpdHRpbmcgfHwgJHRvLmFmdGVyKGQgKyAxKSA8ICR0by5lbmQoZCkpIHtcbiAgICAgICAgICAgIHNwbGl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICBhZnRlciA9IEZyYWdtZW50LmZyb20oJHRvLm5vZGUoZCkuY29weShhZnRlcikpO1xuICAgICAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBnYXBTdGFydCwgZ2FwRW5kLCBuZXcgU2xpY2UoYmVmb3JlLmFwcGVuZChhZnRlciksIG9wZW5TdGFydCwgb3BlbkVuZCksIGJlZm9yZS5zaXplIC0gb3BlblN0YXJ0LCB0cnVlKSk7XG59XG4vKipcblRyeSB0byBmaW5kIGEgdmFsaWQgd2F5IHRvIHdyYXAgdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlIGluIGFcbm5vZGUgb2YgdGhlIGdpdmVuIHR5cGUuIE1heSBpbnRyb2R1Y2UgZXh0cmEgbm9kZXMgYXJvdW5kIGFuZCBpbnNpZGVcbnRoZSB3cmFwcGVyIG5vZGUsIGlmIG5lY2Vzc2FyeS4gUmV0dXJucyBudWxsIGlmIG5vIHZhbGlkIHdyYXBwaW5nXG5jb3VsZCBiZSBmb3VuZC4gV2hlbiBgaW5uZXJSYW5nZWAgaXMgZ2l2ZW4sIHRoYXQgcmFuZ2UncyBjb250ZW50IGlzXG51c2VkIGFzIHRoZSBjb250ZW50IHRvIGZpdCBpbnRvIHRoZSB3cmFwcGluZywgaW5zdGVhZCBvZiB0aGVcbmNvbnRlbnQgb2YgYHJhbmdlYC5cbiovXG5mdW5jdGlvbiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyA9IG51bGwsIGlubmVyUmFuZ2UgPSByYW5nZSkge1xuICAgIGxldCBhcm91bmQgPSBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCBub2RlVHlwZSk7XG4gICAgbGV0IGlubmVyID0gYXJvdW5kICYmIGZpbmRXcmFwcGluZ0luc2lkZShpbm5lclJhbmdlLCBub2RlVHlwZSk7XG4gICAgaWYgKCFpbm5lcilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGFyb3VuZC5tYXAod2l0aEF0dHJzKVxuICAgICAgICAuY29uY2F0KHsgdHlwZTogbm9kZVR5cGUsIGF0dHJzIH0pLmNvbmNhdChpbm5lci5tYXAod2l0aEF0dHJzKSk7XG59XG5mdW5jdGlvbiB3aXRoQXR0cnModHlwZSkgeyByZXR1cm4geyB0eXBlLCBhdHRyczogbnVsbCB9OyB9XG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgbGV0IHsgcGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcmFuZ2U7XG4gICAgbGV0IGFyb3VuZCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChzdGFydEluZGV4KS5maW5kV3JhcHBpbmcodHlwZSk7XG4gICAgaWYgKCFhcm91bmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvdXRlciA9IGFyb3VuZC5sZW5ndGggPyBhcm91bmRbMF0gOiB0eXBlO1xuICAgIHJldHVybiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoc3RhcnRJbmRleCwgZW5kSW5kZXgsIG91dGVyKSA/IGFyb3VuZCA6IG51bGw7XG59XG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdJbnNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICBsZXQgeyBwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBsZXQgaW5uZXIgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCk7XG4gICAgbGV0IGluc2lkZSA9IHR5cGUuY29udGVudE1hdGNoLmZpbmRXcmFwcGluZyhpbm5lci50eXBlKTtcbiAgICBpZiAoIWluc2lkZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGxhc3RUeXBlID0gaW5zaWRlLmxlbmd0aCA/IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0gOiB0eXBlO1xuICAgIGxldCBpbm5lck1hdGNoID0gbGFzdFR5cGUuY29udGVudE1hdGNoO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpbm5lck1hdGNoICYmIGkgPCBlbmRJbmRleDsgaSsrKVxuICAgICAgICBpbm5lck1hdGNoID0gaW5uZXJNYXRjaC5tYXRjaFR5cGUocGFyZW50LmNoaWxkKGkpLnR5cGUpO1xuICAgIGlmICghaW5uZXJNYXRjaCB8fCAhaW5uZXJNYXRjaC52YWxpZEVuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGluc2lkZTtcbn1cbmZ1bmN0aW9uIHdyYXAodHIsIHJhbmdlLCB3cmFwcGVycykge1xuICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHdyYXBwZXJzW2ldLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaC52YWxpZEVuZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIldyYXBwZXIgdHlwZSBnaXZlbiB0byBUcmFuc2Zvcm0ud3JhcCBkb2VzIG5vdCBmb3JtIHZhbGlkIGNvbnRlbnQgb2YgaXRzIHBhcmVudCB3cmFwcGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gICAgfVxuICAgIGxldCBzdGFydCA9IHJhbmdlLnN0YXJ0LCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgc3RhcnQsIGVuZCwgbmV3IFNsaWNlKGNvbnRlbnQsIDAsIDApLCB3cmFwcGVycy5sZW5ndGgsIHRydWUpKTtcbn1cbmZ1bmN0aW9uIHNldEJsb2NrVHlwZSh0ciwgZnJvbSwgdG8sIHR5cGUsIGF0dHJzKSB7XG4gICAgaWYgKCF0eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlR5cGUgZ2l2ZW4gdG8gc2V0QmxvY2tUeXBlIHNob3VsZCBiZSBhIHRleHRibG9ja1wiKTtcbiAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aDtcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmICFub2RlLmhhc01hcmt1cCh0eXBlLCBhdHRycykgJiYgY2FuQ2hhbmdlVHlwZSh0ci5kb2MsIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyksIHR5cGUpKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgYWxsIG1hcmt1cCB0aGF0IGlzbid0IGFsbG93ZWQgaW4gdGhlIG5ldyBub2RlIHR5cGUgaXMgY2xlYXJlZFxuICAgICAgICAgICAgdHIuY2xlYXJJbmNvbXBhdGlibGUodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zLCAxKSwgdHlwZSk7XG4gICAgICAgICAgICBsZXQgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICBsZXQgc3RhcnRNID0gbWFwcGluZy5tYXAocG9zLCAxKSwgZW5kTSA9IG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUsIDEpO1xuICAgICAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnRNLCBlbmRNLCBzdGFydE0gKyAxLCBlbmRNIC0gMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG5vZGUubWFya3MpKSwgMCwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2FuQ2hhbmdlVHlwZShkb2MsIHBvcywgdHlwZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgcmV0dXJuICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIHR5cGUpO1xufVxuLyoqXG5DaGFuZ2UgdGhlIHR5cGUsIGF0dHJpYnV0ZXMsIGFuZC9vciBtYXJrcyBvZiB0aGUgbm9kZSBhdCBgcG9zYC5cbldoZW4gYHR5cGVgIGlzbid0IGdpdmVuLCB0aGUgZXhpc3Rpbmcgbm9kZSB0eXBlIGlzIHByZXNlcnZlZCxcbiovXG5mdW5jdGlvbiBzZXROb2RlTWFya3VwKHRyLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICAgIGxldCBub2RlID0gdHIuZG9jLm5vZGVBdChwb3MpO1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXCIpO1xuICAgIGlmICghdHlwZSlcbiAgICAgICAgdHlwZSA9IG5vZGUudHlwZTtcbiAgICBsZXQgbmV3Tm9kZSA9IHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBtYXJrcyB8fCBub2RlLm1hcmtzKTtcbiAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgIHJldHVybiB0ci5yZXBsYWNlV2l0aChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIG5ld05vZGUpO1xuICAgIGlmICghdHlwZS52YWxpZENvbnRlbnQobm9kZS5jb250ZW50KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgdHlwZSBcIiArIHR5cGUubmFtZSk7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBwb3MgKyAxLCBwb3MgKyBub2RlLm5vZGVTaXplIC0gMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obmV3Tm9kZSksIDAsIDApLCAxLCB0cnVlKSk7XG59XG4vKipcbkNoZWNrIHdoZXRoZXIgc3BsaXR0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBhbGxvd2VkLlxuKi9cbmZ1bmN0aW9uIGNhblNwbGl0KGRvYywgcG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGJhc2UgPSAkcG9zLmRlcHRoIC0gZGVwdGg7XG4gICAgbGV0IGlubmVyVHlwZSA9ICh0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbdHlwZXNBZnRlci5sZW5ndGggLSAxXSkgfHwgJHBvcy5wYXJlbnQ7XG4gICAgaWYgKGJhc2UgPCAwIHx8ICRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgISRwb3MucGFyZW50LmNhblJlcGxhY2UoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSB8fFxuICAgICAgICAhaW5uZXJUeXBlLnR5cGUudmFsaWRDb250ZW50KCRwb3MucGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleCgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMSwgaSA9IGRlcHRoIC0gMjsgZCA+IGJhc2U7IGQtLSwgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gJHBvcy5ub2RlKGQpLCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCByZXN0ID0gbm9kZS5jb250ZW50LmN1dEJ5SW5kZXgoaW5kZXgsIG5vZGUuY2hpbGRDb3VudCk7XG4gICAgICAgIGxldCBhZnRlciA9ICh0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV0pIHx8IG5vZGU7XG4gICAgICAgIGlmIChhZnRlciAhPSBub2RlKVxuICAgICAgICAgICAgcmVzdCA9IHJlc3QucmVwbGFjZUNoaWxkKDAsIGFmdGVyLnR5cGUuY3JlYXRlKGFmdGVyLmF0dHJzKSk7XG4gICAgICAgIGlmICghbm9kZS5jYW5SZXBsYWNlKGluZGV4ICsgMSwgbm9kZS5jaGlsZENvdW50KSB8fCAhYWZ0ZXIudHlwZS52YWxpZENvbnRlbnQocmVzdCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihiYXNlKTtcbiAgICBsZXQgYmFzZVR5cGUgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbMF07XG4gICAgcmV0dXJuICRwb3Mubm9kZShiYXNlKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGJhc2VUeXBlID8gYmFzZVR5cGUudHlwZSA6ICRwb3Mubm9kZShiYXNlICsgMSkudHlwZSk7XG59XG5mdW5jdGlvbiBzcGxpdCh0ciwgcG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICBsZXQgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcyksIGJlZm9yZSA9IEZyYWdtZW50LmVtcHR5LCBhZnRlciA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoLCBlID0gJHBvcy5kZXB0aCAtIGRlcHRoLCBpID0gZGVwdGggLSAxOyBkID4gZTsgZC0tLCBpLS0pIHtcbiAgICAgICAgYmVmb3JlID0gRnJhZ21lbnQuZnJvbSgkcG9zLm5vZGUoZCkuY29weShiZWZvcmUpKTtcbiAgICAgICAgbGV0IHR5cGVBZnRlciA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpXTtcbiAgICAgICAgYWZ0ZXIgPSBGcmFnbWVudC5mcm9tKHR5cGVBZnRlciA/IHR5cGVBZnRlci50eXBlLmNyZWF0ZSh0eXBlQWZ0ZXIuYXR0cnMsIGFmdGVyKSA6ICRwb3Mubm9kZShkKS5jb3B5KGFmdGVyKSk7XG4gICAgfVxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKHBvcywgcG9zLCBuZXcgU2xpY2UoYmVmb3JlLmFwcGVuZChhZnRlciksIGRlcHRoLCBkZXB0aCksIHRydWUpKTtcbn1cbi8qKlxuVGVzdCB3aGV0aGVyIHRoZSBibG9ja3MgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIHBvc2l0aW9uIGNhbiBiZVxuam9pbmVkLlxuKi9cbmZ1bmN0aW9uIGNhbkpvaW4oZG9jLCBwb3MpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIHJldHVybiBqb2luYWJsZSgkcG9zLm5vZGVCZWZvcmUsICRwb3Mubm9kZUFmdGVyKSAmJlxuICAgICAgICAkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpO1xufVxuZnVuY3Rpb24gam9pbmFibGUoYSwgYikge1xuICAgIHJldHVybiAhIShhICYmIGIgJiYgIWEuaXNMZWFmICYmIGEuY2FuQXBwZW5kKGIpKTtcbn1cbi8qKlxuRmluZCBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gdGhhdCBjYW4gYmUgam9pbmVkIHRvIHRoZVxuYmxvY2sgYmVmb3JlIChvciBhZnRlciBpZiBgZGlyYCBpcyBwb3NpdGl2ZSkuIFJldHVybnMgdGhlIGpvaW5hYmxlXG5wb2ludCwgaWYgYW55LlxuKi9cbmZ1bmN0aW9uIGpvaW5Qb2ludChkb2MsIHBvcywgZGlyID0gLTEpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7OyBkLS0pIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIsIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgaWYgKGQgPT0gJHBvcy5kZXB0aCkge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVmb3JlICYmICFiZWZvcmUuaXNUZXh0YmxvY2sgJiYgam9pbmFibGUoYmVmb3JlLCBhZnRlcikgJiZcbiAgICAgICAgICAgICRwb3Mubm9kZShkKS5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgaWYgKGQgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwb3MgPSBkaXIgPCAwID8gJHBvcy5iZWZvcmUoZCkgOiAkcG9zLmFmdGVyKGQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGpvaW4odHIsIHBvcywgZGVwdGgpIHtcbiAgICBsZXQgc3RlcCA9IG5ldyBSZXBsYWNlU3RlcChwb3MgLSBkZXB0aCwgcG9zICsgZGVwdGgsIFNsaWNlLmVtcHR5LCB0cnVlKTtcbiAgICB0ci5zdGVwKHN0ZXApO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHBvaW50IHdoZXJlIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSBjYW4gYmUgaW5zZXJ0ZWRcbm5lYXIgYHBvc2AsIGJ5IHNlYXJjaGluZyB1cCB0aGUgbm9kZSBoaWVyYXJjaHkgd2hlbiBgcG9zYCBpdHNlbGZcbmlzbid0IGEgdmFsaWQgcGxhY2UgYnV0IGlzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBub2RlLiBSZXR1cm5cbm51bGwgaWYgbm8gcG9zaXRpb24gd2FzIGZvdW5kLlxuKi9cbmZ1bmN0aW9uIGluc2VydFBvaW50KGRvYywgcG9zLCBub2RlVHlwZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoJHBvcy5pbmRleCgpLCAkcG9zLmluZGV4KCksIG5vZGVUeXBlKSlcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gMClcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuYmVmb3JlKGQgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gJHBvcy5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmFmdGVyKGQgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8ICRwb3Mubm9kZShkKS5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbkZpbmRzIGEgcG9zaXRpb24gYXQgb3IgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbiB3aGVyZSB0aGUgZ2l2ZW5cbnNsaWNlIGNhbiBiZSBpbnNlcnRlZC4gV2lsbCBsb29rIGF0IHBhcmVudCBub2RlcycgbmVhcmVzdCBib3VuZGFyeVxuYW5kIHRyeSB0aGVyZSwgZXZlbiBpZiB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2Fzbid0IGRpcmVjdGx5IGF0IHRoZVxuc3RhcnQgb3IgZW5kIG9mIHRoYXQgbm9kZS4gUmV0dXJucyBudWxsIHdoZW4gbm8gcG9zaXRpb24gd2FzIGZvdW5kLlxuKi9cbmZ1bmN0aW9uIGRyb3BQb2ludChkb2MsIHBvcywgc2xpY2UpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCFzbGljZS5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgbGV0IGNvbnRlbnQgPSBzbGljZS5jb250ZW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2Uub3BlblN0YXJ0OyBpKyspXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICBmb3IgKGxldCBwYXNzID0gMTsgcGFzcyA8PSAoc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uuc2l6ZSA/IDIgOiAxKTsgcGFzcysrKSB7XG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGJpYXMgPSBkID09ICRwb3MuZGVwdGggPyAwIDogJHBvcy5wb3MgPD0gKCRwb3Muc3RhcnQoZCArIDEpICsgJHBvcy5lbmQoZCArIDEpKSAvIDIgPyAtMSA6IDE7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0UG9zID0gJHBvcy5pbmRleChkKSArIChiaWFzID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoZCksIGZpdHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChwYXNzID09IDEpIHtcbiAgICAgICAgICAgICAgICBmaXRzID0gcGFyZW50LmNhblJlcGxhY2UoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwaW5nID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KGluc2VydFBvcykuZmluZFdyYXBwaW5nKGNvbnRlbnQuZmlyc3RDaGlsZC50eXBlKTtcbiAgICAgICAgICAgICAgICBmaXRzID0gd3JhcHBpbmcgJiYgcGFyZW50LmNhblJlcGxhY2VXaXRoKGluc2VydFBvcywgaW5zZXJ0UG9zLCB3cmFwcGluZ1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZml0cylcbiAgICAgICAgICAgICAgICByZXR1cm4gYmlhcyA9PSAwID8gJHBvcy5wb3MgOiBiaWFzIDwgMCA/ICRwb3MuYmVmb3JlKGQgKyAxKSA6ICRwb3MuYWZ0ZXIoZCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbuKAmEZpdOKAmSBhIHNsaWNlIGludG8gYSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQsIHByb2R1Y2luZyBhXG5bc3RlcF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwKSB0aGF0IGluc2VydHMgaXQuIFdpbGwgcmV0dXJuIG51bGwgaWZcbnRoZXJlJ3Mgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gaW5zZXJ0IHRoZSBzbGljZSBoZXJlLCBvciBpbnNlcnRpbmcgaXRcbndvdWxkIGJlIGEgbm8tb3AgKGFuIGVtcHR5IHNsaWNlIG92ZXIgYW4gZW1wdHkgcmFuZ2UpLlxuKi9cbmZ1bmN0aW9uIHJlcGxhY2VTdGVwKGRvYywgZnJvbSwgdG8gPSBmcm9tLCBzbGljZSA9IFNsaWNlLmVtcHR5KSB7XG4gICAgaWYgKGZyb20gPT0gdG8gJiYgIXNsaWNlLnNpemUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSBkb2MucmVzb2x2ZSh0byk7XG4gICAgLy8gT3B0aW1pemF0aW9uIC0tIGF2b2lkIHdvcmsgaWYgaXQncyBvYnZpb3VzIHRoYXQgaXQncyBub3QgbmVlZGVkLlxuICAgIGlmIChmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSlcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpO1xuICAgIHJldHVybiBuZXcgRml0dGVyKCRmcm9tLCAkdG8sIHNsaWNlKS5maXQoKTtcbn1cbmZ1bmN0aW9uIGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgICByZXR1cm4gIXNsaWNlLm9wZW5TdGFydCAmJiAhc2xpY2Uub3BlbkVuZCAmJiAkZnJvbS5zdGFydCgpID09ICR0by5zdGFydCgpICYmXG4gICAgICAgICRmcm9tLnBhcmVudC5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KCksICR0by5pbmRleCgpLCBzbGljZS5jb250ZW50KTtcbn1cbi8vIEFsZ29yaXRobSBmb3IgJ3BsYWNpbmcnIHRoZSBlbGVtZW50cyBvZiBhIHNsaWNlIGludG8gYSBnYXA6XG4vL1xuLy8gV2UgY29uc2lkZXIgdGhlIGNvbnRlbnQgb2YgZWFjaCBub2RlIHRoYXQgaXMgb3BlbiB0byB0aGUgbGVmdCB0byBiZVxuLy8gaW5kZXBlbmRlbnRseSBwbGFjZWFibGUuIEkuZS4gaW4gPHAoXCJmb29cIiksIHAoXCJiYXJcIik+LCB3aGVuIHRoZVxuLy8gcGFyYWdyYXBoIG9uIHRoZSBsZWZ0IGlzIG9wZW4sIFwiZm9vXCIgY2FuIGJlIHBsYWNlZCAoc29tZXdoZXJlIG9uXG4vLyB0aGUgbGVmdCBzaWRlIG9mIHRoZSByZXBsYWNlbWVudCBnYXApIGluZGVwZW5kZW50bHkgZnJvbSBwKFwiYmFyXCIpLlxuLy9cbi8vIFRoaXMgY2xhc3MgdHJhY2tzIHRoZSBzdGF0ZSBvZiB0aGUgcGxhY2VtZW50IHByb2dyZXNzIGluIHRoZVxuLy8gZm9sbG93aW5nIHByb3BlcnRpZXM6XG4vL1xuLy8gIC0gYGZyb250aWVyYCBob2xkcyBhIHN0YWNrIG9mIGB7dHlwZSwgbWF0Y2h9YCBvYmplY3RzIHRoYXRcbi8vICAgIHJlcHJlc2VudCB0aGUgb3BlbiBzaWRlIG9mIHRoZSByZXBsYWNlbWVudC4gSXQgc3RhcnRzIGF0XG4vLyAgICBgJGZyb21gLCB0aGVuIG1vdmVzIGZvcndhcmQgYXMgY29udGVudCBpcyBwbGFjZWQsIGFuZCBpcyBmaW5hbGx5XG4vLyAgICByZWNvbmNpbGVkIHdpdGggYCR0b2AuXG4vL1xuLy8gIC0gYHVucGxhY2VkYCBpcyBhIHNsaWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY29udGVudCB0aGF0IGhhc24ndFxuLy8gICAgYmVlbiBwbGFjZWQgeWV0LlxuLy9cbi8vICAtIGBwbGFjZWRgIGlzIGEgZnJhZ21lbnQgb2YgcGxhY2VkIGNvbnRlbnQuIEl0cyBvcGVuLXN0YXJ0IHZhbHVlXG4vLyAgICBpcyBpbXBsaWNpdCBpbiBgJGZyb21gLCBhbmQgaXRzIG9wZW4tZW5kIHZhbHVlIGluIGBmcm9udGllcmAuXG5jbGFzcyBGaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCRmcm9tLCAkdG8sIHVucGxhY2VkKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSB1bnBsYWNlZDtcbiAgICAgICAgdGhpcy5mcm9udGllciA9IFtdO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAkZnJvbS5kZXB0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICRmcm9tLm5vZGUoaSk7XG4gICAgICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKGkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9ICRmcm9tLmRlcHRoOyBpID4gMDsgaS0tKVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoaSkuY29weSh0aGlzLnBsYWNlZCkpO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmZyb250aWVyLmxlbmd0aCAtIDE7IH1cbiAgICBmaXQoKSB7XG4gICAgICAgIC8vIEFzIGxvbmcgYXMgdGhlcmUncyB1bnBsYWNlZCBjb250ZW50LCB0cnkgdG8gcGxhY2Ugc29tZSBvZiBpdC5cbiAgICAgICAgLy8gSWYgdGhhdCBmYWlscywgZWl0aGVyIGluY3JlYXNlIHRoZSBvcGVuIHNjb3JlIG9mIHRoZSB1bnBsYWNlZFxuICAgICAgICAvLyBzbGljZSwgb3IgZHJvcCBub2RlcyBmcm9tIGl0LCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgICAgIHdoaWxlICh0aGlzLnVucGxhY2VkLnNpemUpIHtcbiAgICAgICAgICAgIGxldCBmaXQgPSB0aGlzLmZpbmRGaXR0YWJsZSgpO1xuICAgICAgICAgICAgaWYgKGZpdClcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlTm9kZXMoZml0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Nb3JlKCkgfHwgdGhpcy5kcm9wTm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlcmUncyBpbmxpbmUgY29udGVudCBkaXJlY3RseSBhZnRlciB0aGUgZnJvbnRpZXIgX2FuZF9cbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgYHRoaXMuJHRvYCwgd2UgbXVzdCBnZW5lcmF0ZSBhIGBSZXBsYWNlQXJvdW5kYFxuICAgICAgICAvLyBzdGVwIHRoYXQgcHVsbHMgdGhhdCBjb250ZW50IGludG8gdGhlIG5vZGUgYWZ0ZXIgdGhlIGZyb250aWVyLlxuICAgICAgICAvLyBUaGF0IG1lYW5zIHRoZSBmaXR0aW5nIG11c3QgYmUgZG9uZSB0byB0aGUgZW5kIG9mIHRoZSB0ZXh0YmxvY2tcbiAgICAgICAgLy8gbm9kZSBhZnRlciBgdGhpcy4kdG9gLCBub3QgYHRoaXMuJHRvYCBpdHNlbGYuXG4gICAgICAgIGxldCBtb3ZlSW5saW5lID0gdGhpcy5tdXN0TW92ZUlubGluZSgpLCBwbGFjZWRTaXplID0gdGhpcy5wbGFjZWQuc2l6ZSAtIHRoaXMuZGVwdGggLSB0aGlzLiRmcm9tLmRlcHRoO1xuICAgICAgICBsZXQgJGZyb20gPSB0aGlzLiRmcm9tLCAkdG8gPSB0aGlzLmNsb3NlKG1vdmVJbmxpbmUgPCAwID8gdGhpcy4kdG8gOiAkZnJvbS5kb2MucmVzb2x2ZShtb3ZlSW5saW5lKSk7XG4gICAgICAgIGlmICghJHRvKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIElmIGNsb3NpbmcgdG8gYCR0b2Agc3VjY2VlZGVkLCBjcmVhdGUgYSBzdGVwXG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5wbGFjZWQsIG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoLCBvcGVuRW5kID0gJHRvLmRlcHRoO1xuICAgICAgICB3aGlsZSAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEpIHsgLy8gTm9ybWFsaXplIGJ5IGRyb3BwaW5nIG9wZW4gcGFyZW50IG5vZGVzXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgICAgICAgICBvcGVuU3RhcnQtLTtcbiAgICAgICAgICAgIG9wZW5FbmQtLTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgaWYgKG1vdmVJbmxpbmUgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGZyb20ucG9zLCBtb3ZlSW5saW5lLCB0aGlzLiR0by5wb3MsIHRoaXMuJHRvLmVuZCgpLCBzbGljZSwgcGxhY2VkU2l6ZSk7XG4gICAgICAgIGlmIChzbGljZS5zaXplIHx8ICRmcm9tLnBvcyAhPSB0aGlzLiR0by5wb3MpIC8vIERvbid0IGdlbmVyYXRlIG5vLW9wIHN0ZXBzXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKCRmcm9tLnBvcywgJHRvLnBvcywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gRmluZCBhIHBvc2l0aW9uIG9uIHRoZSBzdGFydCBzcGluZSBvZiBgdGhpcy51bnBsYWNlZGAgdGhhdCBoYXNcbiAgICAvLyBjb250ZW50IHRoYXQgY2FuIGJlIG1vdmVkIHNvbWV3aGVyZSBvbiB0aGUgZnJvbnRpZXIuIFJldHVybnMgdHdvXG4gICAgLy8gZGVwdGhzLCBvbmUgZm9yIHRoZSBzbGljZSBhbmQgb25lIGZvciB0aGUgZnJvbnRpZXIuXG4gICAgZmluZEZpdHRhYmxlKCkge1xuICAgICAgICBsZXQgc3RhcnREZXB0aCA9IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjdXIgPSB0aGlzLnVucGxhY2VkLmNvbnRlbnQsIGQgPSAwLCBvcGVuRW5kID0gdGhpcy51bnBsYWNlZC5vcGVuRW5kOyBkIDwgc3RhcnREZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGN1ci5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKGN1ci5jaGlsZENvdW50ID4gMSlcbiAgICAgICAgICAgICAgICBvcGVuRW5kID0gMDtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgJiYgb3BlbkVuZCA8PSBkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnREZXB0aCA9IGQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSB0cnkgd3JhcHBpbmcgbm9kZXMgKHBhc3MgMikgYWZ0ZXIgZmluZGluZyBhIHBsYWNlIHdpdGhvdXRcbiAgICAgICAgLy8gd3JhcHBpbmcgZmFpbGVkLlxuICAgICAgICBmb3IgKGxldCBwYXNzID0gMTsgcGFzcyA8PSAyOyBwYXNzKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNsaWNlRGVwdGggPSBwYXNzID09IDEgPyBzdGFydERlcHRoIDogdGhpcy51bnBsYWNlZC5vcGVuU3RhcnQ7IHNsaWNlRGVwdGggPj0gMDsgc2xpY2VEZXB0aC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyYWdtZW50LCBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZURlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGNvbnRlbnRBdCh0aGlzLnVucGxhY2VkLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxKS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHBhcmVudC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLnVucGxhY2VkLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZnJvbnRpZXJEZXB0aCA9IHRoaXMuZGVwdGg7IGZyb250aWVyRGVwdGggPj0gMDsgZnJvbnRpZXJEZXB0aC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG1hdGNoIH0gPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLCB3cmFwLCBpbmplY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBwYXNzIDEsIGlmIHRoZSBuZXh0IG5vZGUgbWF0Y2hlcywgb3IgdGhlcmUgaXMgbm8gbmV4dFxuICAgICAgICAgICAgICAgICAgICAvLyBub2RlIGJ1dCB0aGUgcGFyZW50cyBsb29rIGNvbXBhdGlibGUsIHdlJ3ZlIGZvdW5kIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXNzID09IDEgJiYgKGZpcnN0ID8gbWF0Y2gubWF0Y2hUeXBlKGZpcnN0LnR5cGUpIHx8IChpbmplY3QgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmZyb20oZmlyc3QpLCBmYWxzZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmVudCAmJiB0eXBlLmNvbXBhdGlibGVDb250ZW50KHBhcmVudC50eXBlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIGluamVjdCB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBwYXNzIDIsIGxvb2sgZm9yIGEgc2V0IG9mIHdyYXBwaW5nIG5vZGVzIHRoYXQgbWFrZVxuICAgICAgICAgICAgICAgICAgICAvLyBgZmlyc3RgIGZpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXNzID09IDIgJiYgZmlyc3QgJiYgKHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcoZmlyc3QudHlwZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCB3cmFwIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbnRpbnVlIGxvb2tpbmcgZnVydGhlciB1cCBpZiB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd291bGQgZml0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgbWF0Y2gubWF0Y2hUeXBlKHBhcmVudC50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvcGVuTW9yZSgpIHtcbiAgICAgICAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSB0aGlzLnVucGxhY2VkO1xuICAgICAgICBsZXQgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcbiAgICAgICAgaWYgKCFpbm5lci5jaGlsZENvdW50IHx8IGlubmVyLmZpcnN0Q2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCArIDEsIE1hdGgubWF4KG9wZW5FbmQsIGlubmVyLnNpemUgKyBvcGVuU3RhcnQgPj0gY29udGVudC5zaXplIC0gb3BlbkVuZCA/IG9wZW5TdGFydCArIDEgOiAwKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkcm9wTm9kZSgpIHtcbiAgICAgICAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSB0aGlzLnVucGxhY2VkO1xuICAgICAgICBsZXQgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcbiAgICAgICAgaWYgKGlubmVyLmNoaWxkQ291bnQgPD0gMSAmJiBvcGVuU3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgb3BlbkF0RW5kID0gY29udGVudC5zaXplIC0gb3BlblN0YXJ0IDw9IG9wZW5TdGFydCArIGlubmVyLnNpemU7XG4gICAgICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0IC0gMSwgMSksIG9wZW5TdGFydCAtIDEsIG9wZW5BdEVuZCA/IG9wZW5TdGFydCAtIDEgOiBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQsIDEpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1vdmUgY29udGVudCBmcm9tIHRoZSB1bnBsYWNlZCBzbGljZSBhdCBgc2xpY2VEZXB0aGAgdG8gdGhlXG4gICAgLy8gZnJvbnRpZXIgbm9kZSBhdCBgZnJvbnRpZXJEZXB0aGAuIENsb3NlIHRoYXQgZnJvbnRpZXIgbm9kZSB3aGVuXG4gICAgLy8gYXBwbGljYWJsZS5cbiAgICBwbGFjZU5vZGVzKHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCBpbmplY3QsIHdyYXAgfSkge1xuICAgICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGZyb250aWVyRGVwdGgpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIGlmICh3cmFwKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZSh3cmFwW2ldKTtcbiAgICAgICAgbGV0IHNsaWNlID0gdGhpcy51bnBsYWNlZCwgZnJhZ21lbnQgPSBwYXJlbnQgPyBwYXJlbnQuY29udGVudCA6IHNsaWNlLmNvbnRlbnQ7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQgLSBzbGljZURlcHRoO1xuICAgICAgICBsZXQgdGFrZW4gPSAwLCBhZGQgPSBbXTtcbiAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF07XG4gICAgICAgIGlmIChpbmplY3QpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5qZWN0LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgICAgICAgICBhZGQucHVzaChpbmplY3QuY2hpbGQoaSkpO1xuICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaEZyYWdtZW50KGluamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIGFtb3VudCBvZiAoZW5kKSBvcGVuIG5vZGVzIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAgICAgIC8vIGZyYWdtZW50LiBXaGVuIDAsIHRoZSBwYXJlbnQgaXMgb3BlbiwgYnV0IG5vIG1vcmUuIFdoZW5cbiAgICAgICAgLy8gbmVnYXRpdmUsIG5vdGhpbmcgaXMgb3Blbi5cbiAgICAgICAgbGV0IG9wZW5FbmRDb3VudCA9IChmcmFnbWVudC5zaXplICsgc2xpY2VEZXB0aCkgLSAoc2xpY2UuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIC8vIFNjYW4gb3ZlciB0aGUgZnJhZ21lbnQsIGZpdHRpbmcgYXMgbWFueSBjaGlsZCBub2RlcyBhc1xuICAgICAgICAvLyBwb3NzaWJsZS5cbiAgICAgICAgd2hpbGUgKHRha2VuIDwgZnJhZ21lbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmcmFnbWVudC5jaGlsZCh0YWtlbiksIG1hdGNoZXMgPSBtYXRjaC5tYXRjaFR5cGUobmV4dC50eXBlKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRha2VuKys7XG4gICAgICAgICAgICBpZiAodGFrZW4gPiAxIHx8IG9wZW5TdGFydCA9PSAwIHx8IG5leHQuY29udGVudC5zaXplKSB7IC8vIERyb3AgZW1wdHkgb3BlbiBub2Rlc1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlcztcbiAgICAgICAgICAgICAgICBhZGQucHVzaChjbG9zZU5vZGVTdGFydChuZXh0Lm1hcmsodHlwZS5hbGxvd2VkTWFya3MobmV4dC5tYXJrcykpLCB0YWtlbiA9PSAxID8gb3BlblN0YXJ0IDogMCwgdGFrZW4gPT0gZnJhZ21lbnQuY2hpbGRDb3VudCA/IG9wZW5FbmRDb3VudCA6IC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvRW5kID0gdGFrZW4gPT0gZnJhZ21lbnQuY2hpbGRDb3VudDtcbiAgICAgICAgaWYgKCF0b0VuZClcbiAgICAgICAgICAgIG9wZW5FbmRDb3VudCA9IC0xO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGZyb250aWVyRGVwdGgsIEZyYWdtZW50LmZyb20oYWRkKSk7XG4gICAgICAgIHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0ubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgLy8gSWYgdGhlIHBhcmVudCB0eXBlcyBtYXRjaCwgYW5kIHRoZSBlbnRpcmUgbm9kZSB3YXMgbW92ZWQsIGFuZFxuICAgICAgICAvLyBpdCdzIG5vdCBvcGVuLCBjbG9zZSB0aGlzIGZyb250aWVyIG5vZGUgcmlnaHQgYXdheS5cbiAgICAgICAgaWYgKHRvRW5kICYmIG9wZW5FbmRDb3VudCA8IDAgJiYgcGFyZW50ICYmIHBhcmVudC50eXBlID09IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF0udHlwZSAmJiB0aGlzLmZyb250aWVyLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIC8vIEFkZCBuZXcgZnJvbnRpZXIgbm9kZXMgZm9yIGFueSBvcGVuIG5vZGVzIGF0IHRoZSBlbmQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjdXIgPSBmcmFnbWVudDsgaSA8IG9wZW5FbmRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGN1ci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goeyB0eXBlOiBub2RlLnR5cGUsIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkgfSk7XG4gICAgICAgICAgICBjdXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGB0aGlzLnVucGxhY2VkYC4gRHJvcCB0aGUgZW50aXJlIG5vZGUgZnJvbSB3aGljaCB3ZVxuICAgICAgICAvLyBwbGFjZWQgaXQgd2UgZ290IHRvIGl0cyBlbmQsIG90aGVyd2lzZSBqdXN0IGRyb3AgdGhlIHBsYWNlZFxuICAgICAgICAvLyBub2Rlcy5cbiAgICAgICAgdGhpcy51bnBsYWNlZCA9ICF0b0VuZCA/IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGgsIHRha2VuKSwgc2xpY2Uub3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKVxuICAgICAgICAgICAgOiBzbGljZURlcHRoID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoc2xpY2UuY29udGVudCwgc2xpY2VEZXB0aCAtIDEsIDEpLCBzbGljZURlcHRoIC0gMSwgb3BlbkVuZENvdW50IDwgMCA/IHNsaWNlLm9wZW5FbmQgOiBzbGljZURlcHRoIC0gMSk7XG4gICAgfVxuICAgIG11c3RNb3ZlSW5saW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHRvLnBhcmVudC5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF0sIGxldmVsO1xuICAgICAgICBpZiAoIXRvcC50eXBlLmlzVGV4dGJsb2NrIHx8ICFjb250ZW50QWZ0ZXJGaXRzKHRoaXMuJHRvLCB0aGlzLiR0by5kZXB0aCwgdG9wLnR5cGUsIHRvcC5tYXRjaCwgZmFsc2UpIHx8XG4gICAgICAgICAgICAodGhpcy4kdG8uZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAobGV2ZWwgPSB0aGlzLmZpbmRDbG9zZUxldmVsKHRoaXMuJHRvKSkgJiYgbGV2ZWwuZGVwdGggPT0gdGhpcy5kZXB0aCkpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCB7IGRlcHRoIH0gPSB0aGlzLiR0bywgYWZ0ZXIgPSB0aGlzLiR0by5hZnRlcihkZXB0aCk7XG4gICAgICAgIHdoaWxlIChkZXB0aCA+IDEgJiYgYWZ0ZXIgPT0gdGhpcy4kdG8uZW5kKC0tZGVwdGgpKVxuICAgICAgICAgICAgKythZnRlcjtcbiAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgIH1cbiAgICBmaW5kQ2xvc2VMZXZlbCgkdG8pIHtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgaSA9IE1hdGgubWluKHRoaXMuZGVwdGgsICR0by5kZXB0aCk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltpXTtcbiAgICAgICAgICAgIGxldCBkcm9wSW5uZXIgPSBpIDwgJHRvLmRlcHRoICYmICR0by5lbmQoaSArIDEpID09ICR0by5wb3MgKyAoJHRvLmRlcHRoIC0gKGkgKyAxKSk7XG4gICAgICAgICAgICBsZXQgZml0ID0gY29udGVudEFmdGVyRml0cygkdG8sIGksIHR5cGUsIG1hdGNoLCBkcm9wSW5uZXIpO1xuICAgICAgICAgICAgaWYgKCFmaXQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gaSAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbZF07XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXMgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZCwgdHlwZSwgbWF0Y2gsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkZXB0aDogaSwgZml0LCBtb3ZlOiBkcm9wSW5uZXIgPyAkdG8uZG9jLnJlc29sdmUoJHRvLmFmdGVyKGkgKyAxKSkgOiAkdG8gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgkdG8pIHtcbiAgICAgICAgbGV0IGNsb3NlID0gdGhpcy5maW5kQ2xvc2VMZXZlbCgkdG8pO1xuICAgICAgICBpZiAoIWNsb3NlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmRlcHRoID4gY2xvc2UuZGVwdGgpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIGlmIChjbG9zZS5maXQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgY2xvc2UuZGVwdGgsIGNsb3NlLmZpdCk7XG4gICAgICAgICR0byA9IGNsb3NlLm1vdmU7XG4gICAgICAgIGZvciAobGV0IGQgPSBjbG9zZS5kZXB0aCArIDE7IGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gJHRvLm5vZGUoZCksIGFkZCA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsICR0by5pbmRleChkKSk7XG4gICAgICAgICAgICB0aGlzLm9wZW5Gcm9udGllck5vZGUobm9kZS50eXBlLCBub2RlLmF0dHJzLCBhZGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdG87XG4gICAgfVxuICAgIG9wZW5Gcm9udGllck5vZGUodHlwZSwgYXR0cnMgPSBudWxsLCBjb250ZW50KSB7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdO1xuICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZGVwdGgsIEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXR0cnMsIGNvbnRlbnQpKSk7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7IHR5cGUsIG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaCB9KTtcbiAgICB9XG4gICAgY2xvc2VGcm9udGllck5vZGUoKSB7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5mcm9udGllci5wb3AoKTtcbiAgICAgICAgbGV0IGFkZCA9IG9wZW4ubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIGlmIChhZGQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5mcm9udGllci5sZW5ndGgsIGFkZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZHJvcEZyb21GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvdW50KSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBmcmFnbWVudC5jdXRCeUluZGV4KGNvdW50LCBmcmFnbWVudC5jaGlsZENvdW50KTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZyYWdtZW50LmZpcnN0Q2hpbGQuY29weShkcm9wRnJvbUZyYWdtZW50KGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudCwgZGVwdGggLSAxLCBjb3VudCkpKTtcbn1cbmZ1bmN0aW9uIGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb250ZW50KSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBmcmFnbWVudC5hcHBlbmQoY29udGVudCk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgZnJhZ21lbnQubGFzdENoaWxkLmNvcHkoYWRkVG9GcmFnbWVudChmcmFnbWVudC5sYXN0Q2hpbGQuY29udGVudCwgZGVwdGggLSAxLCBjb250ZW50KSkpO1xufVxuZnVuY3Rpb24gY29udGVudEF0KGZyYWdtZW50LCBkZXB0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwdGg7IGkrKylcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gY2xvc2VOb2RlU3RhcnQobm9kZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgaWYgKG9wZW5TdGFydCA8PSAwKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBsZXQgZnJhZyA9IG5vZGUuY29udGVudDtcbiAgICBpZiAob3BlblN0YXJ0ID4gMSlcbiAgICAgICAgZnJhZyA9IGZyYWcucmVwbGFjZUNoaWxkKDAsIGNsb3NlTm9kZVN0YXJ0KGZyYWcuZmlyc3RDaGlsZCwgb3BlblN0YXJ0IC0gMSwgZnJhZy5jaGlsZENvdW50ID09IDEgPyBvcGVuRW5kIC0gMSA6IDApKTtcbiAgICBpZiAob3BlblN0YXJ0ID4gMCkge1xuICAgICAgICBmcmFnID0gbm9kZS50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGZyYWcpLmFwcGVuZChmcmFnKTtcbiAgICAgICAgaWYgKG9wZW5FbmQgPD0gMClcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnLmFwcGVuZChub2RlLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZnJhZykuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5jb3B5KGZyYWcpO1xufVxuZnVuY3Rpb24gY29udGVudEFmdGVyRml0cygkdG8sIGRlcHRoLCB0eXBlLCBtYXRjaCwgb3Blbikge1xuICAgIGxldCBub2RlID0gJHRvLm5vZGUoZGVwdGgpLCBpbmRleCA9IG9wZW4gPyAkdG8uaW5kZXhBZnRlcihkZXB0aCkgOiAkdG8uaW5kZXgoZGVwdGgpO1xuICAgIGlmIChpbmRleCA9PSBub2RlLmNoaWxkQ291bnQgJiYgIXR5cGUuY29tcGF0aWJsZUNvbnRlbnQobm9kZS50eXBlKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZpdCA9IG1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCBpbmRleCk7XG4gICAgcmV0dXJuIGZpdCAmJiAhaW52YWxpZE1hcmtzKHR5cGUsIG5vZGUuY29udGVudCwgaW5kZXgpID8gZml0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGludmFsaWRNYXJrcyh0eXBlLCBmcmFnbWVudCwgc3RhcnQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgIGlmICghdHlwZS5hbGxvd3NNYXJrcyhmcmFnbWVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZWZpbmVzQ29udGVudCh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUuc3BlYy5kZWZpbmluZyB8fCB0eXBlLnNwZWMuZGVmaW5pbmdGb3JDb250ZW50O1xufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKHRyLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgICBpZiAoIXNsaWNlLnNpemUpXG4gICAgICAgIHJldHVybiB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpXG4gICAgICAgIHJldHVybiB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpKTtcbiAgICBsZXQgdGFyZ2V0RGVwdGhzID0gY292ZXJlZERlcHRocygkZnJvbSwgdHIuZG9jLnJlc29sdmUodG8pKTtcbiAgICAvLyBDYW4ndCByZXBsYWNlIHRoZSB3aG9sZSBkb2N1bWVudCwgc28gcmVtb3ZlIDAgaWYgaXQncyBwcmVzZW50XG4gICAgaWYgKHRhcmdldERlcHRoc1t0YXJnZXREZXB0aHMubGVuZ3RoIC0gMV0gPT0gMClcbiAgICAgICAgdGFyZ2V0RGVwdGhzLnBvcCgpO1xuICAgIC8vIE5lZ2F0aXZlIG51bWJlcnMgcmVwcmVzZW50IG5vdCBleHBhbnNpb24gb3ZlciB0aGUgd2hvbGUgbm9kZSBhdFxuICAgIC8vIHRoYXQgZGVwdGgsIGJ1dCByZXBsYWNpbmcgZnJvbSAkZnJvbS5iZWZvcmUoLUQpIHRvICR0by5wb3MuXG4gICAgbGV0IHByZWZlcnJlZFRhcmdldCA9IC0oJGZyb20uZGVwdGggKyAxKTtcbiAgICB0YXJnZXREZXB0aHMudW5zaGlmdChwcmVmZXJyZWRUYXJnZXQpO1xuICAgIC8vIFRoaXMgbG9vcCBwaWNrcyBhIHByZWZlcnJlZCB0YXJnZXQgZGVwdGgsIGlmIG9uZSBvZiB0aGUgY292ZXJpbmdcbiAgICAvLyBkZXB0aHMgaXMgbm90IG91dHNpZGUgb2YgYSBkZWZpbmluZyBub2RlLCBhbmQgYWRkcyBuZWdhdGl2ZVxuICAgIC8vIGRlcHRocyBmb3IgYW55IGRlcHRoIHRoYXQgaGFzICRmcm9tIGF0IGl0cyBzdGFydCBhbmQgZG9lcyBub3RcbiAgICAvLyBjcm9zcyBhIGRlZmluaW5nIG5vZGUuXG4gICAgZm9yIChsZXQgZCA9ICRmcm9tLmRlcHRoLCBwb3MgPSAkZnJvbS5wb3MgLSAxOyBkID4gMDsgZC0tLCBwb3MtLSkge1xuICAgICAgICBsZXQgc3BlYyA9ICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjO1xuICAgICAgICBpZiAoc3BlYy5kZWZpbmluZyB8fCBzcGVjLmRlZmluaW5nQXNDb250ZXh0IHx8IHNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICh0YXJnZXREZXB0aHMuaW5kZXhPZihkKSA+IC0xKVxuICAgICAgICAgICAgcHJlZmVycmVkVGFyZ2V0ID0gZDtcbiAgICAgICAgZWxzZSBpZiAoJGZyb20uYmVmb3JlKGQpID09IHBvcylcbiAgICAgICAgICAgIHRhcmdldERlcHRocy5zcGxpY2UoMSwgMCwgLWQpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gZml0IGVhY2ggcG9zc2libGUgZGVwdGggb2YgdGhlIHNsaWNlIGludG8gZWFjaCBwb3NzaWJsZVxuICAgIC8vIHRhcmdldCBkZXB0aCwgc3RhcnRpbmcgd2l0aCB0aGUgcHJlZmVycmVkIGRlcHRocy5cbiAgICBsZXQgcHJlZmVycmVkVGFyZ2V0SW5kZXggPSB0YXJnZXREZXB0aHMuaW5kZXhPZihwcmVmZXJyZWRUYXJnZXQpO1xuICAgIGxldCBsZWZ0Tm9kZXMgPSBbXSwgcHJlZmVycmVkRGVwdGggPSBzbGljZS5vcGVuU3RhcnQ7XG4gICAgZm9yIChsZXQgY29udGVudCA9IHNsaWNlLmNvbnRlbnQsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBsZWZ0Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGkgPT0gc2xpY2Uub3BlblN0YXJ0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gICAgfVxuICAgIC8vIEJhY2sgdXAgcHJlZmVycmVkRGVwdGggdG8gY292ZXIgZGVmaW5pbmcgdGV4dGJsb2NrcyBkaXJlY3RseVxuICAgIC8vIGFib3ZlIGl0LCBwb3NzaWJseSBza2lwcGluZyBhIG5vbi1kZWZpbmluZyB0ZXh0YmxvY2suXG4gICAgZm9yIChsZXQgZCA9IHByZWZlcnJlZERlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IHR5cGUgPSBsZWZ0Tm9kZXNbZF0udHlwZSwgZGVmID0gZGVmaW5lc0NvbnRlbnQodHlwZSk7XG4gICAgICAgIGlmIChkZWYgJiYgJGZyb20ubm9kZShwcmVmZXJyZWRUYXJnZXRJbmRleCkudHlwZSAhPSB0eXBlKVxuICAgICAgICAgICAgcHJlZmVycmVkRGVwdGggPSBkO1xuICAgICAgICBlbHNlIGlmIChkZWYgfHwgIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IHNsaWNlLm9wZW5TdGFydDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgbGV0IG9wZW5EZXB0aCA9IChqICsgcHJlZmVycmVkRGVwdGggKyAxKSAlIChzbGljZS5vcGVuU3RhcnQgKyAxKTtcbiAgICAgICAgbGV0IGluc2VydCA9IGxlZnROb2Rlc1tvcGVuRGVwdGhdO1xuICAgICAgICBpZiAoIWluc2VydClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldERlcHRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHBvc3NpYmxlIGV4cGFuc2lvbiBsZXZlbHMsIHN0YXJ0aW5nIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBwcmVmZXJyZWQgb25lXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RGVwdGggPSB0YXJnZXREZXB0aHNbKGkgKyBwcmVmZXJyZWRUYXJnZXRJbmRleCkgJSB0YXJnZXREZXB0aHMubGVuZ3RoXSwgZXhwYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0YXJnZXREZXB0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBleHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0YXJnZXREZXB0aCA9IC10YXJnZXREZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5ub2RlKHRhcmdldERlcHRoIC0gMSksIGluZGV4ID0gJGZyb20uaW5kZXgodGFyZ2V0RGVwdGggLSAxKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBpbnNlcnQudHlwZSwgaW5zZXJ0Lm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHIucmVwbGFjZSgkZnJvbS5iZWZvcmUodGFyZ2V0RGVwdGgpLCBleHBhbmQgPyAkdG8uYWZ0ZXIodGFyZ2V0RGVwdGgpIDogdG8sIG5ldyBTbGljZShjbG9zZUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIDAsIHNsaWNlLm9wZW5TdGFydCwgb3BlbkRlcHRoKSwgb3BlbkRlcHRoLCBzbGljZS5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXJ0U3RlcHMgPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IHRhcmdldERlcHRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0ci5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPiBzdGFydFN0ZXBzKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXB0aCA9IHRhcmdldERlcHRoc1tpXTtcbiAgICAgICAgaWYgKGRlcHRoIDwgMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmcm9tID0gJGZyb20uYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgdG8gPSAkdG8uYWZ0ZXIoZGVwdGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBvbGRPcGVuLCBuZXdPcGVuLCBwYXJlbnQpIHtcbiAgICBpZiAoZGVwdGggPCBvbGRPcGVuKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZpcnN0LmNvcHkoY2xvc2VGcmFnbWVudChmaXJzdC5jb250ZW50LCBkZXB0aCArIDEsIG9sZE9wZW4sIG5ld09wZW4sIGZpcnN0KSkpO1xuICAgIH1cbiAgICBpZiAoZGVwdGggPiBuZXdPcGVuKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gbWF0Y2guZmlsbEJlZm9yZShmcmFnbWVudCkuYXBwZW5kKGZyYWdtZW50KTtcbiAgICAgICAgZnJhZ21lbnQgPSBzdGFydC5hcHBlbmQobWF0Y2gubWF0Y2hGcmFnbWVudChzdGFydCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2VXaXRoKHRyLCBmcm9tLCB0bywgbm9kZSkge1xuICAgIGlmICghbm9kZS5pc0lubGluZSAmJiBmcm9tID09IHRvICYmIHRyLmRvYy5yZXNvbHZlKGZyb20pLnBhcmVudC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgbGV0IHBvaW50ID0gaW5zZXJ0UG9pbnQodHIuZG9jLCBmcm9tLCBub2RlLnR5cGUpO1xuICAgICAgICBpZiAocG9pbnQgIT0gbnVsbClcbiAgICAgICAgICAgIGZyb20gPSB0byA9IHBvaW50O1xuICAgIH1cbiAgICB0ci5yZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG59XG5mdW5jdGlvbiBkZWxldGVSYW5nZSh0ciwgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGxldCBjb3ZlcmVkID0gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlcHRoID0gY292ZXJlZFtpXSwgbGFzdCA9IGkgPT0gY292ZXJlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoKGxhc3QgJiYgZGVwdGggPT0gMCkgfHwgJGZyb20ubm9kZShkZXB0aCkudHlwZS5jb250ZW50TWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLnN0YXJ0KGRlcHRoKSwgJHRvLmVuZChkZXB0aCkpO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIChsYXN0IHx8ICRmcm9tLm5vZGUoZGVwdGggLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGRlcHRoIC0gMSksICR0by5pbmRleEFmdGVyKGRlcHRoIC0gMSkpKSlcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uYmVmb3JlKGRlcHRoKSwgJHRvLmFmdGVyKGRlcHRoKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGQgPSAxOyBkIDw9ICRmcm9tLmRlcHRoICYmIGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgaWYgKGZyb20gLSAkZnJvbS5zdGFydChkKSA9PSAkZnJvbS5kZXB0aCAtIGQgJiYgdG8gPiAkZnJvbS5lbmQoZCkgJiYgJHRvLmVuZChkKSAtIHRvICE9ICR0by5kZXB0aCAtIGQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkKSwgdG8pO1xuICAgIH1cbiAgICB0ci5kZWxldGUoZnJvbSwgdG8pO1xufVxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGVwdGhzIGZvciB3aGljaCAkZnJvbSAtICR0byBzcGFucyB0aGVcbi8vIHdob2xlIGNvbnRlbnQgb2YgdGhlIG5vZGVzIGF0IHRoYXQgZGVwdGguXG5mdW5jdGlvbiBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pIHtcbiAgICBsZXQgcmVzdWx0ID0gW10sIG1pbkRlcHRoID0gTWF0aC5taW4oJGZyb20uZGVwdGgsICR0by5kZXB0aCk7XG4gICAgZm9yIChsZXQgZCA9IG1pbkRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5zdGFydChkKTtcbiAgICAgICAgaWYgKHN0YXJ0IDwgJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCkgfHxcbiAgICAgICAgICAgICR0by5lbmQoZCkgPiAkdG8ucG9zICsgKCR0by5kZXB0aCAtIGQpIHx8XG4gICAgICAgICAgICAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgICAgICR0by5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHN0YXJ0ID09ICR0by5zdGFydChkKSB8fFxuICAgICAgICAgICAgKGQgPT0gJGZyb20uZGVwdGggJiYgZCA9PSAkdG8uZGVwdGggJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50ICYmXG4gICAgICAgICAgICAgICAgZCAmJiAkdG8uc3RhcnQoZCAtIDEpID09IHN0YXJ0IC0gMSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5VcGRhdGUgYW4gYXR0cmlidXRlIGluIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBBdHRyU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhbiBhdHRyaWJ1dGUgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICovXG4gICAgYXR0ciwgXG4gICAgLy8gVGhlIGF0dHJpYnV0ZSdzIG5ldyB2YWx1ZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgYXR0cmlidXRlIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBub2RlLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBub2RlLmF0dHJzW25hbWVdO1xuICAgICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAodGhpcy5wb3MsIHRoaXMuYXR0ciwgZG9jLm5vZGVBdCh0aGlzLnBvcykuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBdHRyU3RlcChwb3MucG9zLCB0aGlzLmF0dHIsIHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImF0dHJcIiwgcG9zOiB0aGlzLnBvcywgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEF0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTdGVwKGpzb24ucG9zLCBqc29uLmF0dHIsIGpzb24udmFsdWUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYXR0clwiLCBBdHRyU3RlcCk7XG5cbi8qKlxuQGludGVybmFsXG4qL1xubGV0IFRyYW5zZm9ybUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG59O1xuVHJhbnNmb3JtRXJyb3IgPSBmdW5jdGlvbiBUcmFuc2Zvcm1FcnJvcihtZXNzYWdlKSB7XG4gICAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgZXJyLl9fcHJvdG9fXyA9IFRyYW5zZm9ybUVycm9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gZXJyO1xufTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zZm9ybUVycm9yO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlRyYW5zZm9ybUVycm9yXCI7XG4vKipcbkFic3RyYWN0aW9uIHRvIGJ1aWxkIHVwIGFuZCB0cmFjayBhbiBhcnJheSBvZlxuW3N0ZXBzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXApIHJlcHJlc2VudGluZyBhIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uLlxuXG5Nb3N0IHRyYW5zZm9ybWluZyBtZXRob2RzIHJldHVybiB0aGUgYFRyYW5zZm9ybWAgb2JqZWN0IGl0c2VsZiwgc29cbnRoYXQgdGhleSBjYW4gYmUgY2hhaW5lZC5cbiovXG5jbGFzcyBUcmFuc2Zvcm0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyYW5zZm9ybSB0aGF0IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50ICh0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBzdGVwcyBpbiB0aGVcbiAgICB0cmFuc2Zvcm0pLlxuICAgICovXG4gICAgZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZXBzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgZG9jdW1lbnRzIGJlZm9yZSBlYWNoIG9mIHRoZSBzdGVwcy5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb2NzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBBIG1hcHBpbmcgd2l0aCB0aGUgbWFwcyBmb3IgZWFjaCBvZiB0aGUgc3RlcHMgaW4gdGhpcyB0cmFuc2Zvcm0uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnRpbmcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYmVmb3JlKCkgeyByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aCA/IHRoaXMuZG9jc1swXSA6IHRoaXMuZG9jOyB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBuZXcgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybSwgc2F2aW5nIHRoZSByZXN1bHQuIFRocm93cyBhblxuICAgIGVycm9yIHdoZW4gdGhlIHN0ZXAgZmFpbHMuXG4gICAgKi9cbiAgICBzdGVwKHN0ZXApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWF5YmVTdGVwKHN0ZXApO1xuICAgICAgICBpZiAocmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2Zvcm1FcnJvcihyZXN1bHQuZmFpbGVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBhcHBseSBhIHN0ZXAgaW4gdGhpcyB0cmFuc2Zvcm1hdGlvbiwgaWdub3JpbmcgaXQgaWYgaXRcbiAgICBmYWlscy4gUmV0dXJucyB0aGUgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBtYXliZVN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RlcC5hcHBseSh0aGlzLmRvYyk7XG4gICAgICAgIGlmICghcmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRoaXMuYWRkU3RlcChzdGVwLCByZXN1bHQuZG9jKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBjaGFuZ2VkICh3aGVuIHRoZXJlIGFyZSBhbnlcbiAgICBzdGVwcykuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICB0aGlzLmRvY3MucHVzaCh0aGlzLmRvYyk7XG4gICAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICAgICAgdGhpcy5tYXBwaW5nLmFwcGVuZE1hcChzdGVwLmdldE1hcCgpKTtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHdpdGggdGhlXG4gICAgZ2l2ZW4gYHNsaWNlYC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8gPSBmcm9tLCBzbGljZSA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIGxldCBzdGVwID0gcmVwbGFjZVN0ZXAodGhpcy5kb2MsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmIChzdGVwKVxuICAgICAgICAgICAgdGhpcy5zdGVwKHN0ZXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudCwgd2hpY2ggbWF5IGJlIGFcbiAgICBmcmFnbWVudCwgbm9kZSwgb3IgYXJyYXkgb2Ygbm9kZXMuXG4gICAgKi9cbiAgICByZXBsYWNlV2l0aChmcm9tLCB0bywgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShjb250ZW50KSwgMCwgMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgZGVsZXRlKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIFNsaWNlLmVtcHR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5zZXJ0IHRoZSBnaXZlbiBjb250ZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGluc2VydChwb3MsIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgocG9zLCBwb3MsIGNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IHdpdGggYSBnaXZlbiBzbGljZSwgdXNpbmdcbiAgICBgZnJvbWAsIGB0b2AsIGFuZCB0aGUgc2xpY2Unc1xuICAgIFtgb3BlblN0YXJ0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlNsaWNlLm9wZW5TdGFydCkgcHJvcGVydHkgYXMgaGludHMsIHJhdGhlclxuICAgIHRoYW4gZml4ZWQgc3RhcnQgYW5kIGVuZCBwb2ludHMuIFRoaXMgbWV0aG9kIG1heSBncm93IHRoZVxuICAgIHJlcGxhY2VkIGFyZWEgb3IgY2xvc2Ugb3BlbiBub2RlcyBpbiB0aGUgc2xpY2UgaW4gb3JkZXIgdG8gZ2V0IGFcbiAgICBmaXQgdGhhdCBpcyBtb3JlIGluIGxpbmUgd2l0aCBXWVNJV1lHIGV4cGVjdGF0aW9ucywgYnkgZHJvcHBpbmdcbiAgICBmdWxseSBjb3ZlcmVkIHBhcmVudCBub2RlcyBvZiB0aGUgcmVwbGFjZWQgcmVnaW9uIHdoZW4gdGhleSBhcmVcbiAgICBtYXJrZWQgW25vbi1kZWZpbmluZyBhc1xuICAgIGNvbnRleHRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZ0FzQ29udGV4dCksIG9yIGluY2x1ZGluZyBhblxuICAgIG9wZW4gcGFyZW50IG5vZGUgZnJvbSB0aGUgc2xpY2UgdGhhdCBfaXNfIG1hcmtlZCBhcyBbZGVmaW5pbmdcbiAgICBpdHMgY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nRm9yQ29udGVudCkuXG4gICAgXG4gICAgVGhpcyBpcyB0aGUgbWV0aG9kLCBmb3IgZXhhbXBsZSwgdG8gaGFuZGxlIHBhc3RlLiBUaGUgc2ltaWxhclxuICAgIFtgcmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uVHJhbnNmb3JtLnJlcGxhY2UpIG1ldGhvZCBpcyBhIG1vcmVcbiAgICBwcmltaXRpdmUgdG9vbCB3aGljaCB3aWxsIF9ub3RfIG1vdmUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgaXRzIGdpdmVuXG4gICAgcmFuZ2UsIGFuZCBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3UgbmVlZCBtb3JlIHByZWNpc2VcbiAgICBjb250cm9sIG92ZXIgd2hhdCBoYXBwZW5zLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2UodGhpcywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggYSBub2RlLCBidXQgdXNlIGBmcm9tYCBhbmQgYHRvYCBhc1xuICAgIGhpbnRzLCByYXRoZXIgdGhhbiBwcmVjaXNlIHBvc2l0aW9ucy4gV2hlbiBmcm9tIGFuZCB0byBhcmUgdGhlIHNhbWVcbiAgICBhbmQgYXJlIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBwYXJlbnQgbm9kZSBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICBub2RlIGRvZXNuJ3QgZml0LCB0aGlzIG1ldGhvZCBtYXkgX21vdmVfIHRoZW0gb3V0IHRvd2FyZHMgYSBwYXJlbnRcbiAgICB0aGF0IGRvZXMgYWxsb3cgdGhlIGdpdmVuIG5vZGUgdG8gYmUgcGxhY2VkLiBXaGVuIHRoZSBnaXZlbiByYW5nZVxuICAgIGNvbXBsZXRlbHkgY292ZXJzIGEgcGFyZW50IG5vZGUsIHRoaXMgbWV0aG9kIG1heSBjb21wbGV0ZWx5IHJlcGxhY2VcbiAgICB0aGF0IHBhcmVudCBub2RlLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2VXaXRoKHRoaXMsIGZyb20sIHRvLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgZ2l2ZW4gcmFuZ2UsIGV4cGFuZGluZyBpdCB0byBjb3ZlciBmdWxseSBjb3ZlcmVkXG4gICAgcGFyZW50IG5vZGVzIHVudGlsIGEgdmFsaWQgcmVwbGFjZSBpcyBmb3VuZC5cbiAgICAqL1xuICAgIGRlbGV0ZVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICAgIGRlbGV0ZVJhbmdlKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNwbGl0IHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBvZmYgZnJvbSBpdHMgcGFyZW50LCBpZiB0aGVyZVxuICAgIGlzIHNpYmxpbmcgY29udGVudCBiZWZvcmUgb3IgYWZ0ZXIgaXQsIGFuZCBtb3ZlIGl0IHVwIHRoZSB0cmVlIHRvXG4gICAgdGhlIGRlcHRoIHNwZWNpZmllZCBieSBgdGFyZ2V0YC4gWW91J2xsIHByb2JhYmx5IHdhbnQgdG8gdXNlXG4gICAgW2BsaWZ0VGFyZ2V0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5saWZ0VGFyZ2V0KSB0byBjb21wdXRlIGB0YXJnZXRgLCB0byBtYWtlXG4gICAgc3VyZSB0aGUgbGlmdCBpcyB2YWxpZC5cbiAgICAqL1xuICAgIGxpZnQocmFuZ2UsIHRhcmdldCkge1xuICAgICAgICBsaWZ0KHRoaXMsIHJhbmdlLCB0YXJnZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgSm9pbiB0aGUgYmxvY2tzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uIElmIGRlcHRoIGlzIDIsIHRoZWlyXG4gICAgbGFzdCBhbmQgZmlyc3Qgc2libGluZ3MgYXJlIGFsc28gam9pbmVkLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBqb2luKHBvcywgZGVwdGggPSAxKSB7XG4gICAgICAgIGpvaW4odGhpcywgcG9zLCBkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXcmFwIHRoZSBnaXZlbiBbcmFuZ2VdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlUmFuZ2UpIGluIHRoZSBnaXZlbiBzZXQgb2Ygd3JhcHBlcnMuXG4gICAgVGhlIHdyYXBwZXJzIGFyZSBhc3N1bWVkIHRvIGJlIHZhbGlkIGluIHRoaXMgcG9zaXRpb24sIGFuZCBzaG91bGRcbiAgICBwcm9iYWJseSBiZSBjb21wdXRlZCB3aXRoIFtgZmluZFdyYXBwaW5nYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5maW5kV3JhcHBpbmcpLlxuICAgICovXG4gICAgd3JhcChyYW5nZSwgd3JhcHBlcnMpIHtcbiAgICAgICAgd3JhcCh0aGlzLCByYW5nZSwgd3JhcHBlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB0eXBlIG9mIGFsbCB0ZXh0YmxvY2tzIChwYXJ0bHkpIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHRvXG4gICAgdGhlIGdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc2V0QmxvY2tUeXBlKGZyb20sIHRvID0gZnJvbSwgdHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgICAgIHNldEJsb2NrVHlwZSh0aGlzLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG4gICAgV2hlbiBgdHlwZWAgaXNuJ3QgZ2l2ZW4sIHRoZSBleGlzdGluZyBub2RlIHR5cGUgaXMgcHJlc2VydmVkLFxuICAgICovXG4gICAgc2V0Tm9kZU1hcmt1cChwb3MsIHR5cGUsIGF0dHJzID0gbnVsbCwgbWFya3MpIHtcbiAgICAgICAgc2V0Tm9kZU1hcmt1cCh0aGlzLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgYSBzaW5nbGUgYXR0cmlidXRlIG9uIGEgZ2l2ZW4gbm9kZSB0byBhIG5ldyB2YWx1ZS5cbiAgICAqL1xuICAgIHNldE5vZGVBdHRyaWJ1dGUocG9zLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IEF0dHJTdGVwKHBvcywgYXR0ciwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIG5vZGUgYXQgcG9zaXRpb24gYHBvc2AuXG4gICAgKi9cbiAgICBhZGROb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgYSBtYXJrIChvciBhIG1hcmsgb2YgdGhlIGdpdmVuIHR5cGUpIGZyb20gdGhlIG5vZGUgYXRcbiAgICBwb3NpdGlvbiBgcG9zYC5cbiAgICAqL1xuICAgIHJlbW92ZU5vZGVNYXJrKHBvcywgbWFyaykge1xuICAgICAgICBpZiAoIShtYXJrIGluc3RhbmNlb2YgTWFyaykpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5kb2Mubm9kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IHBvc2l0aW9uIFwiICsgcG9zKTtcbiAgICAgICAgICAgIG1hcmsgPSBtYXJrLmlzSW5TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgICAgICBpZiAoIW1hcmspXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGVwKG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTcGxpdCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFuZCBvcHRpb25hbGx5LCBpZiBgZGVwdGhgIGlzXG4gICAgZ3JlYXRlciB0aGFuIG9uZSwgYW55IG51bWJlciBvZiBub2RlcyBhYm92ZSB0aGF0LiBCeSBkZWZhdWx0LCB0aGVcbiAgICBwYXJ0cyBzcGxpdCBvZmYgd2lsbCBpbmhlcml0IHRoZSBub2RlIHR5cGUgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAgVGhpcyBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFuIGFycmF5IG9mIHR5cGVzIGFuZCBhdHRyaWJ1dGVzIHRvXG4gICAgdXNlIGFmdGVyIHRoZSBzcGxpdC5cbiAgICAqL1xuICAgIHNwbGl0KHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgICAgIHNwbGl0KHRoaXMsIHBvcywgZGVwdGgsIHR5cGVzQWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBtYXJrIHRvIHRoZSBpbmxpbmUgY29udGVudCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbiAgICAqL1xuICAgIGFkZE1hcmsoZnJvbSwgdG8sIG1hcmspIHtcbiAgICAgICAgYWRkTWFyayh0aGlzLCBmcm9tLCB0bywgbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgbWFya3MgZnJvbSBpbmxpbmUgbm9kZXMgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuIFdoZW5cbiAgICBgbWFya2AgaXMgYSBzaW5nbGUgbWFyaywgcmVtb3ZlIHByZWNpc2VseSB0aGF0IG1hcmsuIFdoZW4gaXQgaXNcbiAgICBhIG1hcmsgdHlwZSwgcmVtb3ZlIGFsbCBtYXJrcyBvZiB0aGF0IHR5cGUuIFdoZW4gaXQgaXMgbnVsbCxcbiAgICByZW1vdmUgYWxsIG1hcmtzIG9mIGFueSB0eXBlLlxuICAgICovXG4gICAgcmVtb3ZlTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgICByZW1vdmVNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgYWxsIG1hcmtzIGFuZCBub2RlcyBmcm9tIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIGF0XG4gICAgYHBvc2AgdGhhdCBkb24ndCBtYXRjaCB0aGUgZ2l2ZW4gbmV3IHBhcmVudCBub2RlIHR5cGUuIEFjY2VwdHNcbiAgICBhbiBvcHRpb25hbCBzdGFydGluZyBbY29udGVudCBtYXRjaF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkNvbnRlbnRNYXRjaCkgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNsZWFySW5jb21wYXRpYmxlKHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpIHtcbiAgICAgICAgY2xlYXJJbmNvbXBhdGlibGUodGhpcywgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQWRkTWFya1N0ZXAsIEFkZE5vZGVNYXJrU3RlcCwgQXR0clN0ZXAsIE1hcFJlc3VsdCwgTWFwcGluZywgUmVtb3ZlTWFya1N0ZXAsIFJlbW92ZU5vZGVNYXJrU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFJlcGxhY2VTdGVwLCBTdGVwLCBTdGVwTWFwLCBTdGVwUmVzdWx0LCBUcmFuc2Zvcm0sIFRyYW5zZm9ybUVycm9yLCBjYW5Kb2luLCBjYW5TcGxpdCwgZHJvcFBvaW50LCBmaW5kV3JhcHBpbmcsIGluc2VydFBvaW50LCBqb2luUG9pbnQsIGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-transform/dist/index.js\n')},"./node_modules/prosemirror-view/dist/index.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: function() { return /* binding */ Decoration; },\n/* harmony export */   DecorationSet: function() { return /* binding */ DecorationSet; },\n/* harmony export */   EditorView: function() { return /* binding */ EditorView; },\n/* harmony export */   __endComposition: function() { return /* binding */ __endComposition; },\n/* harmony export */   __parseFromClipboard: function() { return /* binding */ __parseFromClipboard; },\n/* harmony export */   __serializeForClipboard: function() { return /* binding */ __serializeForClipboard; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");\n\n\n\n\nconst domIndex = function (node) {\n    for (var index = 0;; index++) {\n        node = node.previousSibling;\n        if (!node)\n            return index;\n    }\n};\nconst parentNode = function (node) {\n    let parent = node.assignedSlot || node.parentNode;\n    return parent && parent.nodeType == 11 ? parent.host : parent;\n};\nlet reusedRange = null;\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nconst textRange = function (node, from, to) {\n    let range = reusedRange || (reusedRange = document.createRange());\n    range.setEnd(node, to == null ? node.nodeValue.length : to);\n    range.setStart(node, from || 0);\n    return range;\n};\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nconst isEquivalentPosition = function (node, off, targetNode, targetOff) {\n    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||\n        scanFor(node, off, targetNode, targetOff, 1));\n};\nconst atomElements = /^(img|br|input|textarea|hr)$/i;\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for (;;) {\n        if (node == targetNode && off == targetOff)\n            return true;\n        if (off == (dir < 0 ? 0 : nodeSize(node))) {\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) ||\n                node.contentEditable == "false")\n                return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        }\n        else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.contentEditable == "false")\n                return false;\n            off = dir < 0 ? nodeSize(node) : 0;\n        }\n        else {\n            return false;\n        }\n    }\n}\nfunction nodeSize(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isOnEdge(node, offset, parent) {\n    for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {\n        if (node == parent)\n            return true;\n        let index = domIndex(node);\n        node = node.parentNode;\n        if (!node)\n            return false;\n        atStart = atStart && index == 0;\n        atEnd = atEnd && index == nodeSize(node);\n    }\n}\nfunction hasBlockDesc(dom) {\n    let desc;\n    for (let cur = dom; cur; cur = cur.parentNode)\n        if (desc = cur.pmViewDesc)\n            break;\n    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nconst selectionCollapsed = function (domSel) {\n    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\nfunction keyEvent(keyCode, key) {\n    let event = document.createEvent("Event");\n    event.initEvent("keydown", true, true);\n    event.keyCode = keyCode;\n    event.key = event.code = key;\n    return event;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while (elt && elt.shadowRoot)\n        elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction caretFromPoint(doc, x, y) {\n    if (doc.caretPositionFromPoint) {\n        try { // Firefox throws for this call in hard-to-predict circumstances (#994)\n            let pos = doc.caretPositionFromPoint(x, y);\n            if (pos)\n                return { node: pos.offsetNode, offset: pos.offset };\n        }\n        catch (_) { }\n    }\n    if (doc.caretRangeFromPoint) {\n        let range = doc.caretRangeFromPoint(x, y);\n        if (range)\n            return { node: range.startContainer, offset: range.startOffset };\n    }\n}\n\nconst nav = typeof navigator != "undefined" ? navigator : null;\nconst doc = typeof document != "undefined" ? document : null;\nconst agent = (nav && nav.userAgent) || "";\nconst ie_edge = /Edge\\/(\\d+)/.exec(agent);\nconst ie_upto10 = /MSIE \\d/.exec(agent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [0, 0])[1];\nconst _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\nconst chrome = !!_chrome;\nconst chrome_version = _chrome ? +_chrome[1] : 0;\nconst safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\n// Is true for both iOS and iPadOS for convenience\nconst ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nconst mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nconst windows = nav ? /Win/.test(nav.platform) : false;\nconst android = /Android \\d/.test(agent);\nconst webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;\nconst webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;\n\nfunction windowRect(doc) {\n    return { left: 0, right: doc.documentElement.clientWidth,\n        top: 0, bottom: doc.documentElement.clientHeight };\n}\nfunction getSide(value, side) {\n    return typeof value == "number" ? value : value[side];\n}\nfunction clientRect(node) {\n    let rect = node.getBoundingClientRect();\n    // Adjust for elements with style "transform: scale()"\n    let scaleX = (rect.width / node.offsetWidth) || 1;\n    let scaleY = (rect.height / node.offsetHeight) || 1;\n    // Make sure scrollbar width isn\'t included in the rectangle\n    return { left: rect.left, right: rect.left + node.clientWidth * scaleX,\n        top: rect.top, bottom: rect.top + node.clientHeight * scaleY };\n}\nfunction scrollRectIntoView(view, rect, startDOM) {\n    let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;\n    let doc = view.dom.ownerDocument;\n    for (let parent = startDOM || view.dom;; parent = parentNode(parent)) {\n        if (!parent)\n            break;\n        if (parent.nodeType != 1)\n            continue;\n        let elt = parent;\n        let atTop = elt == doc.body;\n        let bounding = atTop ? windowRect(doc) : clientRect(elt);\n        let moveX = 0, moveY = 0;\n        if (rect.top < bounding.top + getSide(scrollThreshold, "top"))\n            moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));\n        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))\n            moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");\n        if (rect.left < bounding.left + getSide(scrollThreshold, "left"))\n            moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));\n        else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))\n            moveX = rect.right - bounding.right + getSide(scrollMargin, "right");\n        if (moveX || moveY) {\n            if (atTop) {\n                doc.defaultView.scrollBy(moveX, moveY);\n            }\n            else {\n                let startX = elt.scrollLeft, startY = elt.scrollTop;\n                if (moveY)\n                    elt.scrollTop += moveY;\n                if (moveX)\n                    elt.scrollLeft += moveX;\n                let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n                rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };\n            }\n        }\n        if (atTop)\n            break;\n    }\n}\n// Store the scroll position of the editor\'s parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n    let refDOM, refTop;\n    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {\n        let dom = view.root.elementFromPoint(x, y);\n        if (!dom || dom == view.dom || !view.dom.contains(dom))\n            continue;\n        let localRect = dom.getBoundingClientRect();\n        if (localRect.top >= startY - 20) {\n            refDOM = dom;\n            refTop = localRect.top;\n            break;\n        }\n    }\n    return { refDOM: refDOM, refTop: refTop, stack: scrollStack(view.dom) };\n}\nfunction scrollStack(dom) {\n    let stack = [], doc = dom.ownerDocument;\n    for (let cur = dom; cur; cur = parentNode(cur)) {\n        stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });\n        if (dom == doc)\n            break;\n    }\n    return stack;\n}\n// Reset the scroll position of the editor\'s parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos({ refDOM, refTop, stack }) {\n    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\nfunction restoreScrollStack(stack, dTop) {\n    for (let i = 0; i < stack.length; i++) {\n        let { dom, top, left } = stack[i];\n        if (dom.scrollTop != top + dTop)\n            dom.scrollTop = top + dTop;\n        if (dom.scrollLeft != left)\n            dom.scrollLeft = left;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive)\n        return dom.setActive(); // in IE\n    if (preventScrollSupported)\n        return dom.focus(preventScrollSupported);\n    let stored = scrollStack(dom);\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll() {\n            preventScrollSupported = { preventScroll: true };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        restoreScrollStack(stored, 0);\n    }\n}\nfunction findOffsetInNode(node, coords) {\n    let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n    let rowBot = coords.top, rowTop = coords.top;\n    let firstBelow, coordsBelow;\n    for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n        let rects;\n        if (child.nodeType == 1)\n            rects = child.getClientRects();\n        else if (child.nodeType == 3)\n            rects = textRange(child).getClientRects();\n        else\n            continue;\n        for (let i = 0; i < rects.length; i++) {\n            let rect = rects[i];\n            if (rect.top <= rowBot && rect.bottom >= rowTop) {\n                rowBot = Math.max(rect.bottom, rowBot);\n                rowTop = Math.min(rect.top, rowTop);\n                let dx = rect.left > coords.left ? rect.left - coords.left\n                    : rect.right < coords.left ? coords.left - rect.right : 0;\n                if (dx < dxClosest) {\n                    closest = child;\n                    dxClosest = dx;\n                    coordsClosest = dx && closest.nodeType == 3 ? {\n                        left: rect.right < coords.left ? rect.right : rect.left,\n                        top: coords.top\n                    } : coords;\n                    if (child.nodeType == 1 && dx)\n                        offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n                    continue;\n                }\n            }\n            else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n                firstBelow = child;\n                coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };\n            }\n            if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n                coords.left >= rect.left && coords.top >= rect.bottom))\n                offset = childIndex + 1;\n        }\n    }\n    if (!closest && firstBelow) {\n        closest = firstBelow;\n        coordsClosest = coordsBelow;\n        dxClosest = 0;\n    }\n    if (closest && closest.nodeType == 3)\n        return findOffsetInText(closest, coordsClosest);\n    if (!closest || (dxClosest && closest.nodeType == 1))\n        return { node, offset };\n    return findOffsetInNode(closest, coordsClosest);\n}\nfunction findOffsetInText(node, coords) {\n    let len = node.nodeValue.length;\n    let range = document.createRange();\n    for (let i = 0; i < len; i++) {\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rect = singleRect(range, 1);\n        if (rect.top == rect.bottom)\n            continue;\n        if (inRect(coords, rect))\n            return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };\n    }\n    return { node, offset: 0 };\n}\nfunction inRect(coords, rect) {\n    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 &&\n        coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\nfunction targetKludge(dom, coords) {\n    let parent = dom.parentNode;\n    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n        return parent;\n    return dom;\n}\nfunction posFromElement(view, elt, coords) {\n    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n    if (node.nodeType == 1 && !node.firstChild) {\n        let rect = node.getBoundingClientRect();\n        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n    }\n    return view.docView.posFromDOM(node, offset, bias);\n}\nfunction posFromCaret(view, node, offset, coords) {\n    // Browser (in caretPosition/RangeFromPoint) will agressively\n    // normalize towards nearby inline nodes. Since we are interested in\n    // positions between block nodes too, we first walk up the hierarchy\n    // of nodes to see if there are block nodes that the coordinates\n    // fall outside of. If so, we take the position before/after that\n    // block. If not, we call `posFromDOM` on the raw node/offset.\n    let outsideBlock = -1;\n    for (let cur = node, sawBlock = false;;) {\n        if (cur == view.dom)\n            break;\n        let desc = view.docView.nearestDesc(cur, true);\n        if (!desc)\n            return null;\n        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {\n            let rect = desc.dom.getBoundingClientRect();\n            if (desc.node.isBlock && desc.parent && !sawBlock) {\n                sawBlock = true;\n                if (rect.left > coords.left || rect.top > coords.top)\n                    outsideBlock = desc.posBefore;\n                else if (rect.right < coords.left || rect.bottom < coords.top)\n                    outsideBlock = desc.posAfter;\n            }\n            if (!desc.contentDOM && outsideBlock < 0) {\n                // If we are inside a leaf, return the side of the leaf closer to the coords\n                let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2\n                    : coords.left < (rect.left + rect.right) / 2;\n                return before ? desc.posBefore : desc.posAfter;\n            }\n        }\n        cur = desc.dom.parentNode;\n    }\n    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n}\nfunction elementFromPoint(element, coords, box) {\n    let len = element.childNodes.length;\n    if (len && box.top < box.bottom) {\n        for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {\n            let child = element.childNodes[i];\n            if (child.nodeType == 1) {\n                let rects = child.getClientRects();\n                for (let j = 0; j < rects.length; j++) {\n                    let rect = rects[j];\n                    if (inRect(coords, rect))\n                        return elementFromPoint(child, coords, rect);\n                }\n            }\n            if ((i = (i + 1) % len) == startI)\n                break;\n        }\n    }\n    return element;\n}\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n    let doc = view.dom.ownerDocument, node, offset = 0;\n    let caret = caretFromPoint(doc, coords.left, coords.top);\n    if (caret)\n        ({ node, offset } = caret);\n    let elt = (view.root.elementFromPoint ? view.root : doc)\n        .elementFromPoint(coords.left, coords.top);\n    let pos;\n    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n        let box = view.dom.getBoundingClientRect();\n        if (!inRect(coords, box))\n            return null;\n        elt = elementFromPoint(view.dom, coords, box);\n        if (!elt)\n            return null;\n    }\n    // Safari\'s caretRangeFromPoint returns nonsense when on a draggable element\n    if (safari) {\n        for (let p = elt; node && p; p = parentNode(p))\n            if (p.draggable)\n                node = undefined;\n    }\n    elt = targetKludge(elt, coords);\n    if (node) {\n        if (gecko && node.nodeType == 1) {\n            // Firefox will sometimes return offsets into <input> nodes, which\n            // have no actual children, from caretPositionFromPoint (#953)\n            offset = Math.min(offset, node.childNodes.length);\n            // It\'ll also move the returned position before image nodes,\n            // even if those are behind it.\n            if (offset < node.childNodes.length) {\n                let next = node.childNodes[offset], box;\n                if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left &&\n                    box.bottom > coords.top)\n                    offset++;\n            }\n        }\n        // Suspiciously specific kludge to work around caret*FromPoint\n        // never returning a position at the end of the document\n        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&\n            coords.top > node.lastChild.getBoundingClientRect().bottom)\n            pos = view.state.doc.content.size;\n        // Ignore positions directly after a BR, since caret*FromPoint\n        // \'round up\' positions that would be more accurately placed\n        // before the BR node.\n        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")\n            pos = posFromCaret(view, node, offset, coords);\n    }\n    if (pos == null)\n        pos = posFromElement(view, elt, coords);\n    let desc = view.docView.nearestDesc(elt, true);\n    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };\n}\nfunction nonZero(rect) {\n    return rect.top < rect.bottom || rect.left < rect.right;\n}\nfunction singleRect(target, bias) {\n    let rects = target.getClientRects();\n    if (rects.length) {\n        let first = rects[bias < 0 ? 0 : rects.length - 1];\n        if (nonZero(first))\n            return first;\n    }\n    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n}\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos, side) {\n    let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n    let supportEmptyRange = webkit || gecko;\n    if (node.nodeType == 3) {\n        // These browsers support querying empty text ranges. Prefer that in\n        // bidi context or when at the end of a node.\n        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n            let rect = singleRect(textRange(node, offset, offset), side);\n            // Firefox returns bad results (the position before the space)\n            // when querying a position directly after line-broken\n            // whitespace. Detect this situation and and kludge around it\n            if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n                let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n                if (rectBefore.top == rect.top) {\n                    let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n                    if (rectAfter.top != rect.top)\n                        return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n                }\n            }\n            return rect;\n        }\n        else {\n            let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n            if (side < 0 && !offset) {\n                to++;\n                takeSide = -1;\n            }\n            else if (side >= 0 && offset == node.nodeValue.length) {\n                from--;\n                takeSide = 1;\n            }\n            else if (side < 0) {\n                from--;\n            }\n            else {\n                to++;\n            }\n            return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);\n        }\n    }\n    let $dom = view.state.doc.resolve(pos - (atom || 0));\n    // Return a horizontal line in block context\n    if (!$dom.parent.inlineContent) {\n        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n            let before = node.childNodes[offset - 1];\n            if (before.nodeType == 1)\n                return flattenH(before.getBoundingClientRect(), false);\n        }\n        if (atom == null && offset < nodeSize(node)) {\n            let after = node.childNodes[offset];\n            if (after.nodeType == 1)\n                return flattenH(after.getBoundingClientRect(), true);\n        }\n        return flattenH(node.getBoundingClientRect(), side >= 0);\n    }\n    // Inline, not in text node (this is not Bidi-safe)\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n        let before = node.childNodes[offset - 1];\n        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1))\n            // BR nodes tend to only return the rectangle before them.\n            // Only use them if they are the last element in their parent\n            : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;\n        if (target)\n            return flattenV(singleRect(target, 1), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n        let after = node.childNodes[offset];\n        while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)\n            after = after.nextSibling;\n        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, (supportEmptyRange ? 0 : 1))\n            : after.nodeType == 1 ? after : null;\n        if (target)\n            return flattenV(singleRect(target, -1), true);\n    }\n    // All else failed, just try to get a rectangle for the target node\n    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\nfunction flattenV(rect, left) {\n    if (rect.width == 0)\n        return rect;\n    let x = left ? rect.left : rect.right;\n    return { top: rect.top, bottom: rect.bottom, left: x, right: x };\n}\nfunction flattenH(rect, top) {\n    if (rect.height == 0)\n        return rect;\n    let y = top ? rect.top : rect.bottom;\n    return { top: y, bottom: y, left: rect.left, right: rect.right };\n}\nfunction withFlushedState(view, state, f) {\n    let viewState = view.state, active = view.root.activeElement;\n    if (viewState != state)\n        view.updateState(state);\n    if (active != view.dom)\n        view.focus();\n    try {\n        return f();\n    }\n    finally {\n        if (viewState != state)\n            view.updateState(viewState);\n        if (active != view.dom && active)\n            active.focus();\n    }\n}\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n    let sel = state.selection;\n    let $pos = dir == "up" ? sel.$from : sel.$to;\n    return withFlushedState(view, state, () => {\n        let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);\n        for (;;) {\n            let nearest = view.docView.nearestDesc(dom, true);\n            if (!nearest)\n                break;\n            if (nearest.node.isBlock) {\n                dom = nearest.contentDOM || nearest.dom;\n                break;\n            }\n            dom = nearest.dom.parentNode;\n        }\n        let coords = coordsAtPos(view, $pos.pos, 1);\n        for (let child = dom.firstChild; child; child = child.nextSibling) {\n            let boxes;\n            if (child.nodeType == 1)\n                boxes = child.getClientRects();\n            else if (child.nodeType == 3)\n                boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n            else\n                continue;\n            for (let i = 0; i < boxes.length; i++) {\n                let box = boxes[i];\n                if (box.bottom > box.top + 1 &&\n                    (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2\n                        : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))\n                    return false;\n            }\n        }\n        return true;\n    });\n}\nconst maybeRTL = /[\\u0590-\\u08ac]/;\nfunction endOfTextblockHorizontal(view, state, dir) {\n    let { $head } = state.selection;\n    if (!$head.parent.isTextblock)\n        return false;\n    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n    let sel = view.domSelection();\n    // If the textblock is all LTR, or the browser doesn\'t support\n    // Selection.modify (Edge), fall back to a primitive approach\n    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n        return dir == "left" || dir == "backward" ? atStart : atEnd;\n    return withFlushedState(view, state, () => {\n        // This is a huge hack, but appears to be the best we can\n        // currently do: use `Selection.modify` to move the selection by\n        // one character, and see if that moves the cursor out of the\n        // textblock (or doesn\'t move it at all, when at the start/end of\n        // the document).\n        let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n        let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n        ;\n        sel.modify("move", dir, "character");\n        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n        let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n        let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) ||\n            (oldNode == newNode && oldOff == newOff);\n        // Restore the previous selection\n        try {\n            sel.collapse(anchorNode, anchorOffset);\n            if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)\n                sel.extend(oldNode, oldOff);\n        }\n        catch (_) { }\n        if (oldBidiLevel != null)\n            sel.caretBidiLevel = oldBidiLevel;\n        return result;\n    });\n}\nlet cachedState = null;\nlet cachedDir = null;\nlet cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n    if (cachedState == state && cachedDir == dir)\n        return cachedResult;\n    cachedState = state;\n    cachedDir = dir;\n    return cachedResult = dir == "up" || dir == "down"\n        ? endOfTextblockVertical(view, state, dir)\n        : endOfTextblockHorizontal(view, state, dir);\n}\n\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor\'s content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n    constructor(parent, children, dom, \n    // This is the node that holds the child views. It may be null for\n    // descs that don\'t have children.\n    contentDOM) {\n        this.parent = parent;\n        this.children = children;\n        this.dom = dom;\n        this.contentDOM = contentDOM;\n        this.dirty = NOT_DIRTY;\n        // An expando property on the DOM node provides a link back to its\n        // description.\n        dom.pmViewDesc = this;\n    }\n    // Used to check whether a given description corresponds to a\n    // widget/mark/node.\n    matchesWidget(widget) { return false; }\n    matchesMark(mark) { return false; }\n    matchesNode(node, outerDeco, innerDeco) { return false; }\n    matchesHack(nodeName) { return false; }\n    // When parsing in-editor content (in domchange.js), we allow\n    // descriptions to determine the parse rules that should be used to\n    // parse them.\n    parseRule() { return null; }\n    // Used by the editor\'s event handler to ignore events that come\n    // from certain descs.\n    stopEvent(event) { return false; }\n    // The size of the content represented by this desc.\n    get size() {\n        let size = 0;\n        for (let i = 0; i < this.children.length; i++)\n            size += this.children[i].size;\n        return size;\n    }\n    // For block nodes, this represents the space taken up by their\n    // start/end tokens.\n    get border() { return 0; }\n    destroy() {\n        this.parent = undefined;\n        if (this.dom.pmViewDesc == this)\n            this.dom.pmViewDesc = undefined;\n        for (let i = 0; i < this.children.length; i++)\n            this.children[i].destroy();\n    }\n    posBeforeChild(child) {\n        for (let i = 0, pos = this.posAtStart;; i++) {\n            let cur = this.children[i];\n            if (cur == child)\n                return pos;\n            pos += cur.size;\n        }\n    }\n    get posBefore() {\n        return this.parent.posBeforeChild(this);\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n    get posAfter() {\n        return this.posBefore + this.size;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.size - 2 * this.border;\n    }\n    localPosFromDOM(dom, offset, bias) {\n        // If the DOM position is in the content, use the child desc after\n        // it to figure out a position.\n        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n            if (bias < 0) {\n                let domBefore, desc;\n                if (dom == this.contentDOM) {\n                    domBefore = dom.childNodes[offset - 1];\n                }\n                else {\n                    while (dom.parentNode != this.contentDOM)\n                        dom = dom.parentNode;\n                    domBefore = dom.previousSibling;\n                }\n                while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))\n                    domBefore = domBefore.previousSibling;\n                return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n            }\n            else {\n                let domAfter, desc;\n                if (dom == this.contentDOM) {\n                    domAfter = dom.childNodes[offset];\n                }\n                else {\n                    while (dom.parentNode != this.contentDOM)\n                        dom = dom.parentNode;\n                    domAfter = dom.nextSibling;\n                }\n                while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))\n                    domAfter = domAfter.nextSibling;\n                return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n            }\n        }\n        // Otherwise, use various heuristics, falling back on the bias\n        // parameter, to determine whether to return the position at the\n        // start or at the end of this view desc.\n        let atEnd;\n        if (dom == this.dom && this.contentDOM) {\n            atEnd = offset > domIndex(this.contentDOM);\n        }\n        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n        }\n        else if (this.dom.firstChild) {\n            if (offset == 0)\n                for (let search = dom;; search = search.parentNode) {\n                    if (search == this.dom) {\n                        atEnd = false;\n                        break;\n                    }\n                    if (search.previousSibling)\n                        break;\n                }\n            if (atEnd == null && offset == dom.childNodes.length)\n                for (let search = dom;; search = search.parentNode) {\n                    if (search == this.dom) {\n                        atEnd = true;\n                        break;\n                    }\n                    if (search.nextSibling)\n                        break;\n                }\n        }\n        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n    nearestDesc(dom, onlyNodes = false) {\n        for (let first = true, cur = dom; cur; cur = cur.parentNode) {\n            let desc = this.getDesc(cur), nodeDOM;\n            if (desc && (!onlyNodes || desc.node)) {\n                // If dom is outside of this desc\'s nodeDOM, don\'t count it.\n                if (first && (nodeDOM = desc.nodeDOM) &&\n                    !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))\n                    first = false;\n                else\n                    return desc;\n            }\n        }\n    }\n    getDesc(dom) {\n        let desc = dom.pmViewDesc;\n        for (let cur = desc; cur; cur = cur.parent)\n            if (cur == this)\n                return desc;\n    }\n    posFromDOM(dom, offset, bias) {\n        for (let scan = dom; scan; scan = scan.parentNode) {\n            let desc = this.getDesc(scan);\n            if (desc)\n                return desc.localPosFromDOM(dom, offset, bias);\n        }\n        return -1;\n    }\n    // Find the desc for the node after the given pos, if any. (When a\n    // parent node overrode rendering, there might not be one.)\n    descAt(pos) {\n        for (let i = 0, offset = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (offset == pos && end != offset) {\n                while (!child.border && child.children.length)\n                    child = child.children[0];\n                return child;\n            }\n            if (pos < end)\n                return child.descAt(pos - offset - child.border);\n            offset = end;\n        }\n    }\n    domFromPos(pos, side) {\n        if (!this.contentDOM)\n            return { node: this.dom, offset: 0, atom: pos + 1 };\n        // First find the position in the child array\n        let i = 0, offset = 0;\n        for (let curPos = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = curPos + child.size;\n            if (end > pos || child instanceof TrailingHackViewDesc) {\n                offset = pos - curPos;\n                break;\n            }\n            curPos = end;\n        }\n        // If this points into the middle of a child, call through\n        if (offset)\n            return this.children[i].domFromPos(offset - this.children[i].border, side);\n        // Go back if there were any zero-length widgets with side >= 0 before this point\n        for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) { }\n        // Scan towards the first useable node\n        if (side <= 0) {\n            let prev, enter = true;\n            for (;; i--, enter = false) {\n                prev = i ? this.children[i - 1] : null;\n                if (!prev || prev.dom.parentNode == this.contentDOM)\n                    break;\n            }\n            if (prev && side && enter && !prev.border && !prev.domAtom)\n                return prev.domFromPos(prev.size, side);\n            return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };\n        }\n        else {\n            let next, enter = true;\n            for (;; i++, enter = false) {\n                next = i < this.children.length ? this.children[i] : null;\n                if (!next || next.dom.parentNode == this.contentDOM)\n                    break;\n            }\n            if (next && enter && !next.border && !next.domAtom)\n                return next.domFromPos(0, side);\n            return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };\n        }\n    }\n    // Used to find a DOM range in a single parent for a given changed\n    // range.\n    parseRange(from, to, base = 0) {\n        if (this.children.length == 0)\n            return { node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };\n        let fromOffset = -1, toOffset = -1;\n        for (let offset = base, i = 0;; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (fromOffset == -1 && from <= end) {\n                let childBase = offset + child.border;\n                // FIXME maybe descend mark views to parse a narrower range?\n                if (from >= childBase && to <= end - child.border && child.node &&\n                    child.contentDOM && this.contentDOM.contains(child.contentDOM))\n                    return child.parseRange(from, to, childBase);\n                from = offset;\n                for (let j = i; j > 0; j--) {\n                    let prev = this.children[j - 1];\n                    if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n                        fromOffset = domIndex(prev.dom) + 1;\n                        break;\n                    }\n                    from -= prev.size;\n                }\n                if (fromOffset == -1)\n                    fromOffset = 0;\n            }\n            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n                to = end;\n                for (let j = i + 1; j < this.children.length; j++) {\n                    let next = this.children[j];\n                    if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n                        toOffset = domIndex(next.dom);\n                        break;\n                    }\n                    to += next.size;\n                }\n                if (toOffset == -1)\n                    toOffset = this.contentDOM.childNodes.length;\n                break;\n            }\n            offset = end;\n        }\n        return { node: this.contentDOM, from, to, fromOffset, toOffset };\n    }\n    emptyChildAt(side) {\n        if (this.border || !this.contentDOM || !this.children.length)\n            return false;\n        let child = this.children[side < 0 ? 0 : this.children.length - 1];\n        return child.size == 0 || child.emptyChildAt(side);\n    }\n    domAfterPos(pos) {\n        let { node, offset } = this.domFromPos(pos, 0);\n        if (node.nodeType != 1 || offset == node.childNodes.length)\n            throw new RangeError("No node after pos " + pos);\n        return node.childNodes[offset];\n    }\n    // View descs are responsible for setting any selection that falls\n    // entirely inside of them, so that custom implementations can do\n    // custom things with the selection. Note that this falls apart when\n    // a selection starts in such a node and ends in another, in which\n    // case we just use whatever domFromPos produces as a best effort.\n    setSelection(anchor, head, root, force = false) {\n        // If the selection falls entirely in a child, give it to that child\n        let from = Math.min(anchor, head), to = Math.max(anchor, head);\n        for (let i = 0, offset = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (from > offset && to < end)\n                return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);\n            offset = end;\n        }\n        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n        let domSel = root.getSelection();\n        let brKludge = false;\n        // On Firefox, using Selection.collapse to put the cursor after a\n        // BR node for some reason doesn\'t always work (#1073). On Safari,\n        // the cursor sometimes inexplicable visually lags behind its\n        // reported position in such situations (#1092).\n        if ((gecko || safari) && anchor == head) {\n            let { node, offset } = anchorDOM;\n            if (node.nodeType == 3) {\n                brKludge = !!(offset && node.nodeValue[offset - 1] == "\\n");\n                // Issue #1128\n                if (brKludge && offset == node.nodeValue.length) {\n                    for (let scan = node, after; scan; scan = scan.parentNode) {\n                        if (after = scan.nextSibling) {\n                            if (after.nodeName == "BR")\n                                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };\n                            break;\n                        }\n                        let desc = scan.pmViewDesc;\n                        if (desc && desc.node && desc.node.isBlock)\n                            break;\n                    }\n                }\n            }\n            else {\n                let prev = node.childNodes[offset - 1];\n                brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");\n            }\n        }\n        // Firefox can act strangely when the selection is in front of an\n        // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536\n        if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {\n            let after = domSel.focusNode.childNodes[domSel.focusOffset];\n            if (after && after.contentEditable == "false")\n                force = true;\n        }\n        if (!(force || brKludge && safari) &&\n            isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&\n            isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))\n            return;\n        // Selection.extend can be used to create an \'inverted\' selection\n        // (one where the focus is before the anchor), but not all\n        // browsers support it yet.\n        let domSelExtended = false;\n        if ((domSel.extend || anchor == head) && !brKludge) {\n            domSel.collapse(anchorDOM.node, anchorDOM.offset);\n            try {\n                if (anchor != head)\n                    domSel.extend(headDOM.node, headDOM.offset);\n                domSelExtended = true;\n            }\n            catch (_) {\n                // In some cases with Chrome the selection is empty after calling\n                // collapse, even when it should be valid. This appears to be a bug, but\n                // it is difficult to isolate. If this happens fallback to the old path\n                // without using extend.\n                // Similarly, this could crash on Safari if the editor is hidden, and\n                // there was no selection.\n            }\n        }\n        if (!domSelExtended) {\n            if (anchor > head) {\n                let tmp = anchorDOM;\n                anchorDOM = headDOM;\n                headDOM = tmp;\n            }\n            let range = document.createRange();\n            range.setEnd(headDOM.node, headDOM.offset);\n            range.setStart(anchorDOM.node, anchorDOM.offset);\n            domSel.removeAllRanges();\n            domSel.addRange(range);\n        }\n    }\n    ignoreMutation(mutation) {\n        return !this.contentDOM && mutation.type != "selection";\n    }\n    get contentLost() {\n        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n    // Remove a subtree of the element tree that has been touched\n    // by a DOM change, so that the next update will redraw it.\n    markDirty(from, to) {\n        for (let offset = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n                let startInside = offset + child.border, endInside = end - child.border;\n                if (from >= startInside && to <= endInside) {\n                    this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n                    if (from == startInside && to == endInside &&\n                        (child.contentLost || child.dom.parentNode != this.contentDOM))\n                        child.dirty = NODE_DIRTY;\n                    else\n                        child.markDirty(from - startInside, to - startInside);\n                    return;\n                }\n                else {\n                    child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length\n                        ? CONTENT_DIRTY : NODE_DIRTY;\n                }\n            }\n            offset = end;\n        }\n        this.dirty = CONTENT_DIRTY;\n    }\n    markParentsDirty() {\n        let level = 1;\n        for (let node = this.parent; node; node = node.parent, level++) {\n            let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (node.dirty < dirty)\n                node.dirty = dirty;\n        }\n    }\n    get domAtom() { return false; }\n    get ignoreForCoords() { return false; }\n}\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n    constructor(parent, widget, view, pos) {\n        let self, dom = widget.type.toDOM;\n        if (typeof dom == "function")\n            dom = dom(view, () => {\n                if (!self)\n                    return pos;\n                if (self.parent)\n                    return self.parent.posBeforeChild(self);\n            });\n        if (!widget.type.spec.raw) {\n            if (dom.nodeType != 1) {\n                let wrap = document.createElement("span");\n                wrap.appendChild(dom);\n                dom = wrap;\n            }\n            dom.contentEditable = "false";\n            dom.classList.add("ProseMirror-widget");\n        }\n        super(parent, [], dom, null);\n        this.widget = widget;\n        this.widget = widget;\n        self = this;\n    }\n    matchesWidget(widget) {\n        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n    parseRule() { return { ignore: true }; }\n    stopEvent(event) {\n        let stop = this.widget.spec.stopEvent;\n        return stop ? stop(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != "selection" || this.widget.spec.ignoreSelection;\n    }\n    destroy() {\n        this.widget.type.destroy(this.dom);\n        super.destroy();\n    }\n    get domAtom() { return true; }\n    get side() { return this.widget.type.side; }\n}\nclass CompositionViewDesc extends ViewDesc {\n    constructor(parent, dom, textDOM, text) {\n        super(parent, [], dom, null);\n        this.textDOM = textDOM;\n        this.text = text;\n    }\n    get size() { return this.text.length; }\n    localPosFromDOM(dom, offset) {\n        if (dom != this.textDOM)\n            return this.posAtStart + (offset ? this.size : 0);\n        return this.posAtStart + offset;\n    }\n    domFromPos(pos) {\n        return { node: this.textDOM, offset: pos };\n    }\n    ignoreMutation(mut) {\n        return mut.type === \'characterData\' && mut.target.nodeValue == mut.oldValue;\n    }\n}\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n    constructor(parent, mark, dom, contentDOM) {\n        super(parent, [], dom, contentDOM);\n        this.mark = mark;\n    }\n    static create(parent, mark, inline, view) {\n        let custom = view.nodeViews[mark.type.name];\n        let spec = custom && custom(mark, view, inline);\n        if (!spec || !spec.dom)\n            spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));\n        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);\n    }\n    parseRule() {\n        if ((this.dirty & NODE_DIRTY) || this.mark.type.spec.reparseInView)\n            return null;\n        return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM || undefined };\n    }\n    matchesMark(mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark); }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        // Move dirty info to nearest node view\n        if (this.dirty != NOT_DIRTY) {\n            let parent = this.parent;\n            while (!parent.node)\n                parent = parent.parent;\n            if (parent.dirty < this.dirty)\n                parent.dirty = this.dirty;\n            this.dirty = NOT_DIRTY;\n        }\n    }\n    slice(from, to, view) {\n        let copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n        let nodes = this.children, size = this.size;\n        if (to < size)\n            nodes = replaceNodes(nodes, to, size, view);\n        if (from > 0)\n            nodes = replaceNodes(nodes, 0, from, view);\n        for (let i = 0; i < nodes.length; i++)\n            nodes[i].parent = copy;\n        copy.children = nodes;\n        return copy;\n    }\n}\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n        super(parent, [], dom, contentDOM);\n        this.node = node;\n        this.outerDeco = outerDeco;\n        this.innerDeco = innerDeco;\n        this.nodeDOM = nodeDOM;\n    }\n    // By default, a node is rendered using the `toDOM` method from the\n    // node type spec. But client code can use the `nodeViews` spec to\n    // supply a custom node view, which can influence various aspects of\n    // the way the node works.\n    //\n    // (Using subclassing for this was intentionally decided against,\n    // since it\'d require exposing a whole slew of finicky\n    // implementation details to the user code that they probably will\n    // never need.)\n    static create(parent, node, outerDeco, innerDeco, view, pos) {\n        let custom = view.nodeViews[node.type.name], descObj;\n        let spec = custom && custom(node, view, () => {\n            // (This is a function that allows the custom view to find its\n            // own position)\n            if (!descObj)\n                return pos;\n            if (descObj.parent)\n                return descObj.parent.posBeforeChild(descObj);\n        }, outerDeco, innerDeco);\n        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n        if (node.isText) {\n            if (!dom)\n                dom = document.createTextNode(node.text);\n            else if (dom.nodeType != 3)\n                throw new RangeError("Text must be rendered as a DOM text node");\n        }\n        else if (!dom) {\n            ({ dom, contentDOM } = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));\n        }\n        if (!contentDOM && !node.isText && dom.nodeName != "BR") { // Chrome gets confused by <br contenteditable=false>\n            if (!dom.hasAttribute("contenteditable"))\n                dom.contentEditable = "false";\n            if (node.type.spec.draggable)\n                dom.draggable = true;\n        }\n        let nodeDOM = dom;\n        dom = applyOuterDeco(dom, outerDeco, node);\n        if (spec)\n            return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n        else if (node.isText)\n            return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n        else\n            return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n    parseRule() {\n        // Experimental kludge to allow opt-in re-parsing of nodes\n        if (this.node.type.spec.reparseInView)\n            return null;\n        // FIXME the assumption that this can always return the current\n        // attrs means that if the user somehow manages to change the\n        // attrs in the dom, that won\'t be picked up. Not entirely sure\n        // whether this is a problem\n        let rule = { node: this.node.type.name, attrs: this.node.attrs };\n        if (this.node.type.whitespace == "pre")\n            rule.preserveWhitespace = "full";\n        if (!this.contentDOM) {\n            rule.getContent = () => this.node.content;\n        }\n        else if (!this.contentLost) {\n            rule.contentElement = this.contentDOM;\n        }\n        else {\n            // Chrome likes to randomly recreate parent nodes when\n            // backspacing things. When that happens, this tries to find the\n            // new parent.\n            for (let i = this.children.length - 1; i >= 0; i--) {\n                let child = this.children[i];\n                if (this.dom.contains(child.dom.parentNode)) {\n                    rule.contentElement = child.dom.parentNode;\n                    break;\n                }\n            }\n            if (!rule.contentElement)\n                rule.getContent = () => prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        }\n        return rule;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n            sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n    get size() { return this.node.nodeSize; }\n    get border() { return this.node.isLeaf ? 0 : 1; }\n    // Syncs `this.children` to match `this.node.content` and the local\n    // decorations, possibly introducing nesting for marks. Then, in a\n    // separate step, syncs the DOM inside `this.contentDOM` to\n    // `this.children`.\n    updateChildren(view, pos) {\n        let inline = this.node.inlineContent, off = pos;\n        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n        let localComposition = composition && composition.pos > -1 ? composition : null;\n        let compositionInChild = composition && composition.pos < 0;\n        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n        iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {\n            if (widget.spec.marks)\n                updater.syncToMarks(widget.spec.marks, inline, view);\n            else if (widget.type.side >= 0 && !insideNode)\n                updater.syncToMarks(i == this.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none : this.node.child(i).marks, inline, view);\n            // If the next node is a desc matching this widget, reuse it,\n            // otherwise insert the widget as a new view desc.\n            updater.placeWidget(widget, view, off);\n        }, (child, outerDeco, innerDeco, i) => {\n            // Make sure the wrapping mark descs match the node\'s marks.\n            updater.syncToMarks(child.marks, inline, view);\n            // Try several strategies for drawing this node\n            let compIndex;\n            if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;\n            else if (compositionInChild && view.state.selection.from > off &&\n                view.state.selection.to < off + child.nodeSize &&\n                (compIndex = updater.findIndexWithChild(composition.node)) > -1 &&\n                updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;\n            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;\n            else {\n                // Add it as a new view\n                updater.addNode(child, outerDeco, innerDeco, view, off);\n            }\n            off += child.nodeSize;\n        });\n        // Drop all remaining descs after the current position.\n        updater.syncToMarks([], inline, view);\n        if (this.node.isTextblock)\n            updater.addTextblockHacks();\n        updater.destroyRest();\n        // Sync the DOM if anything changed\n        if (updater.changed || this.dirty == CONTENT_DIRTY) {\n            // May have to protect focused DOM from being changed if a composition is active\n            if (localComposition)\n                this.protectLocalComposition(view, localComposition);\n            renderDescs(this.contentDOM, this.children, view);\n            if (ios)\n                iosHacks(this.dom);\n        }\n    }\n    localCompositionInfo(view, pos) {\n        // Only do something if both the selection and a focused text node\n        // are inside of this node\n        let { from, to } = view.state.selection;\n        if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || from < pos || to > pos + this.node.content.size)\n            return null;\n        let sel = view.domSelectionRange();\n        let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);\n        if (!textNode || !this.dom.contains(textNode.parentNode))\n            return null;\n        if (this.node.inlineContent) {\n            // Find the text in the focused node in the node, stop if it\'s not\n            // there (may have been modified through other means, in which\n            // case it should overwritten)\n            let text = textNode.nodeValue;\n            let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n            return textPos < 0 ? null : { node: textNode, pos: textPos, text };\n        }\n        else {\n            return { node: textNode, pos: -1, text: "" };\n        }\n    }\n    protectLocalComposition(view, { node, pos, text }) {\n        // The node is already part of a local view desc, leave it there\n        if (this.getDesc(node))\n            return;\n        // Create a composition view for the orphaned nodes\n        let topNode = node;\n        for (;; topNode = topNode.parentNode) {\n            if (topNode.parentNode == this.contentDOM)\n                break;\n            while (topNode.previousSibling)\n                topNode.parentNode.removeChild(topNode.previousSibling);\n            while (topNode.nextSibling)\n                topNode.parentNode.removeChild(topNode.nextSibling);\n            if (topNode.pmViewDesc)\n                topNode.pmViewDesc = undefined;\n        }\n        let desc = new CompositionViewDesc(this, topNode, node, text);\n        view.input.compositionNodes.push(desc);\n        // Patch up this.children to contain the composition view\n        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n    }\n    // If this desc must be updated to match the given node decoration,\n    // do so and return true.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY ||\n            !node.sameMarkup(this.node))\n            return false;\n        this.updateInner(node, outerDeco, innerDeco, view);\n        return true;\n    }\n    updateInner(node, outerDeco, innerDeco, view) {\n        this.updateOuterDeco(outerDeco);\n        this.node = node;\n        this.innerDeco = innerDeco;\n        if (this.contentDOM)\n            this.updateChildren(view, this.posAtStart);\n        this.dirty = NOT_DIRTY;\n    }\n    updateOuterDeco(outerDeco) {\n        if (sameOuterDeco(outerDeco, this.outerDeco))\n            return;\n        let needsWrap = this.nodeDOM.nodeType != 1;\n        let oldDOM = this.dom;\n        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n        if (this.dom != oldDOM) {\n            oldDOM.pmViewDesc = undefined;\n            this.dom.pmViewDesc = this;\n        }\n        this.outerDeco = outerDeco;\n    }\n    // Mark this node as being the selected node.\n    selectNode() {\n        if (this.nodeDOM.nodeType == 1)\n            this.nodeDOM.classList.add("ProseMirror-selectednode");\n        if (this.contentDOM || !this.node.type.spec.draggable)\n            this.dom.draggable = true;\n    }\n    // Remove selected node marking from this node.\n    deselectNode() {\n        if (this.nodeDOM.nodeType == 1)\n            this.nodeDOM.classList.remove("ProseMirror-selectednode");\n        if (this.contentDOM || !this.node.type.spec.draggable)\n            this.dom.removeAttribute("draggable");\n    }\n    get domAtom() { return this.node.isAtom; }\n}\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n    applyOuterDeco(dom, outerDeco, doc);\n    let docView = new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);\n    if (docView.contentDOM)\n        docView.updateChildren(view, 0);\n    return docView;\n}\nclass TextViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n    }\n    parseRule() {\n        let skip = this.nodeDOM.parentNode;\n        while (skip && skip != this.dom && !skip.pmIsDeco)\n            skip = skip.parentNode;\n        return { skip: (skip || true) };\n    }\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||\n            !node.sameMarkup(this.node))\n            return false;\n        this.updateOuterDeco(outerDeco);\n        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n            this.nodeDOM.nodeValue = node.text;\n            if (view.trackWrites == this.nodeDOM)\n                view.trackWrites = null;\n        }\n        this.node = node;\n        this.dirty = NOT_DIRTY;\n        return true;\n    }\n    inParent() {\n        let parentDOM = this.parent.contentDOM;\n        for (let n = this.nodeDOM; n; n = n.parentNode)\n            if (n == parentDOM)\n                return true;\n        return false;\n    }\n    domFromPos(pos) {\n        return { node: this.nodeDOM, offset: pos };\n    }\n    localPosFromDOM(dom, offset, bias) {\n        if (dom == this.nodeDOM)\n            return this.posAtStart + Math.min(offset, this.node.text.length);\n        return super.localPosFromDOM(dom, offset, bias);\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != "characterData" && mutation.type != "selection";\n    }\n    slice(from, to, view) {\n        let node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))\n            this.dirty = NODE_DIRTY;\n    }\n    get domAtom() { return false; }\n}\n// A dummy desc used to tag trailing BR or IMG nodes created to work\n// around contentEditable terribleness.\nclass TrailingHackViewDesc extends ViewDesc {\n    parseRule() { return { ignore: true }; }\n    matchesHack(nodeName) { return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName; }\n    get domAtom() { return true; }\n    get ignoreForCoords() { return this.dom.nodeName == "IMG"; }\n}\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n        this.spec = spec;\n    }\n    // A custom `update` method gets to decide whether the update goes\n    // through. If it does, and there\'s a `contentDOM` node, our logic\n    // updates the children.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY)\n            return false;\n        if (this.spec.update) {\n            let result = this.spec.update(node, outerDeco, innerDeco);\n            if (result)\n                this.updateInner(node, outerDeco, innerDeco, view);\n            return result;\n        }\n        else if (!this.contentDOM && !node.isLeaf) {\n            return false;\n        }\n        else {\n            return super.update(node, outerDeco, innerDeco, view);\n        }\n    }\n    selectNode() {\n        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n    }\n    deselectNode() {\n        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n    }\n    setSelection(anchor, head, root, force) {\n        this.spec.setSelection ? this.spec.setSelection(anchor, head, root)\n            : super.setSelection(anchor, head, root, force);\n    }\n    destroy() {\n        if (this.spec.destroy)\n            this.spec.destroy();\n        super.destroy();\n    }\n    stopEvent(event) {\n        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n}\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n    let dom = parentDOM.firstChild, written = false;\n    for (let i = 0; i < descs.length; i++) {\n        let desc = descs[i], childDOM = desc.dom;\n        if (childDOM.parentNode == parentDOM) {\n            while (childDOM != dom) {\n                dom = rm(dom);\n                written = true;\n            }\n            dom = dom.nextSibling;\n        }\n        else {\n            written = true;\n            parentDOM.insertBefore(childDOM, dom);\n        }\n        if (desc instanceof MarkViewDesc) {\n            let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n            renderDescs(desc.contentDOM, desc.children, view);\n            dom = pos ? pos.nextSibling : parentDOM.firstChild;\n        }\n    }\n    while (dom) {\n        dom = rm(dom);\n        written = true;\n    }\n    if (written && view.trackWrites == parentDOM)\n        view.trackWrites = null;\n}\nconst OuterDecoLevel = function (nodeName) {\n    if (nodeName)\n        this.nodeName = nodeName;\n};\nOuterDecoLevel.prototype = Object.create(null);\nconst noDeco = [new OuterDecoLevel];\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n    if (outerDeco.length == 0)\n        return noDeco;\n    let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];\n    for (let i = 0; i < outerDeco.length; i++) {\n        let attrs = outerDeco[i].type.attrs;\n        if (!attrs)\n            continue;\n        if (attrs.nodeName)\n            result.push(top = new OuterDecoLevel(attrs.nodeName));\n        for (let name in attrs) {\n            let val = attrs[name];\n            if (val == null)\n                continue;\n            if (needsWrap && result.length == 1)\n                result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));\n            if (name == "class")\n                top.class = (top.class ? top.class + " " : "") + val;\n            else if (name == "style")\n                top.style = (top.style ? top.style + ";" : "") + val;\n            else if (name != "nodeName")\n                top[name] = val;\n        }\n    }\n    return result;\n}\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n    // Shortcut for trivial case\n    if (prevComputed == noDeco && curComputed == noDeco)\n        return nodeDOM;\n    let curDOM = nodeDOM;\n    for (let i = 0; i < curComputed.length; i++) {\n        let deco = curComputed[i], prev = prevComputed[i];\n        if (i) {\n            let parent;\n            if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n                (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n                curDOM = parent;\n            }\n            else {\n                parent = document.createElement(deco.nodeName);\n                parent.pmIsDeco = true;\n                parent.appendChild(curDOM);\n                prev = noDeco[0];\n                curDOM = parent;\n            }\n        }\n        patchAttributes(curDOM, prev || noDeco[0], deco);\n    }\n    return curDOM;\n}\nfunction patchAttributes(dom, prev, cur) {\n    for (let name in prev)\n        if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))\n            dom.removeAttribute(name);\n    for (let name in cur)\n        if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])\n            dom.setAttribute(name, cur[name]);\n    if (prev.class != cur.class) {\n        let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];\n        let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];\n        for (let i = 0; i < prevList.length; i++)\n            if (curList.indexOf(prevList[i]) == -1)\n                dom.classList.remove(prevList[i]);\n        for (let i = 0; i < curList.length; i++)\n            if (prevList.indexOf(curList[i]) == -1)\n                dom.classList.add(curList[i]);\n        if (dom.classList.length == 0)\n            dom.removeAttribute("class");\n    }\n    if (prev.style != cur.style) {\n        if (prev.style) {\n            let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:"(?:\\\\.|[^"])*"|\'(?:\\\\.|[^\'])*\'|\\(.*?\\)|[^;])*/g, m;\n            while (m = prop.exec(prev.style))\n                dom.style.removeProperty(m[1]);\n        }\n        if (cur.style)\n            dom.style.cssText += cur.style;\n    }\n}\nfunction applyOuterDeco(dom, deco, node) {\n    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\nfunction sameOuterDeco(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].type.eq(b[i].type))\n            return false;\n    return true;\n}\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n    constructor(top, lock, view) {\n        this.lock = lock;\n        this.view = view;\n        // Index into `this.top`\'s child array, represents the current\n        // update position.\n        this.index = 0;\n        // When entering a mark, the current top and index are pushed\n        // onto this.\n        this.stack = [];\n        // Tracks whether anything was changed\n        this.changed = false;\n        this.top = top;\n        this.preMatch = preMatch(top.node.content, top);\n    }\n    // Destroy and remove the children between the given indices in\n    // `this.top`.\n    destroyBetween(start, end) {\n        if (start == end)\n            return;\n        for (let i = start; i < end; i++)\n            this.top.children[i].destroy();\n        this.top.children.splice(start, end - start);\n        this.changed = true;\n    }\n    // Destroy all remaining children in `this.top`.\n    destroyRest() {\n        this.destroyBetween(this.index, this.top.children.length);\n    }\n    // Sync the current stack of mark descs with the given array of\n    // marks, reusing existing mark descs when possible.\n    syncToMarks(marks, inline, view) {\n        let keep = 0, depth = this.stack.length >> 1;\n        let maxKeep = Math.min(depth, marks.length);\n        while (keep < maxKeep &&\n            (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1])\n                .matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)\n            keep++;\n        while (keep < depth) {\n            this.destroyRest();\n            this.top.dirty = NOT_DIRTY;\n            this.index = this.stack.pop();\n            this.top = this.stack.pop();\n            depth--;\n        }\n        while (depth < marks.length) {\n            this.stack.push(this.top, this.index + 1);\n            let found = -1;\n            for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n                let next = this.top.children[i];\n                if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {\n                    found = i;\n                    break;\n                }\n            }\n            if (found > -1) {\n                if (found > this.index) {\n                    this.changed = true;\n                    this.destroyBetween(this.index, found);\n                }\n                this.top = this.top.children[this.index];\n            }\n            else {\n                let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n                this.top.children.splice(this.index, 0, markDesc);\n                this.top = markDesc;\n                this.changed = true;\n            }\n            this.index = 0;\n            depth++;\n        }\n    }\n    // Try to find a node desc matching the given data. Skip over it and\n    // return true when successful.\n    findNodeMatch(node, outerDeco, innerDeco, index) {\n        let found = -1, targetDesc;\n        if (index >= this.preMatch.index &&\n            (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top &&\n            targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n            found = this.top.children.indexOf(targetDesc, this.index);\n        }\n        else {\n            for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {\n                let child = this.top.children[i];\n                if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n                    found = i;\n                    break;\n                }\n            }\n        }\n        if (found < 0)\n            return false;\n        this.destroyBetween(this.index, found);\n        this.index++;\n        return true;\n    }\n    updateNodeAt(node, outerDeco, innerDeco, index, view) {\n        let child = this.top.children[index];\n        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)\n            child.dirty = CONTENT_DIRTY;\n        if (!child.update(node, outerDeco, innerDeco, view))\n            return false;\n        this.destroyBetween(this.index, index);\n        this.index++;\n        return true;\n    }\n    findIndexWithChild(domNode) {\n        for (;;) {\n            let parent = domNode.parentNode;\n            if (!parent)\n                return -1;\n            if (parent == this.top.contentDOM) {\n                let desc = domNode.pmViewDesc;\n                if (desc)\n                    for (let i = this.index; i < this.top.children.length; i++) {\n                        if (this.top.children[i] == desc)\n                            return i;\n                    }\n                return -1;\n            }\n            domNode = parent;\n        }\n    }\n    // Try to update the next node, if any, to the given data. Checks\n    // pre-matches to avoid overwriting nodes that could still be used.\n    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n        for (let i = this.index; i < this.top.children.length; i++) {\n            let next = this.top.children[i];\n            if (next instanceof NodeViewDesc) {\n                let preMatch = this.preMatch.matched.get(next);\n                if (preMatch != null && preMatch != index)\n                    return false;\n                let nextDOM = next.dom, updated;\n                // Can\'t update if nextDOM is or contains this.lock, except if\n                // it\'s a text node whose content already matches the new text\n                // and whose decorations match the new ones.\n                let locked = this.isLocked(nextDOM) &&\n                    !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&\n                        next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n                if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n                    this.destroyBetween(this.index, i);\n                    if (next.dom != nextDOM)\n                        this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n                    this.top.children[this.index] = updated;\n                    updated.dirty = CONTENT_DIRTY;\n                    updated.updateChildren(view, pos + 1);\n                    updated.dirty = NOT_DIRTY;\n                    this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n    // When a node with content is replaced by a different node with\n    // identical content, move over its children.\n    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n        if (next.dirty || node.isAtom || !next.children.length ||\n            !next.node.content.eq(node.content))\n            return null;\n        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (!wrapper.contentDOM)\n            return null;\n        wrapper.children = next.children;\n        next.children = [];\n        for (let ch of wrapper.children)\n            ch.parent = wrapper;\n        return wrapper;\n    }\n    // Insert the node as a newly created node desc.\n    addNode(node, outerDeco, innerDeco, view, pos) {\n        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (desc.contentDOM)\n            desc.updateChildren(view, pos + 1);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n    }\n    placeWidget(widget, view, pos) {\n        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n        if (next && next.matchesWidget(widget) &&\n            (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n            this.index++;\n        }\n        else {\n            let desc = new WidgetViewDesc(this.top, widget, view, pos);\n            this.top.children.splice(this.index++, 0, desc);\n            this.changed = true;\n        }\n    }\n    // Make sure a textblock looks and behaves correctly in\n    // contentEditable.\n    addTextblockHacks() {\n        let lastChild = this.top.children[this.index - 1], parent = this.top;\n        while (lastChild instanceof MarkViewDesc) {\n            parent = lastChild;\n            lastChild = parent.children[parent.children.length - 1];\n        }\n        if (!lastChild || // Empty textblock\n            !(lastChild instanceof TextViewDesc) ||\n            /\\n$/.test(lastChild.node.text) ||\n            (this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text))) {\n            // Avoid bugs in Safari\'s cursor drawing (#1165) and Chrome\'s mouse selection (#1152)\n            if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")\n                this.addHackNode("IMG", parent);\n            this.addHackNode("BR", this.top);\n        }\n    }\n    addHackNode(nodeName, parent) {\n        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n            this.index++;\n        }\n        else {\n            let dom = document.createElement(nodeName);\n            if (nodeName == "IMG") {\n                dom.className = "ProseMirror-separator";\n                dom.alt = "";\n            }\n            if (nodeName == "BR")\n                dom.className = "ProseMirror-trailingBreak";\n            let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n            if (parent != this.top)\n                parent.children.push(hack);\n            else\n                parent.children.splice(this.index++, 0, hack);\n            this.changed = true;\n        }\n    }\n    isLocked(node) {\n        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n    }\n}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, parentDesc) {\n    let curDesc = parentDesc, descI = curDesc.children.length;\n    let fI = frag.childCount, matched = new Map, matches = [];\n    outer: while (fI > 0) {\n        let desc;\n        for (;;) {\n            if (descI) {\n                let next = curDesc.children[descI - 1];\n                if (next instanceof MarkViewDesc) {\n                    curDesc = next;\n                    descI = next.children.length;\n                }\n                else {\n                    desc = next;\n                    descI--;\n                    break;\n                }\n            }\n            else if (curDesc == parentDesc) {\n                break outer;\n            }\n            else {\n                // FIXME\n                descI = curDesc.parent.children.indexOf(curDesc);\n                curDesc = curDesc.parent;\n            }\n        }\n        let node = desc.node;\n        if (!node)\n            continue;\n        if (node != frag.child(fI - 1))\n            break;\n        --fI;\n        matched.set(desc, fI);\n        matches.push(desc);\n    }\n    return { index: fI, matched, matches: matches.reverse() };\n}\nfunction compareSide(a, b) {\n    return a.type.side - b.type.side;\n}\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n    let locals = deco.locals(parent), offset = 0;\n    // Simple, cheap variant for when there are no local decorations\n    if (locals.length == 0) {\n        for (let i = 0; i < parent.childCount; i++) {\n            let child = parent.child(i);\n            onNode(child, locals, deco.forChild(offset, child), i);\n            offset += child.nodeSize;\n        }\n        return;\n    }\n    let decoIndex = 0, active = [], restNode = null;\n    for (let parentIndex = 0;;) {\n        if (decoIndex < locals.length && locals[decoIndex].to == offset) {\n            let widget = locals[decoIndex++], widgets;\n            while (decoIndex < locals.length && locals[decoIndex].to == offset)\n                (widgets || (widgets = [widget])).push(locals[decoIndex++]);\n            if (widgets) {\n                widgets.sort(compareSide);\n                for (let i = 0; i < widgets.length; i++)\n                    onWidget(widgets[i], parentIndex, !!restNode);\n            }\n            else {\n                onWidget(widget, parentIndex, !!restNode);\n            }\n        }\n        let child, index;\n        if (restNode) {\n            index = -1;\n            child = restNode;\n            restNode = null;\n        }\n        else if (parentIndex < parent.childCount) {\n            index = parentIndex;\n            child = parent.child(parentIndex++);\n        }\n        else {\n            break;\n        }\n        for (let i = 0; i < active.length; i++)\n            if (active[i].to <= offset)\n                active.splice(i--, 1);\n        while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n            active.push(locals[decoIndex++]);\n        let end = offset + child.nodeSize;\n        if (child.isText) {\n            let cutAt = end;\n            if (decoIndex < locals.length && locals[decoIndex].from < cutAt)\n                cutAt = locals[decoIndex].from;\n            for (let i = 0; i < active.length; i++)\n                if (active[i].to < cutAt)\n                    cutAt = active[i].to;\n            if (cutAt < end) {\n                restNode = child.cut(cutAt - offset);\n                child = child.cut(0, cutAt - offset);\n                end = cutAt;\n                index = -1;\n            }\n        }\n        let outerDeco = child.isInline && !child.isLeaf ? active.filter(d => !d.inline) : active.slice();\n        onNode(child, outerDeco, deco.forChild(offset, child), index);\n        offset = end;\n    }\n}\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n    if (dom.nodeName == "UL" || dom.nodeName == "OL") {\n        let oldCSS = dom.style.cssText;\n        dom.style.cssText = oldCSS + "; list-style: square !important";\n        window.getComputedStyle(dom).listStyle;\n        dom.style.cssText = oldCSS;\n    }\n}\nfunction nearbyTextNode(node, offset) {\n    for (;;) {\n        if (node.nodeType == 3)\n            return node;\n        if (node.nodeType == 1 && offset > 0) {\n            if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)\n                return node.childNodes[offset];\n            node = node.childNodes[offset - 1];\n            offset = nodeSize(node);\n        }\n        else if (node.nodeType == 1 && offset < node.childNodes.length) {\n            node = node.childNodes[offset];\n            offset = 0;\n        }\n        else {\n            return null;\n        }\n    }\n}\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n    for (let i = 0, pos = 0; i < frag.childCount && pos <= to;) {\n        let child = frag.child(i++), childStart = pos;\n        pos += child.nodeSize;\n        if (!child.isText)\n            continue;\n        let str = child.text;\n        while (i < frag.childCount) {\n            let next = frag.child(i++);\n            pos += next.nodeSize;\n            if (!next.isText)\n                break;\n            str += next.text;\n        }\n        if (pos >= from) {\n            let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n            if (found >= 0 && found + text.length + childStart >= from)\n                return childStart + found;\n            if (from == to && str.length >= (to + text.length) - childStart &&\n                str.slice(to - childStart, to - childStart + text.length) == text)\n                return to;\n        }\n    }\n    return -1;\n}\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n    let result = [];\n    for (let i = 0, off = 0; i < nodes.length; i++) {\n        let child = nodes[i], start = off, end = off += child.size;\n        if (start >= to || end <= from) {\n            result.push(child);\n        }\n        else {\n            if (start < from)\n                result.push(child.slice(0, from - start, view));\n            if (replacement) {\n                result.push(replacement);\n                replacement = undefined;\n            }\n            if (end > to)\n                result.push(child.slice(to - start, child.size, view));\n        }\n    }\n    return result;\n}\n\nfunction selectionFromDOM(view, origin = null) {\n    let domSel = view.domSelectionRange(), doc = view.state.doc;\n    if (!domSel.focusNode)\n        return null;\n    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n    if (head < 0)\n        return null;\n    let $head = doc.resolve(head), $anchor, selection;\n    if (selectionCollapsed(domSel)) {\n        $anchor = $head;\n        while (nearestDesc && !nearestDesc.node)\n            nearestDesc = nearestDesc.parent;\n        let nearestDescNode = nearestDesc.node;\n        if (nearestDesc && nearestDescNode.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent\n            && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n            let pos = nearestDesc.posBefore;\n            selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(head == pos ? $head : doc.resolve(pos));\n        }\n    }\n    else {\n        let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n        if (anchor < 0)\n            return null;\n        $anchor = doc.resolve(anchor);\n    }\n    if (!selection) {\n        let bias = origin == "pointer" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;\n        selection = selectionBetween(view, $anchor, $head, bias);\n    }\n    return selection;\n}\nfunction editorOwnsSelection(view) {\n    return view.editable ? view.hasFocus() :\n        hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\nfunction selectionToDOM(view, force = false) {\n    let sel = view.state.selection;\n    syncNodeSelection(view, sel);\n    if (!editorOwnsSelection(view))\n        return;\n    // The delayed drag selection causes issues with Cell Selections\n    // in Safari. And the drag selection delay is to workarond issues\n    // which only present in Chrome.\n    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n        let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n        if (domSel.anchorNode && curSel.anchorNode &&\n            isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n            view.input.mouseDown.delayedSelectionSync = true;\n            view.domObserver.setCurSelection();\n            return;\n        }\n    }\n    view.domObserver.disconnectSelection();\n    if (view.cursorWrapper) {\n        selectCursorWrapper(view);\n    }\n    else {\n        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) {\n            if (!sel.$from.parent.inlineContent)\n                resetEditableFrom = temporarilyEditableNear(view, sel.from);\n            if (!sel.empty && !sel.$from.parent.inlineContent)\n                resetEditableTo = temporarilyEditableNear(view, sel.to);\n        }\n        view.docView.setSelection(anchor, head, view.root, force);\n        if (brokenSelectBetweenUneditable) {\n            if (resetEditableFrom)\n                resetEditable(resetEditableFrom);\n            if (resetEditableTo)\n                resetEditable(resetEditableTo);\n        }\n        if (sel.visible) {\n            view.dom.classList.remove("ProseMirror-hideselection");\n        }\n        else {\n            view.dom.classList.add("ProseMirror-hideselection");\n            if ("onselectionchange" in document)\n                removeClassOnSelectionChange(view);\n        }\n    }\n    view.domObserver.setCurSelection();\n    view.domObserver.connectSelection();\n}\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\nconst brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\nfunction temporarilyEditableNear(view, pos) {\n    let { node, offset } = view.docView.domFromPos(pos, 0);\n    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n    let before = offset ? node.childNodes[offset - 1] : null;\n    if (safari && after && after.contentEditable == "false")\n        return setEditable(after);\n    if ((!after || after.contentEditable == "false") &&\n        (!before || before.contentEditable == "false")) {\n        if (after)\n            return setEditable(after);\n        else if (before)\n            return setEditable(before);\n    }\n}\nfunction setEditable(element) {\n    element.contentEditable = "true";\n    if (safari && element.draggable) {\n        element.draggable = false;\n        element.wasDraggable = true;\n    }\n    return element;\n}\nfunction resetEditable(element) {\n    element.contentEditable = "false";\n    if (element.wasDraggable) {\n        element.draggable = true;\n        element.wasDraggable = null;\n    }\n}\nfunction removeClassOnSelectionChange(view) {\n    let doc = view.dom.ownerDocument;\n    doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);\n    let domSel = view.domSelectionRange();\n    let node = domSel.anchorNode, offset = domSel.anchorOffset;\n    doc.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {\n        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n            doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);\n            setTimeout(() => {\n                if (!editorOwnsSelection(view) || view.state.selection.visible)\n                    view.dom.classList.remove("ProseMirror-hideselection");\n            }, 20);\n        }\n    });\n}\nfunction selectCursorWrapper(view) {\n    let domSel = view.domSelection(), range = document.createRange();\n    let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";\n    if (img)\n        range.setEnd(node.parentNode, domIndex(node) + 1);\n    else\n        range.setEnd(node, 0);\n    range.collapse(false);\n    domSel.removeAllRanges();\n    domSel.addRange(range);\n    // Kludge to kill \'control selection\' in IE11 when selecting an\n    // invisible cursor wrapper, since that would result in those weird\n    // resize handles and a selection that considers the absolutely\n    // positioned wrapper, rather than the root editable node, the\n    // focused element.\n    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n        node.disabled = true;\n        node.disabled = false;\n    }\n}\nfunction syncNodeSelection(view, sel) {\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        let desc = view.docView.descAt(sel.from);\n        if (desc != view.lastSelectedViewDesc) {\n            clearNodeSelection(view);\n            if (desc)\n                desc.selectNode();\n            view.lastSelectedViewDesc = desc;\n        }\n    }\n    else {\n        clearNodeSelection(view);\n    }\n}\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n    if (view.lastSelectedViewDesc) {\n        if (view.lastSelectedViewDesc.parent)\n            view.lastSelectedViewDesc.deselectNode();\n        view.lastSelectedViewDesc = undefined;\n    }\n}\nfunction selectionBetween(view, $anchor, $head, bias) {\n    return view.someProp("createSelectionBetween", f => f(view, $anchor, $head))\n        || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.between($anchor, $head, bias);\n}\nfunction hasFocusAndSelection(view) {\n    if (view.editable && !view.hasFocus())\n        return false;\n    return hasSelection(view);\n}\nfunction hasSelection(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.anchorNode)\n        return false;\n    try {\n        // Firefox will raise \'permission denied\' errors when accessing\n        // properties of `sel.anchorNode` when it\'s in a generated CSS\n        // element.\n        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&\n            (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction anchorInRightPlace(view) {\n    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n    let domSel = view.domSelectionRange();\n    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\n\nfunction moveSelectionBlock(state, dir) {\n    let { $anchor, $head } = state.selection;\n    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n    return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($start, dir);\n}\nfunction apply(view, sel) {\n    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n    return true;\n}\nfunction selectHorizontally(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (!sel.empty || mods.indexOf("s") > -1) {\n            return false;\n        }\n        else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {\n            let next = moveSelectionBlock(view.state, dir);\n            if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection))\n                return apply(view, next);\n            return false;\n        }\n        else if (!(mac && mods.indexOf("m") > -1)) {\n            let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n            if (!node || node.isText)\n                return false;\n            let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n            if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))\n                return false;\n            if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n            }\n            else if (webkit) {\n                // Chrome and Safari will introduce extra pointless cursor\n                // positions around inline uneditable nodes, so we have to\n                // take over and move the cursor past them (#937)\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n            }\n            else {\n                return false;\n            }\n        }\n    }\n    else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && sel.node.isInline) {\n        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(dir > 0 ? sel.$to : sel.$from));\n    }\n    else {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next)\n            return apply(view, next);\n        return false;\n    }\n}\nfunction nodeLen(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isIgnorable(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");\n}\nfunction skipIgnoredNodes(view, dir) {\n    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n}\n// Make sure the cursor isn\'t directly after one or more ignored\n// nodes, which will confuse the browser\'s cursor motion logic.\nfunction skipIgnoredNodesBefore(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n        return;\n    let moveNode, moveOffset, force = false;\n    // Gecko will do odd things when the selection is directly in front\n    // of a non-editable node, so in that case, move it into the next\n    // node if possible. Issue prosemirror/prosemirror#832.\n    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset]))\n        force = true;\n    for (;;) {\n        if (offset > 0) {\n            if (node.nodeType != 1) {\n                break;\n            }\n            else {\n                let before = node.childNodes[offset - 1];\n                if (isIgnorable(before)) {\n                    moveNode = node;\n                    moveOffset = --offset;\n                }\n                else if (before.nodeType == 3) {\n                    node = before;\n                    offset = node.nodeValue.length;\n                }\n                else\n                    break;\n            }\n        }\n        else if (isBlockNode(node)) {\n            break;\n        }\n        else {\n            let prev = node.previousSibling;\n            while (prev && isIgnorable(prev)) {\n                moveNode = node.parentNode;\n                moveOffset = domIndex(prev);\n                prev = prev.previousSibling;\n            }\n            if (!prev) {\n                node = node.parentNode;\n                if (node == view.dom)\n                    break;\n                offset = 0;\n            }\n            else {\n                node = prev;\n                offset = nodeLen(node);\n            }\n        }\n    }\n    if (force)\n        setSelFocus(view, node, offset);\n    else if (moveNode)\n        setSelFocus(view, moveNode, moveOffset);\n}\n// Make sure the cursor isn\'t directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesAfter(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n        return;\n    let len = nodeLen(node);\n    let moveNode, moveOffset;\n    for (;;) {\n        if (offset < len) {\n            if (node.nodeType != 1)\n                break;\n            let after = node.childNodes[offset];\n            if (isIgnorable(after)) {\n                moveNode = node;\n                moveOffset = ++offset;\n            }\n            else\n                break;\n        }\n        else if (isBlockNode(node)) {\n            break;\n        }\n        else {\n            let next = node.nextSibling;\n            while (next && isIgnorable(next)) {\n                moveNode = next.parentNode;\n                moveOffset = domIndex(next) + 1;\n                next = next.nextSibling;\n            }\n            if (!next) {\n                node = node.parentNode;\n                if (node == view.dom)\n                    break;\n                offset = len = 0;\n            }\n            else {\n                node = next;\n                offset = 0;\n                len = nodeLen(node);\n            }\n        }\n    }\n    if (moveNode)\n        setSelFocus(view, moveNode, moveOffset);\n}\nfunction isBlockNode(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.node && desc.node.isBlock;\n}\nfunction setSelFocus(view, node, offset) {\n    let sel = view.domSelection();\n    if (selectionCollapsed(sel)) {\n        let range = document.createRange();\n        range.setEnd(node, offset);\n        range.setStart(node, offset);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n    else if (sel.extend) {\n        sel.extend(node, offset);\n    }\n    view.domObserver.setCurSelection();\n    let { state } = view;\n    // If no state update ends up happening, reset the selection.\n    setTimeout(() => {\n        if (view.state == state)\n            selectionToDOM(view);\n    }, 50);\n}\nfunction findDirection(view, pos) {\n    let $pos = view.state.doc.resolve(pos);\n    if (!(chrome || windows) && $pos.parent.inlineContent) {\n        let coords = view.coordsAtPos(pos);\n        if (pos > $pos.start()) {\n            let before = view.coordsAtPos(pos - 1);\n            let mid = (before.top + before.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)\n                return before.left < coords.left ? "ltr" : "rtl";\n        }\n        if (pos < $pos.end()) {\n            let after = view.coordsAtPos(pos + 1);\n            let mid = (after.top + after.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)\n                return after.left > coords.left ? "ltr" : "rtl";\n        }\n    }\n    let computed = getComputedStyle(view.dom).direction;\n    return computed == "rtl" ? "rtl" : "ltr";\n}\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty || mods.indexOf("s") > -1)\n        return false;\n    if (mac && mods.indexOf("m") > -1)\n        return false;\n    let { $from, $to } = sel;\n    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection))\n            return apply(view, next);\n    }\n    if (!$from.parent.inlineContent) {\n        let side = dir < 0 ? $from : $to;\n        let beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(side, dir);\n        return beyond ? apply(view, beyond) : false;\n    }\n    return false;\n}\nfunction stopNativeHorizontalDelete(view, dir) {\n    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection))\n        return true;\n    let { $head, $anchor, empty } = view.state.selection;\n    if (!$head.sameParent($anchor))\n        return true;\n    if (!empty)\n        return false;\n    if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))\n        return true;\n    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n    if (nextNode && !nextNode.isText) {\n        let tr = view.state.tr;\n        if (dir < 0)\n            tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n        else\n            tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction switchEditable(view, node, state) {\n    view.domObserver.stop();\n    node.contentEditable = state;\n    view.domObserver.start();\n}\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n    if (!safari || view.state.selection.$head.parentOffset > 0)\n        return false;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&\n        focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {\n        let child = focusNode.firstChild;\n        switchEditable(view, child, "true");\n        setTimeout(() => switchEditable(view, child, "false"), 20);\n    }\n    return false;\n}\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\nfunction getMods(event) {\n    let result = "";\n    if (event.ctrlKey)\n        result += "c";\n    if (event.metaKey)\n        result += "m";\n    if (event.altKey)\n        result += "a";\n    if (event.shiftKey)\n        result += "s";\n    return result;\n}\nfunction captureKeyDown(view, event) {\n    let code = event.keyCode, mods = getMods(event);\n    if (code == 8 || (mac && code == 72 && mods == "c")) { // Backspace, Ctrl-h on Mac\n        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n    }\n    else if (code == 46 || (mac && code == 68 && mods == "c")) { // Delete, Ctrl-d on Mac\n        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n    }\n    else if (code == 13 || code == 27) { // Enter, Esc\n        return true;\n    }\n    else if (code == 37 || (mac && code == 66 && mods == "c")) { // Left arrow, Ctrl-b on Mac\n        let dir = code == 37 ? (findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1) : -1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    }\n    else if (code == 39 || (mac && code == 70 && mods == "c")) { // Right arrow, Ctrl-f on Mac\n        let dir = code == 39 ? (findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1) : 1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    }\n    else if (code == 38 || (mac && code == 80 && mods == "c")) { // Up arrow, Ctrl-p on Mac\n        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n    }\n    else if (code == 40 || (mac && code == 78 && mods == "c")) { // Down arrow, Ctrl-n on Mac\n        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesAfter(view);\n    }\n    else if (mods == (mac ? "m" : "c") &&\n        (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]\n        return true;\n    }\n    return false;\n}\n\nfunction serializeForClipboard(view, slice) {\n    view.someProp("transformCopied", f => { slice = f(slice, view); });\n    let context = [], { content, openStart, openEnd } = slice;\n    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n        openStart--;\n        openEnd--;\n        let node = content.firstChild;\n        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n        content = node.content;\n    }\n    let serializer = view.someProp("clipboardSerializer") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(view.state.schema);\n    let doc = detachedDoc(), wrap = doc.createElement("div");\n    wrap.appendChild(serializer.serializeFragment(content, { document: doc }));\n    let firstChild = wrap.firstChild, needsWrap, wrappers = 0;\n    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n        for (let i = needsWrap.length - 1; i >= 0; i--) {\n            let wrapper = doc.createElement(needsWrap[i]);\n            while (wrap.firstChild)\n                wrapper.appendChild(wrap.firstChild);\n            wrap.appendChild(wrapper);\n            wrappers++;\n        }\n        firstChild = wrap.firstChild;\n    }\n    if (firstChild && firstChild.nodeType == 1)\n        firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);\n    let text = view.someProp("clipboardTextSerializer", f => f(slice, view)) ||\n        slice.content.textBetween(0, slice.content.size, "\\n\\n");\n    return { dom: wrap, text };\n}\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n    let inCode = $context.parent.type.spec.code;\n    let dom, slice;\n    if (!html && !text)\n        return null;\n    let asText = text && (plainText || inCode || !html);\n    if (asText) {\n        view.someProp("transformPastedText", f => { text = f(text, inCode || plainText, view); });\n        if (inCode)\n            return text ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, "\\n"))), 0, 0) : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;\n        let parsed = view.someProp("clipboardTextParser", f => f(text, $context, plainText, view));\n        if (parsed) {\n            slice = parsed;\n        }\n        else {\n            let marks = $context.marks();\n            let { schema } = view.state, serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema);\n            dom = document.createElement("div");\n            text.split(/(?:\\r\\n?|\\n)+/).forEach(block => {\n                let p = dom.appendChild(document.createElement("p"));\n                if (block)\n                    p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n            });\n        }\n    }\n    else {\n        view.someProp("transformPastedHTML", f => { html = f(html, view); });\n        dom = readHTML(html);\n        if (webkit)\n            restoreReplacedSpaces(dom);\n    }\n    let contextNode = dom && dom.querySelector("[data-pm-slice]");\n    let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");\n    if (sliceData && sliceData[3])\n        for (let i = +sliceData[3]; i > 0; i--) {\n            let child = dom.firstChild;\n            while (child && child.nodeType != 1)\n                child = child.nextSibling;\n            if (!child)\n                break;\n            dom = child;\n        }\n    if (!slice) {\n        let parser = view.someProp("clipboardParser") || view.someProp("domParser") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n        slice = parser.parseSlice(dom, {\n            preserveWhitespace: !!(asText || sliceData),\n            context: $context,\n            ruleFromNode(dom) {\n                if (dom.nodeName == "BR" && !dom.nextSibling &&\n                    dom.parentNode && !inlineParents.test(dom.parentNode.nodeName))\n                    return { ignore: true };\n                return null;\n            }\n        });\n    }\n    if (sliceData) {\n        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n    }\n    else { // HTML wasn\'t created by ProseMirror. Make sure top-level siblings are coherent\n        slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n        if (slice.openStart || slice.openEnd) {\n            let openStart = 0, openEnd = 0;\n            for (let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) { }\n            for (let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) { }\n            slice = closeSlice(slice, openStart, openEnd);\n        }\n    }\n    view.someProp("transformPasted", f => { slice = f(slice, view); });\n    return slice;\n}\nconst inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n// Takes a slice parsed with parseSlice, which means there hasn\'t been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don\'t\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n    if (fragment.childCount < 2)\n        return fragment;\n    for (let d = $context.depth; d >= 0; d--) {\n        let parent = $context.node(d);\n        let match = parent.contentMatchAt($context.index(d));\n        let lastWrap, result = [];\n        fragment.forEach(node => {\n            if (!result)\n                return;\n            let wrap = match.findWrapping(node.type), inLast;\n            if (!wrap)\n                return result = null;\n            if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n                result[result.length - 1] = inLast;\n            }\n            else {\n                if (result.length)\n                    result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n                let wrapped = withWrappers(node, wrap);\n                result.push(wrapped);\n                match = match.matchType(wrapped.type);\n                lastWrap = wrap;\n            }\n        });\n        if (result)\n            return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(result);\n    }\n    return fragment;\n}\nfunction withWrappers(node, wrap, from = 0) {\n    for (let i = wrap.length - 1; i >= from; i--)\n        node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node));\n    return node;\n}\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n    if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n        let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n        if (inner)\n            return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n        let match = sibling.contentMatchAt(sibling.childCount);\n        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))\n            return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(withWrappers(node, wrap, depth + 1))));\n    }\n}\nfunction closeRight(node, depth) {\n    if (depth == 0)\n        return node;\n    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n    let fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    return node.copy(fragment.append(fill));\n}\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n    if (depth < to - 1)\n        inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n    if (depth >= from)\n        inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)\n            : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\nfunction closeSlice(slice, openStart, openEnd) {\n    if (openStart < slice.openStart)\n        slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n    if (openEnd < slice.openEnd)\n        slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n    return slice;\n}\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// "<td>..</td>"` the table cells are ignored.\nconst wrapMap = {\n    thead: ["table"],\n    tbody: ["table"],\n    tfoot: ["table"],\n    caption: ["table"],\n    colgroup: ["table"],\n    col: ["table", "colgroup"],\n    tr: ["table", "tbody"],\n    td: ["table", "tbody", "tr"],\n    th: ["table", "tbody", "tr"]\n};\nlet _detachedDoc = null;\nfunction detachedDoc() {\n    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));\n}\nfunction readHTML(html) {\n    let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n    if (metas)\n        html = html.slice(metas[0].length);\n    let elt = detachedDoc().createElement("div");\n    let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n    if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])\n        html = wrap.map(n => "<" + n + ">").join("") + html + wrap.map(n => "</" + n + ">").reverse().join("");\n    elt.innerHTML = html;\n    if (wrap)\n        for (let i = 0; i < wrap.length; i++)\n            elt = elt.querySelector(wrap[i]) || elt;\n    return elt;\n}\n// Webkit browsers do some hard-to-predict replacement of regular\n// spaces with non-breaking spaces when putting content on the\n// clipboard. This tries to convert such non-breaking spaces (which\n// will be wrapped in a plain span on Chrome, a span with class\n// Apple-converted-space on Safari) back to regular spaces.\nfunction restoreReplacedSpaces(dom) {\n    let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");\n    for (let i = 0; i < nodes.length; i++) {\n        let node = nodes[i];\n        if (node.childNodes.length == 1 && node.textContent == "\\u00a0" && node.parentNode)\n            node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);\n    }\n}\nfunction addContext(slice, context) {\n    if (!slice.size)\n        return slice;\n    let schema = slice.content.firstChild.type.schema, array;\n    try {\n        array = JSON.parse(context);\n    }\n    catch (e) {\n        return slice;\n    }\n    let { content, openStart, openEnd } = slice;\n    for (let i = array.length - 2; i >= 0; i -= 2) {\n        let type = schema.nodes[array[i]];\n        if (!type || type.hasRequiredAttrs())\n            break;\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(array[i + 1], content));\n        openStart++;\n        openEnd++;\n    }\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n}\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {};\nconst editHandlers = {};\nconst passiveHandlers = { touchstart: true, touchmove: true };\nclass InputState {\n    constructor() {\n        this.shiftKey = false;\n        this.mouseDown = null;\n        this.lastKeyCode = null;\n        this.lastKeyCodeTime = 0;\n        this.lastClick = { time: 0, x: 0, y: 0, type: "" };\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastIOSEnter = 0;\n        this.lastIOSEnterFallbackTimeout = -1;\n        this.lastFocus = 0;\n        this.lastTouch = 0;\n        this.lastAndroidDelete = 0;\n        this.composing = false;\n        this.composingTimeout = -1;\n        this.compositionNodes = [];\n        this.compositionEndedAt = -2e8;\n        this.compositionID = 1;\n        this.domChangeCount = 0;\n        this.eventHandlers = Object.create(null);\n        this.hideSelectionGuard = null;\n    }\n}\nfunction initInput(view) {\n    for (let event in handlers) {\n        let handler = handlers[event];\n        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event) => {\n            if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n                (view.editable || !(event.type in editHandlers)))\n                handler(view, event);\n        }, passiveHandlers[event] ? { passive: true } : undefined);\n    }\n    // On Safari, for reasons beyond my understanding, adding an input\n    // event handler makes an issue where the composition vanishes when\n    // you press enter go away.\n    if (safari)\n        view.dom.addEventListener("input", () => null);\n    ensureListeners(view);\n}\nfunction setSelectionOrigin(view, origin) {\n    view.input.lastSelectionOrigin = origin;\n    view.input.lastSelectionTime = Date.now();\n}\nfunction destroyInput(view) {\n    view.domObserver.stop();\n    for (let type in view.input.eventHandlers)\n        view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n    clearTimeout(view.input.composingTimeout);\n    clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\nfunction ensureListeners(view) {\n    view.someProp("handleDOMEvents", currentHandlers => {\n        for (let type in currentHandlers)\n            if (!view.input.eventHandlers[type])\n                view.dom.addEventListener(type, view.input.eventHandlers[type] = event => runCustomHandler(view, event));\n    });\n}\nfunction runCustomHandler(view, event) {\n    return view.someProp("handleDOMEvents", handlers => {\n        let handler = handlers[event.type];\n        return handler ? handler(view, event) || event.defaultPrevented : false;\n    });\n}\nfunction eventBelongsToView(view, event) {\n    if (!event.bubbles)\n        return true;\n    if (event.defaultPrevented)\n        return false;\n    for (let node = event.target; node != view.dom; node = node.parentNode)\n        if (!node || node.nodeType == 11 ||\n            (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n            return false;\n    return true;\n}\nfunction dispatchEvent(view, event) {\n    if (!runCustomHandler(view, event) && handlers[event.type] &&\n        (view.editable || !(event.type in editHandlers)))\n        handlers[event.type](view, event);\n}\neditHandlers.keydown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n    if (inOrNearComposition(view, event))\n        return;\n    view.input.lastKeyCode = event.keyCode;\n    view.input.lastKeyCodeTime = Date.now();\n    // Suppress enter key events on Chrome Android, because those tend\n    // to be part of a confused sequence of composition events fired,\n    // and handling them eagerly tends to corrupt the input.\n    if (android && chrome && event.keyCode == 13)\n        return;\n    if (event.keyCode != 229)\n        view.domObserver.forceFlush();\n    // On iOS, if we preventDefault enter key presses, the virtual\n    // keyboard gets confused. So the hack here is to set a flag that\n    // makes the DOM change code recognize that what just happens should\n    // be replaced by whatever the Enter key handlers do.\n    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n        let now = Date.now();\n        view.input.lastIOSEnter = now;\n        view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {\n            if (view.input.lastIOSEnter == now) {\n                view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter")));\n                view.input.lastIOSEnter = 0;\n            }\n        }, 200);\n    }\n    else if (view.someProp("handleKeyDown", f => f(view, event)) || captureKeyDown(view, event)) {\n        event.preventDefault();\n    }\n    else {\n        setSelectionOrigin(view, "key");\n    }\n};\neditHandlers.keyup = (view, event) => {\n    if (event.keyCode == 16)\n        view.input.shiftKey = false;\n};\neditHandlers.keypress = (view, _event) => {\n    let event = _event;\n    if (inOrNearComposition(view, event) || !event.charCode ||\n        event.ctrlKey && !event.altKey || mac && event.metaKey)\n        return;\n    if (view.someProp("handleKeyPress", f => f(view, event))) {\n        event.preventDefault();\n        return;\n    }\n    let sel = view.state.selection;\n    if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n        let text = String.fromCharCode(event.charCode);\n        if (!/[\\r\\n]/.test(text) && !view.someProp("handleTextInput", f => f(view, sel.$from.pos, sel.$to.pos, text)))\n            view.dispatch(view.state.tr.insertText(text).scrollIntoView());\n        event.preventDefault();\n    }\n};\nfunction eventCoords(event) { return { left: event.clientX, top: event.clientY }; }\nfunction isNear(event, click) {\n    let dx = click.x - event.clientX, dy = click.y - event.clientY;\n    return dx * dx + dy * dy < 100;\n}\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n    if (inside == -1)\n        return false;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        if (view.someProp(propName, f => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n            : f(view, pos, $pos.node(i), $pos.before(i), event, false)))\n            return true;\n    }\n    return false;\n}\nfunction updateSelection(view, selection, origin) {\n    if (!view.focused)\n        view.focus();\n    let tr = view.state.tr.setSelection(selection);\n    if (origin == "pointer")\n        tr.setMeta("pointer", true);\n    view.dispatch(tr);\n}\nfunction selectClickedLeaf(view, inside) {\n    if (inside == -1)\n        return false;\n    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n    if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n        updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos), "pointer");\n        return true;\n    }\n    return false;\n}\nfunction selectClickedNode(view, inside) {\n    if (inside == -1)\n        return false;\n    let sel = view.state.selection, selectedNode, selectAt;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection)\n        selectedNode = sel.node;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n            if (selectedNode && sel.$from.depth > 0 &&\n                i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n                selectAt = $pos.before(sel.$from.depth);\n            else\n                selectAt = $pos.before(i);\n            break;\n        }\n    }\n    if (selectAt != null) {\n        updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, selectAt), "pointer");\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n    return runHandlerOnContext(view, "handleClickOn", pos, inside, event) ||\n        view.someProp("handleClick", f => f(view, pos, event)) ||\n        (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\nfunction handleDoubleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) ||\n        view.someProp("handleDoubleClick", f => f(view, pos, event));\n}\nfunction handleTripleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) ||\n        view.someProp("handleTripleClick", f => f(view, pos, event)) ||\n        defaultTripleClick(view, inside, event);\n}\nfunction defaultTripleClick(view, inside, event) {\n    if (event.button != 0)\n        return false;\n    let doc = view.state.doc;\n    if (inside == -1) {\n        if (doc.inlineContent) {\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, 0, doc.content.size), "pointer");\n            return true;\n        }\n        return false;\n    }\n    let $pos = doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        let nodePos = $pos.before(i);\n        if (node.inlineContent)\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer");\n        else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc, nodePos), "pointer");\n        else\n            continue;\n        return true;\n    }\n}\nfunction forceDOMFlush(view) {\n    return endComposition(view);\n}\nconst selectNodeModifier = mac ? "metaKey" : "ctrlKey";\nhandlers.mousedown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.shiftKey;\n    let flushed = forceDOMFlush(view);\n    let now = Date.now(), type = "singleClick";\n    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {\n        if (view.input.lastClick.type == "singleClick")\n            type = "doubleClick";\n        else if (view.input.lastClick.type == "doubleClick")\n            type = "tripleClick";\n    }\n    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };\n    let pos = view.posAtCoords(eventCoords(event));\n    if (!pos)\n        return;\n    if (type == "singleClick") {\n        if (view.input.mouseDown)\n            view.input.mouseDown.done();\n        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n    }\n    else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n        event.preventDefault();\n    }\n    else {\n        setSelectionOrigin(view, "pointer");\n    }\n};\nclass MouseDown {\n    constructor(view, pos, event, flushed) {\n        this.view = view;\n        this.pos = pos;\n        this.event = event;\n        this.flushed = flushed;\n        this.delayedSelectionSync = false;\n        this.mightDrag = null;\n        this.startDoc = view.state.doc;\n        this.selectNode = !!event[selectNodeModifier];\n        this.allowDefault = event.shiftKey;\n        let targetNode, targetPos;\n        if (pos.inside > -1) {\n            targetNode = view.state.doc.nodeAt(pos.inside);\n            targetPos = pos.inside;\n        }\n        else {\n            let $pos = view.state.doc.resolve(pos.pos);\n            targetNode = $pos.parent;\n            targetPos = $pos.depth ? $pos.before() : 0;\n        }\n        const target = flushed ? null : event.target;\n        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n        this.target = targetDesc ? targetDesc.dom : null;\n        let { selection } = view.state;\n        if (event.button == 0 &&\n            targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||\n            selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.from <= targetPos && selection.to > targetPos)\n            this.mightDrag = {\n                node: targetNode,\n                pos: targetPos,\n                addAttr: !!(this.target && !this.target.draggable),\n                setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))\n            };\n        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr)\n                this.target.draggable = true;\n            if (this.mightDrag.setUneditable)\n                setTimeout(() => {\n                    if (this.view.input.mouseDown == this)\n                        this.target.setAttribute("contentEditable", "false");\n                }, 20);\n            this.view.domObserver.start();\n        }\n        view.root.addEventListener("mouseup", this.up = this.up.bind(this));\n        view.root.addEventListener("mousemove", this.move = this.move.bind(this));\n        setSelectionOrigin(view, "pointer");\n    }\n    done() {\n        this.view.root.removeEventListener("mouseup", this.up);\n        this.view.root.removeEventListener("mousemove", this.move);\n        if (this.mightDrag && this.target) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr)\n                this.target.removeAttribute("draggable");\n            if (this.mightDrag.setUneditable)\n                this.target.removeAttribute("contentEditable");\n            this.view.domObserver.start();\n        }\n        if (this.delayedSelectionSync)\n            setTimeout(() => selectionToDOM(this.view));\n        this.view.input.mouseDown = null;\n    }\n    up(event) {\n        this.done();\n        if (!this.view.dom.contains(event.target))\n            return;\n        let pos = this.pos;\n        if (this.view.state.doc != this.startDoc)\n            pos = this.view.posAtCoords(eventCoords(event));\n        this.updateAllowDefault(event);\n        if (this.allowDefault || !pos) {\n            setSelectionOrigin(this.view, "pointer");\n        }\n        else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n            event.preventDefault();\n        }\n        else if (event.button == 0 &&\n            (this.flushed ||\n                // Safari ignores clicks on draggable elements\n                (safari && this.mightDrag && !this.mightDrag.node.isAtom) ||\n                // Chrome will sometimes treat a node selection as a\n                // cursor, but still report that the node is selected\n                // when asked through getSelection. You\'ll then get a\n                // situation where clicking at the point where that\n                // (hidden) cursor is doesn\'t change the selection, and\n                // thus doesn\'t get a reaction from ProseMirror. This\n                // works around that.\n                (chrome && !this.view.state.selection.visible &&\n                    Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2))) {\n            updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");\n            event.preventDefault();\n        }\n        else {\n            setSelectionOrigin(this.view, "pointer");\n        }\n    }\n    move(event) {\n        this.updateAllowDefault(event);\n        setSelectionOrigin(this.view, "pointer");\n        if (event.buttons == 0)\n            this.done();\n    }\n    updateAllowDefault(event) {\n        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||\n            Math.abs(this.event.y - event.clientY) > 4))\n            this.allowDefault = true;\n    }\n}\nhandlers.touchstart = view => {\n    view.input.lastTouch = Date.now();\n    forceDOMFlush(view);\n    setSelectionOrigin(view, "pointer");\n};\nhandlers.touchmove = view => {\n    view.input.lastTouch = Date.now();\n    setSelectionOrigin(view, "pointer");\n};\nhandlers.contextmenu = view => forceDOMFlush(view);\nfunction inOrNearComposition(view, event) {\n    if (view.composing)\n        return true;\n    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n    // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n    // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n    // emitted. The keydown event triggers newline insertion, which we don\'t want.\n    // This method returns true if the keydown event should be ignored.\n    // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n    // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n    // This guards against the case where compositionend is triggered without the keyboard\n    // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n    // afterwards- we wouldn\'t want to ignore the keydown event in this case.\n    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n        view.input.compositionEndedAt = -2e8;\n        return true;\n    }\n    return false;\n}\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = android ? 5000 : -1;\neditHandlers.compositionstart = editHandlers.compositionupdate = view => {\n    if (!view.composing) {\n        view.domObserver.flush();\n        let { state } = view, $pos = state.selection.$from;\n        if (state.selection.empty &&\n            (state.storedMarks ||\n                (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(m => m.type.spec.inclusive === false)))) {\n            // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n            view.markCursor = view.state.storedMarks || $pos.marks();\n            endComposition(view, true);\n            view.markCursor = null;\n        }\n        else {\n            endComposition(view);\n            // In firefox, if the cursor is after but outside a marked node,\n            // the inserted text won\'t inherit the marks. So this moves it\n            // inside if necessary.\n            if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n                let sel = view.domSelectionRange();\n                for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {\n                    let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n                    if (!before)\n                        break;\n                    if (before.nodeType == 3) {\n                        view.domSelection().collapse(before, before.nodeValue.length);\n                        break;\n                    }\n                    else {\n                        node = before;\n                        offset = -1;\n                    }\n                }\n            }\n        }\n        view.input.composing = true;\n    }\n    scheduleComposeEnd(view, timeoutComposition);\n};\neditHandlers.compositionend = (view, event) => {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = event.timeStamp;\n        view.input.compositionID++;\n        scheduleComposeEnd(view, 20);\n    }\n};\nfunction scheduleComposeEnd(view, delay) {\n    clearTimeout(view.input.composingTimeout);\n    if (delay > -1)\n        view.input.composingTimeout = setTimeout(() => endComposition(view), delay);\n}\nfunction clearComposition(view) {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = timestampFromCustomEvent();\n    }\n    while (view.input.compositionNodes.length > 0)\n        view.input.compositionNodes.pop().markParentsDirty();\n}\nfunction timestampFromCustomEvent() {\n    let event = document.createEvent("Event");\n    event.initEvent("event", true, true);\n    return event.timeStamp;\n}\n/**\n@internal\n*/\nfunction endComposition(view, forceUpdate = false) {\n    if (android && view.domObserver.flushingSoon >= 0)\n        return;\n    view.domObserver.forceFlush();\n    clearComposition(view);\n    if (forceUpdate || view.docView && view.docView.dirty) {\n        let sel = selectionFromDOM(view);\n        if (sel && !sel.eq(view.state.selection))\n            view.dispatch(view.state.tr.setSelection(sel));\n        else\n            view.updateState(view.state);\n        return true;\n    }\n    return false;\n}\nfunction captureCopy(view, dom) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    if (!view.dom.parentNode)\n        return;\n    let wrap = view.dom.parentNode.appendChild(document.createElement("div"));\n    wrap.appendChild(dom);\n    wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";\n    let sel = getSelection(), range = document.createRange();\n    range.selectNodeContents(dom);\n    // Done because IE will fire a selectionchange moving the selection\n    // to its start when removeAllRanges is called and the editor still\n    // has focus (which will mess up the editor\'s selection state).\n    view.dom.blur();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    setTimeout(() => {\n        if (wrap.parentNode)\n            wrap.parentNode.removeChild(wrap);\n        view.focus();\n    }, 50);\n}\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don\'t work, and they are hard to test.\nconst brokenClipboardAPI = (ie && ie_version < 15) ||\n    (ios && webkit_version < 604);\nhandlers.copy = editHandlers.cut = (view, _event) => {\n    let event = _event;\n    let sel = view.state.selection, cut = event.type == "cut";\n    if (sel.empty)\n        return;\n    // IE and Edge\'s clipboard interface is completely broken\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData("text/html", dom.innerHTML);\n        data.setData("text/plain", text);\n    }\n    else {\n        captureCopy(view, dom);\n    }\n    if (cut)\n        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));\n};\nfunction sliceSingleNode(slice) {\n    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\nfunction capturePaste(view, event) {\n    if (!view.dom.parentNode)\n        return;\n    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));\n    if (!plainText)\n        target.contentEditable = "true";\n    target.style.cssText = "position: fixed; left: -10000px; top: 10px";\n    target.focus();\n    setTimeout(() => {\n        view.focus();\n        if (target.parentNode)\n            target.parentNode.removeChild(target);\n        if (plainText)\n            doPaste(view, target.value, null, view.input.shiftKey, event);\n        else\n            doPaste(view, target.textContent, target.innerHTML, view.input.shiftKey, event);\n    }, 50);\n}\nfunction doPaste(view, text, html, preferPlain, event) {\n    let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);\n    if (view.someProp("handlePaste", f => f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty)))\n        return true;\n    if (!slice)\n        return false;\n    let singleNode = sliceSingleNode(slice);\n    let tr = singleNode\n        ? view.state.tr.replaceSelectionWith(singleNode, view.input.shiftKey)\n        : view.state.tr.replaceSelection(slice);\n    view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));\n    return true;\n}\neditHandlers.paste = (view, _event) => {\n    let event = _event;\n    // Handling paste from JavaScript during composition is very poorly\n    // handled by browsers, so as a dodgy but preferable kludge, we just\n    // let the browser do its native thing there, except on Android,\n    // where the editor is almost always composing.\n    if (view.composing && !android)\n        return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), view.input.shiftKey, event))\n        event.preventDefault();\n    else\n        capturePaste(view, event);\n};\nclass Dragging {\n    constructor(slice, move) {\n        this.slice = slice;\n        this.move = move;\n    }\n}\nconst dragCopyModifier = mac ? "altKey" : "ctrlKey";\nhandlers.dragstart = (view, _event) => {\n    let event = _event;\n    let mouseDown = view.input.mouseDown;\n    if (mouseDown)\n        mouseDown.done();\n    if (!event.dataTransfer)\n        return;\n    let sel = view.state.selection;\n    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection ? sel.to - 1 : sel.to)) ;\n    else if (mouseDown && mouseDown.mightDrag) {\n        view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));\n    }\n    else if (event.target && event.target.nodeType == 1) {\n        let desc = view.docView.nearestDesc(event.target, true);\n        if (desc && desc.node.type.spec.draggable && desc != view.docView)\n            view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, desc.posBefore)));\n    }\n    let slice = view.state.selection.content(), { dom, text } = serializeForClipboard(view, slice);\n    event.dataTransfer.clearData();\n    event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);\n    // See https://github.com/ProseMirror/prosemirror/issues/1156\n    event.dataTransfer.effectAllowed = "copyMove";\n    if (!brokenClipboardAPI)\n        event.dataTransfer.setData("text/plain", text);\n    view.dragging = new Dragging(slice, !event[dragCopyModifier]);\n};\nhandlers.dragend = view => {\n    let dragging = view.dragging;\n    window.setTimeout(() => {\n        if (view.dragging == dragging)\n            view.dragging = null;\n    }, 50);\n};\neditHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();\neditHandlers.drop = (view, _event) => {\n    let event = _event;\n    let dragging = view.dragging;\n    view.dragging = null;\n    if (!event.dataTransfer)\n        return;\n    let eventPos = view.posAtCoords(eventCoords(event));\n    if (!eventPos)\n        return;\n    let $mouse = view.state.doc.resolve(eventPos.pos);\n    let slice = dragging && dragging.slice;\n    if (slice) {\n        view.someProp("transformPasted", f => { slice = f(slice, view); });\n    }\n    else {\n        slice = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);\n    }\n    let move = !!(dragging && !event[dragCopyModifier]);\n    if (view.someProp("handleDrop", f => f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, move))) {\n        event.preventDefault();\n        return;\n    }\n    if (!slice)\n        return;\n    event.preventDefault();\n    let insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n    if (insertPos == null)\n        insertPos = $mouse.pos;\n    let tr = view.state.tr;\n    if (move)\n        tr.deleteSelection();\n    let pos = tr.mapping.map(insertPos);\n    let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n    let beforeInsert = tr.doc;\n    if (isNode)\n        tr.replaceRangeWith(pos, pos, slice.content.firstChild);\n    else\n        tr.replaceRange(pos, pos, slice);\n    if (tr.doc.eq(beforeInsert))\n        return;\n    let $pos = tr.doc.resolve(pos);\n    if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(slice.content.firstChild) &&\n        $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n        tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos));\n    }\n    else {\n        let end = tr.mapping.map(insertPos);\n        tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);\n        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n    }\n    view.focus();\n    view.dispatch(tr.setMeta("uiEvent", "drop"));\n};\nhandlers.focus = view => {\n    view.input.lastFocus = Date.now();\n    if (!view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.add("ProseMirror-focused");\n        view.domObserver.start();\n        view.focused = true;\n        setTimeout(() => {\n            if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))\n                selectionToDOM(view);\n        }, 20);\n    }\n};\nhandlers.blur = (view, _event) => {\n    let event = _event;\n    if (view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.remove("ProseMirror-focused");\n        view.domObserver.start();\n        if (event.relatedTarget && view.dom.contains(event.relatedTarget))\n            view.domObserver.currentSelection.clear();\n        view.focused = false;\n    }\n};\nhandlers.beforeinput = (view, _event) => {\n    let event = _event;\n    // We should probably do more with beforeinput events, but support\n    // is so spotty that I\'m still waiting to see where they are going.\n    // Very specific hack to deal with backspace sometimes failing on\n    // Chrome Android when after an uneditable node.\n    if (chrome && android && event.inputType == "deleteContentBackward") {\n        view.domObserver.flushSoon();\n        let { domChangeCount } = view.input;\n        setTimeout(() => {\n            if (view.input.domChangeCount != domChangeCount)\n                return; // Event already had some effect\n            // This bug tends to close the virtual keyboard, so we refocus\n            view.dom.blur();\n            view.focus();\n            if (view.someProp("handleKeyDown", f => f(view, keyEvent(8, "Backspace"))))\n                return;\n            let { $cursor } = view.state.selection;\n            // Crude approximation of backspace behavior when no command handled it\n            if ($cursor && $cursor.pos > 0)\n                view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n        }, 50);\n    }\n};\n// Make sure all handlers get registered\nfor (let prop in editHandlers)\n    handlers[prop] = editHandlers[prop];\n\nfunction compareObjs(a, b) {\n    if (a == b)\n        return true;\n    for (let p in a)\n        if (a[p] !== b[p])\n            return false;\n    for (let p in b)\n        if (!(p in a))\n            return false;\n    return true;\n}\nclass WidgetType {\n    constructor(toDOM, spec) {\n        this.toDOM = toDOM;\n        this.spec = spec || noSpec;\n        this.side = this.spec.side || 0;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n        return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n    valid() { return true; }\n    eq(other) {\n        return this == other ||\n            (other instanceof WidgetType &&\n                (this.spec.key && this.spec.key == other.spec.key ||\n                    this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)));\n    }\n    destroy(node) {\n        if (this.spec.destroy)\n            this.spec.destroy(node);\n    }\n}\nclass InlineType {\n    constructor(attrs, spec) {\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n        return from >= to ? null : new Decoration(from, to, this);\n    }\n    valid(_, span) { return span.from < span.to; }\n    eq(other) {\n        return this == other ||\n            (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n                compareObjs(this.spec, other.spec));\n    }\n    static is(span) { return span.type instanceof InlineType; }\n    destroy() { }\n}\nclass NodeType {\n    constructor(attrs, spec) {\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.mapResult(span.from + oldOffset, 1);\n        if (from.deleted)\n            return null;\n        let to = mapping.mapResult(span.to + oldOffset, -1);\n        if (to.deleted || to.pos <= from.pos)\n            return null;\n        return new Decoration(from.pos - offset, to.pos - offset, this);\n    }\n    valid(node, span) {\n        let { index, offset } = node.content.findIndex(span.from), child;\n        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n    eq(other) {\n        return this == other ||\n            (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n                compareObjs(this.spec, other.spec));\n    }\n    destroy() { }\n}\n/**\nDecoration objects can be provided to the view through the\n[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in\nseveral variants—see the static members of this class for details.\n*/\nclass Decoration {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start position of the decoration.\n    */\n    from, \n    /**\n    The end position. Will be the same as `from` for [widget\n    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).\n    */\n    to, \n    /**\n    @internal\n    */\n    type) {\n        this.from = from;\n        this.to = to;\n        this.type = type;\n    }\n    /**\n    @internal\n    */\n    copy(from, to) {\n        return new Decoration(from, to, this.type);\n    }\n    /**\n    @internal\n    */\n    eq(other, offset = 0) {\n        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n    /**\n    @internal\n    */\n    map(mapping, offset, oldOffset) {\n        return this.type.map(mapping, this, offset, oldOffset);\n    }\n    /**\n    Creates a widget decoration, which is a DOM node that\'s shown in\n    the document at the given position. It is recommended that you\n    delay rendering the widget by passing a function that will be\n    called when the widget is actually drawn in a view, but you can\n    also directly pass a DOM node. `getPos` can be used to find the\n    widget\'s current document position.\n    */\n    static widget(pos, toDOM, spec) {\n        return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n    /**\n    Creates an inline decoration, which adds the given attributes to\n    each inline node between `from` and `to`.\n    */\n    static inline(from, to, attrs, spec) {\n        return new Decoration(from, to, new InlineType(attrs, spec));\n    }\n    /**\n    Creates a node decoration. `from` and `to` should point precisely\n    before and after a node in the document. That node, and only that\n    node, will receive the given attributes.\n    */\n    static node(from, to, attrs, spec) {\n        return new Decoration(from, to, new NodeType(attrs, spec));\n    }\n    /**\n    The spec provided when creating this decoration. Can be useful\n    if you\'ve stored extra information in that object.\n    */\n    get spec() { return this.type.spec; }\n    /**\n    @internal\n    */\n    get inline() { return this.type instanceof InlineType; }\n}\nconst none = [], noSpec = {};\n/**\nA collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such\na way that the drawing algorithm can efficiently use and compare\nthem. This is a persistent data structure—it is not modified,\nupdates create a new value.\n*/\nclass DecorationSet {\n    /**\n    @internal\n    */\n    constructor(local, children) {\n        this.local = local.length ? local : none;\n        this.children = children.length ? children : none;\n    }\n    /**\n    Create a set of decorations, using the structure of the given\n    document.\n    */\n    static create(doc, decorations) {\n        return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;\n    }\n    /**\n    Find all decorations in this set which touch the given range\n    (including decorations that start or end directly at the\n    boundaries) and match the given predicate on their spec. When\n    `start` and `end` are omitted, all decorations in the set are\n    considered. When `predicate` isn\'t given, all decorations are\n    assumed to match.\n    */\n    find(start, end, predicate) {\n        let result = [];\n        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n        return result;\n    }\n    findInner(start, end, result, offset, predicate) {\n        for (let i = 0; i < this.local.length; i++) {\n            let span = this.local[i];\n            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n                result.push(span.copy(span.from + offset, span.to + offset));\n        }\n        for (let i = 0; i < this.children.length; i += 3) {\n            if (this.children[i] < end && this.children[i + 1] > start) {\n                let childOff = this.children[i] + 1;\n                this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n            }\n        }\n    }\n    /**\n    Map the set of decorations in response to a change in the\n    document.\n    */\n    map(mapping, doc, options) {\n        if (this == empty || mapping.maps.length == 0)\n            return this;\n        return this.mapInner(mapping, doc, 0, 0, options || noSpec);\n    }\n    /**\n    @internal\n    */\n    mapInner(mapping, node, offset, oldOffset, options) {\n        let newLocal;\n        for (let i = 0; i < this.local.length; i++) {\n            let mapped = this.local[i].map(mapping, offset, oldOffset);\n            if (mapped && mapped.type.valid(node, mapped))\n                (newLocal || (newLocal = [])).push(mapped);\n            else if (options.onRemove)\n                options.onRemove(this.local[i].spec);\n        }\n        if (this.children.length)\n            return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n        else\n            return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n    /**\n    Add the given array of decorations to the ones in the set,\n    producing a new set. Needs access to the current document to\n    create the appropriate tree structure.\n    */\n    add(doc, decorations) {\n        if (!decorations.length)\n            return this;\n        if (this == empty)\n            return DecorationSet.create(doc, decorations);\n        return this.addInner(doc, decorations, 0);\n    }\n    addInner(doc, decorations, offset) {\n        let children, childIndex = 0;\n        doc.forEach((childNode, childOffset) => {\n            let baseOffset = childOffset + offset, found;\n            if (!(found = takeSpansForNode(decorations, childNode, baseOffset)))\n                return;\n            if (!children)\n                children = this.children.slice();\n            while (childIndex < children.length && children[childIndex] < childOffset)\n                childIndex += 3;\n            if (children[childIndex] == childOffset)\n                children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);\n            else\n                children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));\n            childIndex += 3;\n        });\n        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n        for (let i = 0; i < local.length; i++)\n            if (!local[i].type.valid(doc, local[i]))\n                local.splice(i--, 1);\n        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n    /**\n    Create a new set that contains the decorations in this set, minus\n    the ones in the given array.\n    */\n    remove(decorations) {\n        if (decorations.length == 0 || this == empty)\n            return this;\n        return this.removeInner(decorations, 0);\n    }\n    removeInner(decorations, offset) {\n        let children = this.children, local = this.local;\n        for (let i = 0; i < children.length; i += 3) {\n            let found;\n            let from = children[i] + offset, to = children[i + 1] + offset;\n            for (let j = 0, span; j < decorations.length; j++)\n                if (span = decorations[j]) {\n                    if (span.from > from && span.to < to) {\n                        decorations[j] = null;\n                        (found || (found = [])).push(span);\n                    }\n                }\n            if (!found)\n                continue;\n            if (children == this.children)\n                children = this.children.slice();\n            let removed = children[i + 2].removeInner(found, from + 1);\n            if (removed != empty) {\n                children[i + 2] = removed;\n            }\n            else {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        }\n        if (local.length)\n            for (let i = 0, span; i < decorations.length; i++)\n                if (span = decorations[i]) {\n                    for (let j = 0; j < local.length; j++)\n                        if (local[j].eq(span, offset)) {\n                            if (local == this.local)\n                                local = this.local.slice();\n                            local.splice(j--, 1);\n                        }\n                }\n        if (children == this.children && local == this.local)\n            return this;\n        return local.length || children.length ? new DecorationSet(local, children) : empty;\n    }\n    /**\n    @internal\n    */\n    forChild(offset, node) {\n        if (this == empty)\n            return this;\n        if (node.isLeaf)\n            return DecorationSet.empty;\n        let child, local;\n        for (let i = 0; i < this.children.length; i += 3)\n            if (this.children[i] >= offset) {\n                if (this.children[i] == offset)\n                    child = this.children[i + 2];\n                break;\n            }\n        let start = offset + 1, end = start + node.content.size;\n        for (let i = 0; i < this.local.length; i++) {\n            let dec = this.local[i];\n            if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n                let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n                if (from < to)\n                    (local || (local = [])).push(dec.copy(from, to));\n            }\n        }\n        if (local) {\n            let localSet = new DecorationSet(local.sort(byPos), none);\n            return child ? new DecorationGroup([localSet, child]) : localSet;\n        }\n        return child || empty;\n    }\n    /**\n    @internal\n    */\n    eq(other) {\n        if (this == other)\n            return true;\n        if (!(other instanceof DecorationSet) ||\n            this.local.length != other.local.length ||\n            this.children.length != other.children.length)\n            return false;\n        for (let i = 0; i < this.local.length; i++)\n            if (!this.local[i].eq(other.local[i]))\n                return false;\n        for (let i = 0; i < this.children.length; i += 3)\n            if (this.children[i] != other.children[i] ||\n                this.children[i + 1] != other.children[i + 1] ||\n                !this.children[i + 2].eq(other.children[i + 2]))\n                return false;\n        return true;\n    }\n    /**\n    @internal\n    */\n    locals(node) {\n        return removeOverlap(this.localsInner(node));\n    }\n    /**\n    @internal\n    */\n    localsInner(node) {\n        if (this == empty)\n            return none;\n        if (node.inlineContent || !this.local.some(InlineType.is))\n            return this.local;\n        let result = [];\n        for (let i = 0; i < this.local.length; i++) {\n            if (!(this.local[i].type instanceof InlineType))\n                result.push(this.local[i]);\n        }\n        return result;\n    }\n}\n/**\nThe empty set of decorations.\n*/\nDecorationSet.empty = new DecorationSet([], []);\n/**\n@internal\n*/\nDecorationSet.removeOverlap = removeOverlap;\nconst empty = DecorationSet.empty;\n// An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n    constructor(members) {\n        this.members = members;\n    }\n    map(mapping, doc) {\n        const mappedDecos = this.members.map(member => member.map(mapping, doc, noSpec));\n        return DecorationGroup.from(mappedDecos);\n    }\n    forChild(offset, child) {\n        if (child.isLeaf)\n            return DecorationSet.empty;\n        let found = [];\n        for (let i = 0; i < this.members.length; i++) {\n            let result = this.members[i].forChild(offset, child);\n            if (result == empty)\n                continue;\n            if (result instanceof DecorationGroup)\n                found = found.concat(result.members);\n            else\n                found.push(result);\n        }\n        return DecorationGroup.from(found);\n    }\n    eq(other) {\n        if (!(other instanceof DecorationGroup) ||\n            other.members.length != this.members.length)\n            return false;\n        for (let i = 0; i < this.members.length; i++)\n            if (!this.members[i].eq(other.members[i]))\n                return false;\n        return true;\n    }\n    locals(node) {\n        let result, sorted = true;\n        for (let i = 0; i < this.members.length; i++) {\n            let locals = this.members[i].localsInner(node);\n            if (!locals.length)\n                continue;\n            if (!result) {\n                result = locals;\n            }\n            else {\n                if (sorted) {\n                    result = result.slice();\n                    sorted = false;\n                }\n                for (let j = 0; j < locals.length; j++)\n                    result.push(locals[j]);\n            }\n        }\n        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n    // Create a group for the given array of decoration sets, or return\n    // a single set when possible.\n    static from(members) {\n        switch (members.length) {\n            case 0: return empty;\n            case 1: return members[0];\n            default: return new DecorationGroup(members.every(m => m instanceof DecorationSet) ? members :\n                members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));\n        }\n    }\n}\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n    let children = oldChildren.slice();\n    // Mark the children that are directly touched by changes, and\n    // move those that are after the changes.\n    for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {\n        let moved = 0;\n        mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {\n            let dSize = (newEnd - newStart) - (oldEnd - oldStart);\n            for (let i = 0; i < children.length; i += 3) {\n                let end = children[i + 1];\n                if (end < 0 || oldStart > end + baseOffset - moved)\n                    continue;\n                let start = children[i] + baseOffset - moved;\n                if (oldEnd >= start) {\n                    children[i + 1] = oldStart <= start ? -2 : -1;\n                }\n                else if (newStart >= offset && dSize) {\n                    children[i] += dSize;\n                    children[i + 1] += dSize;\n                }\n            }\n            moved += dSize;\n        });\n        baseOffset = mapping.maps[i].map(baseOffset, -1);\n    }\n    // Find the child nodes that still correspond to a single node,\n    // recursively call mapInner on them and update their positions.\n    let mustRebuild = false;\n    for (let i = 0; i < children.length; i += 3)\n        if (children[i + 1] < 0) { // Touched nodes\n            if (children[i + 1] == -2) {\n                mustRebuild = true;\n                children[i + 1] = -1;\n                continue;\n            }\n            let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;\n            if (fromLocal < 0 || fromLocal >= node.content.size) {\n                mustRebuild = true;\n                continue;\n            }\n            // Must read oldChildren because children was tagged with -1\n            let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n            let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n            let childNode = node.maybeChild(index);\n            if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n                let mapped = children[i + 2]\n                    .mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);\n                if (mapped != empty) {\n                    children[i] = fromLocal;\n                    children[i + 1] = toLocal;\n                    children[i + 2] = mapped;\n                }\n                else {\n                    children[i + 1] = -2;\n                    mustRebuild = true;\n                }\n            }\n            else {\n                mustRebuild = true;\n            }\n        }\n    // Remaining children must be collected and rebuilt into the appropriate structure\n    if (mustRebuild) {\n        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n        let built = buildTree(decorations, node, 0, options);\n        newLocal = built.local;\n        for (let i = 0; i < children.length; i += 3)\n            if (children[i + 1] < 0) {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        for (let i = 0, j = 0; i < built.children.length; i += 3) {\n            let from = built.children[i];\n            while (j < children.length && children[j] < from)\n                j += 3;\n            children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n        }\n    }\n    return new DecorationSet(newLocal.sort(byPos), children);\n}\nfunction moveSpans(spans, offset) {\n    if (!offset || !spans.length)\n        return spans;\n    let result = [];\n    for (let i = 0; i < spans.length; i++) {\n        let span = spans[i];\n        result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n    }\n    return result;\n}\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n    // Gather all decorations from the remaining marked children\n    function gather(set, oldOffset) {\n        for (let i = 0; i < set.local.length; i++) {\n            let mapped = set.local[i].map(mapping, offset, oldOffset);\n            if (mapped)\n                decorations.push(mapped);\n            else if (options.onRemove)\n                options.onRemove(set.local[i].spec);\n        }\n        for (let i = 0; i < set.children.length; i += 3)\n            gather(set.children[i + 2], set.children[i] + oldOffset + 1);\n    }\n    for (let i = 0; i < children.length; i += 3)\n        if (children[i + 1] == -1)\n            gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n    return decorations;\n}\nfunction takeSpansForNode(spans, node, offset) {\n    if (node.isLeaf)\n        return null;\n    let end = offset + node.nodeSize, found = null;\n    for (let i = 0, span; i < spans.length; i++) {\n        if ((span = spans[i]) && span.from > offset && span.to < end) {\n            (found || (found = [])).push(span);\n            spans[i] = null;\n        }\n    }\n    return found;\n}\nfunction withoutNulls(array) {\n    let result = [];\n    for (let i = 0; i < array.length; i++)\n        if (array[i] != null)\n            result.push(array[i]);\n    return result;\n}\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtracted from the `from` and `to`\n// positions in the spans (so that we don\'t have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n    let children = [], hasNulls = false;\n    node.forEach((childNode, localStart) => {\n        let found = takeSpansForNode(spans, childNode, localStart + offset);\n        if (found) {\n            hasNulls = true;\n            let subtree = buildTree(found, childNode, offset + localStart + 1, options);\n            if (subtree != empty)\n                children.push(localStart, localStart + childNode.nodeSize, subtree);\n        }\n    });\n    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n    for (let i = 0; i < locals.length; i++)\n        if (!locals[i].type.valid(node, locals[i])) {\n            if (options.onRemove)\n                options.onRemove(locals[i].spec);\n            locals.splice(i--, 1);\n        }\n    return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n    return a.from - b.from || a.to - b.to;\n}\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n    let working = spans;\n    for (let i = 0; i < working.length - 1; i++) {\n        let span = working[i];\n        if (span.from != span.to)\n            for (let j = i + 1; j < working.length; j++) {\n                let next = working[j];\n                if (next.from == span.from) {\n                    if (next.to != span.to) {\n                        if (working == spans)\n                            working = spans.slice();\n                        // Followed by a partially overlapping larger span. Split that\n                        // span.\n                        working[j] = next.copy(next.from, span.to);\n                        insertAhead(working, j + 1, next.copy(span.to, next.to));\n                    }\n                    continue;\n                }\n                else {\n                    if (next.from < span.to) {\n                        if (working == spans)\n                            working = spans.slice();\n                        // The end of this one overlaps with a subsequent span. Split\n                        // this one.\n                        working[i] = span.copy(span.from, next.from);\n                        insertAhead(working, j, span.copy(next.from, span.to));\n                    }\n                    break;\n                }\n            }\n    }\n    return working;\n}\nfunction insertAhead(array, i, deco) {\n    while (i < array.length && byPos(deco, array[i]) > 0)\n        i++;\n    array.splice(i, 0, deco);\n}\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n    let found = [];\n    view.someProp("decorations", f => {\n        let result = f(view.state);\n        if (result && result != empty)\n            found.push(result);\n    });\n    if (view.cursorWrapper)\n        found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));\n    return DecorationGroup.from(found);\n}\n\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n    attributes: true,\n    attributeOldValue: true,\n    subtree: true\n};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = ie && ie_version <= 11;\nclass SelectionState {\n    constructor() {\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    set(sel) {\n        this.anchorNode = sel.anchorNode;\n        this.anchorOffset = sel.anchorOffset;\n        this.focusNode = sel.focusNode;\n        this.focusOffset = sel.focusOffset;\n    }\n    clear() {\n        this.anchorNode = this.focusNode = null;\n    }\n    eq(sel) {\n        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&\n            sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n}\nclass DOMObserver {\n    constructor(view, handleDOMChange) {\n        this.view = view;\n        this.handleDOMChange = handleDOMChange;\n        this.queue = [];\n        this.flushingSoon = -1;\n        this.observer = null;\n        this.currentSelection = new SelectionState;\n        this.onCharData = null;\n        this.suppressingSelectionUpdates = false;\n        this.observer = window.MutationObserver &&\n            new window.MutationObserver(mutations => {\n                for (let i = 0; i < mutations.length; i++)\n                    this.queue.push(mutations[i]);\n                // IE11 will sometimes (on backspacing out a single character\n                // text node after a BR node) call the observer callback\n                // before actually updating the DOM, which will cause\n                // ProseMirror to miss the change (see #930)\n                if (ie && ie_version <= 11 && mutations.some(m => m.type == "childList" && m.removedNodes.length ||\n                    m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))\n                    this.flushSoon();\n                else\n                    this.flush();\n            });\n        if (useCharData) {\n            this.onCharData = e => {\n                this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });\n                this.flushSoon();\n            };\n        }\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    flushSoon() {\n        if (this.flushingSoon < 0)\n            this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1; this.flush(); }, 20);\n    }\n    forceFlush() {\n        if (this.flushingSoon > -1) {\n            window.clearTimeout(this.flushingSoon);\n            this.flushingSoon = -1;\n            this.flush();\n        }\n    }\n    start() {\n        if (this.observer) {\n            this.observer.takeRecords();\n            this.observer.observe(this.view.dom, observeOptions);\n        }\n        if (this.onCharData)\n            this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);\n        this.connectSelection();\n    }\n    stop() {\n        if (this.observer) {\n            let take = this.observer.takeRecords();\n            if (take.length) {\n                for (let i = 0; i < take.length; i++)\n                    this.queue.push(take[i]);\n                window.setTimeout(() => this.flush(), 20);\n            }\n            this.observer.disconnect();\n        }\n        if (this.onCharData)\n            this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);\n        this.disconnectSelection();\n    }\n    connectSelection() {\n        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);\n    }\n    disconnectSelection() {\n        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);\n    }\n    suppressSelectionUpdates() {\n        this.suppressingSelectionUpdates = true;\n        setTimeout(() => this.suppressingSelectionUpdates = false, 50);\n    }\n    onSelectionChange() {\n        if (!hasFocusAndSelection(this.view))\n            return;\n        if (this.suppressingSelectionUpdates)\n            return selectionToDOM(this.view);\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n            let sel = this.view.domSelectionRange();\n            // Selection.isCollapsed isn\'t reliable on IE\n            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n                return this.flushSoon();\n        }\n        this.flush();\n    }\n    setCurSelection() {\n        this.currentSelection.set(this.view.domSelectionRange());\n    }\n    ignoreSelectionChange(sel) {\n        if (!sel.focusNode)\n            return true;\n        let ancestors = new Set, container;\n        for (let scan = sel.focusNode; scan; scan = parentNode(scan))\n            ancestors.add(scan);\n        for (let scan = sel.anchorNode; scan; scan = parentNode(scan))\n            if (ancestors.has(scan)) {\n                container = scan;\n                break;\n            }\n        let desc = container && this.view.docView.nearestDesc(container);\n        if (desc && desc.ignoreMutation({\n            type: "selection",\n            target: container.nodeType == 3 ? container.parentNode : container\n        })) {\n            this.setCurSelection();\n            return true;\n        }\n    }\n    flush() {\n        let { view } = this;\n        if (!view.docView || this.flushingSoon > -1)\n            return;\n        let mutations = this.observer ? this.observer.takeRecords() : [];\n        if (this.queue.length) {\n            mutations = this.queue.concat(mutations);\n            this.queue.length = 0;\n        }\n        let sel = view.domSelectionRange();\n        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n        let from = -1, to = -1, typeOver = false, added = [];\n        if (view.editable) {\n            for (let i = 0; i < mutations.length; i++) {\n                let result = this.registerMutation(mutations[i], added);\n                if (result) {\n                    from = from < 0 ? result.from : Math.min(result.from, from);\n                    to = to < 0 ? result.to : Math.max(result.to, to);\n                    if (result.typeOver)\n                        typeOver = true;\n                }\n            }\n        }\n        if (gecko && added.length > 1) {\n            let brs = added.filter(n => n.nodeName == "BR");\n            if (brs.length == 2) {\n                let a = brs[0], b = brs[1];\n                if (a.parentNode && a.parentNode.parentNode == b.parentNode)\n                    b.remove();\n                else\n                    a.remove();\n            }\n        }\n        let readSel = null;\n        // If it looks like the browser has reset the selection to the\n        // start of the document after focus, restore the selection from\n        // the state\n        if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 &&\n            Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 &&\n            selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) &&\n            readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(view.state.doc.resolve(0), 1))) {\n            view.input.lastFocus = 0;\n            selectionToDOM(view);\n            this.currentSelection.set(sel);\n            view.scrollToSelection();\n        }\n        else if (from > -1 || newSel) {\n            if (from > -1) {\n                view.docView.markDirty(from, to);\n                checkCSS(view);\n            }\n            this.handleDOMChange(from, to, typeOver, added);\n            if (view.docView && view.docView.dirty)\n                view.updateState(view.state);\n            else if (!this.currentSelection.eq(sel))\n                selectionToDOM(view);\n            this.currentSelection.set(sel);\n        }\n    }\n    registerMutation(mut, added) {\n        // Ignore mutations inside nodes that were already noted as inserted\n        if (added.indexOf(mut.target) > -1)\n            return null;\n        let desc = this.view.docView.nearestDesc(mut.target);\n        if (mut.type == "attributes" &&\n            (desc == this.view.docView || mut.attributeName == "contenteditable" ||\n                // Firefox sometimes fires spurious events for null/empty styles\n                (mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))))\n            return null;\n        if (!desc || desc.ignoreMutation(mut))\n            return null;\n        if (mut.type == "childList") {\n            for (let i = 0; i < mut.addedNodes.length; i++)\n                added.push(mut.addedNodes[i]);\n            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n                return { from: desc.posBefore, to: desc.posAfter };\n            let prev = mut.previousSibling, next = mut.nextSibling;\n            if (ie && ie_version <= 11 && mut.addedNodes.length) {\n                // IE11 gives us incorrect next/prev siblings for some\n                // insertions, so if there are added nodes, recompute those\n                for (let i = 0; i < mut.addedNodes.length; i++) {\n                    let { previousSibling, nextSibling } = mut.addedNodes[i];\n                    if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)\n                        prev = previousSibling;\n                    if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)\n                        next = nextSibling;\n                }\n            }\n            let fromOffset = prev && prev.parentNode == mut.target\n                ? domIndex(prev) + 1 : 0;\n            let from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n            let toOffset = next && next.parentNode == mut.target\n                ? domIndex(next) : mut.target.childNodes.length;\n            let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n            return { from, to };\n        }\n        else if (mut.type == "attributes") {\n            return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };\n        }\n        else { // "characterData"\n            return {\n                from: desc.posAtStart,\n                to: desc.posAtEnd,\n                // An event was generated for a text change that didn\'t change\n                // any text. Mark the dom change to fall back to assuming the\n                // selection was typed over with an identical value if it can\'t\n                // find another change.\n                typeOver: mut.target.nodeValue == mut.oldValue\n            };\n        }\n    }\n}\nlet cssChecked = new WeakMap();\nlet cssCheckWarned = false;\nfunction checkCSS(view) {\n    if (cssChecked.has(view))\n        return;\n    cssChecked.set(view, null);\n    if ([\'normal\', \'nowrap\', \'pre-line\'].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n        view.requiresGeckoHackNode = gecko;\n        if (cssCheckWarned)\n            return;\n        console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to \'pre-wrap\'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");\n        cssCheckWarned = true;\n    }\n}\n// Used to work around a Safari Selection/shadow DOM bug\n// Based on https://github.com/codemirror/dev/issues/414 fix\nfunction safariShadowSelectionRange(view) {\n    let found;\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    // Because Safari (at least in 2018-2022) doesn\'t provide regular\n    // access to the selection inside a shadowRoot, we have to perform a\n    // ridiculous hack to get at it—using `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    view.dom.addEventListener("beforeinput", read, true);\n    document.execCommand("indent");\n    view.dom.removeEventListener("beforeinput", read, true);\n    let anchorNode = found.startContainer, anchorOffset = found.startOffset;\n    let focusNode = found.endContainer, focusOffset = found.endOffset;\n    let currentAnchor = view.domAtPos(view.state.selection.anchor);\n    // Since such a range doesn\'t distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))\n        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n    return { anchorNode, anchorOffset, focusNode, focusOffset };\n}\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that\'s the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\nfunction parseBetween(view, from_, to_) {\n    let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);\n    let domSel = view.domSelectionRange();\n    let find;\n    let anchor = domSel.anchorNode;\n    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n        find = [{ node: anchor, offset: domSel.anchorOffset }];\n        if (!selectionCollapsed(domSel))\n            find.push({ node: domSel.focusNode, offset: domSel.focusOffset });\n    }\n    // Work around issue in Chrome where backspacing sometimes replaces\n    // the deleted content with a random BR node (issues #799, #831)\n    if (chrome && view.input.lastKeyCode === 8) {\n        for (let off = toOffset; off > fromOffset; off--) {\n            let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n            if (node.nodeName == "BR" && !desc) {\n                toOffset = off;\n                break;\n            }\n            if (!desc || desc.size)\n                break;\n        }\n    }\n    let startDoc = view.state.doc;\n    let parser = view.someProp("domParser") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n    let $from = startDoc.resolve(from);\n    let sel = null, doc = parser.parse(parent, {\n        topNode: $from.parent,\n        topMatch: $from.parent.contentMatchAt($from.index()),\n        topOpen: true,\n        from: fromOffset,\n        to: toOffset,\n        preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,\n        findPositions: find,\n        ruleFromNode,\n        context: $from\n    });\n    if (find && find[0].pos != null) {\n        let anchor = find[0].pos, head = find[1] && find[1].pos;\n        if (head == null)\n            head = anchor;\n        sel = { anchor: anchor + from, head: head + from };\n    }\n    return { doc, sel, from, to };\n}\nfunction ruleFromNode(dom) {\n    let desc = dom.pmViewDesc;\n    if (desc) {\n        return desc.parseRule();\n    }\n    else if (dom.nodeName == "BR" && dom.parentNode) {\n        // Safari replaces the list item or table cell with a BR\n        // directly in the list node (?!) if you delete the last\n        // character in a list item or table cell (#708, #862)\n        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n            let skip = document.createElement("div");\n            skip.appendChild(document.createElement("li"));\n            return { skip };\n        }\n        else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n            return { ignore: true };\n        }\n    }\n    else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {\n        return { ignore: true };\n    }\n    return null;\n}\nconst isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n    if (from < 0) {\n        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n        let newSel = selectionFromDOM(view, origin);\n        if (newSel && !view.state.selection.eq(newSel)) {\n            if (chrome && android &&\n                view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime &&\n                view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter"))))\n                return;\n            let tr = view.state.tr.setSelection(newSel);\n            if (origin == "pointer")\n                tr.setMeta("pointer", true);\n            else if (origin == "key")\n                tr.scrollIntoView();\n            if (view.composing)\n                tr.setMeta("composition", view.input.compositionID);\n            view.dispatch(tr);\n        }\n        return;\n    }\n    let $before = view.state.doc.resolve(from);\n    let shared = $before.sharedDepth(to);\n    from = $before.before(shared + 1);\n    to = view.state.doc.resolve(to).after(shared + 1);\n    let sel = view.state.selection;\n    let parse = parseBetween(view, from, to);\n    let doc = view.state.doc, compare = doc.slice(parse.from, parse.to);\n    let preferredPos, preferredSide;\n    // Prefer anchoring to end when Backspace is pressed\n    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n        preferredPos = view.state.selection.to;\n        preferredSide = "end";\n    }\n    else {\n        preferredPos = view.state.selection.from;\n        preferredSide = "start";\n    }\n    view.input.lastKeyCode = null;\n    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) &&\n        addedNodes.some(n => n.nodeType == 1 && !isInline.test(n.nodeName)) &&\n        (!change || change.endA >= change.endB) &&\n        view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    if (!change) {\n        if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&\n            !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n            change = { start: sel.from, endA: sel.to, endB: sel.to };\n        }\n        else {\n            if (parse.sel) {\n                let sel = resolveSelection(view, view.state.doc, parse.sel);\n                if (sel && !sel.eq(view.state.selection)) {\n                    let tr = view.state.tr.setSelection(sel);\n                    if (view.composing)\n                        tr.setMeta("composition", view.input.compositionID);\n                    view.dispatch(tr);\n                }\n            }\n            return;\n        }\n    }\n    // Chrome sometimes leaves the cursor before the inserted text when\n    // composing after a cursor wrapper. This moves it forward.\n    if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from &&\n        parse.sel.head == parse.sel.anchor) {\n        let size = change.endB - change.start;\n        parse.sel = { anchor: parse.sel.anchor + size, head: parse.sel.anchor + size };\n    }\n    view.input.domChangeCount++;\n    // Handle the case where overwriting a selection by typing matches\n    // the start or end of the selected content, creating a change\n    // that\'s smaller than what was actually overwritten.\n    if (view.state.selection.from < view.state.selection.to &&\n        change.start == change.endB &&\n        view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 &&\n            view.state.selection.from >= parse.from) {\n            change.start = view.state.selection.from;\n        }\n        else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 &&\n            view.state.selection.to <= parse.to) {\n            change.endB += (view.state.selection.to - change.endA);\n            change.endA = view.state.selection.to;\n        }\n    }\n    // IE11 will insert a non-breaking space _ahead_ of the space after\n    // the cursor space when adding a space before another space. When\n    // that happened, adjust the change to cover the space instead.\n    if (ie && ie_version <= 11 && change.endB == change.start + 1 &&\n        change.endA == change.start && change.start > parse.from &&\n        parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \\u00a0") {\n        change.start--;\n        change.endA--;\n        change.endB--;\n    }\n    let $from = parse.doc.resolveNoCache(change.start - parse.from);\n    let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    let $fromA = doc.resolve(change.start);\n    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n    let nextSel;\n    // If this looks like the effect of pressing Enter (or was recorded\n    // as being an iOS enter press), just dispatch an Enter key instead.\n    if (((ios && view.input.lastIOSEnter > Date.now() - 225 &&\n        (!inlineChange || addedNodes.some(n => n.nodeName == "DIV" || n.nodeName == "P"))) ||\n        (!inlineChange && $from.pos < parse.doc.content.size &&\n            (nextSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&\n            nextSel.head == $to.pos)) &&\n        view.someProp("handleKeyDown", f => f(view, keyEvent(13, "Enter")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    // Same for backspace\n    if (view.state.selection.anchor > change.start &&\n        looksLikeJoin(doc, change.start, change.endA, $from, $to) &&\n        view.someProp("handleKeyDown", f => f(view, keyEvent(8, "Backspace")))) {\n        if (android && chrome)\n            view.domObserver.suppressSelectionUpdates(); // #820\n        return;\n    }\n    // Chrome Android will occasionally, during composition, delete the\n    // entire composition and then immediately insert it again. This is\n    // used to detect that situation.\n    if (chrome && android && change.endB == change.start)\n        view.input.lastAndroidDelete = Date.now();\n    // This tries to detect Android virtual keyboard\n    // enter-and-pick-suggestion action. That sometimes (see issue\n    // #1059) first fires a DOM mutation, before moving the selection to\n    // the newly created block. And then, because ProseMirror cleans up\n    // the DOM selection, it gives up moving the selection entirely,\n    // leaving the cursor in the wrong place. When that happens, we drop\n    // the new paragraph from the initial change, and fire a simulated\n    // enter key afterwards.\n    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&\n        parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n        change.endB -= 2;\n        $to = parse.doc.resolveNoCache(change.endB - parse.from);\n        setTimeout(() => {\n            view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); });\n        }, 20);\n    }\n    let chFrom = change.start, chTo = change.endA;\n    let tr, storedMarks, markChange;\n    if (inlineChange) {\n        if ($from.pos == $to.pos) { // Deletion\n            // IE11 sometimes weirdly moves the DOM selection around after\n            // backspacing out the first element in a textblock\n            if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n                view.domObserver.suppressSelectionUpdates();\n                setTimeout(() => selectionToDOM(view), 20);\n            }\n            tr = view.state.tr.delete(chFrom, chTo);\n            storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n        }\n        else if ( // Adding or removing a mark\n        change.endA == change.endB &&\n            (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n            tr = view.state.tr;\n            if (markChange.type == "add")\n                tr.addMark(chFrom, chTo, markChange.mark);\n            else\n                tr.removeMark(chFrom, chTo, markChange.mark);\n        }\n        else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n            // Both positions in the same text node -- simply insert text\n            let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n            if (view.someProp("handleTextInput", f => f(view, chFrom, chTo, text)))\n                return;\n            tr = view.state.tr.insertText(text, chFrom, chTo);\n        }\n    }\n    if (!tr)\n        tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n    if (parse.sel) {\n        let sel = resolveSelection(view, tr.doc, parse.sel);\n        // Chrome Android will sometimes, during composition, report the\n        // selection in the wrong place. If it looks like that is\n        // happening, don\'t update the selection.\n        // Edge just doesn\'t move the cursor forward when you start typing\n        // in an empty block or between br nodes.\n        if (sel && !(chrome && android && view.composing && sel.empty &&\n            (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) &&\n            (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) ||\n            ie && sel.empty && sel.head == chFrom))\n            tr.setSelection(sel);\n    }\n    if (storedMarks)\n        tr.ensureMarks(storedMarks);\n    if (view.composing)\n        tr.setMeta("composition", view.input.compositionID);\n    view.dispatch(tr.scrollIntoView());\n}\nfunction resolveSelection(view, doc, parsedSel) {\n    if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size)\n        return null;\n    return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));\n}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n    let added = curMarks, removed = prevMarks, type, mark, update;\n    for (let i = 0; i < prevMarks.length; i++)\n        added = prevMarks[i].removeFromSet(added);\n    for (let i = 0; i < curMarks.length; i++)\n        removed = curMarks[i].removeFromSet(removed);\n    if (added.length == 1 && removed.length == 0) {\n        mark = added[0];\n        type = "add";\n        update = (node) => node.mark(mark.addToSet(node.marks));\n    }\n    else if (added.length == 0 && removed.length == 1) {\n        mark = removed[0];\n        type = "remove";\n        update = (node) => node.mark(mark.removeFromSet(node.marks));\n    }\n    else {\n        return null;\n    }\n    let updated = [];\n    for (let i = 0; i < prev.childCount; i++)\n        updated.push(update(prev.child(i)));\n    if (prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated).eq(cur))\n        return { mark, type };\n}\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n    if (!$newStart.parent.isTextblock ||\n        // The content must have shrunk\n        end - start <= $newEnd.pos - $newStart.pos ||\n        // newEnd must point directly at or after the end of the block that newStart points into\n        skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n        return false;\n    let $start = old.resolve(start);\n    // Start must be at the end of a block\n    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n        return false;\n    let $next = old.resolve(skipClosingAndOpening($start, true, true));\n    // The next textblock must start before end and end near it\n    if (!$next.parent.isTextblock || $next.pos > end ||\n        skipClosingAndOpening($next, true, false) < end)\n        return false;\n    // The fragments after the join point must match\n    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n        depth--;\n        end++;\n        fromEnd = false;\n    }\n    if (mayOpen) {\n        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n        while (next && !next.isLeaf) {\n            next = next.firstChild;\n            end++;\n        }\n    }\n    return end;\n}\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n    let start = a.findDiffStart(b, pos);\n    if (start == null)\n        return null;\n    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n    if (preferredSide == "end") {\n        let adjust = Math.max(0, start - Math.min(endA, endB));\n        preferredPos -= endA + adjust - start;\n    }\n    if (endA < start && a.size < b.size) {\n        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n        start -= move;\n        endB = start + (endB - endA);\n        endA = start;\n    }\n    else if (endB < start) {\n        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n        start -= move;\n        endA = start + (endA - endB);\n        endB = start;\n    }\n    return { start, endA, endB };\n}\n\n/**\n@internal\n*/\nconst __serializeForClipboard = serializeForClipboard;\n/**\n@internal\n*/\nconst __parseFromClipboard = parseFromClipboard;\n/**\n@internal\n*/\nconst __endComposition = endComposition;\n/**\nAn editor view manages the DOM structure that represents an\neditable document. Its state and behavior are determined by its\n[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).\n*/\nclass EditorView {\n    /**\n    Create a view. `place` may be a DOM node that the editor should\n    be appended to, a function that will place it into the document,\n    or an object whose `mount` property holds the node to use as the\n    document container. If it is `null`, the editor will not be\n    added to the document.\n    */\n    constructor(place, props) {\n        this._root = null;\n        /**\n        @internal\n        */\n        this.focused = false;\n        /**\n        Kludge used to work around a Chrome bug @internal\n        */\n        this.trackWrites = null;\n        this.mounted = false;\n        /**\n        @internal\n        */\n        this.markCursor = null;\n        /**\n        @internal\n        */\n        this.cursorWrapper = null;\n        /**\n        @internal\n        */\n        this.lastSelectedViewDesc = undefined;\n        /**\n        @internal\n        */\n        this.input = new InputState;\n        this.prevDirectPlugins = [];\n        this.pluginViews = [];\n        /**\n        Holds `true` when a hack node is needed in Firefox to prevent the\n        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)\n        @internal\n        */\n        this.requiresGeckoHackNode = false;\n        /**\n        When editor content is being dragged, this object contains\n        information about the dragged slice and whether it is being\n        copied or moved. At any other time, it is null.\n        */\n        this.dragging = null;\n        this._props = props;\n        this.state = props.state;\n        this.directPlugins = props.plugins || [];\n        this.directPlugins.forEach(checkStateComponent);\n        this.dispatch = this.dispatch.bind(this);\n        this.dom = (place && place.mount) || document.createElement("div");\n        if (place) {\n            if (place.appendChild)\n                place.appendChild(this.dom);\n            else if (typeof place == "function")\n                place(this.dom);\n            else if (place.mount)\n                this.mounted = true;\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        this.nodeViews = buildNodeViews(this);\n        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n        this.domObserver = new DOMObserver(this, (from, to, typeOver, added) => readDOMChange(this, from, to, typeOver, added));\n        this.domObserver.start();\n        initInput(this);\n        this.updatePluginViews();\n    }\n    /**\n    Holds `true` when a\n    [composition](https://w3c.github.io/uievents/#events-compositionevents)\n    is active.\n    */\n    get composing() { return this.input.composing; }\n    /**\n    The view\'s current [props](https://prosemirror.net/docs/ref/#view.EditorProps).\n    */\n    get props() {\n        if (this._props.state != this.state) {\n            let prev = this._props;\n            this._props = {};\n            for (let name in prev)\n                this._props[name] = prev[name];\n            this._props.state = this.state;\n        }\n        return this._props;\n    }\n    /**\n    Update the view\'s props. Will immediately cause an update to\n    the DOM.\n    */\n    update(props) {\n        if (props.handleDOMEvents != this._props.handleDOMEvents)\n            ensureListeners(this);\n        let prevProps = this._props;\n        this._props = props;\n        if (props.plugins) {\n            props.plugins.forEach(checkStateComponent);\n            this.directPlugins = props.plugins;\n        }\n        this.updateStateInner(props.state, prevProps);\n    }\n    /**\n    Update the view by updating existing props object with the object\n    given as argument. Equivalent to `view.update(Object.assign({},\n    view.props, props))`.\n    */\n    setProps(props) {\n        let updated = {};\n        for (let name in this._props)\n            updated[name] = this._props[name];\n        updated.state = this.state;\n        for (let name in props)\n            updated[name] = props[name];\n        this.update(updated);\n    }\n    /**\n    Update the editor\'s `state` prop, without touching any of the\n    other props.\n    */\n    updateState(state) {\n        this.updateStateInner(state, this._props);\n    }\n    updateStateInner(state, prevProps) {\n        let prev = this.state, redraw = false, updateSel = false;\n        // When stored marks are added, stop composition, so that they can\n        // be displayed.\n        if (state.storedMarks && this.composing) {\n            clearComposition(this);\n            updateSel = true;\n        }\n        this.state = state;\n        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n            let nodeViews = buildNodeViews(this);\n            if (changedNodeViews(nodeViews, this.nodeViews)) {\n                this.nodeViews = nodeViews;\n                redraw = true;\n            }\n        }\n        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n            ensureListeners(this);\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset"\n            : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";\n        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n        if (updateDoc || !state.selection.eq(prev.selection))\n            updateSel = true;\n        let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n        if (updateSel) {\n            this.domObserver.stop();\n            // Work around an issue in Chrome, IE, and Edge where changing\n            // the DOM around an active selection puts it into a broken\n            // state where the thing the user sees differs from the\n            // selection reported by the Selection object (#710, #973,\n            // #1011, #1013, #1035).\n            let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing &&\n                !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n            if (updateDoc) {\n                // If the node that the selection points into is written to,\n                // Chrome sometimes starts misreporting the selection, so this\n                // tracks that and forces a selection reset when our update\n                // did write to the node.\n                let chromeKludge = chrome ? (this.trackWrites = this.domSelectionRange().focusNode) : null;\n                if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n                    this.docView.updateOuterDeco([]);\n                    this.docView.destroy();\n                    this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n                }\n                if (chromeKludge && !this.trackWrites)\n                    forceSelUpdate = true;\n            }\n            // Work around for an issue where an update arriving right between\n            // a DOM selection change and the "selectionchange" event for it\n            // can cause a spurious DOM selection update, disrupting mouse\n            // drag selection.\n            if (forceSelUpdate ||\n                !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) &&\n                    anchorInRightPlace(this))) {\n                selectionToDOM(this, forceSelUpdate);\n            }\n            else {\n                syncNodeSelection(this, state.selection);\n                this.domObserver.setCurSelection();\n            }\n            this.domObserver.start();\n        }\n        this.updatePluginViews(prev);\n        if (scroll == "reset") {\n            this.dom.scrollTop = 0;\n        }\n        else if (scroll == "to selection") {\n            this.scrollToSelection();\n        }\n        else if (oldScrollPos) {\n            resetScrollPos(oldScrollPos);\n        }\n    }\n    /**\n    @internal\n    */\n    scrollToSelection() {\n        let startDOM = this.domSelectionRange().focusNode;\n        if (this.someProp("handleScrollToSelection", f => f(this))) ;\n        else if (this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n            let target = this.docView.domAfterPos(this.state.selection.from);\n            if (target.nodeType == 1)\n                scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n        }\n        else {\n            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n        }\n    }\n    destroyPluginViews() {\n        let view;\n        while (view = this.pluginViews.pop())\n            if (view.destroy)\n                view.destroy();\n    }\n    updatePluginViews(prevState) {\n        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n            this.prevDirectPlugins = this.directPlugins;\n            this.destroyPluginViews();\n            for (let i = 0; i < this.directPlugins.length; i++) {\n                let plugin = this.directPlugins[i];\n                if (plugin.spec.view)\n                    this.pluginViews.push(plugin.spec.view(this));\n            }\n            for (let i = 0; i < this.state.plugins.length; i++) {\n                let plugin = this.state.plugins[i];\n                if (plugin.spec.view)\n                    this.pluginViews.push(plugin.spec.view(this));\n            }\n        }\n        else {\n            for (let i = 0; i < this.pluginViews.length; i++) {\n                let pluginView = this.pluginViews[i];\n                if (pluginView.update)\n                    pluginView.update(this, prevState);\n            }\n        }\n    }\n    someProp(propName, f) {\n        let prop = this._props && this._props[propName], value;\n        if (prop != null && (value = f ? f(prop) : prop))\n            return value;\n        for (let i = 0; i < this.directPlugins.length; i++) {\n            let prop = this.directPlugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop))\n                return value;\n        }\n        let plugins = this.state.plugins;\n        if (plugins)\n            for (let i = 0; i < plugins.length; i++) {\n                let prop = plugins[i].props[propName];\n                if (prop != null && (value = f ? f(prop) : prop))\n                    return value;\n            }\n    }\n    /**\n    Query whether the view has focus.\n    */\n    hasFocus() {\n        // Work around IE not handling focus correctly if resize handles are shown.\n        // If the cursor is inside an element with resize handles, activeElement\n        // will be that element instead of this.dom.\n        if (ie) {\n            // If activeElement is within this.dom, and there are no other elements\n            // setting `contenteditable` to false in between, treat it as focused.\n            let node = this.root.activeElement;\n            if (node == this.dom)\n                return true;\n            if (!node || !this.dom.contains(node))\n                return false;\n            while (node && this.dom != node && this.dom.contains(node)) {\n                if (node.contentEditable == \'false\')\n                    return false;\n                node = node.parentElement;\n            }\n            return true;\n        }\n        return this.root.activeElement == this.dom;\n    }\n    /**\n    Focus the editor.\n    */\n    focus() {\n        this.domObserver.stop();\n        if (this.editable)\n            focusPreventScroll(this.dom);\n        selectionToDOM(this);\n        this.domObserver.start();\n    }\n    /**\n    Get the document root in which the editor exists. This will\n    usually be the top-level `document`, but might be a [shadow\n    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n    root if the editor is inside one.\n    */\n    get root() {\n        let cached = this._root;\n        if (cached == null)\n            for (let search = this.dom.parentNode; search; search = search.parentNode) {\n                if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {\n                    if (!search.getSelection)\n                        Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();\n                    return this._root = search;\n                }\n            }\n        return cached || document;\n    }\n    /**\n    Given a pair of viewport coordinates, return the document\n    position that corresponds to them. May return null if the given\n    coordinates aren\'t inside of the editor. When an object is\n    returned, its `pos` property is the position nearest to the\n    coordinates, and its `inside` property holds the position of the\n    inner node that the position falls inside of, or -1 if it is at\n    the top level, not in any node.\n    */\n    posAtCoords(coords) {\n        return posAtCoords(this, coords);\n    }\n    /**\n    Returns the viewport rectangle at a given document position.\n    `left` and `right` will be the same number, as this returns a\n    flat cursor-ish rectangle. If the position is between two things\n    that aren\'t directly adjacent, `side` determines which element\n    is used. When < 0, the element before the position is used,\n    otherwise the element after.\n    */\n    coordsAtPos(pos, side = 1) {\n        return coordsAtPos(this, pos, side);\n    }\n    /**\n    Find the DOM position that corresponds to the given document\n    position. When `side` is negative, find the position as close as\n    possible to the content before the position. When positive,\n    prefer positions close to the content after the position. When\n    zero, prefer as shallow a position as possible.\n    \n    Note that you should **not** mutate the editor\'s internal DOM,\n    only inspect it (and even that is usually not necessary).\n    */\n    domAtPos(pos, side = 0) {\n        return this.docView.domFromPos(pos, side);\n    }\n    /**\n    Find the DOM node that represents the document node after the\n    given position. May return `null` when the position doesn\'t point\n    in front of a node or if the node is inside an opaque node view.\n    \n    This is intended to be able to call things like\n    `getBoundingClientRect` on that DOM node. Do **not** mutate the\n    editor DOM directly, or add styling this way, since that will be\n    immediately overriden by the editor as it redraws the node.\n    */\n    nodeDOM(pos) {\n        let desc = this.docView.descAt(pos);\n        return desc ? desc.nodeDOM : null;\n    }\n    /**\n    Find the document position that corresponds to a given DOM\n    position. (Whenever possible, it is preferable to inspect the\n    document structure directly, rather than poking around in the\n    DOM, but sometimes—for example when interpreting an event\n    target—you don\'t have a choice.)\n    \n    The `bias` parameter can be used to influence which side of a DOM\n    node to use when the position is inside a leaf node.\n    */\n    posAtDOM(node, offset, bias = -1) {\n        let pos = this.docView.posFromDOM(node, offset, bias);\n        if (pos == null)\n            throw new RangeError("DOM position not inside the editor");\n        return pos;\n    }\n    /**\n    Find out whether the selection is at the end of a textblock when\n    moving in a given direction. When, for example, given `"left"`,\n    it will return true if moving left from the current cursor\n    position would leave that position\'s parent textblock. Will apply\n    to the view\'s current state by default, but it is possible to\n    pass a different state.\n    */\n    endOfTextblock(dir, state) {\n        return endOfTextblock(this, state || this.state, dir);\n    }\n    /**\n    Run the editor\'s paste logic with the given HTML string. The\n    `event`, if given, will be passed to the\n    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.\n    */\n    pasteHTML(html, event) {\n        return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));\n    }\n    /**\n    Run the editor\'s paste logic with the given plain-text input.\n    */\n    pasteText(text, event) {\n        return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));\n    }\n    /**\n    Removes the editor from the DOM and destroys all [node\n    views](https://prosemirror.net/docs/ref/#view.NodeView).\n    */\n    destroy() {\n        if (!this.docView)\n            return;\n        destroyInput(this);\n        this.destroyPluginViews();\n        if (this.mounted) {\n            this.docView.update(this.state.doc, [], viewDecorations(this), this);\n            this.dom.textContent = "";\n        }\n        else if (this.dom.parentNode) {\n            this.dom.parentNode.removeChild(this.dom);\n        }\n        this.docView.destroy();\n        this.docView = null;\n    }\n    /**\n    This is true when the view has been\n    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be\n    used anymore).\n    */\n    get isDestroyed() {\n        return this.docView == null;\n    }\n    /**\n    Used for testing.\n    */\n    dispatchEvent(event) {\n        return dispatchEvent(this, event);\n    }\n    /**\n    Dispatch a transaction. Will call\n    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)\n    when given, and otherwise defaults to applying the transaction to\n    the current state and calling\n    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.\n    This method is bound to the view instance, so that it can be\n    easily passed around.\n    */\n    dispatch(tr) {\n        let dispatchTransaction = this._props.dispatchTransaction;\n        if (dispatchTransaction)\n            dispatchTransaction.call(this, tr);\n        else\n            this.updateState(this.state.apply(tr));\n    }\n    /**\n    @internal\n    */\n    domSelectionRange() {\n        return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom\n            ? safariShadowSelectionRange(this) : this.domSelection();\n    }\n    /**\n    @internal\n    */\n    domSelection() {\n        return this.root.getSelection();\n    }\n}\nfunction computeDocDeco(view) {\n    let attrs = Object.create(null);\n    attrs.class = "ProseMirror";\n    attrs.contenteditable = String(view.editable);\n    attrs.translate = "no";\n    view.someProp("attributes", value => {\n        if (typeof value == "function")\n            value = value(view.state);\n        if (value)\n            for (let attr in value) {\n                if (attr == "class")\n                    attrs.class += " " + value[attr];\n                if (attr == "style") {\n                    attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];\n                }\n                else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")\n                    attrs[attr] = String(value[attr]);\n            }\n    });\n    return [Decoration.node(0, view.state.doc.content.size, attrs)];\n}\nfunction updateCursorWrapper(view) {\n    if (view.markCursor) {\n        let dom = document.createElement("img");\n        dom.className = "ProseMirror-separator";\n        dom.setAttribute("mark-placeholder", "true");\n        dom.setAttribute("alt", "");\n        view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };\n    }\n    else {\n        view.cursorWrapper = null;\n    }\n}\nfunction getEditable(view) {\n    return !view.someProp("editable", value => value(view.state) === false);\n}\nfunction selectionContextChanged(sel1, sel2) {\n    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\nfunction buildNodeViews(view) {\n    let result = Object.create(null);\n    function add(obj) {\n        for (let prop in obj)\n            if (!Object.prototype.hasOwnProperty.call(result, prop))\n                result[prop] = obj[prop];\n    }\n    view.someProp("nodeViews", add);\n    view.someProp("markViews", add);\n    return result;\n}\nfunction changedNodeViews(a, b) {\n    let nA = 0, nB = 0;\n    for (let prop in a) {\n        if (a[prop] != b[prop])\n            return true;\n        nA++;\n    }\n    for (let _ in b)\n        nB++;\n    return nA != nB;\n}\nfunction checkStateComponent(plugin) {\n    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)\n        throw new RangeError("Plugins passed directly to the view must not have a state component");\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0LWd1bHAvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itdmlldy9kaXN0L2luZGV4LmpzPzhmNzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiwgU2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgTWFyaywgU2xpY2UsIERPTVBhcnNlciB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IGRyb3BQb2ludCB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbmNvbnN0IGRvbUluZGV4ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7OyBpbmRleCsrKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn07XG5jb25zdCBwYXJlbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBsZXQgcGFyZW50ID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xuICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09IDExID8gcGFyZW50Lmhvc3QgOiBwYXJlbnQ7XG59O1xubGV0IHJldXNlZFJhbmdlID0gbnVsbDtcbi8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgc2FtZSByYW5nZSwgYmVjYXVzZSBET00gcmFuZ2Vcbi8vIG9iamVjdHMgYXJlIGV2ZXJ5IGV4cGVuc2l2ZSwgYW5kIGtlZXAgc2xvd2luZyBkb3duIHN1YnNlcXVlbnQgRE9NXG4vLyB1cGRhdGVzLCBmb3Igc29tZSByZWFzb24uXG5jb25zdCB0ZXh0UmFuZ2UgPSBmdW5jdGlvbiAobm9kZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgcmFuZ2UgPSByZXVzZWRSYW5nZSB8fCAocmV1c2VkUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgdG8gPT0gbnVsbCA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IHRvKTtcbiAgICByYW5nZS5zZXRTdGFydChub2RlLCBmcm9tIHx8IDApO1xuICAgIHJldHVybiByYW5nZTtcbn07XG4vLyBTY2FucyBmb3J3YXJkIGFuZCBiYWNrd2FyZCB0aHJvdWdoIERPTSBwb3NpdGlvbnMgZXF1aXZhbGVudCB0byB0aGVcbi8vIGdpdmVuIG9uZSB0byBzZWUgaWYgdGhlIHR3byBhcmUgaW4gdGhlIHNhbWUgcGxhY2UgKGkuZS4gYWZ0ZXIgYVxuLy8gdGV4dCBub2RlIHZzIGF0IHRoZSBlbmQgb2YgdGhhdCB0ZXh0IG5vZGUpXG5jb25zdCBpc0VxdWl2YWxlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZikge1xuICAgIHJldHVybiB0YXJnZXROb2RlICYmIChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHxcbiAgICAgICAgc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgMSkpO1xufTtcbmNvbnN0IGF0b21FbGVtZW50cyA9IC9eKGltZ3xicnxpbnB1dHx0ZXh0YXJlYXxocikkL2k7XG5mdW5jdGlvbiBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCBkaXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IGhhc0Jsb2NrRGVzYyhub2RlKSB8fCBhdG9tRWxlbWVudHMudGVzdChub2RlLm5vZGVOYW1lKSB8fFxuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2ZmICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZGlyIDwgMCA/IG5vZGVTaXplKG5vZGUpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVTaXplKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzT25FZGdlKG5vZGUsIG9mZnNldCwgcGFyZW50KSB7XG4gICAgZm9yIChsZXQgYXRTdGFydCA9IG9mZnNldCA9PSAwLCBhdEVuZCA9IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKTsgYXRTdGFydCB8fCBhdEVuZDspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBpbmRleCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGF0U3RhcnQgPSBhdFN0YXJ0ICYmIGluZGV4ID09IDA7XG4gICAgICAgIGF0RW5kID0gYXRFbmQgJiYgaW5kZXggPT0gbm9kZVNpemUobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQmxvY2tEZXNjKGRvbSkge1xuICAgIGxldCBkZXNjO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKGRlc2MgPSBjdXIucG1WaWV3RGVzYylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jayAmJiAoZGVzYy5kb20gPT0gZG9tIHx8IGRlc2MuY29udGVudERPTSA9PSBkb20pO1xufVxuLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzUyM1xuLy8gKGlzQ29sbGFwc2VkIGluYXBwcm9wcmlhdGVseSByZXR1cm5zIHRydWUgaW4gc2hhZG93IGRvbSlcbmNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGZ1bmN0aW9uIChkb21TZWwpIHtcbiAgICByZXR1cm4gZG9tU2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn07XG5mdW5jdGlvbiBrZXlFdmVudChrZXlDb2RlLCBrZXkpIHtcbiAgICBsZXQgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChcImtleWRvd25cIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQua2V5Q29kZSA9IGtleUNvZGU7XG4gICAgZXZlbnQua2V5ID0gZXZlbnQuY29kZSA9IGtleTtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBkZWVwQWN0aXZlRWxlbWVudChkb2MpIHtcbiAgICBsZXQgZWx0ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsdCAmJiBlbHQuc2hhZG93Um9vdClcbiAgICAgICAgZWx0ID0gZWx0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICByZXR1cm4gZWx0O1xufVxuZnVuY3Rpb24gY2FyZXRGcm9tUG9pbnQoZG9jLCB4LCB5KSB7XG4gICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgIHRyeSB7IC8vIEZpcmVmb3ggdGhyb3dzIGZvciB0aGlzIGNhbGwgaW4gaGFyZC10by1wcmVkaWN0IGNpcmN1bXN0YW5jZXMgKCM5OTQpXG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHBvcy5vZmZzZXROb2RlLCBvZmZzZXQ6IHBvcy5vZmZzZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgfVxuICAgIGlmIChkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogcmFuZ2Uuc3RhcnRDb250YWluZXIsIG9mZnNldDogcmFuZ2Uuc3RhcnRPZmZzZXQgfTtcbiAgICB9XG59XG5cbmNvbnN0IG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvciA6IG51bGw7XG5jb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogbnVsbDtcbmNvbnN0IGFnZW50ID0gKG5hdiAmJiBuYXYudXNlckFnZW50KSB8fCBcIlwiO1xuY29uc3QgaWVfZWRnZSA9IC9FZGdlXFwvKFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGllX3VwdG8xMCA9IC9NU0lFIFxcZC8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZV8xMXVwID0gL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGllID0gISEoaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgaWVfZWRnZSk7XG5jb25zdCBpZV92ZXJzaW9uID0gaWVfdXB0bzEwID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMDtcbmNvbnN0IGdlY2tvID0gIWllICYmIC9nZWNrb1xcLyhcXGQrKS9pLnRlc3QoYWdlbnQpO1xuZ2Vja28gJiYgKygvRmlyZWZveFxcLyhcXGQrKS8uZXhlYyhhZ2VudCkgfHwgWzAsIDBdKVsxXTtcbmNvbnN0IF9jaHJvbWUgPSAhaWUgJiYgL0Nocm9tZVxcLyhcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBjaHJvbWUgPSAhIV9jaHJvbWU7XG5jb25zdCBjaHJvbWVfdmVyc2lvbiA9IF9jaHJvbWUgPyArX2Nocm9tZVsxXSA6IDA7XG5jb25zdCBzYWZhcmkgPSAhaWUgJiYgISFuYXYgJiYgL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xuLy8gSXMgdHJ1ZSBmb3IgYm90aCBpT1MgYW5kIGlQYWRPUyBmb3IgY29udmVuaWVuY2VcbmNvbnN0IGlvcyA9IHNhZmFyaSAmJiAoL01vYmlsZVxcL1xcdysvLnRlc3QoYWdlbnQpIHx8ICEhbmF2ICYmIG5hdi5tYXhUb3VjaFBvaW50cyA+IDIpO1xuY29uc3QgbWFjID0gaW9zIHx8IChuYXYgPyAvTWFjLy50ZXN0KG5hdi5wbGF0Zm9ybSkgOiBmYWxzZSk7XG5jb25zdCB3aW5kb3dzID0gbmF2ID8gL1dpbi8udGVzdChuYXYucGxhdGZvcm0pIDogZmFsc2U7XG5jb25zdCBhbmRyb2lkID0gL0FuZHJvaWQgXFxkLy50ZXN0KGFnZW50KTtcbmNvbnN0IHdlYmtpdCA9ICEhZG9jICYmIFwid2Via2l0Rm9udFNtb290aGluZ1wiIGluIGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5jb25zdCB3ZWJraXRfdmVyc2lvbiA9IHdlYmtpdCA/ICsoL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwO1xuXG5mdW5jdGlvbiB3aW5kb3dSZWN0KGRvYykge1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICB0b3A6IDAsIGJvdHRvbTogZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIGdldFNpZGUodmFsdWUsIHNpZGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IHZhbHVlW3NpZGVdO1xufVxuZnVuY3Rpb24gY2xpZW50UmVjdChub2RlKSB7XG4gICAgbGV0IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEFkanVzdCBmb3IgZWxlbWVudHMgd2l0aCBzdHlsZSBcInRyYW5zZm9ybTogc2NhbGUoKVwiXG4gICAgbGV0IHNjYWxlWCA9IChyZWN0LndpZHRoIC8gbm9kZS5vZmZzZXRXaWR0aCkgfHwgMTtcbiAgICBsZXQgc2NhbGVZID0gKHJlY3QuaGVpZ2h0IC8gbm9kZS5vZmZzZXRIZWlnaHQpIHx8IDE7XG4gICAgLy8gTWFrZSBzdXJlIHNjcm9sbGJhciB3aWR0aCBpc24ndCBpbmNsdWRlZCBpbiB0aGUgcmVjdGFuZ2xlXG4gICAgcmV0dXJuIHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0ICsgbm9kZS5jbGllbnRXaWR0aCAqIHNjYWxlWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIG5vZGUuY2xpZW50SGVpZ2h0ICogc2NhbGVZIH07XG59XG5mdW5jdGlvbiBzY3JvbGxSZWN0SW50b1ZpZXcodmlldywgcmVjdCwgc3RhcnRET00pIHtcbiAgICBsZXQgc2Nyb2xsVGhyZXNob2xkID0gdmlldy5zb21lUHJvcChcInNjcm9sbFRocmVzaG9sZFwiKSB8fCAwLCBzY3JvbGxNYXJnaW4gPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsTWFyZ2luXCIpIHx8IDU7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gc3RhcnRET00gfHwgdmlldy5kb207OyBwYXJlbnQgPSBwYXJlbnROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBlbHQgPSBwYXJlbnQ7XG4gICAgICAgIGxldCBhdFRvcCA9IGVsdCA9PSBkb2MuYm9keTtcbiAgICAgICAgbGV0IGJvdW5kaW5nID0gYXRUb3AgPyB3aW5kb3dSZWN0KGRvYykgOiBjbGllbnRSZWN0KGVsdCk7XG4gICAgICAgIGxldCBtb3ZlWCA9IDAsIG1vdmVZID0gMDtcbiAgICAgICAgaWYgKHJlY3QudG9wIDwgYm91bmRpbmcudG9wICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwidG9wXCIpKVxuICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCAtIHJlY3QudG9wICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwidG9wXCIpKTtcbiAgICAgICAgZWxzZSBpZiAocmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJib3R0b21cIikpXG4gICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwiYm90dG9tXCIpO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImxlZnRcIikpXG4gICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImxlZnRcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJyaWdodFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwicmlnaHRcIik7XG4gICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgaWYgKGF0VG9wKSB7XG4gICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3LnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRYID0gZWx0LnNjcm9sbExlZnQsIHN0YXJ0WSA9IGVsdC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVZKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wICs9IG1vdmVZO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgKz0gbW92ZVg7XG4gICAgICAgICAgICAgICAgbGV0IGRYID0gZWx0LnNjcm9sbExlZnQgLSBzdGFydFgsIGRZID0gZWx0LnNjcm9sbFRvcCAtIHN0YXJ0WTtcbiAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBkWCwgdG9wOiByZWN0LnRvcCAtIGRZLCByaWdodDogcmVjdC5yaWdodCAtIGRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gZFkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRUb3ApXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG4vLyBTdG9yZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3IncyBwYXJlbnQgbm9kZXMsIGFsb25nIHdpdGhcbi8vIHRoZSB0b3AgcG9zaXRpb24gb2YgYW4gZWxlbWVudCBuZWFyIHRoZSB0b3Agb2YgdGhlIGVkaXRvciwgd2hpY2hcbi8vIHdpbGwgYmUgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHZpc2libGUgdmlld3BvcnQgcmVtYWlucyBzdGFibGUgZXZlblxuLy8gd2hlbiB0aGUgc2l6ZSBvZiB0aGUgY29udGVudCBhYm92ZSBjaGFuZ2VzLlxuZnVuY3Rpb24gc3RvcmVTY3JvbGxQb3Modmlldykge1xuICAgIGxldCByZWN0ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0WSA9IE1hdGgubWF4KDAsIHJlY3QudG9wKTtcbiAgICBsZXQgcmVmRE9NLCByZWZUb3A7XG4gICAgZm9yIChsZXQgeCA9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsIHkgPSBzdGFydFkgKyAxOyB5IDwgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHJlY3QuYm90dG9tKTsgeSArPSA1KSB7XG4gICAgICAgIGxldCBkb20gPSB2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKCFkb20gfHwgZG9tID09IHZpZXcuZG9tIHx8ICF2aWV3LmRvbS5jb250YWlucyhkb20pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBsb2NhbFJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChsb2NhbFJlY3QudG9wID49IHN0YXJ0WSAtIDIwKSB7XG4gICAgICAgICAgICByZWZET00gPSBkb207XG4gICAgICAgICAgICByZWZUb3AgPSBsb2NhbFJlY3QudG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcmVmRE9NOiByZWZET00sIHJlZlRvcDogcmVmVG9wLCBzdGFjazogc2Nyb2xsU3RhY2sodmlldy5kb20pIH07XG59XG5mdW5jdGlvbiBzY3JvbGxTdGFjayhkb20pIHtcbiAgICBsZXQgc3RhY2sgPSBbXSwgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IHBhcmVudE5vZGUoY3VyKSkge1xuICAgICAgICBzdGFjay5wdXNoKHsgZG9tOiBjdXIsIHRvcDogY3VyLnNjcm9sbFRvcCwgbGVmdDogY3VyLnNjcm9sbExlZnQgfSk7XG4gICAgICAgIGlmIChkb20gPT0gZG9jKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbn1cbi8vIFJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcyB0byB0aGF0IHdoYXRcbi8vIGl0IHdhcyBiZWZvcmUsIHdoZW4gc3RvcmVTY3JvbGxQb3Mgd2FzIGNhbGxlZC5cbmZ1bmN0aW9uIHJlc2V0U2Nyb2xsUG9zKHsgcmVmRE9NLCByZWZUb3AsIHN0YWNrIH0pIHtcbiAgICBsZXQgbmV3UmVmVG9wID0gcmVmRE9NID8gcmVmRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IDA7XG4gICAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBuZXdSZWZUb3AgPT0gMCA/IDAgOiBuZXdSZWZUb3AgLSByZWZUb3ApO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcm9sbFN0YWNrKHN0YWNrLCBkVG9wKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyBkb20sIHRvcCwgbGVmdCB9ID0gc3RhY2tbaV07XG4gICAgICAgIGlmIChkb20uc2Nyb2xsVG9wICE9IHRvcCArIGRUb3ApXG4gICAgICAgICAgICBkb20uc2Nyb2xsVG9wID0gdG9wICsgZFRvcDtcbiAgICAgICAgaWYgKGRvbS5zY3JvbGxMZWZ0ICE9IGxlZnQpXG4gICAgICAgICAgICBkb20uc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgfVxufVxubGV0IHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICAgIGlmIChkb20uc2V0QWN0aXZlKVxuICAgICAgICByZXR1cm4gZG9tLnNldEFjdGl2ZSgpOyAvLyBpbiBJRVxuICAgIGlmIChwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xuICAgIGxldCBzdG9yZWQgPSBzY3JvbGxTdGFjayhkb20pO1xuICAgIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICByZXN0b3JlU2Nyb2xsU3RhY2soc3RvcmVkLCAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5Ob2RlKG5vZGUsIGNvb3Jkcykge1xuICAgIGxldCBjbG9zZXN0LCBkeENsb3Nlc3QgPSAyZTgsIGNvb3Jkc0Nsb3Nlc3QsIG9mZnNldCA9IDA7XG4gICAgbGV0IHJvd0JvdCA9IGNvb3Jkcy50b3AsIHJvd1RvcCA9IGNvb3Jkcy50b3A7XG4gICAgbGV0IGZpcnN0QmVsb3csIGNvb3Jkc0JlbG93O1xuICAgIGZvciAobGV0IGNoaWxkID0gbm9kZS5maXJzdENoaWxkLCBjaGlsZEluZGV4ID0gMDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcsIGNoaWxkSW5kZXgrKykge1xuICAgICAgICBsZXQgcmVjdHM7XG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKHJlY3QudG9wIDw9IHJvd0JvdCAmJiByZWN0LmJvdHRvbSA+PSByb3dUb3ApIHtcbiAgICAgICAgICAgICAgICByb3dCb3QgPSBNYXRoLm1heChyZWN0LmJvdHRvbSwgcm93Qm90KTtcbiAgICAgICAgICAgICAgICByb3dUb3AgPSBNYXRoLm1pbihyZWN0LnRvcCwgcm93VG9wKTtcbiAgICAgICAgICAgICAgICBsZXQgZHggPSByZWN0LmxlZnQgPiBjb29yZHMubGVmdCA/IHJlY3QubGVmdCAtIGNvb3Jkcy5sZWZ0XG4gICAgICAgICAgICAgICAgICAgIDogcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0ID8gY29vcmRzLmxlZnQgLSByZWN0LnJpZ2h0IDogMDtcbiAgICAgICAgICAgICAgICBpZiAoZHggPCBkeENsb3Nlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBkeENsb3Nlc3QgPSBkeDtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzQ2xvc2VzdCA9IGR4ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMyA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCA/IHJlY3QucmlnaHQgOiByZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGNvb3Jkcy50b3BcbiAgICAgICAgICAgICAgICAgICAgfSA6IGNvb3JkcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEgJiYgZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBjaGlsZEluZGV4ICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QudG9wID4gY29vcmRzLnRvcCAmJiAhZmlyc3RCZWxvdyAmJiByZWN0LmxlZnQgPD0gY29vcmRzLmxlZnQgJiYgcmVjdC5yaWdodCA+PSBjb29yZHMubGVmdCkge1xuICAgICAgICAgICAgICAgIGZpcnN0QmVsb3cgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjb29yZHNCZWxvdyA9IHsgbGVmdDogTWF0aC5tYXgocmVjdC5sZWZ0LCBNYXRoLm1pbihyZWN0LnJpZ2h0LCBjb29yZHMubGVmdCkpLCB0b3A6IHJlY3QudG9wIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QgJiYgKGNvb3Jkcy5sZWZ0ID49IHJlY3QucmlnaHQgJiYgY29vcmRzLnRvcCA+PSByZWN0LnRvcCB8fFxuICAgICAgICAgICAgICAgIGNvb3Jkcy5sZWZ0ID49IHJlY3QubGVmdCAmJiBjb29yZHMudG9wID49IHJlY3QuYm90dG9tKSlcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBjaGlsZEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3QgJiYgZmlyc3RCZWxvdykge1xuICAgICAgICBjbG9zZXN0ID0gZmlyc3RCZWxvdztcbiAgICAgICAgY29vcmRzQ2xvc2VzdCA9IGNvb3Jkc0JlbG93O1xuICAgICAgICBkeENsb3Nlc3QgPSAwO1xuICAgIH1cbiAgICBpZiAoY2xvc2VzdCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiBmaW5kT2Zmc2V0SW5UZXh0KGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpO1xuICAgIGlmICghY2xvc2VzdCB8fCAoZHhDbG9zZXN0ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMSkpXG4gICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldCB9O1xuICAgIHJldHVybiBmaW5kT2Zmc2V0SW5Ob2RlKGNsb3Nlc3QsIGNvb3Jkc0Nsb3Nlc3QpO1xufVxuZnVuY3Rpb24gZmluZE9mZnNldEluVGV4dChub2RlLCBjb29yZHMpIHtcbiAgICBsZXQgbGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgaSArIDEpO1xuICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBpKTtcbiAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHJhbmdlLCAxKTtcbiAgICAgICAgaWYgKHJlY3QudG9wID09IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChpblJlY3QoY29vcmRzLCByZWN0KSlcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogaSArIChjb29yZHMubGVmdCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IDApIH07XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogMCB9O1xufVxuZnVuY3Rpb24gaW5SZWN0KGNvb3JkcywgcmVjdCkge1xuICAgIHJldHVybiBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgLSAxICYmIGNvb3Jkcy5sZWZ0IDw9IHJlY3QucmlnaHQgKyAxICYmXG4gICAgICAgIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgLSAxICYmIGNvb3Jkcy50b3AgPD0gcmVjdC5ib3R0b20gKyAxO1xufVxuZnVuY3Rpb24gdGFyZ2V0S2x1ZGdlKGRvbSwgY29vcmRzKSB7XG4gICAgbGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQgJiYgL15saSQvaS50ZXN0KHBhcmVudC5ub2RlTmFtZSkgJiYgY29vcmRzLmxlZnQgPCBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdClcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICByZXR1cm4gZG9tO1xufVxuZnVuY3Rpb24gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IGZpbmRPZmZzZXRJbk5vZGUoZWx0LCBjb29yZHMpLCBiaWFzID0gLTE7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiAhbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGxldCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgYmlhcyA9IHJlY3QubGVmdCAhPSByZWN0LnJpZ2h0ICYmIGNvb3Jkcy5sZWZ0ID4gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG59XG5mdW5jdGlvbiBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpIHtcbiAgICAvLyBCcm93c2VyIChpbiBjYXJldFBvc2l0aW9uL1JhbmdlRnJvbVBvaW50KSB3aWxsIGFncmVzc2l2ZWx5XG4gICAgLy8gbm9ybWFsaXplIHRvd2FyZHMgbmVhcmJ5IGlubGluZSBub2Rlcy4gU2luY2Ugd2UgYXJlIGludGVyZXN0ZWQgaW5cbiAgICAvLyBwb3NpdGlvbnMgYmV0d2VlbiBibG9jayBub2RlcyB0b28sIHdlIGZpcnN0IHdhbGsgdXAgdGhlIGhpZXJhcmNoeVxuICAgIC8vIG9mIG5vZGVzIHRvIHNlZSBpZiB0aGVyZSBhcmUgYmxvY2sgbm9kZXMgdGhhdCB0aGUgY29vcmRpbmF0ZXNcbiAgICAvLyBmYWxsIG91dHNpZGUgb2YuIElmIHNvLCB3ZSB0YWtlIHRoZSBwb3NpdGlvbiBiZWZvcmUvYWZ0ZXIgdGhhdFxuICAgIC8vIGJsb2NrLiBJZiBub3QsIHdlIGNhbGwgYHBvc0Zyb21ET01gIG9uIHRoZSByYXcgbm9kZS9vZmZzZXQuXG4gICAgbGV0IG91dHNpZGVCbG9jayA9IC0xO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGUsIHNhd0Jsb2NrID0gZmFsc2U7Oykge1xuICAgICAgICBpZiAoY3VyID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGN1ciwgdHJ1ZSk7XG4gICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZGVzYy5kb20ubm9kZVR5cGUgPT0gMSAmJiAoZGVzYy5ub2RlLmlzQmxvY2sgJiYgZGVzYy5wYXJlbnQgJiYgIXNhd0Jsb2NrIHx8ICFkZXNjLmNvbnRlbnRET00pKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGRlc2MuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaWYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50ICYmICFzYXdCbG9jaykge1xuICAgICAgICAgICAgICAgIHNhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgfHwgcmVjdC50b3AgPiBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvdXRzaWRlQmxvY2sgPSBkZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgfHwgcmVjdC5ib3R0b20gPCBjb29yZHMudG9wKVxuICAgICAgICAgICAgICAgICAgICBvdXRzaWRlQmxvY2sgPSBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjLmNvbnRlbnRET00gJiYgb3V0c2lkZUJsb2NrIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbnNpZGUgYSBsZWFmLCByZXR1cm4gdGhlIHNpZGUgb2YgdGhlIGxlYWYgY2xvc2VyIHRvIHRoZSBjb29yZHNcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gZGVzYy5ub2RlLmlzQmxvY2sgPyBjb29yZHMudG9wIDwgKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IGNvb3Jkcy5sZWZ0IDwgKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlID8gZGVzYy5wb3NCZWZvcmUgOiBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGRlc2MuZG9tLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBvdXRzaWRlQmxvY2sgPiAtMSA/IG91dHNpZGVCbG9jayA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgLTEpO1xufVxuZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChlbGVtZW50LCBjb29yZHMsIGJveCkge1xuICAgIGxldCBsZW4gPSBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGlmIChsZW4gJiYgYm94LnRvcCA8IGJveC5ib3R0b20pIHtcbiAgICAgICAgZm9yIChsZXQgc3RhcnRJID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVuIC0gMSwgTWF0aC5mbG9vcihsZW4gKiAoY29vcmRzLnRvcCAtIGJveC50b3ApIC8gKGJveC5ib3R0b20gLSBib3gudG9wKSkgLSAyKSksIGkgPSBzdGFydEk7Oykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRGcm9tUG9pbnQoY2hpbGQsIGNvb3JkcywgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0gKGkgKyAxKSAlIGxlbikgPT0gc3RhcnRJKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuLy8gR2l2ZW4gYW4geCx5IHBvc2l0aW9uIG9uIHRoZSBlZGl0b3IsIGdldCB0aGUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgY29vcmRzKSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQsIG5vZGUsIG9mZnNldCA9IDA7XG4gICAgbGV0IGNhcmV0ID0gY2FyZXRGcm9tUG9pbnQoZG9jLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgaWYgKGNhcmV0KVxuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGNhcmV0KTtcbiAgICBsZXQgZWx0ID0gKHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50ID8gdmlldy5yb290IDogZG9jKVxuICAgICAgICAuZWxlbWVudEZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgbGV0IHBvcztcbiAgICBpZiAoIWVsdCB8fCAhdmlldy5kb20uY29udGFpbnMoZWx0Lm5vZGVUeXBlICE9IDEgPyBlbHQucGFyZW50Tm9kZSA6IGVsdCkpIHtcbiAgICAgICAgbGV0IGJveCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWluUmVjdChjb29yZHMsIGJveCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWx0ID0gZWxlbWVudEZyb21Qb2ludCh2aWV3LmRvbSwgY29vcmRzLCBib3gpO1xuICAgICAgICBpZiAoIWVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHJldHVybnMgbm9uc2Vuc2Ugd2hlbiBvbiBhIGRyYWdnYWJsZSBlbGVtZW50XG4gICAgaWYgKHNhZmFyaSkge1xuICAgICAgICBmb3IgKGxldCBwID0gZWx0OyBub2RlICYmIHA7IHAgPSBwYXJlbnROb2RlKHApKVxuICAgICAgICAgICAgaWYgKHAuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsdCA9IHRhcmdldEtsdWRnZShlbHQsIGNvb3Jkcyk7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gb2Zmc2V0cyBpbnRvIDxpbnB1dD4gbm9kZXMsIHdoaWNoXG4gICAgICAgICAgICAvLyBoYXZlIG5vIGFjdHVhbCBjaGlsZHJlbiwgZnJvbSBjYXJldFBvc2l0aW9uRnJvbVBvaW50ICgjOTUzKVxuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIEl0J2xsIGFsc28gbW92ZSB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYmVmb3JlIGltYWdlIG5vZGVzLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aG9zZSBhcmUgYmVoaW5kIGl0LlxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCBib3g7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiAoYm94ID0gbmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkucmlnaHQgPD0gY29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgICAgICAgICAgYm94LmJvdHRvbSA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN1c3BpY2lvdXNseSBzcGVjaWZpYyBrbHVkZ2UgdG8gd29yayBhcm91bmQgY2FyZXQqRnJvbVBvaW50XG4gICAgICAgIC8vIG5ldmVyIHJldHVybmluZyBhIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tICYmIG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMSAmJiBub2RlLmxhc3RDaGlsZC5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBjb29yZHMudG9wID4gbm9kZS5sYXN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKVxuICAgICAgICAgICAgcG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplO1xuICAgICAgICAvLyBJZ25vcmUgcG9zaXRpb25zIGRpcmVjdGx5IGFmdGVyIGEgQlIsIHNpbmNlIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyAncm91bmQgdXAnIHBvc2l0aW9ucyB0aGF0IHdvdWxkIGJlIG1vcmUgYWNjdXJhdGVseSBwbGFjZWRcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBCUiBub2RlLlxuICAgICAgICBlbHNlIGlmIChvZmZzZXQgPT0gMCB8fCBub2RlLm5vZGVUeXBlICE9IDEgfHwgbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdLm5vZGVOYW1lICE9IFwiQlJcIilcbiAgICAgICAgICAgIHBvcyA9IHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcyk7XG4gICAgfVxuICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgcG9zID0gcG9zRnJvbUVsZW1lbnQodmlldywgZWx0LCBjb29yZHMpO1xuICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGVsdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHsgcG9zLCBpbnNpZGU6IGRlc2MgPyBkZXNjLnBvc0F0U3RhcnQgLSBkZXNjLmJvcmRlciA6IC0xIH07XG59XG5mdW5jdGlvbiBub25aZXJvKHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPCByZWN0LmJvdHRvbSB8fCByZWN0LmxlZnQgPCByZWN0LnJpZ2h0O1xufVxuZnVuY3Rpb24gc2luZ2xlUmVjdCh0YXJnZXQsIGJpYXMpIHtcbiAgICBsZXQgcmVjdHMgPSB0YXJnZXQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBpZiAocmVjdHMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IHJlY3RzW2JpYXMgPCAwID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobm9uWmVybyhmaXJzdCkpXG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHJlY3RzLCBub25aZXJvKSB8fCB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5jb25zdCBCSURJID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbi8vIEdpdmVuIGEgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50IG1vZGVsLCBnZXQgYSBib3VuZGluZyBib3ggb2YgdGhlXG4vLyBjaGFyYWN0ZXIgYXQgdGhhdCBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIHdpbmRvdy5cbmZ1bmN0aW9uIGNvb3Jkc0F0UG9zKHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCwgYXRvbSB9ID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3MocG9zLCBzaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgbGV0IHN1cHBvcnRFbXB0eVJhbmdlID0gd2Via2l0IHx8IGdlY2tvO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgLy8gVGhlc2UgYnJvd3NlcnMgc3VwcG9ydCBxdWVyeWluZyBlbXB0eSB0ZXh0IHJhbmdlcy4gUHJlZmVyIHRoYXQgaW5cbiAgICAgICAgLy8gYmlkaSBjb250ZXh0IG9yIHdoZW4gYXQgdGhlIGVuZCBvZiBhIG5vZGUuXG4gICAgICAgIGlmIChzdXBwb3J0RW1wdHlSYW5nZSAmJiAoQklESS50ZXN0KG5vZGUubm9kZVZhbHVlKSB8fCAoc2lkZSA8IDAgPyAhb2Zmc2V0IDogb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkpKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0KSwgc2lkZSk7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHJldHVybnMgYmFkIHJlc3VsdHMgKHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIHNwYWNlKVxuICAgICAgICAgICAgLy8gd2hlbiBxdWVyeWluZyBhIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIGxpbmUtYnJva2VuXG4gICAgICAgICAgICAvLyB3aGl0ZXNwYWNlLiBEZXRlY3QgdGhpcyBzaXR1YXRpb24gYW5kIGFuZCBrbHVkZ2UgYXJvdW5kIGl0XG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgb2Zmc2V0ICYmIC9cXHMvLnRlc3Qobm9kZS5ub2RlVmFsdWVbb2Zmc2V0IC0gMV0pICYmIG9mZnNldCA8IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0QmVmb3JlID0gc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgb2Zmc2V0IC0gMSwgb2Zmc2V0IC0gMSksIC0xKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdEJlZm9yZS50b3AgPT0gcmVjdC50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RBZnRlciA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCwgb2Zmc2V0ICsgMSksIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RBZnRlci50b3AgIT0gcmVjdC50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlblYocmVjdEFmdGVyLCByZWN0QWZ0ZXIubGVmdCA8IHJlY3RCZWZvcmUubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG9mZnNldCwgdG8gPSBvZmZzZXQsIHRha2VTaWRlID0gc2lkZSA8IDAgPyAxIDogLTE7XG4gICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgIW9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgdGFrZVNpZGUgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPj0gMCAmJiBvZmZzZXQgPT0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpZGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBmcm9tLCB0byksIHRha2VTaWRlKSwgdGFrZVNpZGUgPCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgJGRvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zIC0gKGF0b20gfHwgMCkpO1xuICAgIC8vIFJldHVybiBhIGhvcml6b250YWwgbGluZSBpbiBibG9jayBjb250ZXh0XG4gICAgaWYgKCEkZG9tLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0ICYmIChzaWRlIDwgMCB8fCBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuSChiZWZvcmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCA8IG5vZGVTaXplKG5vZGUpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChhZnRlci5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuSChhZnRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5IKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHNpZGUgPj0gMCk7XG4gICAgfVxuICAgIC8vIElubGluZSwgbm90IGluIHRleHQgbm9kZSAodGhpcyBpcyBub3QgQmlkaS1zYWZlKVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0ICYmIChzaWRlIDwgMCB8fCBvZmZzZXQgPT0gbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgIGxldCB0YXJnZXQgPSBiZWZvcmUubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShiZWZvcmUsIG5vZGVTaXplKGJlZm9yZSkgLSAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICAvLyBCUiBub2RlcyB0ZW5kIHRvIG9ubHkgcmV0dXJuIHRoZSByZWN0YW5nbGUgYmVmb3JlIHRoZW0uXG4gICAgICAgICAgICAvLyBPbmx5IHVzZSB0aGVtIGlmIHRoZXkgYXJlIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlaXIgcGFyZW50XG4gICAgICAgICAgICA6IGJlZm9yZS5ub2RlVHlwZSA9PSAxICYmIChiZWZvcmUubm9kZU5hbWUgIT0gXCJCUlwiIHx8ICFiZWZvcmUubmV4dFNpYmxpbmcpID8gYmVmb3JlIDogbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRhcmdldCwgMSksIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgd2hpbGUgKGFmdGVyLnBtVmlld0Rlc2MgJiYgYWZ0ZXIucG1WaWV3RGVzYy5pZ25vcmVGb3JDb29yZHMpXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gIWFmdGVyID8gbnVsbCA6IGFmdGVyLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYWZ0ZXIsIDAsIChzdXBwb3J0RW1wdHlSYW5nZSA/IDAgOiAxKSlcbiAgICAgICAgICAgIDogYWZ0ZXIubm9kZVR5cGUgPT0gMSA/IGFmdGVyIDogbnVsbDtcbiAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KHRhcmdldCwgLTEpLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gQWxsIGVsc2UgZmFpbGVkLCBqdXN0IHRyeSB0byBnZXQgYSByZWN0YW5nbGUgZm9yIHRoZSB0YXJnZXQgbm9kZVxuICAgIHJldHVybiBmbGF0dGVuVihzaW5nbGVSZWN0KG5vZGUubm9kZVR5cGUgPT0gMyA/IHRleHRSYW5nZShub2RlKSA6IG5vZGUsIC1zaWRlKSwgc2lkZSA+PSAwKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5WKHJlY3QsIGxlZnQpIHtcbiAgICBpZiAocmVjdC53aWR0aCA9PSAwKVxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICBsZXQgeCA9IGxlZnQgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0O1xuICAgIHJldHVybiB7IHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC5ib3R0b20sIGxlZnQ6IHgsIHJpZ2h0OiB4IH07XG59XG5mdW5jdGlvbiBmbGF0dGVuSChyZWN0LCB0b3ApIHtcbiAgICBpZiAocmVjdC5oZWlnaHQgPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHkgPSB0b3AgPyByZWN0LnRvcCA6IHJlY3QuYm90dG9tO1xuICAgIHJldHVybiB7IHRvcDogeSwgYm90dG9tOiB5LCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LnJpZ2h0IH07XG59XG5mdW5jdGlvbiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCBmKSB7XG4gICAgbGV0IHZpZXdTdGF0ZSA9IHZpZXcuc3RhdGUsIGFjdGl2ZSA9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgIHZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20pXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZigpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHZpZXdTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlld1N0YXRlKTtcbiAgICAgICAgaWYgKGFjdGl2ZSAhPSB2aWV3LmRvbSAmJiBhY3RpdmUpXG4gICAgICAgICAgICBhY3RpdmUuZm9jdXMoKTtcbiAgICB9XG59XG4vLyBXaGV0aGVyIHZlcnRpY2FsIHBvc2l0aW9uIG1vdGlvbiBpbiBhIGdpdmVuIGRpcmVjdGlvblxuLy8gZnJvbSBhIHBvc2l0aW9uIHdvdWxkIGxlYXZlIGEgdGV4dCBibG9jay5cbmZ1bmN0aW9uIGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcikge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0ICRwb3MgPSBkaXIgPT0gXCJ1cFwiID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICBsZXQgeyBub2RlOiBkb20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKCRwb3MucG9zLCBkaXIgPT0gXCJ1cFwiID8gLTEgOiAxKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5lYXJlc3QgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghbmVhcmVzdClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChuZWFyZXN0Lm5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgICAgIGRvbSA9IG5lYXJlc3QuY29udGVudERPTSB8fCBuZWFyZXN0LmRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IG5lYXJlc3QuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvb3JkcyA9IGNvb3Jkc0F0UG9zKHZpZXcsICRwb3MucG9zLCAxKTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGxldCBib3hlcztcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIGJveGVzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgYm94ZXMgPSB0ZXh0UmFuZ2UoY2hpbGQsIDAsIGNoaWxkLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJveCA9IGJveGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChib3guYm90dG9tID4gYm94LnRvcCArIDEgJiZcbiAgICAgICAgICAgICAgICAgICAgKGRpciA9PSBcInVwXCIgPyBjb29yZHMudG9wIC0gYm94LnRvcCA+IChib3guYm90dG9tIC0gY29vcmRzLnRvcCkgKiAyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJveC5ib3R0b20gLSBjb29yZHMuYm90dG9tID4gKGNvb3Jkcy5ib3R0b20gLSBib3gudG9wKSAqIDIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59XG5jb25zdCBtYXliZVJUTCA9IC9bXFx1MDU5MC1cXHUwOGFjXS87XG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcikge1xuICAgIGxldCB7ICRoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gJGhlYWQucGFyZW50T2Zmc2V0LCBhdFN0YXJ0ID0gIW9mZnNldCwgYXRFbmQgPSBvZmZzZXQgPT0gJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICAvLyBJZiB0aGUgdGV4dGJsb2NrIGlzIGFsbCBMVFIsIG9yIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydFxuICAgIC8vIFNlbGVjdGlvbi5tb2RpZnkgKEVkZ2UpLCBmYWxsIGJhY2sgdG8gYSBwcmltaXRpdmUgYXBwcm9hY2hcbiAgICBpZiAoIW1heWJlUlRMLnRlc3QoJGhlYWQucGFyZW50LnRleHRDb250ZW50KSB8fCAhc2VsLm1vZGlmeSlcbiAgICAgICAgcmV0dXJuIGRpciA9PSBcImxlZnRcIiB8fCBkaXIgPT0gXCJiYWNrd2FyZFwiID8gYXRTdGFydCA6IGF0RW5kO1xuICAgIHJldHVybiB3aXRoRmx1c2hlZFN0YXRlKHZpZXcsIHN0YXRlLCAoKSA9PiB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBodWdlIGhhY2ssIGJ1dCBhcHBlYXJzIHRvIGJlIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBjdXJyZW50bHkgZG86IHVzZSBgU2VsZWN0aW9uLm1vZGlmeWAgdG8gbW92ZSB0aGUgc2VsZWN0aW9uIGJ5XG4gICAgICAgIC8vIG9uZSBjaGFyYWN0ZXIsIGFuZCBzZWUgaWYgdGhhdCBtb3ZlcyB0aGUgY3Vyc29yIG91dCBvZiB0aGVcbiAgICAgICAgLy8gdGV4dGJsb2NrIChvciBkb2Vzbid0IG1vdmUgaXQgYXQgYWxsLCB3aGVuIGF0IHRoZSBzdGFydC9lbmQgb2ZcbiAgICAgICAgLy8gdGhlIGRvY3VtZW50KS5cbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBvbGROb2RlLCBmb2N1c09mZnNldDogb2xkT2ZmLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG9sZEJpZGlMZXZlbCA9IHNlbC5jYXJldEJpZGlMZXZlbCAvLyBPbmx5IGZvciBGaXJlZm94XG4gICAgICAgIDtcbiAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgZGlyLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgbGV0IHBhcmVudERPTSA9ICRoZWFkLmRlcHRoID8gdmlldy5kb2NWaWV3LmRvbUFmdGVyUG9zKCRoZWFkLmJlZm9yZSgpKSA6IHZpZXcuZG9tO1xuICAgICAgICBsZXQgeyBmb2N1c05vZGU6IG5ld05vZGUsIGZvY3VzT2Zmc2V0OiBuZXdPZmYgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ld05vZGUgJiYgIXBhcmVudERPTS5jb250YWlucyhuZXdOb2RlLm5vZGVUeXBlID09IDEgPyBuZXdOb2RlIDogbmV3Tm9kZS5wYXJlbnROb2RlKSB8fFxuICAgICAgICAgICAgKG9sZE5vZGUgPT0gbmV3Tm9kZSAmJiBvbGRPZmYgPT0gbmV3T2ZmKTtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZWwuY29sbGFwc2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChvbGROb2RlICYmIChvbGROb2RlICE9IGFuY2hvck5vZGUgfHwgb2xkT2ZmICE9IGFuY2hvck9mZnNldCkgJiYgc2VsLmV4dGVuZClcbiAgICAgICAgICAgICAgICBzZWwuZXh0ZW5kKG9sZE5vZGUsIG9sZE9mZik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICBpZiAob2xkQmlkaUxldmVsICE9IG51bGwpXG4gICAgICAgICAgICBzZWwuY2FyZXRCaWRpTGV2ZWwgPSBvbGRCaWRpTGV2ZWw7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5sZXQgY2FjaGVkU3RhdGUgPSBudWxsO1xubGV0IGNhY2hlZERpciA9IG51bGw7XG5sZXQgY2FjaGVkUmVzdWx0ID0gZmFsc2U7XG5mdW5jdGlvbiBlbmRPZlRleHRibG9jayh2aWV3LCBzdGF0ZSwgZGlyKSB7XG4gICAgaWYgKGNhY2hlZFN0YXRlID09IHN0YXRlICYmIGNhY2hlZERpciA9PSBkaXIpXG4gICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgY2FjaGVkU3RhdGUgPSBzdGF0ZTtcbiAgICBjYWNoZWREaXIgPSBkaXI7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdCA9IGRpciA9PSBcInVwXCIgfHwgZGlyID09IFwiZG93blwiXG4gICAgICAgID8gZW5kT2ZUZXh0YmxvY2tWZXJ0aWNhbCh2aWV3LCBzdGF0ZSwgZGlyKVxuICAgICAgICA6IGVuZE9mVGV4dGJsb2NrSG9yaXpvbnRhbCh2aWV3LCBzdGF0ZSwgZGlyKTtcbn1cblxuLy8gVmlldyBkZXNjcmlwdGlvbnMgYXJlIGRhdGEgc3RydWN0dXJlcyB0aGF0IGRlc2NyaWJlIHRoZSBET00gdGhhdCBpc1xuLy8gdXNlZCB0byByZXByZXNlbnQgdGhlIGVkaXRvcidzIGNvbnRlbnQuIFRoZXkgYXJlIHVzZWQgZm9yOlxuLy9cbi8vIC0gSW5jcmVtZW50YWwgcmVkcmF3aW5nIHdoZW4gdGhlIGRvY3VtZW50IGNoYW5nZXNcbi8vXG4vLyAtIEZpZ3VyaW5nIG91dCB3aGF0IHBhcnQgb2YgdGhlIGRvY3VtZW50IGEgZ2l2ZW4gRE9NIHBvc2l0aW9uXG4vLyAgIGNvcnJlc3BvbmRzIHRvXG4vL1xuLy8gLSBXaXJpbmcgaW4gY3VzdG9tIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgZWRpdGluZyBpbnRlcmZhY2UgZm9yIGFcbi8vICAgZ2l2ZW4gbm9kZVxuLy9cbi8vIFRoZXkgZm9ybSBhIGRvdWJseS1saW5rZWQgbXV0YWJsZSB0cmVlLCBzdGFydGluZyBhdCBgdmlldy5kb2NWaWV3YC5cbmNvbnN0IE5PVF9ESVJUWSA9IDAsIENISUxEX0RJUlRZID0gMSwgQ09OVEVOVF9ESVJUWSA9IDIsIE5PREVfRElSVFkgPSAzO1xuLy8gU3VwZXJjbGFzcyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2YgZGVzY3JpcHRpb25zLiBEZWZpbmVzIHRoZWlyXG4vLyBiYXNpYyBzdHJ1Y3R1cmUgYW5kIHNoYXJlZCBtZXRob2RzLlxuY2xhc3MgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgY2hpbGRyZW4sIGRvbSwgXG4gICAgLy8gVGhpcyBpcyB0aGUgbm9kZSB0aGF0IGhvbGRzIHRoZSBjaGlsZCB2aWV3cy4gSXQgbWF5IGJlIG51bGwgZm9yXG4gICAgLy8gZGVzY3MgdGhhdCBkb24ndCBoYXZlIGNoaWxkcmVuLlxuICAgIGNvbnRlbnRET00pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGNvbnRlbnRET007XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgIC8vIEFuIGV4cGFuZG8gcHJvcGVydHkgb24gdGhlIERPTSBub2RlIHByb3ZpZGVzIGEgbGluayBiYWNrIHRvIGl0c1xuICAgICAgICAvLyBkZXNjcmlwdGlvbi5cbiAgICAgICAgZG9tLnBtVmlld0Rlc2MgPSB0aGlzO1xuICAgIH1cbiAgICAvLyBVc2VkIHRvIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiBkZXNjcmlwdGlvbiBjb3JyZXNwb25kcyB0byBhXG4gICAgLy8gd2lkZ2V0L21hcmsvbm9kZS5cbiAgICBtYXRjaGVzV2lkZ2V0KHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1hdGNoZXNIYWNrKG5vZGVOYW1lKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFdoZW4gcGFyc2luZyBpbi1lZGl0b3IgY29udGVudCAoaW4gZG9tY2hhbmdlLmpzKSwgd2UgYWxsb3dcbiAgICAvLyBkZXNjcmlwdGlvbnMgdG8gZGV0ZXJtaW5lIHRoZSBwYXJzZSBydWxlcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvXG4gICAgLy8gcGFyc2UgdGhlbS5cbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgLy8gVXNlZCBieSB0aGUgZWRpdG9yJ3MgZXZlbnQgaGFuZGxlciB0byBpZ25vcmUgZXZlbnRzIHRoYXQgY29tZVxuICAgIC8vIGZyb20gY2VydGFpbiBkZXNjcy5cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLy8gVGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcmVwcmVzZW50ZWQgYnkgdGhpcyBkZXNjLlxuICAgIGdldCBzaXplKCkge1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5jaGlsZHJlbltpXS5zaXplO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLy8gRm9yIGJsb2NrIG5vZGVzLCB0aGlzIHJlcHJlc2VudHMgdGhlIHNwYWNlIHRha2VuIHVwIGJ5IHRoZWlyXG4gICAgLy8gc3RhcnQvZW5kIHRva2Vucy5cbiAgICBnZXQgYm9yZGVyKCkgeyByZXR1cm4gMDsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5kb20ucG1WaWV3RGVzYyA9PSB0aGlzKVxuICAgICAgICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHBvc0JlZm9yZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGN1ciA9PSBjaGlsZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGN1ci5zaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwb3NCZWZvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZUNoaWxkKHRoaXMpICsgdGhpcy5ib3JkZXIgOiAwO1xuICAgIH1cbiAgICBnZXQgcG9zQWZ0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSArIHRoaXMuc2l6ZTtcbiAgICB9XG4gICAgZ2V0IHBvc0F0RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5zaXplIC0gMiAqIHRoaXMuYm9yZGVyO1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgLy8gSWYgdGhlIERPTSBwb3NpdGlvbiBpcyBpbiB0aGUgY29udGVudCwgdXNlIHRoZSBjaGlsZCBkZXNjIGFmdGVyXG4gICAgICAgIC8vIGl0IHRvIGZpZ3VyZSBvdXQgYSBwb3NpdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChiaWFzIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCBkb21CZWZvcmUsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChkb21CZWZvcmUgJiYgISgoZGVzYyA9IGRvbUJlZm9yZS5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQmVmb3JlID0gZG9tQmVmb3JlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQmVmb3JlID8gdGhpcy5wb3NCZWZvcmVDaGlsZChkZXNjKSArIGRlc2Muc2l6ZSA6IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkb21BZnRlciwgZGVzYztcbiAgICAgICAgICAgICAgICBpZiAoZG9tID09IHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRvbUFmdGVyID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQWZ0ZXIgJiYgISgoZGVzYyA9IGRvbUFmdGVyLnBtVmlld0Rlc2MpICYmIGRlc2MucGFyZW50ID09IHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbUFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21BZnRlciA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgOiB0aGlzLnBvc0F0RW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHZhcmlvdXMgaGV1cmlzdGljcywgZmFsbGluZyBiYWNrIG9uIHRoZSBiaWFzXG4gICAgICAgIC8vIHBhcmFtZXRlciwgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwb3NpdGlvbiBhdCB0aGVcbiAgICAgICAgLy8gc3RhcnQgb3IgYXQgdGhlIGVuZCBvZiB0aGlzIHZpZXcgZGVzYy5cbiAgICAgICAgbGV0IGF0RW5kO1xuICAgICAgICBpZiAoZG9tID09IHRoaXMuZG9tICYmIHRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgYXRFbmQgPSBvZmZzZXQgPiBkb21JbmRleCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKSkge1xuICAgICAgICAgICAgYXRFbmQgPSBkb20uY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5jb250ZW50RE9NKSAmIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAwKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdEVuZCA9PSBudWxsICYmIG9mZnNldCA9PSBkb20uY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2VhcmNoID0gZG9tOzsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaCA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGF0RW5kID09IG51bGwgPyBiaWFzID4gMCA6IGF0RW5kKSA/IHRoaXMucG9zQXRFbmQgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgfVxuICAgIG5lYXJlc3REZXNjKGRvbSwgb25seU5vZGVzID0gZmFsc2UpIHtcbiAgICAgICAgZm9yIChsZXQgZmlyc3QgPSB0cnVlLCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKGN1ciksIG5vZGVET007XG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAoIW9ubHlOb2RlcyB8fCBkZXNjLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZG9tIGlzIG91dHNpZGUgb2YgdGhpcyBkZXNjJ3Mgbm9kZURPTSwgZG9uJ3QgY291bnQgaXQuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0ICYmIChub2RlRE9NID0gZGVzYy5ub2RlRE9NKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG5vZGVET00ubm9kZVR5cGUgPT0gMSA/IG5vZGVET00uY29udGFpbnMoZG9tLm5vZGVUeXBlID09IDEgPyBkb20gOiBkb20ucGFyZW50Tm9kZSkgOiBub2RlRE9NID09IGRvbSkpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREZXNjKGRvbSkge1xuICAgICAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBkZXNjOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgICAgICBpZiAoY3VyID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuICAgIHBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpIHtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IGRvbTsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmdldERlc2Moc2Nhbik7XG4gICAgICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZGVzYyBmb3IgdGhlIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIHBvcywgaWYgYW55LiAoV2hlbiBhXG4gICAgLy8gcGFyZW50IG5vZGUgb3ZlcnJvZGUgcmVuZGVyaW5nLCB0aGVyZSBtaWdodCBub3QgYmUgb25lLilcbiAgICBkZXNjQXQocG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gcG9zICYmIGVuZCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWNoaWxkLmJvcmRlciAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZGVzY0F0KHBvcyAtIG9mZnNldCAtIGNoaWxkLmJvcmRlcik7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmRvbSwgb2Zmc2V0OiAwLCBhdG9tOiBwb3MgKyAxIH07XG4gICAgICAgIC8vIEZpcnN0IGZpbmQgdGhlIHBvc2l0aW9uIGluIHRoZSBjaGlsZCBhcnJheVxuICAgICAgICBsZXQgaSA9IDAsIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGN1clBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBjdXJQb3MgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHBvcyB8fCBjaGlsZCBpbnN0YW5jZW9mIFRyYWlsaW5nSGFja1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcG9zIC0gY3VyUG9zO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgcG9pbnRzIGludG8gdGhlIG1pZGRsZSBvZiBhIGNoaWxkLCBjYWxsIHRocm91Z2hcbiAgICAgICAgaWYgKG9mZnNldClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldLmRvbUZyb21Qb3Mob2Zmc2V0IC0gdGhpcy5jaGlsZHJlbltpXS5ib3JkZXIsIHNpZGUpO1xuICAgICAgICAvLyBHbyBiYWNrIGlmIHRoZXJlIHdlcmUgYW55IHplcm8tbGVuZ3RoIHdpZGdldHMgd2l0aCBzaWRlID49IDAgYmVmb3JlIHRoaXMgcG9pbnRcbiAgICAgICAgZm9yIChsZXQgcHJldjsgaSAmJiAhKHByZXYgPSB0aGlzLmNoaWxkcmVuW2kgLSAxXSkuc2l6ZSAmJiBwcmV2IGluc3RhbmNlb2YgV2lkZ2V0Vmlld0Rlc2MgJiYgcHJldi5zaWRlID49IDA7IGktLSkgeyB9XG4gICAgICAgIC8vIFNjYW4gdG93YXJkcyB0aGUgZmlyc3QgdXNlYWJsZSBub2RlXG4gICAgICAgIGlmIChzaWRlIDw9IDApIHtcbiAgICAgICAgICAgIGxldCBwcmV2LCBlbnRlciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKDs7IGktLSwgZW50ZXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBpID8gdGhpcy5jaGlsZHJlbltpIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcHJldiB8fCBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldiAmJiBzaWRlICYmIGVudGVyICYmICFwcmV2LmJvcmRlciAmJiAhcHJldi5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2LmRvbUZyb21Qb3MocHJldi5zaXplLCBzaWRlKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBwcmV2ID8gZG9tSW5kZXgocHJldi5kb20pICsgMSA6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXh0LCBlbnRlciA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKDs7IGkrKywgZW50ZXIgPSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG5leHQgPSBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLmNoaWxkcmVuW2ldIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgZW50ZXIgJiYgIW5leHQuYm9yZGVyICYmICFuZXh0LmRvbUF0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9tRnJvbVBvcygwLCBzaWRlKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgb2Zmc2V0OiBuZXh0ID8gZG9tSW5kZXgobmV4dC5kb20pIDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlZCB0byBmaW5kIGEgRE9NIHJhbmdlIGluIGEgc2luZ2xlIHBhcmVudCBmb3IgYSBnaXZlbiBjaGFuZ2VkXG4gICAgLy8gcmFuZ2UuXG4gICAgcGFyc2VSYW5nZShmcm9tLCB0bywgYmFzZSA9IDApIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIGZyb20sIHRvLCBmcm9tT2Zmc2V0OiAwLCB0b09mZnNldDogdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoIH07XG4gICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gLTEsIHRvT2Zmc2V0ID0gLTE7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IGJhc2UsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPT0gLTEgJiYgZnJvbSA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRCYXNlID0gb2Zmc2V0ICsgY2hpbGQuYm9yZGVyO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIG1heWJlIGRlc2NlbmQgbWFyayB2aWV3cyB0byBwYXJzZSBhIG5hcnJvd2VyIHJhbmdlP1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGNoaWxkQmFzZSAmJiB0byA8PSBlbmQgLSBjaGlsZC5ib3JkZXIgJiYgY2hpbGQubm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTS5jb250YWlucyhjaGlsZC5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnBhcnNlUmFuZ2UoZnJvbSwgdG8sIGNoaWxkQmFzZSk7XG4gICAgICAgICAgICAgICAgZnJvbSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuY2hpbGRyZW5baiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5zaXplICYmIHByZXYuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFwcmV2LmVtcHR5Q2hpbGRBdCgxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU9mZnNldCA9IGRvbUluZGV4KHByZXYuZG9tKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmcm9tIC09IHByZXYuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21PZmZzZXQgPiAtMSAmJiAoZW5kID4gdG8gfHwgaSA9PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgdG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnNpemUgJiYgbmV4dC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIW5leHQuZW1wdHlDaGlsZEF0KC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9PZmZzZXQgPSBkb21JbmRleChuZXh0LmRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0byArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b09mZnNldCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdG9PZmZzZXQgPSB0aGlzLmNvbnRlbnRET00uY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldCwgdG9PZmZzZXQgfTtcbiAgICB9XG4gICAgZW1wdHlDaGlsZEF0KHNpZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9yZGVyIHx8ICF0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW3NpZGUgPCAwID8gMCA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBjaGlsZC5zaXplID09IDAgfHwgY2hpbGQuZW1wdHlDaGlsZEF0KHNpZGUpO1xuICAgIH1cbiAgICBkb21BZnRlclBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB0aGlzLmRvbUZyb21Qb3MocG9zLCAwKTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSB8fCBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhZnRlciBwb3MgXCIgKyBwb3MpO1xuICAgICAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgfVxuICAgIC8vIFZpZXcgZGVzY3MgYXJlIHJlc3BvbnNpYmxlIGZvciBzZXR0aW5nIGFueSBzZWxlY3Rpb24gdGhhdCBmYWxsc1xuICAgIC8vIGVudGlyZWx5IGluc2lkZSBvZiB0aGVtLCBzbyB0aGF0IGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgY2FuIGRvXG4gICAgLy8gY3VzdG9tIHRoaW5ncyB3aXRoIHRoZSBzZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIGZhbGxzIGFwYXJ0IHdoZW5cbiAgICAvLyBhIHNlbGVjdGlvbiBzdGFydHMgaW4gc3VjaCBhIG5vZGUgYW5kIGVuZHMgaW4gYW5vdGhlciwgaW4gd2hpY2hcbiAgICAvLyBjYXNlIHdlIGp1c3QgdXNlIHdoYXRldmVyIGRvbUZyb21Qb3MgcHJvZHVjZXMgYXMgYSBiZXN0IGVmZm9ydC5cbiAgICBzZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gZmFsbHMgZW50aXJlbHkgaW4gYSBjaGlsZCwgZ2l2ZSBpdCB0byB0aGF0IGNoaWxkXG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oYW5jaG9yLCBoZWFkKSwgdG8gPSBNYXRoLm1heChhbmNob3IsIGhlYWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IG9mZnNldCAmJiB0byA8IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuc2V0U2VsZWN0aW9uKGFuY2hvciAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgaGVhZCAtIG9mZnNldCAtIGNoaWxkLmJvcmRlciwgcm9vdCwgZm9yY2UpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbmNob3JET00gPSB0aGlzLmRvbUZyb21Qb3MoYW5jaG9yLCBhbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgaGVhZERPTSA9IGhlYWQgPT0gYW5jaG9yID8gYW5jaG9yRE9NIDogdGhpcy5kb21Gcm9tUG9zKGhlYWQsIGhlYWQgPyAtMSA6IDEpO1xuICAgICAgICBsZXQgZG9tU2VsID0gcm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IGJyS2x1ZGdlID0gZmFsc2U7XG4gICAgICAgIC8vIE9uIEZpcmVmb3gsIHVzaW5nIFNlbGVjdGlvbi5jb2xsYXBzZSB0byBwdXQgdGhlIGN1cnNvciBhZnRlciBhXG4gICAgICAgIC8vIEJSIG5vZGUgZm9yIHNvbWUgcmVhc29uIGRvZXNuJ3QgYWx3YXlzIHdvcmsgKCMxMDczKS4gT24gU2FmYXJpLFxuICAgICAgICAvLyB0aGUgY3Vyc29yIHNvbWV0aW1lcyBpbmV4cGxpY2FibGUgdmlzdWFsbHkgbGFncyBiZWhpbmQgaXRzXG4gICAgICAgIC8vIHJlcG9ydGVkIHBvc2l0aW9uIGluIHN1Y2ggc2l0dWF0aW9ucyAoIzEwOTIpLlxuICAgICAgICBpZiAoKGdlY2tvIHx8IHNhZmFyaSkgJiYgYW5jaG9yID09IGhlYWQpIHtcbiAgICAgICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gYW5jaG9yRE9NO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgIGJyS2x1ZGdlID0gISEob2Zmc2V0ICYmIG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdID09IFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIC8vIElzc3VlICMxMTI4XG4gICAgICAgICAgICAgICAgaWYgKGJyS2x1ZGdlICYmIG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIGFmdGVyOyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIgPSBzY2FuLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFmdGVyLm5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yRE9NID0gaGVhZERPTSA9IHsgbm9kZTogYWZ0ZXIucGFyZW50Tm9kZSwgb2Zmc2V0OiBkb21JbmRleChhZnRlcikgKyAxIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IHNjYW4ucG1WaWV3RGVzYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGJyS2x1ZGdlID0gcHJldiAmJiAocHJldi5ub2RlTmFtZSA9PSBcIkJSXCIgfHwgcHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJlZm94IGNhbiBhY3Qgc3RyYW5nZWx5IHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBmcm9udCBvZiBhblxuICAgICAgICAvLyB1bmVkaXRhYmxlIG5vZGUuIFNlZSAjMTE2MyBhbmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTcwOTUzNlxuICAgICAgICBpZiAoZ2Vja28gJiYgZG9tU2VsLmZvY3VzTm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlICE9IGhlYWRET00ubm9kZSAmJiBkb21TZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGRvbVNlbC5mb2N1c05vZGUuY2hpbGROb2Rlc1tkb21TZWwuZm9jdXNPZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZvcmNlIHx8IGJyS2x1ZGdlICYmIHNhZmFyaSkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQsIGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFNlbGVjdGlvbi5leHRlbmQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuICdpbnZlcnRlZCcgc2VsZWN0aW9uXG4gICAgICAgIC8vIChvbmUgd2hlcmUgdGhlIGZvY3VzIGlzIGJlZm9yZSB0aGUgYW5jaG9yKSwgYnV0IG5vdCBhbGxcbiAgICAgICAgLy8gYnJvd3NlcnMgc3VwcG9ydCBpdCB5ZXQuXG4gICAgICAgIGxldCBkb21TZWxFeHRlbmRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKGRvbVNlbC5leHRlbmQgfHwgYW5jaG9yID09IGhlYWQpICYmICFicktsdWRnZSkge1xuICAgICAgICAgICAgZG9tU2VsLmNvbGxhcHNlKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciAhPSBoZWFkKVxuICAgICAgICAgICAgICAgICAgICBkb21TZWwuZXh0ZW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGRvbVNlbEV4dGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB3aXRoIENocm9tZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFmdGVyIGNhbGxpbmdcbiAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZSwgZXZlbiB3aGVuIGl0IHNob3VsZCBiZSB2YWxpZC4gVGhpcyBhcHBlYXJzIHRvIGJlIGEgYnVnLCBidXRcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBkaWZmaWN1bHQgdG8gaXNvbGF0ZS4gSWYgdGhpcyBoYXBwZW5zIGZhbGxiYWNrIHRvIHRoZSBvbGQgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgdXNpbmcgZXh0ZW5kLlxuICAgICAgICAgICAgICAgIC8vIFNpbWlsYXJseSwgdGhpcyBjb3VsZCBjcmFzaCBvbiBTYWZhcmkgaWYgdGhlIGVkaXRvciBpcyBoaWRkZW4sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIHdhcyBubyBzZWxlY3Rpb24uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb21TZWxFeHRlbmRlZCkge1xuICAgICAgICAgICAgaWYgKGFuY2hvciA+IGhlYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wID0gYW5jaG9yRE9NO1xuICAgICAgICAgICAgICAgIGFuY2hvckRPTSA9IGhlYWRET007XG4gICAgICAgICAgICAgICAgaGVhZERPTSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQoaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICBkb21TZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb250ZW50RE9NICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRMb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NICYmIHRoaXMuY29udGVudERPTSAhPSB0aGlzLmRvbSAmJiAhdGhpcy5kb20uY29udGFpbnModGhpcy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGEgc3VidHJlZSBvZiB0aGUgZWxlbWVudCB0cmVlIHRoYXQgaGFzIGJlZW4gdG91Y2hlZFxuICAgIC8vIGJ5IGEgRE9NIGNoYW5nZSwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCByZWRyYXcgaXQuXG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IG9mZnNldCA9IDAsIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gZW5kID8gZnJvbSA8PSBlbmQgJiYgdG8gPj0gb2Zmc2V0IDogZnJvbSA8IGVuZCAmJiB0byA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluc2lkZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlciwgZW5kSW5zaWRlID0gZW5kIC0gY2hpbGQuYm9yZGVyO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHN0YXJ0SW5zaWRlICYmIHRvIDw9IGVuZEluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZnJvbSA9PSBvZmZzZXQgfHwgdG8gPT0gZW5kID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSBzdGFydEluc2lkZSAmJiB0byA9PSBlbmRJbnNpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGlsZC5jb250ZW50TG9zdCB8fCBjaGlsZC5kb20ucGFyZW50Tm9kZSAhPSB0aGlzLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBOT0RFX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5tYXJrRGlydHkoZnJvbSAtIHN0YXJ0SW5zaWRlLCB0byAtIHN0YXJ0SW5zaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00gJiYgIWNoaWxkLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBDT05URU5UX0RJUlRZIDogTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJ0eSA9IENPTlRFTlRfRElSVFk7XG4gICAgfVxuICAgIG1hcmtQYXJlbnRzRGlydHkoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IDE7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSB0aGlzLnBhcmVudDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50LCBsZXZlbCsrKSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSBsZXZlbCA9PSAxID8gQ09OVEVOVF9ESVJUWSA6IENISUxEX0RJUlRZO1xuICAgICAgICAgICAgaWYgKG5vZGUuZGlydHkgPCBkaXJ0eSlcbiAgICAgICAgICAgICAgICBub2RlLmRpcnR5ID0gZGlydHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpZ25vcmVGb3JDb29yZHMoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLy8gQSB3aWRnZXQgZGVzYyByZXByZXNlbnRzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGVcbi8vIGRyYXduIGJldHdlZW4gdGhlIGRvY3VtZW50IG5vZGVzLlxuY2xhc3MgV2lkZ2V0Vmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgc2VsZiwgZG9tID0gd2lkZ2V0LnR5cGUudG9ET007XG4gICAgICAgIGlmICh0eXBlb2YgZG9tID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGRvbSA9IGRvbSh2aWV3LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGFyZW50LnBvc0JlZm9yZUNoaWxkKHNlbGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICghd2lkZ2V0LnR5cGUuc3BlYy5yYXcpIHtcbiAgICAgICAgICAgIGlmIChkb20ubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci13aWRnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICB9XG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHdpZGdldC50eXBlLmVxKHRoaXMud2lkZ2V0LnR5cGUpO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBzdG9wID0gdGhpcy53aWRnZXQuc3BlYy5zdG9wRXZlbnQ7XG4gICAgICAgIHJldHVybiBzdG9wID8gc3RvcChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIiB8fCB0aGlzLndpZGdldC5zcGVjLmlnbm9yZVNlbGVjdGlvbjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy53aWRnZXQudHlwZS5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgc2lkZSgpIHsgcmV0dXJuIHRoaXMud2lkZ2V0LnR5cGUuc2lkZTsgfVxufVxuY2xhc3MgQ29tcG9zaXRpb25WaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGRvbSwgdGV4dERPTSwgdGV4dCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICB0aGlzLnRleHRET00gPSB0ZXh0RE9NO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKGRvbSAhPSB0aGlzLnRleHRET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgKG9mZnNldCA/IHRoaXMuc2l6ZSA6IDApO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgb2Zmc2V0O1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLnRleHRET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dCkge1xuICAgICAgICByZXR1cm4gbXV0LnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWU7XG4gICAgfVxufVxuLy8gQSBtYXJrIGRlc2MgcmVwcmVzZW50cyBhIG1hcmsuIE1heSBoYXZlIG11bHRpcGxlIGNoaWxkcmVuLFxuLy8gZGVwZW5kaW5nIG9uIGhvdyB0aGUgbWFyayBpcyBzcGxpdC4gTm90ZSB0aGF0IG1hcmtzIGFyZSBkcmF3biB1c2luZ1xuLy8gYSBmaXhlZCBuZXN0aW5nIG9yZGVyLCBmb3Igc2ltcGxpY2l0eSBhbmQgcHJlZGljdGFiaWxpdHksIHNvIGluXG4vLyBzb21lIGNhc2VzIHRoZXkgd2lsbCBiZSBzcGxpdCBtb3JlIG9mdGVuIHRoYW4gd291bGQgYXBwZWFyXG4vLyBuZWNlc3NhcnkuXG5jbGFzcyBNYXJrVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBtYXJrLCBkb20sIGNvbnRlbnRET00pIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBjb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG1hcmssIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQgY3VzdG9tID0gdmlldy5ub2RlVmlld3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgICBsZXQgc3BlYyA9IGN1c3RvbSAmJiBjdXN0b20obWFyaywgdmlldywgaW5saW5lKTtcbiAgICAgICAgaWYgKCFzcGVjIHx8ICFzcGVjLmRvbSlcbiAgICAgICAgICAgIHNwZWMgPSBET01TZXJpYWxpemVyLnJlbmRlclNwZWMoZG9jdW1lbnQsIG1hcmsudHlwZS5zcGVjLnRvRE9NKG1hcmssIGlubGluZSkpO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3RGVzYyhwYXJlbnQsIG1hcmssIHNwZWMuZG9tLCBzcGVjLmNvbnRlbnRET00gfHwgc3BlYy5kb20pO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7XG4gICAgICAgIGlmICgodGhpcy5kaXJ0eSAmIE5PREVfRElSVFkpIHx8IHRoaXMubWFyay50eXBlLnNwZWMucmVwYXJzZUluVmlldylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4geyBtYXJrOiB0aGlzLm1hcmsudHlwZS5uYW1lLCBhdHRyczogdGhpcy5tYXJrLmF0dHJzLCBjb250ZW50RWxlbWVudDogdGhpcy5jb250ZW50RE9NIHx8IHVuZGVmaW5lZCB9O1xuICAgIH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiB0aGlzLmRpcnR5ICE9IE5PREVfRElSVFkgJiYgdGhpcy5tYXJrLmVxKG1hcmspOyB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIC8vIE1vdmUgZGlydHkgaW5mbyB0byBuZWFyZXN0IG5vZGUgdmlld1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICghcGFyZW50Lm5vZGUpXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZGlydHkgPCB0aGlzLmRpcnR5KVxuICAgICAgICAgICAgICAgIHBhcmVudC5kaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBjb3B5ID0gTWFya1ZpZXdEZXNjLmNyZWF0ZSh0aGlzLnBhcmVudCwgdGhpcy5tYXJrLCB0cnVlLCB2aWV3KTtcbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5jaGlsZHJlbiwgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHRvIDwgc2l6ZSlcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCB0bywgc2l6ZSwgdmlldyk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCAwLCBmcm9tLCB2aWV3KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVzW2ldLnBhcmVudCA9IGNvcHk7XG4gICAgICAgIGNvcHkuY2hpbGRyZW4gPSBub2RlcztcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuLy8gTm9kZSB2aWV3IGRlc2NzIGFyZSB0aGUgbWFpbiwgbW9zdCBjb21tb24gdHlwZSBvZiB2aWV3IGRlc2MsIGFuZFxuLy8gY29ycmVzcG9uZCB0byBhbiBhY3R1YWwgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFVubGlrZSBtYXJrIGRlc2NzLFxuLy8gdGhleSBwb3B1bGF0ZSB0aGVpciBjaGlsZCBhcnJheSB0aGVtc2VsdmVzLlxuY2xhc3MgTm9kZVZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgdGhpcy5ub2RlRE9NID0gbm9kZURPTTtcbiAgICB9XG4gICAgLy8gQnkgZGVmYXVsdCwgYSBub2RlIGlzIHJlbmRlcmVkIHVzaW5nIHRoZSBgdG9ET01gIG1ldGhvZCBmcm9tIHRoZVxuICAgIC8vIG5vZGUgdHlwZSBzcGVjLiBCdXQgY2xpZW50IGNvZGUgY2FuIHVzZSB0aGUgYG5vZGVWaWV3c2Agc3BlYyB0b1xuICAgIC8vIHN1cHBseSBhIGN1c3RvbSBub2RlIHZpZXcsIHdoaWNoIGNhbiBpbmZsdWVuY2UgdmFyaW91cyBhc3BlY3RzIG9mXG4gICAgLy8gdGhlIHdheSB0aGUgbm9kZSB3b3Jrcy5cbiAgICAvL1xuICAgIC8vIChVc2luZyBzdWJjbGFzc2luZyBmb3IgdGhpcyB3YXMgaW50ZW50aW9uYWxseSBkZWNpZGVkIGFnYWluc3QsXG4gICAgLy8gc2luY2UgaXQnZCByZXF1aXJlIGV4cG9zaW5nIGEgd2hvbGUgc2xldyBvZiBmaW5pY2t5XG4gICAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscyB0byB0aGUgdXNlciBjb2RlIHRoYXQgdGhleSBwcm9iYWJseSB3aWxsXG4gICAgLy8gbmV2ZXIgbmVlZC4pXG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW25vZGUudHlwZS5uYW1lXSwgZGVzY09iajtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG5vZGUsIHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIChUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGN1c3RvbSB2aWV3IHRvIGZpbmQgaXRzXG4gICAgICAgICAgICAvLyBvd24gcG9zaXRpb24pXG4gICAgICAgICAgICBpZiAoIWRlc2NPYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIGlmIChkZXNjT2JqLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY09iai5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoZGVzY09iaik7XG4gICAgICAgIH0sIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgbGV0IGRvbSA9IHNwZWMgJiYgc3BlYy5kb20sIGNvbnRlbnRET00gPSBzcGVjICYmIHNwZWMuY29udGVudERPTTtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRvbSlcbiAgICAgICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLnRleHQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlICE9IDMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXh0IG11c3QgYmUgcmVuZGVyZWQgYXMgYSBET00gdGV4dCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkb20pIHtcbiAgICAgICAgICAgICh7IGRvbSwgY29udGVudERPTSB9ID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBub2RlLnR5cGUuc3BlYy50b0RPTShub2RlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGVudERPTSAmJiAhbm9kZS5pc1RleHQgJiYgZG9tLm5vZGVOYW1lICE9IFwiQlJcIikgeyAvLyBDaHJvbWUgZ2V0cyBjb25mdXNlZCBieSA8YnIgY29udGVudGVkaXRhYmxlPWZhbHNlPlxuICAgICAgICAgICAgaWYgKCFkb20uaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIGRvbS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlRE9NID0gZG9tO1xuICAgICAgICBkb20gPSBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgbm9kZSk7XG4gICAgICAgIGlmIChzcGVjKVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NPYmogPSBuZXcgQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgdmlldywgcG9zICsgMSk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgLy8gRXhwZXJpbWVudGFsIGtsdWRnZSB0byBhbGxvdyBvcHQtaW4gcmUtcGFyc2luZyBvZiBub2Rlc1xuICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUuc3BlYy5yZXBhcnNlSW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEZJWE1FIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBjYW4gYWx3YXlzIHJldHVybiB0aGUgY3VycmVudFxuICAgICAgICAvLyBhdHRycyBtZWFucyB0aGF0IGlmIHRoZSB1c2VyIHNvbWVob3cgbWFuYWdlcyB0byBjaGFuZ2UgdGhlXG4gICAgICAgIC8vIGF0dHJzIGluIHRoZSBkb20sIHRoYXQgd29uJ3QgYmUgcGlja2VkIHVwLiBOb3QgZW50aXJlbHkgc3VyZVxuICAgICAgICAvLyB3aGV0aGVyIHRoaXMgaXMgYSBwcm9ibGVtXG4gICAgICAgIGxldCBydWxlID0geyBub2RlOiB0aGlzLm5vZGUudHlwZS5uYW1lLCBhdHRyczogdGhpcy5ub2RlLmF0dHJzIH07XG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIpXG4gICAgICAgICAgICBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSA9IFwiZnVsbFwiO1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50ID0gKCkgPT4gdGhpcy5ub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudExvc3QpIHtcbiAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSB0aGlzLmNvbnRlbnRET007XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgbGlrZXMgdG8gcmFuZG9tbHkgcmVjcmVhdGUgcGFyZW50IG5vZGVzIHdoZW5cbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIHRoaW5ncy4gV2hlbiB0aGF0IGhhcHBlbnMsIHRoaXMgdHJpZXMgdG8gZmluZCB0aGVcbiAgICAgICAgICAgIC8vIG5ldyBwYXJlbnQuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKGNoaWxkLmRvbS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLmNvbnRlbnRFbGVtZW50ID0gY2hpbGQuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gICAgbWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIG5vZGUuZXEodGhpcy5ub2RlKSAmJlxuICAgICAgICAgICAgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSAmJiBpbm5lckRlY28uZXEodGhpcy5pbm5lckRlY28pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTsgfVxuICAgIGdldCBib3JkZXIoKSB7IHJldHVybiB0aGlzLm5vZGUuaXNMZWFmID8gMCA6IDE7IH1cbiAgICAvLyBTeW5jcyBgdGhpcy5jaGlsZHJlbmAgdG8gbWF0Y2ggYHRoaXMubm9kZS5jb250ZW50YCBhbmQgdGhlIGxvY2FsXG4gICAgLy8gZGVjb3JhdGlvbnMsIHBvc3NpYmx5IGludHJvZHVjaW5nIG5lc3RpbmcgZm9yIG1hcmtzLiBUaGVuLCBpbiBhXG4gICAgLy8gc2VwYXJhdGUgc3RlcCwgc3luY3MgdGhlIERPTSBpbnNpZGUgYHRoaXMuY29udGVudERPTWAgdG9cbiAgICAvLyBgdGhpcy5jaGlsZHJlbmAuXG4gICAgdXBkYXRlQ2hpbGRyZW4odmlldywgcG9zKSB7XG4gICAgICAgIGxldCBpbmxpbmUgPSB0aGlzLm5vZGUuaW5saW5lQ29udGVudCwgb2ZmID0gcG9zO1xuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSB2aWV3LmNvbXBvc2luZyA/IHRoaXMubG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSA6IG51bGw7XG4gICAgICAgIGxldCBsb2NhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zID4gLTEgPyBjb21wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbkluQ2hpbGQgPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPCAwO1xuICAgICAgICBsZXQgdXBkYXRlciA9IG5ldyBWaWV3VHJlZVVwZGF0ZXIodGhpcywgbG9jYWxDb21wb3NpdGlvbiAmJiBsb2NhbENvbXBvc2l0aW9uLm5vZGUsIHZpZXcpO1xuICAgICAgICBpdGVyRGVjbyh0aGlzLm5vZGUsIHRoaXMuaW5uZXJEZWNvLCAod2lkZ2V0LCBpLCBpbnNpZGVOb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0LnNwZWMubWFya3MpXG4gICAgICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyh3aWRnZXQuc3BlYy5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHdpZGdldC50eXBlLnNpZGUgPj0gMCAmJiAhaW5zaWRlTm9kZSlcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGkgPT0gdGhpcy5ub2RlLmNoaWxkQ291bnQgPyBNYXJrLm5vbmUgOiB0aGlzLm5vZGUuY2hpbGQoaSkubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGEgZGVzYyBtYXRjaGluZyB0aGlzIHdpZGdldCwgcmV1c2UgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaW5zZXJ0IHRoZSB3aWRnZXQgYXMgYSBuZXcgdmlldyBkZXNjLlxuICAgICAgICAgICAgdXBkYXRlci5wbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIG9mZik7XG4gICAgICAgIH0sIChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgd3JhcHBpbmcgbWFyayBkZXNjcyBtYXRjaCB0aGUgbm9kZSdzIG1hcmtzLlxuICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhjaGlsZC5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIC8vIFRyeSBzZXZlcmFsIHN0cmF0ZWdpZXMgZm9yIGRyYXdpbmcgdGhpcyBub2RlXG4gICAgICAgICAgICBsZXQgY29tcEluZGV4O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXIuZmluZE5vZGVNYXRjaChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb3NpdGlvbkluQ2hpbGQgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+IG9mZiAmJlxuICAgICAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDwgb2ZmICsgY2hpbGQubm9kZVNpemUgJiZcbiAgICAgICAgICAgICAgICAoY29tcEluZGV4ID0gdXBkYXRlci5maW5kSW5kZXhXaXRoQ2hpbGQoY29tcG9zaXRpb24ubm9kZSkpID4gLTEgJiZcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnVwZGF0ZU5vZGVBdChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGNvbXBJbmRleCwgdmlldykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZXIudXBkYXRlTmV4dE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpLCBvZmYpKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgYXMgYSBuZXcgdmlld1xuICAgICAgICAgICAgICAgIHVwZGF0ZXIuYWRkTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIG9mZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEcm9wIGFsbCByZW1haW5pbmcgZGVzY3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoW10sIGlubGluZSwgdmlldyk7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICB1cGRhdGVyLmFkZFRleHRibG9ja0hhY2tzKCk7XG4gICAgICAgIHVwZGF0ZXIuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgLy8gU3luYyB0aGUgRE9NIGlmIGFueXRoaW5nIGNoYW5nZWRcbiAgICAgICAgaWYgKHVwZGF0ZXIuY2hhbmdlZCB8fCB0aGlzLmRpcnR5ID09IENPTlRFTlRfRElSVFkpIHtcbiAgICAgICAgICAgIC8vIE1heSBoYXZlIHRvIHByb3RlY3QgZm9jdXNlZCBET00gZnJvbSBiZWluZyBjaGFuZ2VkIGlmIGEgY29tcG9zaXRpb24gaXMgYWN0aXZlXG4gICAgICAgICAgICBpZiAobG9jYWxDb21wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIGxvY2FsQ29tcG9zaXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3ModGhpcy5jb250ZW50RE9NLCB0aGlzLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGlmIChpb3MpXG4gICAgICAgICAgICAgICAgaW9zSGFja3ModGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykge1xuICAgICAgICAvLyBPbmx5IGRvIHNvbWV0aGluZyBpZiBib3RoIHRoZSBzZWxlY3Rpb24gYW5kIGEgZm9jdXNlZCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYXJlIGluc2lkZSBvZiB0aGlzIG5vZGVcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8IGZyb20gPCBwb3MgfHwgdG8gPiBwb3MgKyB0aGlzLm5vZGUuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCB0ZXh0Tm9kZSA9IG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgIGlmICghdGV4dE5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKHRleHROb2RlLnBhcmVudE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdGV4dCBpbiB0aGUgZm9jdXNlZCBub2RlIGluIHRoZSBub2RlLCBzdG9wIGlmIGl0J3Mgbm90XG4gICAgICAgICAgICAvLyB0aGVyZSAobWF5IGhhdmUgYmVlbiBtb2RpZmllZCB0aHJvdWdoIG90aGVyIG1lYW5zLCBpbiB3aGljaFxuICAgICAgICAgICAgLy8gY2FzZSBpdCBzaG91bGQgb3ZlcndyaXR0ZW4pXG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIGxldCB0ZXh0UG9zID0gZmluZFRleHRJbkZyYWdtZW50KHRoaXMubm9kZS5jb250ZW50LCB0ZXh0LCBmcm9tIC0gcG9zLCB0byAtIHBvcyk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFBvcyA8IDAgPyBudWxsIDogeyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiB0ZXh0UG9zLCB0ZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0ZXh0Tm9kZSwgcG9zOiAtMSwgdGV4dDogXCJcIiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIHsgbm9kZSwgcG9zLCB0ZXh0IH0pIHtcbiAgICAgICAgLy8gVGhlIG5vZGUgaXMgYWxyZWFkeSBwYXJ0IG9mIGEgbG9jYWwgdmlldyBkZXNjLCBsZWF2ZSBpdCB0aGVyZVxuICAgICAgICBpZiAodGhpcy5nZXREZXNjKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb21wb3NpdGlvbiB2aWV3IGZvciB0aGUgb3JwaGFuZWQgbm9kZXNcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBub2RlO1xuICAgICAgICBmb3IgKDs7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0b3BOb2RlLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b3BOb2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICB3aGlsZSAodG9wTm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVzYyA9IG5ldyBDb21wb3NpdGlvblZpZXdEZXNjKHRoaXMsIHRvcE5vZGUsIG5vZGUsIHRleHQpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucHVzaChkZXNjKTtcbiAgICAgICAgLy8gUGF0Y2ggdXAgdGhpcy5jaGlsZHJlbiB0byBjb250YWluIHRoZSBjb21wb3NpdGlvbiB2aWV3XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSByZXBsYWNlTm9kZXModGhpcy5jaGlsZHJlbiwgcG9zLCBwb3MgKyB0ZXh0Lmxlbmd0aCwgdmlldywgZGVzYyk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgZGVzYyBtdXN0IGJlIHVwZGF0ZWQgdG8gbWF0Y2ggdGhlIGdpdmVuIG5vZGUgZGVjb3JhdGlvbixcbiAgICAvLyBkbyBzbyBhbmQgcmV0dXJuIHRydWUuXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHxcbiAgICAgICAgICAgICFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1cGRhdGVJbm5lcihub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4odmlldywgdGhpcy5wb3NBdFN0YXJ0KTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICB9XG4gICAgdXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbykge1xuICAgICAgICBpZiAoc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG5lZWRzV3JhcCA9IHRoaXMubm9kZURPTS5ub2RlVHlwZSAhPSAxO1xuICAgICAgICBsZXQgb2xkRE9NID0gdGhpcy5kb207XG4gICAgICAgIHRoaXMuZG9tID0gcGF0Y2hPdXRlckRlY28odGhpcy5kb20sIHRoaXMubm9kZURPTSwgY29tcHV0ZU91dGVyRGVjbyh0aGlzLm91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApLCBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5ub2RlLCBuZWVkc1dyYXApKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9IG9sZERPTSkge1xuICAgICAgICAgICAgb2xkRE9NLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dGVyRGVjbyA9IG91dGVyRGVjbztcbiAgICB9XG4gICAgLy8gTWFyayB0aGlzIG5vZGUgYXMgYmVpbmcgdGhlIHNlbGVjdGVkIG5vZGUuXG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgdGhpcy5kb20uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGUgbWFya2luZyBmcm9tIHRoaXMgbm9kZS5cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlXCIpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0aGlzLm5vZGUuaXNBdG9tOyB9XG59XG4vLyBDcmVhdGUgYSB2aWV3IGRlc2MgZm9yIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgbm9kZSwgdG8gYmUgZXhwb3J0ZWRcbi8vIGFuZCB1c2VkIGJ5IHRoZSB2aWV3IGNsYXNzLlxuZnVuY3Rpb24gZG9jVmlld0Rlc2MoZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCB2aWV3KSB7XG4gICAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gICAgbGV0IGRvY1ZpZXcgPSBuZXcgTm9kZVZpZXdEZXNjKHVuZGVmaW5lZCwgZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBkb20sIGRvbSwgdmlldywgMCk7XG4gICAgaWYgKGRvY1ZpZXcuY29udGVudERPTSlcbiAgICAgICAgZG9jVmlldy51cGRhdGVDaGlsZHJlbih2aWV3LCAwKTtcbiAgICByZXR1cm4gZG9jVmlldztcbn1cbmNsYXNzIFRleHRWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbnVsbCwgbm9kZURPTSwgdmlldywgMCk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgbGV0IHNraXAgPSB0aGlzLm5vZGVET00ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKHNraXAgJiYgc2tpcCAhPSB0aGlzLmRvbSAmJiAhc2tpcC5wbUlzRGVjbylcbiAgICAgICAgICAgIHNraXAgPSBza2lwLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiB7IHNraXA6IChza2lwIHx8IHRydWUpIH07XG4gICAgfVxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpKSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZIHx8IG5vZGUudGV4dCAhPSB0aGlzLm5vZGUudGV4dCkgJiYgbm9kZS50ZXh0ICE9IHRoaXMubm9kZURPTS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5ub2RlVmFsdWUgPSBub2RlLnRleHQ7XG4gICAgICAgICAgICBpZiAodmlldy50cmFja1dyaXRlcyA9PSB0aGlzLm5vZGVET00pXG4gICAgICAgICAgICAgICAgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50RE9NID0gdGhpcy5wYXJlbnQuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgbiA9IHRoaXMubm9kZURPTTsgbjsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGlmIChuID09IHBhcmVudERPTSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLm5vZGVET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyBNYXRoLm1pbihvZmZzZXQsIHRoaXMubm9kZS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcImNoYXJhY3RlckRhdGFcIiAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHRoaXMucGFyZW50LCBub2RlLCB0aGlzLm91dGVyRGVjbywgdGhpcy5pbm5lckRlY28sIGRvbSwgZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSB0aGlzLm5vZGVET00gJiYgKGZyb20gPT0gMCB8fCB0byA9PSB0aGlzLm5vZGVET00ubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLy8gQSBkdW1teSBkZXNjIHVzZWQgdG8gdGFnIHRyYWlsaW5nIEJSIG9yIElNRyBub2RlcyBjcmVhdGVkIHRvIHdvcmtcbi8vIGFyb3VuZCBjb250ZW50RWRpdGFibGUgdGVycmlibGVuZXNzLlxuY2xhc3MgVHJhaWxpbmdIYWNrVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIG1hdGNoZXNIYWNrKG5vZGVOYW1lKSB7IHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBub2RlTmFtZTsgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpZ25vcmVGb3JDb29yZHMoKSB7IHJldHVybiB0aGlzLmRvbS5ub2RlTmFtZSA9PSBcIklNR1wiOyB9XG59XG4vLyBBIHNlcGFyYXRlIHN1YmNsYXNzIGlzIHVzZWQgZm9yIGN1c3RvbWl6ZWQgbm9kZSB2aWV3cywgc28gdGhhdCB0aGVcbi8vIGV4dHJhIGNoZWNrcyBvbmx5IGhhdmUgdG8gYmUgbWFkZSBmb3Igbm9kZXMgdGhhdCBhcmUgYWN0dWFsbHlcbi8vIGN1c3RvbWl6ZWQuXG5jbGFzcyBDdXN0b21Ob2RlVmlld0Rlc2MgZXh0ZW5kcyBOb2RlVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgc3BlYywgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgLy8gQSBjdXN0b20gYHVwZGF0ZWAgbWV0aG9kIGdldHMgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHVwZGF0ZSBnb2VzXG4gICAgLy8gdGhyb3VnaC4gSWYgaXQgZG9lcywgYW5kIHRoZXJlJ3MgYSBgY29udGVudERPTWAgbm9kZSwgb3VyIGxvZ2ljXG4gICAgLy8gdXBkYXRlcyB0aGUgY2hpbGRyZW4uXG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNwZWMudXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zcGVjLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50RE9NICYmICFub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuc2VsZWN0Tm9kZSgpIDogc3VwZXIuc2VsZWN0Tm9kZSgpO1xuICAgIH1cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlKCkgOiBzdXBlci5kZXNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgcm9vdCwgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNldFNlbGVjdGlvbiA/IHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290KVxuICAgICAgICAgICAgOiBzdXBlci5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCByb290LCBmb3JjZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuc3RvcEV2ZW50ID8gdGhpcy5zcGVjLnN0b3BFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBzdXBlci5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgfVxufVxuLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgd2l0aCB0aGUgbm9kZXMgYXNzb2NpYXRlZFxuLy8gd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmlldyBkZXNjcywgcmVjdXJzaW5nIGludG8gbWFyayBkZXNjc1xuLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBzeW5jIHRoZSBzdWJ0cmVlIGZvciBhIHdob2xlIG5vZGUgYXQgYSB0aW1lLlxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICAgIGxldCBkb20gPSBwYXJlbnRET00uZmlyc3RDaGlsZCwgd3JpdHRlbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkZXNjc1tpXSwgY2hpbGRET00gPSBkZXNjLmRvbTtcbiAgICAgICAgaWYgKGNoaWxkRE9NLnBhcmVudE5vZGUgPT0gcGFyZW50RE9NKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRET00gIT0gZG9tKSB7XG4gICAgICAgICAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShjaGlsZERPTSwgZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvbSA/IGRvbS5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnRET00ubGFzdENoaWxkO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3MoZGVzYy5jb250ZW50RE9NLCBkZXNjLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGRvbSA9IHBvcyA/IHBvcy5uZXh0U2libGluZyA6IHBhcmVudERPTS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh3cml0dGVuICYmIHZpZXcudHJhY2tXcml0ZXMgPT0gcGFyZW50RE9NKVxuICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbn1cbmNvbnN0IE91dGVyRGVjb0xldmVsID0gZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gICAgaWYgKG5vZGVOYW1lKVxuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG59O1xuT3V0ZXJEZWNvTGV2ZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG5vRGVjbyA9IFtuZXcgT3V0ZXJEZWNvTGV2ZWxdO1xuZnVuY3Rpb24gY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIG5vZGUsIG5lZWRzV3JhcCkge1xuICAgIGlmIChvdXRlckRlY28ubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBub0RlY287XG4gICAgbGV0IHRvcCA9IG5lZWRzV3JhcCA/IG5vRGVjb1swXSA6IG5ldyBPdXRlckRlY29MZXZlbCwgcmVzdWx0ID0gW3RvcF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRlckRlY28ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHJzID0gb3V0ZXJEZWNvW2ldLnR5cGUuYXR0cnM7XG4gICAgICAgIGlmICghYXR0cnMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGF0dHJzLm5vZGVOYW1lKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKGF0dHJzLm5vZGVOYW1lKSk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZWVkc1dyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvcCA9IG5ldyBPdXRlckRlY29MZXZlbChub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgdG9wLmNsYXNzID0gKHRvcC5jbGFzcyA/IHRvcC5jbGFzcyArIFwiIFwiIDogXCJcIikgKyB2YWw7XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICB0b3Auc3R5bGUgPSAodG9wLnN0eWxlID8gdG9wLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgIHRvcFtuYW1lXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0Y2hPdXRlckRlY28ob3V0ZXJET00sIG5vZGVET00sIHByZXZDb21wdXRlZCwgY3VyQ29tcHV0ZWQpIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgdHJpdmlhbCBjYXNlXG4gICAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKVxuICAgICAgICByZXR1cm4gbm9kZURPTTtcbiAgICBsZXQgY3VyRE9NID0gbm9kZURPTTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ckNvbXB1dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlTmFtZSA9PSBkZWNvLm5vZGVOYW1lICYmIGN1ckRPTSAhPSBvdXRlckRPTSAmJlxuICAgICAgICAgICAgICAgIChwYXJlbnQgPSBjdXJET00ucGFyZW50Tm9kZSkgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVjby5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50LnBtSXNEZWNvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9EZWNvWzBdO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gICAgfVxuICAgIHJldHVybiBjdXJET007XG59XG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiAhKG5hbWUgaW4gY3VyKSlcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBjdXIpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiBjdXJbbmFtZV0gIT0gcHJldltuYW1lXSlcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgY3VyW25hbWVdKTtcbiAgICBpZiAocHJldi5jbGFzcyAhPSBjdXIuY2xhc3MpIHtcbiAgICAgICAgbGV0IHByZXZMaXN0ID0gcHJldi5jbGFzcyA/IHByZXYuY2xhc3Muc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBsZXQgY3VyTGlzdCA9IGN1ci5jbGFzcyA/IGN1ci5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY3VyTGlzdC5pbmRleE9mKHByZXZMaXN0W2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwcmV2TGlzdC5pbmRleE9mKGN1ckxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKGN1ckxpc3RbaV0pO1xuICAgICAgICBpZiAoZG9tLmNsYXNzTGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHByZXYuc3R5bGUgIT0gY3VyLnN0eWxlKSB7XG4gICAgICAgIGlmIChwcmV2LnN0eWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IC9cXHMqKFtcXHdcXC1cXHhhMS1cXHVmZmZmXSspXFxzKjooPzpcIig/OlxcXFwufFteXCJdKSpcInwnKD86XFxcXC58W14nXSkqJ3xcXCguKj9cXCl8W147XSkqL2csIG07XG4gICAgICAgICAgICB3aGlsZSAobSA9IHByb3AuZXhlYyhwcmV2LnN0eWxlKSlcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5zdHlsZSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ICs9IGN1ci5zdHlsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseU91dGVyRGVjbyhkb20sIGRlY28sIG5vZGUpIHtcbiAgICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpO1xufVxuZnVuY3Rpb24gc2FtZU91dGVyRGVjbyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0udHlwZS5lcShiW2ldLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0oZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8vIEhlbHBlciBjbGFzcyBmb3IgaW5jcmVtZW50YWxseSB1cGRhdGluZyBhIHRyZWUgb2YgbWFyayBkZXNjcyBhbmRcbi8vIHRoZSB3aWRnZXQgYW5kIG5vZGUgZGVzY3MgaW5zaWRlIG9mIHRoZW0uXG5jbGFzcyBWaWV3VHJlZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgbG9jaywgdmlldykge1xuICAgICAgICB0aGlzLmxvY2sgPSBsb2NrO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAvLyBJbmRleCBpbnRvIGB0aGlzLnRvcGAncyBjaGlsZCBhcnJheSwgcmVwcmVzZW50cyB0aGUgY3VycmVudFxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBXaGVuIGVudGVyaW5nIGEgbWFyaywgdGhlIGN1cnJlbnQgdG9wIGFuZCBpbmRleCBhcmUgcHVzaGVkXG4gICAgICAgIC8vIG9udG8gdGhpcy5cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciBhbnl0aGluZyB3YXMgY2hhbmdlZFxuICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMucHJlTWF0Y2ggPSBwcmVNYXRjaCh0b3Aubm9kZS5jb250ZW50LCB0b3ApO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFuZCByZW1vdmUgdGhlIGNoaWxkcmVuIGJldHdlZW4gdGhlIGdpdmVuIGluZGljZXMgaW5cbiAgICAvLyBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lCZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFsbCByZW1haW5pbmcgY2hpbGRyZW4gaW4gYHRoaXMudG9wYC5cbiAgICBkZXN0cm95UmVzdCgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hcmsgZGVzY3Mgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2ZcbiAgICAvLyBtYXJrcywgcmV1c2luZyBleGlzdGluZyBtYXJrIGRlc2NzIHdoZW4gcG9zc2libGUuXG4gICAgc3luY1RvTWFya3MobWFya3MsIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQga2VlcCA9IDAsIGRlcHRoID0gdGhpcy5zdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgbGV0IG1heEtlZXAgPSBNYXRoLm1pbihkZXB0aCwgbWFya3MubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBtYXhLZWVwICYmXG4gICAgICAgICAgICAoa2VlcCA9PSBkZXB0aCAtIDEgPyB0aGlzLnRvcCA6IHRoaXMuc3RhY2tbKGtlZXAgKyAxKSA8PCAxXSlcbiAgICAgICAgICAgICAgICAubWF0Y2hlc01hcmsobWFya3Nba2VlcF0pICYmIG1hcmtzW2tlZXBdLnR5cGUuc3BlYy5zcGFubmluZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkZXB0aCA8IG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMudG9wLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgTWF0aC5taW4odGhpcy5pbmRleCArIDMsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubWF0Y2hlc01hcmsobWFya3NbZGVwdGhdKSAmJiAhdGhpcy5pc0xvY2tlZChuZXh0LmRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya0Rlc2MgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBtYXJrc1tkZXB0aF0sIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgsIDAsIG1hcmtEZXNjKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IG1hcmtEZXNjO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBub2RlIGRlc2MgbWF0Y2hpbmcgdGhlIGdpdmVuIGRhdGEuIFNraXAgb3ZlciBpdCBhbmRcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAgZmluZE5vZGVNYXRjaChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gLTEsIHRhcmdldERlc2M7XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLnByZU1hdGNoLmluZGV4ICYmXG4gICAgICAgICAgICAodGFyZ2V0RGVzYyA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlc1tpbmRleCAtIHRoaXMucHJlTWF0Y2guaW5kZXhdKS5wYXJlbnQgPT0gdGhpcy50b3AgJiZcbiAgICAgICAgICAgIHRhcmdldERlc2MubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMudG9wLmNoaWxkcmVuLmluZGV4T2YodGFyZ2V0RGVzYywgdGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleCwgZSA9IE1hdGgubWluKHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCwgaSArIDUpOyBpIDwgZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSAmJiAhdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZU5vZGVBdChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGQuZGlydHkgPT0gTk9ERV9ESVJUWSAmJiBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSlcbiAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgaWYgKCFjaGlsZC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGluZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZmluZEluZGV4V2l0aENoaWxkKGRvbU5vZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgIGxldCBkZXNjID0gZG9tTm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3AuY2hpbGRyZW5baV0gPT0gZGVzYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbU5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIHVwZGF0ZSB0aGUgbmV4dCBub2RlLCBpZiBhbnksIHRvIHRoZSBnaXZlbiBkYXRhLiBDaGVja3NcbiAgICAvLyBwcmUtbWF0Y2hlcyB0byBhdm9pZCBvdmVyd3JpdGluZyBub2RlcyB0aGF0IGNvdWxkIHN0aWxsIGJlIHVzZWQuXG4gICAgdXBkYXRlTmV4dE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGluZGV4LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTm9kZVZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZU1hdGNoID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlTWF0Y2ggIT0gbnVsbCAmJiBwcmVNYXRjaCAhPSBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0RE9NID0gbmV4dC5kb20sIHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdXBkYXRlIGlmIG5leHRET00gaXMgb3IgY29udGFpbnMgdGhpcy5sb2NrLCBleGNlcHQgaWZcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgdGV4dCBub2RlIHdob3NlIGNvbnRlbnQgYWxyZWFkeSBtYXRjaGVzIHRoZSBuZXcgdGV4dFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3aG9zZSBkZWNvcmF0aW9ucyBtYXRjaCB0aGUgbmV3IG9uZXMuXG4gICAgICAgICAgICAgICAgbGV0IGxvY2tlZCA9IHRoaXMuaXNMb2NrZWQobmV4dERPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGUgJiYgbmV4dC5ub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGVET00ubm9kZVZhbHVlID09IG5vZGUudGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykpO1xuICAgICAgICAgICAgICAgIGlmICghbG9ja2VkICYmIG5leHQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb20gIT0gbmV4dERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFsb2NrZWQgJiYgKHVwZGF0ZWQgPSB0aGlzLnJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXaGVuIGEgbm9kZSB3aXRoIGNvbnRlbnQgaXMgcmVwbGFjZWQgYnkgYSBkaWZmZXJlbnQgbm9kZSB3aXRoXG4gICAgLy8gaWRlbnRpY2FsIGNvbnRlbnQsIG1vdmUgb3ZlciBpdHMgY2hpbGRyZW4uXG4gICAgcmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgaWYgKG5leHQuZGlydHkgfHwgbm9kZS5pc0F0b20gfHwgIW5leHQuY2hpbGRyZW4ubGVuZ3RoIHx8XG4gICAgICAgICAgICAhbmV4dC5ub2RlLmNvbnRlbnQuZXEobm9kZS5jb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgd3JhcHBlciA9IE5vZGVWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpO1xuICAgICAgICBpZiAoIXdyYXBwZXIuY29udGVudERPTSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3cmFwcGVyLmNoaWxkcmVuID0gbmV4dC5jaGlsZHJlbjtcbiAgICAgICAgbmV4dC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB3cmFwcGVyLmNoaWxkcmVuKVxuICAgICAgICAgICAgY2gucGFyZW50ID0gd3JhcHBlcjtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIC8vIEluc2VydCB0aGUgbm9kZSBhcyBhIG5ld2x5IGNyZWF0ZWQgbm9kZSBkZXNjLlxuICAgIGFkZE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgZGVzYyA9IE5vZGVWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpO1xuICAgICAgICBpZiAoZGVzYy5jb250ZW50RE9NKVxuICAgICAgICAgICAgZGVzYy51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgZGVzYyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIHBsYWNlV2lkZ2V0KHdpZGdldCwgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5pbmRleCA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCA/IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXhdIDogbnVsbDtcbiAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5tYXRjaGVzV2lkZ2V0KHdpZGdldCkgJiZcbiAgICAgICAgICAgICh3aWRnZXQgPT0gbmV4dC53aWRnZXQgfHwgIW5leHQud2lkZ2V0LnR5cGUudG9ET00ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gbmV3IFdpZGdldFZpZXdEZXNjKHRoaXMudG9wLCB3aWRnZXQsIHZpZXcsIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIGEgdGV4dGJsb2NrIGxvb2tzIGFuZCBiZWhhdmVzIGNvcnJlY3RseSBpblxuICAgIC8vIGNvbnRlbnRFZGl0YWJsZS5cbiAgICBhZGRUZXh0YmxvY2tIYWNrcygpIHtcbiAgICAgICAgbGV0IGxhc3RDaGlsZCA9IHRoaXMudG9wLmNoaWxkcmVuW3RoaXMuaW5kZXggLSAxXSwgcGFyZW50ID0gdGhpcy50b3A7XG4gICAgICAgIHdoaWxlIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IGxhc3RDaGlsZDtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHBhcmVudC5jaGlsZHJlbltwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXN0Q2hpbGQgfHwgLy8gRW1wdHkgdGV4dGJsb2NrXG4gICAgICAgICAgICAhKGxhc3RDaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3RGVzYykgfHxcbiAgICAgICAgICAgIC9cXG4kLy50ZXN0KGxhc3RDaGlsZC5ub2RlLnRleHQpIHx8XG4gICAgICAgICAgICAodGhpcy52aWV3LnJlcXVpcmVzR2Vja29IYWNrTm9kZSAmJiAvXFxzJC8udGVzdChsYXN0Q2hpbGQubm9kZS50ZXh0KSkpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3MgaW4gU2FmYXJpJ3MgY3Vyc29yIGRyYXdpbmcgKCMxMTY1KSBhbmQgQ2hyb21lJ3MgbW91c2Ugc2VsZWN0aW9uICgjMTE1MilcbiAgICAgICAgICAgIGlmICgoc2FmYXJpIHx8IGNocm9tZSkgJiYgbGFzdENoaWxkICYmIGxhc3RDaGlsZC5kb20uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEhhY2tOb2RlKFwiSU1HXCIsIHBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmFkZEhhY2tOb2RlKFwiQlJcIiwgdGhpcy50b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEhhY2tOb2RlKG5vZGVOYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLnRvcCAmJiB0aGlzLmluZGV4IDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAmJiBwYXJlbnQuY2hpbGRyZW5bdGhpcy5pbmRleF0ubWF0Y2hlc0hhY2sobm9kZU5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT0gXCJJTUdcIikge1xuICAgICAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXNlcGFyYXRvclwiO1xuICAgICAgICAgICAgICAgIGRvbS5hbHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci10cmFpbGluZ0JyZWFrXCI7XG4gICAgICAgICAgICBsZXQgaGFjayA9IG5ldyBUcmFpbGluZ0hhY2tWaWV3RGVzYyh0aGlzLnRvcCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9IHRoaXMudG9wKVxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKGhhY2spO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBoYWNrKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNMb2NrZWQobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrICYmIChub2RlID09IHRoaXMubG9jayB8fCBub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250YWlucyh0aGlzLmxvY2sucGFyZW50Tm9kZSkpO1xuICAgIH1cbn1cbi8vIEl0ZXJhdGUgZnJvbSB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCBhbmQgYXJyYXkgb2YgZGVzY3MgdG8gZmluZFxuLy8gZGlyZWN0bHkgbWF0Y2hpbmcgb25lcywgaW4gb3JkZXIgdG8gYXZvaWQgb3ZlcmVhZ2VybHkgcmV1c2luZyB0aG9zZVxuLy8gZm9yIG90aGVyIG5vZGVzLiBSZXR1cm5zIHRoZSBmcmFnbWVudCBpbmRleCBvZiB0aGUgZmlyc3Qgbm9kZSB0aGF0XG4vLyBpcyBwYXJ0IG9mIHRoZSBzZXF1ZW5jZSBvZiBtYXRjaGVkIG5vZGVzIGF0IHRoZSBlbmQgb2YgdGhlXG4vLyBmcmFnbWVudC5cbmZ1bmN0aW9uIHByZU1hdGNoKGZyYWcsIHBhcmVudERlc2MpIHtcbiAgICBsZXQgY3VyRGVzYyA9IHBhcmVudERlc2MsIGRlc2NJID0gY3VyRGVzYy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgbGV0IGZJID0gZnJhZy5jaGlsZENvdW50LCBtYXRjaGVkID0gbmV3IE1hcCwgbWF0Y2hlcyA9IFtdO1xuICAgIG91dGVyOiB3aGlsZSAoZkkgPiAwKSB7XG4gICAgICAgIGxldCBkZXNjO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoZGVzY0kpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGN1ckRlc2MuY2hpbGRyZW5bZGVzY0kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgICAgICBjdXJEZXNjID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZGVzY0kgPSBuZXh0LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkZXNjSS0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJEZXNjID09IHBhcmVudERlc2MpIHtcbiAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAgICAgZGVzY0kgPSBjdXJEZXNjLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGN1ckRlc2MpO1xuICAgICAgICAgICAgICAgIGN1ckRlc2MgPSBjdXJEZXNjLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IGRlc2Mubm9kZTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChub2RlICE9IGZyYWcuY2hpbGQoZkkgLSAxKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAtLWZJO1xuICAgICAgICBtYXRjaGVkLnNldChkZXNjLCBmSSk7XG4gICAgICAgIG1hdGNoZXMucHVzaChkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaW5kZXg6IGZJLCBtYXRjaGVkLCBtYXRjaGVzOiBtYXRjaGVzLnJldmVyc2UoKSB9O1xufVxuZnVuY3Rpb24gY29tcGFyZVNpZGUoYSwgYikge1xuICAgIHJldHVybiBhLnR5cGUuc2lkZSAtIGIudHlwZS5zaWRlO1xufVxuLy8gVGhpcyBmdW5jdGlvbiBhYnN0cmFjdHMgaXRlcmF0aW5nIG92ZXIgdGhlIG5vZGVzIGFuZCBkZWNvcmF0aW9ucyBpblxuLy8gYSBmcmFnbWVudC4gQ2FsbHMgYG9uTm9kZWAgZm9yIGVhY2ggbm9kZSwgd2l0aCBpdHMgbG9jYWwgYW5kIGNoaWxkXG4vLyBkZWNvcmF0aW9ucy4gU3BsaXRzIHRleHQgbm9kZXMgd2hlbiB0aGVyZSBpcyBhIGRlY29yYXRpb24gc3RhcnRpbmdcbi8vIG9yIGVuZGluZyBpbnNpZGUgb2YgdGhlbS4gQ2FsbHMgYG9uV2lkZ2V0YCBmb3IgZWFjaCB3aWRnZXQuXG5mdW5jdGlvbiBpdGVyRGVjbyhwYXJlbnQsIGRlY28sIG9uV2lkZ2V0LCBvbk5vZGUpIHtcbiAgICBsZXQgbG9jYWxzID0gZGVjby5sb2NhbHMocGFyZW50KSwgb2Zmc2V0ID0gMDtcbiAgICAvLyBTaW1wbGUsIGNoZWFwIHZhcmlhbnQgZm9yIHdoZW4gdGhlcmUgYXJlIG5vIGxvY2FsIGRlY29yYXRpb25zXG4gICAgaWYgKGxvY2Fscy5sZW5ndGggPT0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHBhcmVudC5jaGlsZChpKTtcbiAgICAgICAgICAgIG9uTm9kZShjaGlsZCwgbG9jYWxzLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpLCBpKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkZWNvSW5kZXggPSAwLCBhY3RpdmUgPSBbXSwgcmVzdE5vZGUgPSBudWxsO1xuICAgIGZvciAobGV0IHBhcmVudEluZGV4ID0gMDs7KSB7XG4gICAgICAgIGlmIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID09IG9mZnNldCkge1xuICAgICAgICAgICAgbGV0IHdpZGdldCA9IGxvY2Fsc1tkZWNvSW5kZXgrK10sIHdpZGdldHM7XG4gICAgICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA9PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgKHdpZGdldHMgfHwgKHdpZGdldHMgPSBbd2lkZ2V0XSkpLnB1c2gobG9jYWxzW2RlY29JbmRleCsrXSk7XG4gICAgICAgICAgICBpZiAod2lkZ2V0cykge1xuICAgICAgICAgICAgICAgIHdpZGdldHMuc29ydChjb21wYXJlU2lkZSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWRnZXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBvbldpZGdldCh3aWRnZXRzW2ldLCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbldpZGdldCh3aWRnZXQsIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGQsIGluZGV4O1xuICAgICAgICBpZiAocmVzdE5vZGUpIHtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjaGlsZCA9IHJlc3ROb2RlO1xuICAgICAgICAgICAgcmVzdE5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudEluZGV4IDwgcGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICAgICAgICBjaGlsZCA9IHBhcmVudC5jaGlsZChwYXJlbnRJbmRleCsrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnNwbGljZShpLS0sIDEpO1xuICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDw9IG9mZnNldCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA+IG9mZnNldClcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGxvY2Fsc1tkZWNvSW5kZXgrK10pO1xuICAgICAgICBsZXQgZW5kID0gb2Zmc2V0ICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGlmIChjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgICAgIGxldCBjdXRBdCA9IGVuZDtcbiAgICAgICAgICAgIGlmIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPCBjdXRBdClcbiAgICAgICAgICAgICAgICBjdXRBdCA9IGxvY2Fsc1tkZWNvSW5kZXhdLmZyb207XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlW2ldLnRvIDwgY3V0QXQpXG4gICAgICAgICAgICAgICAgICAgIGN1dEF0ID0gYWN0aXZlW2ldLnRvO1xuICAgICAgICAgICAgaWYgKGN1dEF0IDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdE5vZGUgPSBjaGlsZC5jdXQoY3V0QXQgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KDAsIGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBlbmQgPSBjdXRBdDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRlckRlY28gPSBjaGlsZC5pc0lubGluZSAmJiAhY2hpbGQuaXNMZWFmID8gYWN0aXZlLmZpbHRlcihkID0+ICFkLmlubGluZSkgOiBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgb25Ob2RlKGNoaWxkLCBvdXRlckRlY28sIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGluZGV4KTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbn1cbi8vIExpc3QgbWFya2VycyBpbiBNb2JpbGUgU2FmYXJpIHdpbGwgbXlzdGVyaW91c2x5IGRpc2FwcGVhclxuLy8gc29tZXRpbWVzLiBUaGlzIHdvcmtzIGFyb3VuZCB0aGF0LlxuZnVuY3Rpb24gaW9zSGFja3MoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIlVMXCIgfHwgZG9tLm5vZGVOYW1lID09IFwiT0xcIikge1xuICAgICAgICBsZXQgb2xkQ1NTID0gZG9tLnN0eWxlLmNzc1RleHQ7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTICsgXCI7IGxpc3Qtc3R5bGU6IHNxdWFyZSAhaW1wb3J0YW50XCI7XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSkubGlzdFN0eWxlO1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgICB9XG59XG5mdW5jdGlvbiBuZWFyYnlUZXh0Tm9kZShub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBvZmZzZXQgPSBub2RlU2l6ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gRmluZCBhIHBpZWNlIG9mIHRleHQgaW4gYW4gaW5saW5lIGZyYWdtZW50LCBvdmVybGFwcGluZyBmcm9tLXRvXG5mdW5jdGlvbiBmaW5kVGV4dEluRnJhZ21lbnQoZnJhZywgdGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IGZyYWcuY2hpbGRDb3VudCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWcuY2hpbGQoaSsrKSwgY2hpbGRTdGFydCA9IHBvcztcbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoIWNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc3RyID0gY2hpbGQudGV4dDtcbiAgICAgICAgd2hpbGUgKGkgPCBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZy5jaGlsZChpKyspO1xuICAgICAgICAgICAgcG9zICs9IG5leHQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoIW5leHQuaXNUZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RyICs9IG5leHQudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGNoaWxkU3RhcnQgPCB0byA/IHN0ci5sYXN0SW5kZXhPZih0ZXh0LCB0byAtIGNoaWxkU3RhcnQgLSAxKSA6IC0xO1xuICAgICAgICAgICAgaWYgKGZvdW5kID49IDAgJiYgZm91bmQgKyB0ZXh0Lmxlbmd0aCArIGNoaWxkU3RhcnQgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRTdGFydCArIGZvdW5kO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gdG8gJiYgc3RyLmxlbmd0aCA+PSAodG8gKyB0ZXh0Lmxlbmd0aCkgLSBjaGlsZFN0YXJ0ICYmXG4gICAgICAgICAgICAgICAgc3RyLnNsaWNlKHRvIC0gY2hpbGRTdGFydCwgdG8gLSBjaGlsZFN0YXJ0ICsgdGV4dC5sZW5ndGgpID09IHRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8vIFJlcGxhY2UgcmFuZ2UgZnJvbS10byBpbiBhbiBhcnJheSBvZiB2aWV3IGRlc2NzIHdpdGggcmVwbGFjZW1lbnRcbi8vIChtYXkgYmUgbnVsbCB0byBqdXN0IGRlbGV0ZSkuIFRoaXMgZ29lcyB2ZXJ5IG11Y2ggYWdhaW5zdCB0aGUgZ3JhaW5cbi8vIG9mIHRoZSByZXN0IG9mIHRoaXMgY29kZSwgd2hpY2ggdGVuZHMgdG8gY3JlYXRlIG5vZGVzIHdpdGggdGhlXG4vLyByaWdodCBzaGFwZSBpbiBvbmUgZ28sIHJhdGhlciB0aGFuIG1lc3Npbmcgd2l0aCB0aGVtIGFmdGVyXG4vLyBjcmVhdGlvbiwgYnV0IGlzIG5lY2Vzc2FyeSBpbiB0aGUgY29tcG9zaXRpb24gaGFjay5cbmZ1bmN0aW9uIHJlcGxhY2VOb2Rlcyhub2RlcywgZnJvbSwgdG8sIHZpZXcsIHJlcGxhY2VtZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZXNbaV0sIHN0YXJ0ID0gb2ZmLCBlbmQgPSBvZmYgKz0gY2hpbGQuc2l6ZTtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRvIHx8IGVuZCA8PSBmcm9tKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKDAsIGZyb20gLSBzdGFydCwgdmlldykpO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKHRvIC0gc3RhcnQsIGNoaWxkLnNpemUsIHZpZXcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcsIG9yaWdpbiA9IG51bGwpIHtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpLCBkb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBpZiAoIWRvbVNlbC5mb2N1c05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBuZWFyZXN0RGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhkb21TZWwuZm9jdXNOb2RlKSwgaW5XaWRnZXQgPSBuZWFyZXN0RGVzYyAmJiBuZWFyZXN0RGVzYy5zaXplID09IDA7XG4gICAgbGV0IGhlYWQgPSB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIDEpO1xuICAgIGlmIChoZWFkIDwgMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0ICRoZWFkID0gZG9jLnJlc29sdmUoaGVhZCksICRhbmNob3IsIHNlbGVjdGlvbjtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpIHtcbiAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICB3aGlsZSAobmVhcmVzdERlc2MgJiYgIW5lYXJlc3REZXNjLm5vZGUpXG4gICAgICAgICAgICBuZWFyZXN0RGVzYyA9IG5lYXJlc3REZXNjLnBhcmVudDtcbiAgICAgICAgbGV0IG5lYXJlc3REZXNjTm9kZSA9IG5lYXJlc3REZXNjLm5vZGU7XG4gICAgICAgIGlmIChuZWFyZXN0RGVzYyAmJiBuZWFyZXN0RGVzY05vZGUuaXNBdG9tICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5lYXJlc3REZXNjTm9kZSkgJiYgbmVhcmVzdERlc2MucGFyZW50XG4gICAgICAgICAgICAmJiAhKG5lYXJlc3REZXNjTm9kZS5pc0lubGluZSAmJiBpc09uRWRnZShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIG5lYXJlc3REZXNjLmRvbSkpKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gbmVhcmVzdERlc2MucG9zQmVmb3JlO1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gbmV3IE5vZGVTZWxlY3Rpb24oaGVhZCA9PSBwb3MgPyAkaGVhZCA6IGRvYy5yZXNvbHZlKHBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgYW5jaG9yID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIDEpO1xuICAgICAgICBpZiAoYW5jaG9yIDwgMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgICB9XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGJpYXMgPSBvcmlnaW4gPT0gXCJwb2ludGVyXCIgfHwgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQgPCAkaGVhZC5wb3MgJiYgIWluV2lkZ2V0KSA/IDEgOiAtMTtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiBlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy5lZGl0YWJsZSA/IHZpZXcuaGFzRm9jdXMoKSA6XG4gICAgICAgIGhhc1NlbGVjdGlvbih2aWV3KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY29udGFpbnModmlldy5kb20pO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uVG9ET00odmlldywgZm9yY2UgPSBmYWxzZSkge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpO1xuICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIFRoZSBkZWxheWVkIGRyYWcgc2VsZWN0aW9uIGNhdXNlcyBpc3N1ZXMgd2l0aCBDZWxsIFNlbGVjdGlvbnNcbiAgICAvLyBpbiBTYWZhcmkuIEFuZCB0aGUgZHJhZyBzZWxlY3Rpb24gZGVsYXkgaXMgdG8gd29ya2Fyb25kIGlzc3Vlc1xuICAgIC8vIHdoaWNoIG9ubHkgcHJlc2VudCBpbiBDaHJvbWUuXG4gICAgaWYgKCFmb3JjZSAmJiB2aWV3LmlucHV0Lm1vdXNlRG93biAmJiB2aWV3LmlucHV0Lm1vdXNlRG93bi5hbGxvd0RlZmF1bHQgJiYgY2hyb21lKSB7XG4gICAgICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCksIGN1clNlbCA9IHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICYmIGN1clNlbC5hbmNob3JOb2RlICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCwgY3VyU2VsLmFuY2hvck5vZGUsIGN1clNlbC5hbmNob3JPZmZzZXQpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kZWxheWVkU2VsZWN0aW9uU3luYyA9IHRydWU7XG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIGlmICh2aWV3LmN1cnNvcldyYXBwZXIpIHtcbiAgICAgICAgc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB7IGFuY2hvciwgaGVhZCB9ID0gc2VsLCByZXNldEVkaXRhYmxlRnJvbSwgcmVzZXRFZGl0YWJsZVRvO1xuICAgICAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgJiYgIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKCFzZWwuJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZUZyb20gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwuZnJvbSk7XG4gICAgICAgICAgICBpZiAoIXNlbC5lbXB0eSAmJiAhc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGVUbyA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC50byk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kb2NWaWV3LnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcucm9vdCwgZm9yY2UpO1xuICAgICAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGlmIChyZXNldEVkaXRhYmxlRnJvbSlcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVGcm9tKTtcbiAgICAgICAgICAgIGlmIChyZXNldEVkaXRhYmxlVG8pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlVG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChcIm9uc2VsZWN0aW9uY2hhbmdlXCIgaW4gZG9jdW1lbnQpXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuY29ubmVjdFNlbGVjdGlvbigpO1xufVxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIFdlYmtpdCBub3QgYWxsb3dpbmcgYSBzZWxlY3Rpb24gdG8gc3RhcnQvZW5kXG4vLyBiZXR3ZWVuIG5vbi1lZGl0YWJsZSBibG9jayBub2Rlcy4gV2UgYnJpZWZseSBtYWtlIHNvbWV0aGluZ1xuLy8gZWRpdGFibGUsIHNldCB0aGUgc2VsZWN0aW9uLCB0aGVuIHNldCBpdCB1bmVkaXRhYmxlIGFnYWluLlxuY29uc3QgYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgPSBzYWZhcmkgfHwgY2hyb21lICYmIGNocm9tZV92ZXJzaW9uIDwgNjM7XG5mdW5jdGlvbiB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBwb3MpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgbGV0IGFmdGVyID0gb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdIDogbnVsbDtcbiAgICBsZXQgYmVmb3JlID0gb2Zmc2V0ID8gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdIDogbnVsbDtcbiAgICBpZiAoc2FmYXJpICYmIGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShhZnRlcik7XG4gICAgaWYgKCghYWZ0ZXIgfHwgYWZ0ZXIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgJiZcbiAgICAgICAgKCFiZWZvcmUgfHwgYmVmb3JlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpKSB7XG4gICAgICAgIGlmIChhZnRlcilcbiAgICAgICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShhZnRlcik7XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZSlcbiAgICAgICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShiZWZvcmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIGlmIChzYWZhcmkgJiYgZWxlbWVudC5kcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgZWxlbWVudC53YXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIHJlc2V0RWRpdGFibGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgIGlmIChlbGVtZW50Lndhc0RyYWdnYWJsZSkge1xuICAgICAgICBlbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlKHZpZXcpIHtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IGRvbVNlbC5hbmNob3JOb2RlLCBvZmZzZXQgPSBkb21TZWwuYW5jaG9yT2Zmc2V0O1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkID0gKCkgPT4ge1xuICAgICAgICBpZiAoZG9tU2VsLmFuY2hvck5vZGUgIT0gbm9kZSB8fCBkb21TZWwuYW5jaG9yT2Zmc2V0ICE9IG9mZnNldCkge1xuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZWxlY3RDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb24oKSwgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGxldCBub2RlID0gdmlldy5jdXJzb3JXcmFwcGVyLmRvbSwgaW1nID0gbm9kZS5ub2RlTmFtZSA9PSBcIklNR1wiO1xuICAgIGlmIChpbWcpXG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLnBhcmVudE5vZGUsIGRvbUluZGV4KG5vZGUpICsgMSk7XG4gICAgZWxzZVxuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgMCk7XG4gICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgIGRvbVNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBkb21TZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIC8vIEtsdWRnZSB0byBraWxsICdjb250cm9sIHNlbGVjdGlvbicgaW4gSUUxMSB3aGVuIHNlbGVjdGluZyBhblxuICAgIC8vIGludmlzaWJsZSBjdXJzb3Igd3JhcHBlciwgc2luY2UgdGhhdCB3b3VsZCByZXN1bHQgaW4gdGhvc2Ugd2VpcmRcbiAgICAvLyByZXNpemUgaGFuZGxlcyBhbmQgYSBzZWxlY3Rpb24gdGhhdCBjb25zaWRlcnMgdGhlIGFic29sdXRlbHlcbiAgICAvLyBwb3NpdGlvbmVkIHdyYXBwZXIsIHJhdGhlciB0aGFuIHRoZSByb290IGVkaXRhYmxlIG5vZGUsIHRoZVxuICAgIC8vIGZvY3VzZWQgZWxlbWVudC5cbiAgICBpZiAoIWltZyAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJiBpZSAmJiBpZV92ZXJzaW9uIDw9IDExKSB7XG4gICAgICAgIG5vZGUuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBub2RlLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKSB7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KHNlbC5mcm9tKTtcbiAgICAgICAgaWYgKGRlc2MgIT0gdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgZGVzYy5zZWxlY3ROb2RlKCk7XG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gZGVzYztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgIH1cbn1cbi8vIENsZWFyIGFsbCBET00gc3RhdGVmdWxuZXNzIG9mIHRoZSBsYXN0IG5vZGUgc2VsZWN0aW9uLlxuZnVuY3Rpb24gY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5wYXJlbnQpXG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLmRlc2VsZWN0Tm9kZSgpO1xuICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImNyZWF0ZVNlbGVjdGlvbkJldHdlZW5cIiwgZiA9PiBmKHZpZXcsICRhbmNob3IsICRoZWFkKSlcbiAgICAgICAgfHwgVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKCRhbmNob3IsICRoZWFkLCBiaWFzKTtcbn1cbmZ1bmN0aW9uIGhhc0ZvY3VzQW5kU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5lZGl0YWJsZSAmJiAhdmlldy5oYXNGb2N1cygpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGhhc1NlbGVjdGlvbih2aWV3KTtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbih2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoIXNlbC5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiB2aWV3LmRvbS5jb250YWlucyhzZWwuYW5jaG9yTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmFuY2hvck5vZGUucGFyZW50Tm9kZSA6IHNlbC5hbmNob3JOb2RlKSAmJlxuICAgICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgdmlldy5kb20uY29udGFpbnMoc2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmZvY3VzTm9kZS5wYXJlbnROb2RlIDogc2VsLmZvY3VzTm9kZSkpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYW5jaG9ySW5SaWdodFBsYWNlKHZpZXcpIHtcbiAgICBsZXQgYW5jaG9yRE9NID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLCAwKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIHJldHVybiBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBtb3ZlU2VsZWN0aW9uQmxvY2soc3RhdGUsIGRpcikge1xuICAgIGxldCB7ICRhbmNob3IsICRoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0ICRzaWRlID0gZGlyID4gMCA/ICRhbmNob3IubWF4KCRoZWFkKSA6ICRhbmNob3IubWluKCRoZWFkKTtcbiAgICBsZXQgJHN0YXJ0ID0gISRzaWRlLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJHNpZGUgOiAkc2lkZS5kZXB0aCA/IHN0YXRlLmRvYy5yZXNvbHZlKGRpciA+IDAgPyAkc2lkZS5hZnRlcigpIDogJHNpZGUuYmVmb3JlKCkpIDogbnVsbDtcbiAgICByZXR1cm4gJHN0YXJ0ICYmIFNlbGVjdGlvbi5maW5kRnJvbSgkc3RhcnQsIGRpcik7XG59XG5mdW5jdGlvbiBhcHBseSh2aWV3LCBzZWwpIHtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmICghc2VsLmVtcHR5IHx8IG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyID4gMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIChuZXh0IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEobWFjICYmIG1vZHMuaW5kZXhPZihcIm1cIikgPiAtMSkpIHtcbiAgICAgICAgICAgIGxldCAkaGVhZCA9IHNlbC4kaGVhZCwgbm9kZSA9ICRoZWFkLnRleHRPZmZzZXQgPyBudWxsIDogZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGVQb3MgPSBkaXIgPCAwID8gJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSA6ICRoZWFkLnBvcztcbiAgICAgICAgICAgIGlmICghKG5vZGUuaXNBdG9tIHx8IChkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChub2RlUG9zKSkgJiYgIWRlc2MuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBOb2RlU2VsZWN0aW9uKGRpciA8IDAgPyB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKCRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUpIDogJGhlYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdlYmtpdCkge1xuICAgICAgICAgICAgICAgIC8vIENocm9tZSBhbmQgU2FmYXJpIHdpbGwgaW50cm9kdWNlIGV4dHJhIHBvaW50bGVzcyBjdXJzb3JcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbnMgYXJvdW5kIGlubGluZSB1bmVkaXRhYmxlIG5vZGVzLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gdGFrZSBvdmVyIGFuZCBtb3ZlIHRoZSBjdXJzb3IgcGFzdCB0aGVtICgjOTM3KVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgVGV4dFNlbGVjdGlvbih2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGRpciA8IDAgPyBub2RlUG9zIDogbm9kZVBvcyArIG5vZGUubm9kZVNpemUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzZWwubm9kZS5pc0lubGluZSkge1xuICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24oZGlyID4gMCA/IHNlbC4kdG8gOiBzZWwuJGZyb20pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZUxlbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc0lnbm9yYWJsZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Muc2l6ZSA9PSAwICYmIChkb20ubmV4dFNpYmxpbmcgfHwgZG9tLm5vZGVOYW1lICE9IFwiQlJcIik7XG59XG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcikge1xuICAgIHJldHVybiBkaXIgPCAwID8gc2tpcElnbm9yZWROb2Rlc0JlZm9yZSh2aWV3KSA6IHNraXBJZ25vcmVkTm9kZXNBZnRlcih2aWV3KTtcbn1cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGFmdGVyIG9uZSBvciBtb3JlIGlnbm9yZWRcbi8vIG5vZGVzLCB3aGljaCB3aWxsIGNvbmZ1c2UgdGhlIGJyb3dzZXIncyBjdXJzb3IgbW90aW9uIGxvZ2ljLlxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc0JlZm9yZSh2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbW92ZU5vZGUsIG1vdmVPZmZzZXQsIGZvcmNlID0gZmFsc2U7XG4gICAgLy8gR2Vja28gd2lsbCBkbyBvZGQgdGhpbmdzIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBkaXJlY3RseSBpbiBmcm9udFxuICAgIC8vIG9mIGEgbm9uLWVkaXRhYmxlIG5vZGUsIHNvIGluIHRoYXQgY2FzZSwgbW92ZSBpdCBpbnRvIHRoZSBuZXh0XG4gICAgLy8gbm9kZSBpZiBwb3NzaWJsZS4gSXNzdWUgcHJvc2VtaXJyb3IvcHJvc2VtaXJyb3IjODMyLlxuICAgIGlmIChnZWNrbyAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZUxlbihub2RlKSAmJiBpc0lnbm9yYWJsZShub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSkpXG4gICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShiZWZvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IC0tb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICYmIGlzSWdub3JhYmxlKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KHByZXYpO1xuICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gcHJldjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlTGVuKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmb3JjZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbm9kZSwgb2Zmc2V0KTtcbiAgICBlbHNlIGlmIChtb3ZlTm9kZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYmVmb3JlIG9uZSBvciBtb3JlIGlnbm9yZWRcbi8vIG5vZGVzLlxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlc0FmdGVyKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBsZW4gPSBub2RlTGVuKG5vZGUpO1xuICAgIGxldCBtb3ZlTm9kZSwgbW92ZU9mZnNldDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShhZnRlcikpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9ICsrb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIGlzSWdub3JhYmxlKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBuZXh0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IGRvbUluZGV4KG5leHQpICsgMTtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gdmlldy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGxlbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vdmVOb2RlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBtb3ZlTm9kZSwgbW92ZU9mZnNldCk7XG59XG5mdW5jdGlvbiBpc0Jsb2NrTm9kZShkb20pIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jaztcbn1cbmZ1bmN0aW9uIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCkge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoc2VsKSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWwuZXh0ZW5kKSB7XG4gICAgICAgIHNlbC5leHRlbmQobm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldztcbiAgICAvLyBJZiBubyBzdGF0ZSB1cGRhdGUgZW5kcyB1cCBoYXBwZW5pbmcsIHJlc2V0IHRoZSBzZWxlY3Rpb24uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlID09IHN0YXRlKVxuICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gZmluZERpcmVjdGlvbih2aWV3LCBwb3MpIHtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIShjaHJvbWUgfHwgd2luZG93cykgJiYgJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgY29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAocG9zID4gJHBvcy5zdGFydCgpKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gdmlldy5jb29yZHNBdFBvcyhwb3MgLSAxKTtcbiAgICAgICAgICAgIGxldCBtaWQgPSAoYmVmb3JlLnRvcCArIGJlZm9yZS5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgIGlmIChtaWQgPiBjb29yZHMudG9wICYmIG1pZCA8IGNvb3Jkcy5ib3R0b20gJiYgTWF0aC5hYnMoYmVmb3JlLmxlZnQgLSBjb29yZHMubGVmdCkgPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmUubGVmdCA8IGNvb3Jkcy5sZWZ0ID8gXCJsdHJcIiA6IFwicnRsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA8ICRwb3MuZW5kKCkpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHZpZXcuY29vcmRzQXRQb3MocG9zICsgMSk7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGFmdGVyLnRvcCArIGFmdGVyLmJvdHRvbSkgLyAyO1xuICAgICAgICAgICAgaWYgKG1pZCA+IGNvb3Jkcy50b3AgJiYgbWlkIDwgY29vcmRzLmJvdHRvbSAmJiBNYXRoLmFicyhhZnRlci5sZWZ0IC0gY29vcmRzLmxlZnQpID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXIubGVmdCA+IGNvb3Jkcy5sZWZ0ID8gXCJsdHJcIiA6IFwicnRsXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh2aWV3LmRvbSkuZGlyZWN0aW9uO1xuICAgIHJldHVybiBjb21wdXRlZCA9PSBcInJ0bFwiID8gXCJydGxcIiA6IFwibHRyXCI7XG59XG4vLyBDaGVjayB3aGV0aGVyIHZlcnRpY2FsIHNlbGVjdGlvbiBtb3Rpb24gd291bGQgaW52b2x2ZSBub2RlXG4vLyBzZWxlY3Rpb25zLiBJZiBzbywgYXBwbHkgaXQgKGlmIG5vdCwgdGhlIHJlc3VsdCBpcyBsZWZ0IHRvIHRoZVxuLy8gYnJvd3NlcilcbmZ1bmN0aW9uIHNlbGVjdFZlcnRpY2FsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgfHwgbW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA8IDAgPyBcInVwXCIgOiBcImRvd25cIikpIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgaWYgKG5leHQgJiYgKG5leHQgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICB9XG4gICAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgc2lkZSA9IGRpciA8IDAgPyAkZnJvbSA6ICR0bztcbiAgICAgICAgbGV0IGJleW9uZCA9IHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiA/IFNlbGVjdGlvbi5uZWFyKHNpZGUsIGRpcikgOiBTZWxlY3Rpb24uZmluZEZyb20oc2lkZSwgZGlyKTtcbiAgICAgICAgcmV0dXJuIGJleW9uZCA/IGFwcGx5KHZpZXcsIGJleW9uZCkgOiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgZGlyKSB7XG4gICAgaWYgKCEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IsIGVtcHR5IH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbmV4dE5vZGUgPSAhJGhlYWQudGV4dE9mZnNldCAmJiAoZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIpO1xuICAgIGlmIChuZXh0Tm9kZSAmJiAhbmV4dE5vZGUuaXNUZXh0KSB7XG4gICAgICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgdHIuZGVsZXRlKCRoZWFkLnBvcyAtIG5leHROb2RlLm5vZGVTaXplLCAkaGVhZC5wb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ci5kZWxldGUoJGhlYWQucG9zLCAkaGVhZC5wb3MgKyBuZXh0Tm9kZS5ub2RlU2l6ZSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3dpdGNoRWRpdGFibGUodmlldywgbm9kZSwgc3RhdGUpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IHN0YXRlO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbn1cbi8vIElzc3VlICM4NjcgLyAjMTA5MCAvIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkwMzgyMVxuLy8gSW4gd2hpY2ggU2FmYXJpIChhbmQgYXQgc29tZSBwb2ludCBpbiB0aGUgcGFzdCwgQ2hyb21lKSBkb2VzIHJlYWxseVxuLy8gd3JvbmcgdGhpbmdzIHdoZW4gdGhlIGRvd24gYXJyb3cgaXMgcHJlc3NlZCB3aGVuIHRoZSBjdXJzb3IgaXNcbi8vIGRpcmVjdGx5IGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBhbmQgaGFzIGFuIHVuZWRpdGFibGUgbm9kZVxuLy8gYWZ0ZXIgaXRcbmZ1bmN0aW9uIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB7XG4gICAgaWYgKCFzYWZhcmkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoZm9jdXNOb2RlICYmIGZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxICYmIGZvY3VzT2Zmc2V0ID09IDAgJiZcbiAgICAgICAgZm9jdXNOb2RlLmZpcnN0Q2hpbGQgJiYgZm9jdXNOb2RlLmZpcnN0Q2hpbGQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikge1xuICAgICAgICBsZXQgY2hpbGQgPSBmb2N1c05vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwidHJ1ZVwiKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBjaGlsZCwgXCJmYWxzZVwiKSwgMjApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBBIGJhY2tkcm9wIGtleSBtYXBwaW5nIHVzZWQgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBzdXBwcmVzcyBrZXlzXG4vLyB0aGF0IGhhdmUgYSBkYW5nZXJvdXMgZGVmYXVsdCBlZmZlY3QsIGV2ZW4gaWYgdGhlIGNvbW1hbmRzIHRoZXkgYXJlXG4vLyBib3VuZCB0byByZXR1cm4gZmFsc2UsIGFuZCB0byBtYWtlIHN1cmUgdGhhdCBjdXJzb3ItbW90aW9uIGtleXNcbi8vIGZpbmQgYSBjdXJzb3IgKGFzIG9wcG9zZWQgdG8gYSBub2RlIHNlbGVjdGlvbikgd2hlbiBwcmVzc2VkLiBGb3Jcbi8vIGN1cnNvci1tb3Rpb24ga2V5cywgdGhlIGNvZGUgaW4gdGhlIGhhbmRsZXJzIGFsc28gdGFrZXMgY2FyZSBvZlxuLy8gYmxvY2sgc2VsZWN0aW9ucy5cbmZ1bmN0aW9uIGdldE1vZHMoZXZlbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwiY1wiO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJtXCI7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwiYVwiO1xuICAgIGlmIChldmVudC5zaGlmdEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwic1wiO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjYXB0dXJlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgIGxldCBjb2RlID0gZXZlbnQua2V5Q29kZSwgbW9kcyA9IGdldE1vZHMoZXZlbnQpO1xuICAgIGlmIChjb2RlID09IDggfHwgKG1hYyAmJiBjb2RlID09IDcyICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIEJhY2tzcGFjZSwgQ3RybC1oIG9uIE1hY1xuICAgICAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgLTEpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgLTEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDQ2IHx8IChtYWMgJiYgY29kZSA9PSA2OCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBEZWxldGUsIEN0cmwtZCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIDEpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMTMgfHwgY29kZSA9PSAyNykgeyAvLyBFbnRlciwgRXNjXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM3IHx8IChtYWMgJiYgY29kZSA9PSA2NiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBMZWZ0IGFycm93LCBDdHJsLWIgb24gTWFjXG4gICAgICAgIGxldCBkaXIgPSBjb2RlID09IDM3ID8gKGZpbmREaXJlY3Rpb24odmlldywgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSkgPT0gXCJsdHJcIiA/IC0xIDogMSkgOiAtMTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzOSB8fCAobWFjICYmIGNvZGUgPT0gNzAgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gUmlnaHQgYXJyb3csIEN0cmwtZiBvbiBNYWNcbiAgICAgICAgbGV0IGRpciA9IGNvZGUgPT0gMzkgPyAoZmluZERpcmVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSA9PSBcImx0clwiID8gMSA6IC0xKSA6IDE7XG4gICAgICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzggfHwgKG1hYyAmJiBjb2RlID09IDgwICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIFVwIGFycm93LCBDdHJsLXAgb24gTWFjXG4gICAgICAgIHJldHVybiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIC0xLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSA0MCB8fCAobWFjICYmIGNvZGUgPT0gNzggJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gRG93biBhcnJvdywgQ3RybC1uIG9uIE1hY1xuICAgICAgICByZXR1cm4gc2FmYXJpRG93bkFycm93QnVnKHZpZXcpIHx8IHNlbGVjdFZlcnRpY2FsbHkodmlldywgMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlc0FmdGVyKHZpZXcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtb2RzID09IChtYWMgPyBcIm1cIiA6IFwiY1wiKSAmJlxuICAgICAgICAoY29kZSA9PSA2NiB8fCBjb2RlID09IDczIHx8IGNvZGUgPT0gODkgfHwgY29kZSA9PSA5MCkpIHsgLy8gTW9kLVtiaXl6XVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpIHtcbiAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtQ29waWVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcpOyB9KTtcbiAgICBsZXQgY29udGV4dCA9IFtdLCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gICAgd2hpbGUgKG9wZW5TdGFydCA+IDEgJiYgb3BlbkVuZCA+IDEgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEgJiYgY29udGVudC5maXJzdENoaWxkLmNoaWxkQ291bnQgPT0gMSkge1xuICAgICAgICBvcGVuU3RhcnQtLTtcbiAgICAgICAgb3BlbkVuZC0tO1xuICAgICAgICBsZXQgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgY29udGV4dC5wdXNoKG5vZGUudHlwZS5uYW1lLCBub2RlLmF0dHJzICE9IG5vZGUudHlwZS5kZWZhdWx0QXR0cnMgPyBub2RlLmF0dHJzIDogbnVsbCk7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gICAgfVxuICAgIGxldCBzZXJpYWxpemVyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFNlcmlhbGl6ZXJcIikgfHwgRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICBsZXQgZG9jID0gZGV0YWNoZWREb2MoKSwgd3JhcCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHdyYXAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVGcmFnbWVudChjb250ZW50LCB7IGRvY3VtZW50OiBkb2MgfSkpO1xuICAgIGxldCBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkLCBuZWVkc1dyYXAsIHdyYXBwZXJzID0gMDtcbiAgICB3aGlsZSAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09IDEgJiYgKG5lZWRzV3JhcCA9IHdyYXBNYXBbZmlyc3RDaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG5lZWRzV3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2MuY3JlYXRlRWxlbWVudChuZWVkc1dyYXBbaV0pO1xuICAgICAgICAgICAgd2hpbGUgKHdyYXAuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHdyYXAuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgICAgICAgd3JhcHBlcnMrKztcbiAgICAgICAgfVxuICAgICAgICBmaXJzdENoaWxkID0gd3JhcC5maXJzdENoaWxkO1xuICAgIH1cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgIGZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwiZGF0YS1wbS1zbGljZVwiLCBgJHtvcGVuU3RhcnR9ICR7b3BlbkVuZH0ke3dyYXBwZXJzID8gYCAtJHt3cmFwcGVyc31gIDogXCJcIn0gJHtKU09OLnN0cmluZ2lmeShjb250ZXh0KX1gKTtcbiAgICBsZXQgdGV4dCA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRUZXh0U2VyaWFsaXplclwiLCBmID0+IGYoc2xpY2UsIHZpZXcpKSB8fFxuICAgICAgICBzbGljZS5jb250ZW50LnRleHRCZXR3ZWVuKDAsIHNsaWNlLmNvbnRlbnQuc2l6ZSwgXCJcXG5cXG5cIik7XG4gICAgcmV0dXJuIHsgZG9tOiB3cmFwLCB0ZXh0IH07XG59XG4vLyBSZWFkIGEgc2xpY2Ugb2YgY29udGVudCBmcm9tIHRoZSBjbGlwYm9hcmQgKG9yIGRyb3AgZGF0YSkuXG5mdW5jdGlvbiBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgdGV4dCwgaHRtbCwgcGxhaW5UZXh0LCAkY29udGV4dCkge1xuICAgIGxldCBpbkNvZGUgPSAkY29udGV4dC5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gICAgbGV0IGRvbSwgc2xpY2U7XG4gICAgaWYgKCFodG1sICYmICF0ZXh0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYXNUZXh0ID0gdGV4dCAmJiAocGxhaW5UZXh0IHx8IGluQ29kZSB8fCAhaHRtbCk7XG4gICAgaWYgKGFzVGV4dCkge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkVGV4dFwiLCBmID0+IHsgdGV4dCA9IGYodGV4dCwgaW5Db2RlIHx8IHBsYWluVGV4dCwgdmlldyk7IH0pO1xuICAgICAgICBpZiAoaW5Db2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRleHQgPyBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh2aWV3LnN0YXRlLnNjaGVtYS50ZXh0KHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSkpLCAwLCAwKSA6IFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgcGFyc2VkID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRQYXJzZXJcIiwgZiA9PiBmKHRleHQsICRjb250ZXh0LCBwbGFpblRleHQsIHZpZXcpKTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgc2xpY2UgPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSAkY29udGV4dC5tYXJrcygpO1xuICAgICAgICAgICAgbGV0IHsgc2NoZW1hIH0gPSB2aWV3LnN0YXRlLCBzZXJpYWxpemVyID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGV4dC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pKy8pLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwID0gZG9tLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICAgICAgICAgIHAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVOb2RlKHNjaGVtYS50ZXh0KGJsb2NrLCBtYXJrcykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkSFRNTFwiLCBmID0+IHsgaHRtbCA9IGYoaHRtbCwgdmlldyk7IH0pO1xuICAgICAgICBkb20gPSByZWFkSFRNTChodG1sKTtcbiAgICAgICAgaWYgKHdlYmtpdClcbiAgICAgICAgICAgIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pO1xuICAgIH1cbiAgICBsZXQgY29udGV4dE5vZGUgPSBkb20gJiYgZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1wbS1zbGljZV1cIik7XG4gICAgbGV0IHNsaWNlRGF0YSA9IGNvbnRleHROb2RlICYmIC9eKFxcZCspIChcXGQrKSg/OiAtKFxcZCspKT8gKC4qKS8uZXhlYyhjb250ZXh0Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIpIHx8IFwiXCIpO1xuICAgIGlmIChzbGljZURhdGEgJiYgc2xpY2VEYXRhWzNdKVxuICAgICAgICBmb3IgKGxldCBpID0gK3NsaWNlRGF0YVszXTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRvbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgaWYgKCFzbGljZSkge1xuICAgICAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFBhcnNlclwiKSB8fCB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgc2xpY2UgPSBwYXJzZXIucGFyc2VTbGljZShkb20sIHtcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogISEoYXNUZXh0IHx8IHNsaWNlRGF0YSksXG4gICAgICAgICAgICBjb250ZXh0OiAkY29udGV4dCxcbiAgICAgICAgICAgIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZG9tLm5leHRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGRvbS5wYXJlbnROb2RlICYmICFpbmxpbmVQYXJlbnRzLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzbGljZURhdGEpIHtcbiAgICAgICAgc2xpY2UgPSBhZGRDb250ZXh0KGNsb3NlU2xpY2Uoc2xpY2UsICtzbGljZURhdGFbMV0sICtzbGljZURhdGFbMl0pLCBzbGljZURhdGFbNF0pO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gSFRNTCB3YXNuJ3QgY3JlYXRlZCBieSBQcm9zZU1pcnJvci4gTWFrZSBzdXJlIHRvcC1sZXZlbCBzaWJsaW5ncyBhcmUgY29oZXJlbnRcbiAgICAgICAgc2xpY2UgPSBTbGljZS5tYXhPcGVuKG5vcm1hbGl6ZVNpYmxpbmdzKHNsaWNlLmNvbnRlbnQsICRjb250ZXh0KSwgdHJ1ZSk7XG4gICAgICAgIGlmIChzbGljZS5vcGVuU3RhcnQgfHwgc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZDsgb3BlblN0YXJ0IDwgc2xpY2Uub3BlblN0YXJ0ICYmICFub2RlLnR5cGUuc3BlYy5pc29sYXRpbmc7IG9wZW5TdGFydCsrLCBub2RlID0gbm9kZS5maXJzdENoaWxkKSB7IH1cbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzbGljZS5jb250ZW50Lmxhc3RDaGlsZDsgb3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlbkVuZCsrLCBub2RlID0gbm9kZS5sYXN0Q2hpbGQpIHsgfVxuICAgICAgICAgICAgc2xpY2UgPSBjbG9zZVNsaWNlKHNsaWNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIHJldHVybiBzbGljZTtcbn1cbmNvbnN0IGlubGluZVBhcmVudHMgPSAvXihhfGFiYnJ8YWNyb255bXxifGNpdGV8Y29kZXxkZWx8ZW18aXxpbnN8a2JkfGxhYmVsfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNwYW58c3Ryb25nfHN1YnxzdXB8dGltZXx1fHR0fHZhcikkL2k7XG4vLyBUYWtlcyBhIHNsaWNlIHBhcnNlZCB3aXRoIHBhcnNlU2xpY2UsIHdoaWNoIG1lYW5zIHRoZXJlIGhhc24ndCBiZWVuXG4vLyBhbnkgY29udGVudC1leHByZXNzaW9uIGNoZWNraW5nIGRvbmUgb24gdGhlIHRvcCBub2RlcywgdHJpZXMgdG9cbi8vIGZpbmQgYSBwYXJlbnQgbm9kZSBpbiB0aGUgY3VycmVudCBjb250ZXh0IHRoYXQgbWlnaHQgZml0IHRoZSBub2Rlcyxcbi8vIGFuZCBpZiBzdWNjZXNzZnVsLCByZWJ1aWxkcyB0aGUgc2xpY2Ugc28gdGhhdCBpdCBmaXRzIGludG8gdGhhdCBwYXJlbnQuXG4vL1xuLy8gVGhpcyBhZGRyZXNzZXMgdGhlIHByb2JsZW0gdGhhdCBUcmFuc2Zvcm0ucmVwbGFjZSBleHBlY3RzIGFcbi8vIGNvaGVyZW50IHNsaWNlLCBhbmQgd2lsbCBmYWlsIHRvIHBsYWNlIGEgc2V0IG9mIHNpYmxpbmdzIHRoYXQgZG9uJ3Rcbi8vIGZpdCBhbnl3aGVyZSBpbiB0aGUgc2NoZW1hLlxuZnVuY3Rpb24gbm9ybWFsaXplU2libGluZ3MoZnJhZ21lbnQsICRjb250ZXh0KSB7XG4gICAgaWYgKGZyYWdtZW50LmNoaWxkQ291bnQgPCAyKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgZm9yIChsZXQgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gJGNvbnRleHQubm9kZShkKTtcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4KGQpKTtcbiAgICAgICAgbGV0IGxhc3RXcmFwLCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKG5vZGUudHlwZSksIGluTGFzdDtcbiAgICAgICAgICAgIGlmICghd3JhcClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpbkxhc3QgPSByZXN1bHQubGVuZ3RoICYmIGxhc3RXcmFwLmxlbmd0aCAmJiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIDApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IGluTGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gY2xvc2VSaWdodChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsYXN0V3JhcC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxldCB3cmFwcGVkID0gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXApO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHdyYXBwZWQpO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hUeXBlKHdyYXBwZWQudHlwZSk7XG4gICAgICAgICAgICAgICAgbGFzdFdyYXAgPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBmcm9tID0gMCkge1xuICAgIGZvciAobGV0IGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gZnJvbTsgaS0tKVxuICAgICAgICBub2RlID0gd3JhcFtpXS5jcmVhdGUobnVsbCwgRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG4vLyBVc2VkIHRvIGdyb3VwIGFkamFjZW50IG5vZGVzIHdyYXBwZWQgaW4gc2ltaWxhciBwYXJlbnRzIGJ5XG4vLyBub3JtYWxpemVTaWJsaW5ncyBpbnRvIHRoZSBzYW1lIHBhcmVudCBub2RlXG5mdW5jdGlvbiBhZGRUb1NpYmxpbmcod3JhcCwgbGFzdFdyYXAsIG5vZGUsIHNpYmxpbmcsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoIDwgd3JhcC5sZW5ndGggJiYgZGVwdGggPCBsYXN0V3JhcC5sZW5ndGggJiYgd3JhcFtkZXB0aF0gPT0gbGFzdFdyYXBbZGVwdGhdKSB7XG4gICAgICAgIGxldCBpbm5lciA9IGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZy5sYXN0Q2hpbGQsIGRlcHRoICsgMSk7XG4gICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LnJlcGxhY2VDaGlsZChzaWJsaW5nLmNoaWxkQ291bnQgLSAxLCBpbm5lcikpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBzaWJsaW5nLmNvbnRlbnRNYXRjaEF0KHNpYmxpbmcuY2hpbGRDb3VudCk7XG4gICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUoZGVwdGggPT0gd3JhcC5sZW5ndGggLSAxID8gbm9kZS50eXBlIDogd3JhcFtkZXB0aCArIDFdKSlcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nLmNvcHkoc2libGluZy5jb250ZW50LmFwcGVuZChGcmFnbWVudC5mcm9tKHdpdGhXcmFwcGVycyhub2RlLCB3cmFwLCBkZXB0aCArIDEpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlUmlnaHQobm9kZSwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgbGV0IGZyYWdtZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChub2RlLmNoaWxkQ291bnQgLSAxLCBjbG9zZVJpZ2h0KG5vZGUubGFzdENoaWxkLCBkZXB0aCAtIDEpKTtcbiAgICBsZXQgZmlsbCA9IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICByZXR1cm4gbm9kZS5jb3B5KGZyYWdtZW50LmFwcGVuZChmaWxsKSk7XG59XG5mdW5jdGlvbiBjbG9zZVJhbmdlKGZyYWdtZW50LCBzaWRlLCBmcm9tLCB0bywgZGVwdGgsIG9wZW5FbmQpIHtcbiAgICBsZXQgbm9kZSA9IHNpZGUgPCAwID8gZnJhZ21lbnQuZmlyc3RDaGlsZCA6IGZyYWdtZW50Lmxhc3RDaGlsZCwgaW5uZXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgaWYgKGRlcHRoIDwgdG8gLSAxKVxuICAgICAgICBpbm5lciA9IGNsb3NlUmFuZ2UoaW5uZXIsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCArIDEsIG9wZW5FbmQpO1xuICAgIGlmIChkZXB0aCA+PSBmcm9tKVxuICAgICAgICBpbm5lciA9IHNpZGUgPCAwID8gbm9kZS5jb250ZW50TWF0Y2hBdCgwKS5maWxsQmVmb3JlKGlubmVyLCBmcmFnbWVudC5jaGlsZENvdW50ID4gMSB8fCBvcGVuRW5kIDw9IGRlcHRoKS5hcHBlbmQoaW5uZXIpXG4gICAgICAgICAgICA6IGlubmVyLmFwcGVuZChub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoc2lkZSA8IDAgPyAwIDogZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIG5vZGUuY29weShpbm5lcikpO1xufVxuZnVuY3Rpb24gY2xvc2VTbGljZShzbGljZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgaWYgKG9wZW5TdGFydCA8IHNsaWNlLm9wZW5TdGFydClcbiAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAtMSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuU3RhcnQsIDAsIHNsaWNlLm9wZW5FbmQpLCBvcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpO1xuICAgIGlmIChvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZClcbiAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoY2xvc2VSYW5nZShzbGljZS5jb250ZW50LCAxLCBvcGVuRW5kLCBzbGljZS5vcGVuRW5kLCAwLCAwKSwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICByZXR1cm4gc2xpY2U7XG59XG4vLyBUcmljayBmcm9tIGpRdWVyeSAtLSBzb21lIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBvdGhlclxuLy8gZWxlbWVudHMgZm9yIGlubmVySFRNTCB0byB3b3JrLiBJLmUuIGlmIHlvdSBkbyBgZGl2LmlubmVySFRNTCA9XG4vLyBcIjx0ZD4uLjwvdGQ+XCJgIHRoZSB0YWJsZSBjZWxscyBhcmUgaWdub3JlZC5cbmNvbnN0IHdyYXBNYXAgPSB7XG4gICAgdGhlYWQ6IFtcInRhYmxlXCJdLFxuICAgIHRib2R5OiBbXCJ0YWJsZVwiXSxcbiAgICB0Zm9vdDogW1widGFibGVcIl0sXG4gICAgY2FwdGlvbjogW1widGFibGVcIl0sXG4gICAgY29sZ3JvdXA6IFtcInRhYmxlXCJdLFxuICAgIGNvbDogW1widGFibGVcIiwgXCJjb2xncm91cFwiXSxcbiAgICB0cjogW1widGFibGVcIiwgXCJ0Ym9keVwiXSxcbiAgICB0ZDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdLFxuICAgIHRoOiBbXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidHJcIl1cbn07XG5sZXQgX2RldGFjaGVkRG9jID0gbnVsbDtcbmZ1bmN0aW9uIGRldGFjaGVkRG9jKCkge1xuICAgIHJldHVybiBfZGV0YWNoZWREb2MgfHwgKF9kZXRhY2hlZERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcInRpdGxlXCIpKTtcbn1cbmZ1bmN0aW9uIHJlYWRIVE1MKGh0bWwpIHtcbiAgICBsZXQgbWV0YXMgPSAvXihcXHMqPG1ldGEgW14+XSo+KSovLmV4ZWMoaHRtbCk7XG4gICAgaWYgKG1ldGFzKVxuICAgICAgICBodG1sID0gaHRtbC5zbGljZShtZXRhc1swXS5sZW5ndGgpO1xuICAgIGxldCBlbHQgPSBkZXRhY2hlZERvYygpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbGV0IGZpcnN0VGFnID0gLzwoW2Etel1bXj5cXHNdKykvaS5leGVjKGh0bWwpLCB3cmFwO1xuICAgIGlmICh3cmFwID0gZmlyc3RUYWcgJiYgd3JhcE1hcFtmaXJzdFRhZ1sxXS50b0xvd2VyQ2FzZSgpXSlcbiAgICAgICAgaHRtbCA9IHdyYXAubWFwKG4gPT4gXCI8XCIgKyBuICsgXCI+XCIpLmpvaW4oXCJcIikgKyBodG1sICsgd3JhcC5tYXAobiA9PiBcIjwvXCIgKyBuICsgXCI+XCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIGVsdC5pbm5lckhUTUwgPSBodG1sO1xuICAgIGlmICh3cmFwKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBlbHQgPSBlbHQucXVlcnlTZWxlY3Rvcih3cmFwW2ldKSB8fCBlbHQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbi8vIFdlYmtpdCBicm93c2VycyBkbyBzb21lIGhhcmQtdG8tcHJlZGljdCByZXBsYWNlbWVudCBvZiByZWd1bGFyXG4vLyBzcGFjZXMgd2l0aCBub24tYnJlYWtpbmcgc3BhY2VzIHdoZW4gcHV0dGluZyBjb250ZW50IG9uIHRoZVxuLy8gY2xpcGJvYXJkLiBUaGlzIHRyaWVzIHRvIGNvbnZlcnQgc3VjaCBub24tYnJlYWtpbmcgc3BhY2VzICh3aGljaFxuLy8gd2lsbCBiZSB3cmFwcGVkIGluIGEgcGxhaW4gc3BhbiBvbiBDaHJvbWUsIGEgc3BhbiB3aXRoIGNsYXNzXG4vLyBBcHBsZS1jb252ZXJ0ZWQtc3BhY2Ugb24gU2FmYXJpKSBiYWNrIHRvIHJlZ3VsYXIgc3BhY2VzLlxuZnVuY3Rpb24gcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSkge1xuICAgIGxldCBub2RlcyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKGNocm9tZSA/IFwic3Bhbjpub3QoW2NsYXNzXSk6bm90KFtzdHlsZV0pXCIgOiBcInNwYW4uQXBwbGUtY29udmVydGVkLXNwYWNlXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLnRleHRDb250ZW50ID09IFwiXFx1MDBhMFwiICYmIG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRDb250ZXh0KHNsaWNlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgbGV0IHNjaGVtYSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLnNjaGVtYSwgYXJyYXk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXJyYXkgPSBKU09OLnBhcnNlKGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfVxuICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm5vZGVzW2FycmF5W2ldXTtcbiAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGFycmF5W2kgKyAxXSwgY29udGVudCkpO1xuICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgb3BlbkVuZCsrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbi8vIEEgY29sbGVjdGlvbiBvZiBET00gZXZlbnRzIHRoYXQgb2NjdXIgd2l0aGluIHRoZSBlZGl0b3IsIGFuZCBjYWxsYmFjayBmdW5jdGlvbnNcbi8vIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBmaXJlcy5cbmNvbnN0IGhhbmRsZXJzID0ge307XG5jb25zdCBlZGl0SGFuZGxlcnMgPSB7fTtcbmNvbnN0IHBhc3NpdmVIYW5kbGVycyA9IHsgdG91Y2hzdGFydDogdHJ1ZSwgdG91Y2htb3ZlOiB0cnVlIH07XG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaGlmdEtleSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdENsaWNrID0geyB0aW1lOiAwLCB4OiAwLCB5OiAwLCB0eXBlOiBcIlwiIH07XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHRoaXMubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSAwO1xuICAgICAgICB0aGlzLmxhc3RBbmRyb2lkRGVsZXRlID0gMDtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmdUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25JRCA9IDE7XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmhpZGVTZWxlY3Rpb25HdWFyZCA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdElucHV0KHZpZXcpIHtcbiAgICBmb3IgKGxldCBldmVudCBpbiBoYW5kbGVycykge1xuICAgICAgICBsZXQgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW2V2ZW50XSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50QmVsb25nc1RvVmlldyh2aWV3LCBldmVudCkgJiYgIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmXG4gICAgICAgICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKVxuICAgICAgICAgICAgICAgIGhhbmRsZXIodmlldywgZXZlbnQpO1xuICAgICAgICB9LCBwYXNzaXZlSGFuZGxlcnNbZXZlbnRdID8geyBwYXNzaXZlOiB0cnVlIH0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvLyBPbiBTYWZhcmksIGZvciByZWFzb25zIGJleW9uZCBteSB1bmRlcnN0YW5kaW5nLCBhZGRpbmcgYW4gaW5wdXRcbiAgICAvLyBldmVudCBoYW5kbGVyIG1ha2VzIGFuIGlzc3VlIHdoZXJlIHRoZSBjb21wb3NpdGlvbiB2YW5pc2hlcyB3aGVuXG4gICAgLy8geW91IHByZXNzIGVudGVyIGdvIGF3YXkuXG4gICAgaWYgKHNhZmFyaSlcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpO1xuICAgIGVuc3VyZUxpc3RlbmVycyh2aWV3KTtcbn1cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBvcmlnaW4pIHtcbiAgICB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBvcmlnaW47XG4gICAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG59XG5mdW5jdGlvbiBkZXN0cm95SW5wdXQodmlldykge1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIGZvciAobGV0IHR5cGUgaW4gdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzKVxuICAgICAgICB2aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSk7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0KTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUxpc3RlbmVycyh2aWV3KSB7XG4gICAgdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBjdXJyZW50SGFuZGxlcnMgPT4ge1xuICAgICAgICBmb3IgKGxldCB0eXBlIGluIGN1cnJlbnRIYW5kbGVycylcbiAgICAgICAgICAgIGlmICghdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdKVxuICAgICAgICAgICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdmlldy5pbnB1dC5ldmVudEhhbmRsZXJzW3R5cGVdID0gZXZlbnQgPT4gcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkge1xuICAgIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRE9NRXZlbnRzXCIsIGhhbmRsZXJzID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudC50eXBlXTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIgPyBoYW5kbGVyKHZpZXcsIGV2ZW50KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkIDogZmFsc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmJ1YmJsZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbm9kZSA9IGV2ZW50LnRhcmdldDsgbm9kZSAhPSB2aWV3LmRvbTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgfHxcbiAgICAgICAgICAgIChub2RlLnBtVmlld0Rlc2MgJiYgbm9kZS5wbVZpZXdEZXNjLnN0b3BFdmVudChldmVudCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh2aWV3LCBldmVudCkge1xuICAgIGlmICghcnVuQ3VzdG9tSGFuZGxlcih2aWV3LCBldmVudCkgJiYgaGFuZGxlcnNbZXZlbnQudHlwZV0gJiZcbiAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgIShldmVudC50eXBlIGluIGVkaXRIYW5kbGVycykpKVxuICAgICAgICBoYW5kbGVyc1tldmVudC50eXBlXSh2aWV3LCBldmVudCk7XG59XG5lZGl0SGFuZGxlcnMua2V5ZG93biA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGV2ZW50LmtleUNvZGUgPT0gMTYgfHwgZXZlbnQuc2hpZnRLZXk7XG4gICAgaWYgKGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFN1cHByZXNzIGVudGVyIGtleSBldmVudHMgb24gQ2hyb21lIEFuZHJvaWQsIGJlY2F1c2UgdGhvc2UgdGVuZFxuICAgIC8vIHRvIGJlIHBhcnQgb2YgYSBjb25mdXNlZCBzZXF1ZW5jZSBvZiBjb21wb3NpdGlvbiBldmVudHMgZmlyZWQsXG4gICAgLy8gYW5kIGhhbmRsaW5nIHRoZW0gZWFnZXJseSB0ZW5kcyB0byBjb3JydXB0IHRoZSBpbnB1dC5cbiAgICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUgJiYgZXZlbnQua2V5Q29kZSA9PSAxMylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChldmVudC5rZXlDb2RlICE9IDIyOSlcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgLy8gT24gaU9TLCBpZiB3ZSBwcmV2ZW50RGVmYXVsdCBlbnRlciBrZXkgcHJlc3NlcywgdGhlIHZpcnR1YWxcbiAgICAvLyBrZXlib2FyZCBnZXRzIGNvbmZ1c2VkLiBTbyB0aGUgaGFjayBoZXJlIGlzIHRvIHNldCBhIGZsYWcgdGhhdFxuICAgIC8vIG1ha2VzIHRoZSBET00gY2hhbmdlIGNvZGUgcmVjb2duaXplIHRoYXQgd2hhdCBqdXN0IGhhcHBlbnMgc2hvdWxkXG4gICAgLy8gYmUgcmVwbGFjZWQgYnkgd2hhdGV2ZXIgdGhlIEVudGVyIGtleSBoYW5kbGVycyBkby5cbiAgICBpZiAoaW9zICYmIGV2ZW50LmtleUNvZGUgPT0gMTMgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQubWV0YUtleSkge1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSBub3c7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyRmFsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPT0gbm93KSB7XG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSk7XG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywgZXZlbnQpKSB8fCBjYXB0dXJlS2V5RG93bih2aWV3LCBldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcImtleVwiKTtcbiAgICB9XG59O1xuZWRpdEhhbmRsZXJzLmtleXVwID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTYpXG4gICAgICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBmYWxzZTtcbn07XG5lZGl0SGFuZGxlcnMua2V5cHJlc3MgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSB8fCAhZXZlbnQuY2hhckNvZGUgfHxcbiAgICAgICAgZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5IHx8IG1hYyAmJiBldmVudC5tZXRhS2V5KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlQcmVzc1wiLCBmID0+IGYodmlldywgZXZlbnQpKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB8fCAhc2VsLiRmcm9tLnNhbWVQYXJlbnQoc2VsLiR0bykpIHtcbiAgICAgICAgbGV0IHRleHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmNoYXJDb2RlKTtcbiAgICAgICAgaWYgKCEvW1xcclxcbl0vLnRlc3QodGV4dCkgJiYgIXZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZiA9PiBmKHZpZXcsIHNlbC4kZnJvbS5wb3MsIHNlbC4kdG8ucG9zLCB0ZXh0KSkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZXZlbnRDb29yZHMoZXZlbnQpIHsgcmV0dXJuIHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH07IH1cbmZ1bmN0aW9uIGlzTmVhcihldmVudCwgY2xpY2spIHtcbiAgICBsZXQgZHggPSBjbGljay54IC0gZXZlbnQuY2xpZW50WCwgZHkgPSBjbGljay55IC0gZXZlbnQuY2xpZW50WTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPCAxMDA7XG59XG5mdW5jdGlvbiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIHByb3BOYW1lLCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSk7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggKyAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGlmICh2aWV3LnNvbWVQcm9wKHByb3BOYW1lLCBmID0+IGkgPiAkcG9zLmRlcHRoID8gZih2aWV3LCBwb3MsICRwb3Mubm9kZUFmdGVyLCAkcG9zLmJlZm9yZShpKSwgZXZlbnQsIHRydWUpXG4gICAgICAgICAgICA6IGYodmlldywgcG9zLCAkcG9zLm5vZGUoaSksICRwb3MuYmVmb3JlKGkpLCBldmVudCwgZmFsc2UpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24odmlldywgc2VsZWN0aW9uLCBvcmlnaW4pIHtcbiAgICBpZiAoIXZpZXcuZm9jdXNlZClcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgaWYgKG9yaWdpbiA9PSBcInBvaW50ZXJcIilcbiAgICAgICAgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG59XG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGluc2lkZSksIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICBpZiAobm9kZSAmJiBub2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyksIFwicG9pbnRlclwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24sIHNlbGVjdGVkTm9kZSwgc2VsZWN0QXQ7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pXG4gICAgICAgIHNlbGVjdGVkTm9kZSA9IHNlbC5ub2RlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpO1xuICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9IGkgPiAkcG9zLmRlcHRoID8gJHBvcy5ub2RlQWZ0ZXIgOiAkcG9zLm5vZGUoaSk7XG4gICAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBzZWwuJGZyb20uZGVwdGggPiAwICYmXG4gICAgICAgICAgICAgICAgaSA+PSBzZWwuJGZyb20uZGVwdGggJiYgJHBvcy5iZWZvcmUoc2VsLiRmcm9tLmRlcHRoICsgMSkgPT0gc2VsLiRmcm9tLnBvcylcbiAgICAgICAgICAgICAgICBzZWxlY3RBdCA9ICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VsZWN0QXQgPSAkcG9zLmJlZm9yZShpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxlY3RBdCAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgc2VsZWN0QXQpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCwgc2VsZWN0Tm9kZSkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpIHx8XG4gICAgICAgIChzZWxlY3ROb2RlID8gc2VsZWN0Q2xpY2tlZE5vZGUodmlldywgaW5zaWRlKSA6IHNlbGVjdENsaWNrZWRMZWFmKHZpZXcsIGluc2lkZSkpO1xufVxuZnVuY3Rpb24gaGFuZGxlRG91YmxlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVEb3VibGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZURvdWJsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSk7XG59XG5mdW5jdGlvbiBoYW5kbGVUcmlwbGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZVRyaXBsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlVHJpcGxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKSB8fFxuICAgICAgICBkZWZhdWx0VHJpcGxlQ2xpY2sodmlldywgaW5zaWRlLCBldmVudCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0VHJpcGxlQ2xpY2sodmlldywgaW5zaWRlLCBldmVudCkge1xuICAgIGlmIChldmVudC5idXR0b24gIT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBpZiAoaW5zaWRlID09IC0xKSB7XG4gICAgICAgIGlmIChkb2MuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgMCwgZG9jLmNvbnRlbnQuc2l6ZSksIFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShpbnNpZGUpO1xuICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoICsgMTsgaSA+IDA7IGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9IGkgPiAkcG9zLmRlcHRoID8gJHBvcy5ub2RlQWZ0ZXIgOiAkcG9zLm5vZGUoaSk7XG4gICAgICAgIGxldCBub2RlUG9zID0gJHBvcy5iZWZvcmUoaSk7XG4gICAgICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zICsgMSwgbm9kZVBvcyArIDEgKyBub2RlLmNvbnRlbnQuc2l6ZSksIFwicG9pbnRlclwiKTtcbiAgICAgICAgZWxzZSBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBub2RlUG9zKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZm9yY2VET01GbHVzaCh2aWV3KSB7XG4gICAgcmV0dXJuIGVuZENvbXBvc2l0aW9uKHZpZXcpO1xufVxuY29uc3Qgc2VsZWN0Tm9kZU1vZGlmaWVyID0gbWFjID8gXCJtZXRhS2V5XCIgOiBcImN0cmxLZXlcIjtcbmhhbmRsZXJzLm1vdXNlZG93biA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgdmlldy5pbnB1dC5zaGlmdEtleSA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGxldCBmbHVzaGVkID0gZm9yY2VET01GbHVzaCh2aWV3KTtcbiAgICBsZXQgbm93ID0gRGF0ZS5ub3coKSwgdHlwZSA9IFwic2luZ2xlQ2xpY2tcIjtcbiAgICBpZiAobm93IC0gdmlldy5pbnB1dC5sYXN0Q2xpY2sudGltZSA8IDUwMCAmJiBpc05lYXIoZXZlbnQsIHZpZXcuaW5wdXQubGFzdENsaWNrKSAmJiAhZXZlbnRbc2VsZWN0Tm9kZU1vZGlmaWVyXSkge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpXG4gICAgICAgICAgICB0eXBlID0gXCJkb3VibGVDbGlja1wiO1xuICAgICAgICBlbHNlIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwiZG91YmxlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcInRyaXBsZUNsaWNrXCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdENsaWNrID0geyB0aW1lOiBub3csIHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHR5cGUgfTtcbiAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGlmICghcG9zKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGUgPT0gXCJzaW5nbGVDbGlja1wiKSB7XG4gICAgICAgIGlmICh2aWV3LmlucHV0Lm1vdXNlRG93bilcbiAgICAgICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duLmRvbmUoKTtcbiAgICAgICAgdmlldy5pbnB1dC5tb3VzZURvd24gPSBuZXcgTW91c2VEb3duKHZpZXcsIHBvcywgZXZlbnQsICEhZmx1c2hlZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCh0eXBlID09IFwiZG91YmxlQ2xpY2tcIiA/IGhhbmRsZURvdWJsZUNsaWNrIDogaGFuZGxlVHJpcGxlQ2xpY2spKHZpZXcsIHBvcy5wb3MsIHBvcy5pbnNpZGUsIGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbiAgICB9XG59O1xuY2xhc3MgTW91c2VEb3duIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBwb3MsIGV2ZW50LCBmbHVzaGVkKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuZmx1c2hlZCA9IGZsdXNoZWQ7XG4gICAgICAgIHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taWdodERyYWcgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXJ0RG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgICAgIHRoaXMuc2VsZWN0Tm9kZSA9ICEhZXZlbnRbc2VsZWN0Tm9kZU1vZGlmaWVyXTtcbiAgICAgICAgdGhpcy5hbGxvd0RlZmF1bHQgPSBldmVudC5zaGlmdEtleTtcbiAgICAgICAgbGV0IHRhcmdldE5vZGUsIHRhcmdldFBvcztcbiAgICAgICAgaWYgKHBvcy5pbnNpZGUgPiAtMSkge1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHZpZXcuc3RhdGUuZG9jLm5vZGVBdChwb3MuaW5zaWRlKTtcbiAgICAgICAgICAgIHRhcmdldFBvcyA9IHBvcy5pbnNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcyk7XG4gICAgICAgICAgICB0YXJnZXROb2RlID0gJHBvcy5wYXJlbnQ7XG4gICAgICAgICAgICB0YXJnZXRQb3MgPSAkcG9zLmRlcHRoID8gJHBvcy5iZWZvcmUoKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZmx1c2hlZCA/IG51bGwgOiBldmVudC50YXJnZXQ7XG4gICAgICAgIGNvbnN0IHRhcmdldERlc2MgPSB0YXJnZXQgPyB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2ModGFyZ2V0LCB0cnVlKSA6IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0RGVzYyA/IHRhcmdldERlc2MuZG9tIDogbnVsbDtcbiAgICAgICAgbGV0IHsgc2VsZWN0aW9uIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgIHRhcmdldE5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiB0YXJnZXROb2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZSB8fFxuICAgICAgICAgICAgc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzZWxlY3Rpb24uZnJvbSA8PSB0YXJnZXRQb3MgJiYgc2VsZWN0aW9uLnRvID4gdGFyZ2V0UG9zKVxuICAgICAgICAgICAgdGhpcy5taWdodERyYWcgPSB7XG4gICAgICAgICAgICAgICAgbm9kZTogdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgICAgICBwb3M6IHRhcmdldFBvcyxcbiAgICAgICAgICAgICAgICBhZGRBdHRyOiAhISh0aGlzLnRhcmdldCAmJiAhdGhpcy50YXJnZXQuZHJhZ2dhYmxlKSxcbiAgICAgICAgICAgICAgICBzZXRVbmVkaXRhYmxlOiAhISh0aGlzLnRhcmdldCAmJiBnZWNrbyAmJiAhdGhpcy50YXJnZXQuaGFzQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0ICYmIHRoaXMubWlnaHREcmFnICYmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyIHx8IHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LmlucHV0Lm1vdXNlRG93biA9PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuc2V0QXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIsIFwiZmFsc2VcIik7XG4gICAgICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xuICAgICAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gICAgfVxuICAgIGRvbmUoKSB7XG4gICAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG4gICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZyAmJiB0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRTZWxlY3Rpb25TeW5jKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0Lm1vdXNlRG93biA9IG51bGw7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgICBpZiAoIXRoaXMudmlldy5kb20uY29udGFpbnMoZXZlbnQudGFyZ2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmRvYyAhPSB0aGlzLnN0YXJ0RG9jKVxuICAgICAgICAgICAgcG9zID0gdGhpcy52aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgICAgIHRoaXMudXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dEZWZhdWx0IHx8ICFwb3MpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYW5kbGVTaW5nbGVDbGljayh0aGlzLnZpZXcsIHBvcy5wb3MsIHBvcy5pbnNpZGUsIGV2ZW50LCB0aGlzLnNlbGVjdE5vZGUpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmJ1dHRvbiA9PSAwICYmXG4gICAgICAgICAgICAodGhpcy5mbHVzaGVkIHx8XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGlnbm9yZXMgY2xpY2tzIG9uIGRyYWdnYWJsZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIChzYWZhcmkgJiYgdGhpcy5taWdodERyYWcgJiYgIXRoaXMubWlnaHREcmFnLm5vZGUuaXNBdG9tKSB8fFxuICAgICAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHNvbWV0aW1lcyB0cmVhdCBhIG5vZGUgc2VsZWN0aW9uIGFzIGFcbiAgICAgICAgICAgICAgICAvLyBjdXJzb3IsIGJ1dCBzdGlsbCByZXBvcnQgdGhhdCB0aGUgbm9kZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gYXNrZWQgdGhyb3VnaCBnZXRTZWxlY3Rpb24uIFlvdSdsbCB0aGVuIGdldCBhXG4gICAgICAgICAgICAgICAgLy8gc2l0dWF0aW9uIHdoZXJlIGNsaWNraW5nIGF0IHRoZSBwb2ludCB3aGVyZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gKGhpZGRlbikgY3Vyc29yIGlzIGRvZXNuJ3QgY2hhbmdlIHRoZSBzZWxlY3Rpb24sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRodXMgZG9lc24ndCBnZXQgYSByZWFjdGlvbiBmcm9tIFByb3NlTWlycm9yLiBUaGlzXG4gICAgICAgICAgICAgICAgLy8gd29ya3MgYXJvdW5kIHRoYXQuXG4gICAgICAgICAgICAgICAgKGNocm9tZSAmJiAhdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlICYmXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pLCBNYXRoLmFicyhwb3MucG9zIC0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi50bykpIDw9IDIpKSkge1xuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHRoaXMudmlldywgU2VsZWN0aW9uLm5lYXIodGhpcy52aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKVxuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgfVxuICAgIHVwZGF0ZUFsbG93RGVmYXVsdChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dEZWZhdWx0ICYmIChNYXRoLmFicyh0aGlzLmV2ZW50LnggLSBldmVudC5jbGllbnRYKSA+IDQgfHxcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuZXZlbnQueSAtIGV2ZW50LmNsaWVudFkpID4gNCkpXG4gICAgICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IHRydWU7XG4gICAgfVxufVxuaGFuZGxlcnMudG91Y2hzdGFydCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXQubGFzdFRvdWNoID0gRGF0ZS5ub3coKTtcbiAgICBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMudG91Y2htb3ZlID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0VG91Y2ggPSBEYXRlLm5vdygpO1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMuY29udGV4dG1lbnUgPSB2aWV3ID0+IGZvcmNlRE9NRmx1c2godmlldyk7XG5mdW5jdGlvbiBpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXG4gICAgLy8gT24gSmFwYW5lc2UgaW5wdXQgbWV0aG9kIGVkaXRvcnMgKElNRXMpLCB0aGUgRW50ZXIga2V5IGlzIHVzZWQgdG8gY29uZmlybSBjaGFyYWN0ZXJcbiAgICAvLyBzZWxlY3Rpb24uIE9uIFNhZmFyaSwgd2hlbiBFbnRlciBpcyBwcmVzc2VkLCBjb21wb3NpdGlvbmVuZCBhbmQga2V5ZG93biBldmVudHMgYXJlXG4gICAgLy8gZW1pdHRlZC4gVGhlIGtleWRvd24gZXZlbnQgdHJpZ2dlcnMgbmV3bGluZSBpbnNlcnRpb24sIHdoaWNoIHdlIGRvbid0IHdhbnQuXG4gICAgLy8gVGhpcyBtZXRob2QgcmV0dXJucyB0cnVlIGlmIHRoZSBrZXlkb3duIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkLlxuICAgIC8vIFdlIG9ubHkgaWdub3JlIGl0IG9uY2UsIGFzIHByZXNzaW5nIEVudGVyIGEgc2Vjb25kIHRpbWUgKnNob3VsZCogaW5zZXJ0IGEgbmV3bGluZS5cbiAgICAvLyBGdXJ0aGVybW9yZSwgdGhlIGtleWRvd24gZXZlbnQgdGltZXN0YW1wIG11c3QgYmUgY2xvc2UgdG8gdGhlIGNvbXBvc2l0aW9uRW5kZWRBdCB0aW1lc3RhbXAuXG4gICAgLy8gVGhpcyBndWFyZHMgYWdhaW5zdCB0aGUgY2FzZSB3aGVyZSBjb21wb3NpdGlvbmVuZCBpcyB0cmlnZ2VyZWQgd2l0aG91dCB0aGUga2V5Ym9hcmRcbiAgICAvLyAoZS5nLiBjaGFyYWN0ZXIgY29uZmlybWF0aW9uIG1heSBiZSBkb25lIHdpdGggdGhlIG1vdXNlKSwgYW5kIGtleWRvd24gaXMgdHJpZ2dlcmVkXG4gICAgLy8gYWZ0ZXJ3YXJkcy0gd2Ugd291bGRuJ3Qgd2FudCB0byBpZ25vcmUgdGhlIGtleWRvd24gZXZlbnQgaW4gdGhpcyBjYXNlLlxuICAgIGlmIChzYWZhcmkgJiYgTWF0aC5hYnMoZXZlbnQudGltZVN0YW1wIC0gdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQpIDwgNTAwKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gLTJlODtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIERyb3AgYWN0aXZlIGNvbXBvc2l0aW9uIGFmdGVyIDUgc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIEFuZHJvaWRcbmNvbnN0IHRpbWVvdXRDb21wb3NpdGlvbiA9IGFuZHJvaWQgPyA1MDAwIDogLTE7XG5lZGl0SGFuZGxlcnMuY29tcG9zaXRpb25zdGFydCA9IGVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IHZpZXcgPT4ge1xuICAgIGlmICghdmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5mbHVzaCgpO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgJHBvcyA9IHN0YXRlLnNlbGVjdGlvbi4kZnJvbTtcbiAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJlxuICAgICAgICAgICAgKHN0YXRlLnN0b3JlZE1hcmtzIHx8XG4gICAgICAgICAgICAgICAgKCEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5wYXJlbnRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLnNvbWUobSA9PiBtLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlKSkpKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHdyYXAgdGhlIGN1cnNvciBpbiBtYXJrIG5vZGVzIGRpZmZlcmVudCBmcm9tIHRoZSBvbmVzIGluIHRoZSBET00gY29udGV4dFxuICAgICAgICAgICAgdmlldy5tYXJrQ3Vyc29yID0gdmlldy5zdGF0ZS5zdG9yZWRNYXJrcyB8fCAkcG9zLm1hcmtzKCk7XG4gICAgICAgICAgICBlbmRDb21wb3NpdGlvbih2aWV3LCB0cnVlKTtcbiAgICAgICAgICAgIHZpZXcubWFya0N1cnNvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRDb21wb3NpdGlvbih2aWV3KTtcbiAgICAgICAgICAgIC8vIEluIGZpcmVmb3gsIGlmIHRoZSBjdXJzb3IgaXMgYWZ0ZXIgYnV0IG91dHNpZGUgYSBtYXJrZWQgbm9kZSxcbiAgICAgICAgICAgIC8vIHRoZSBpbnNlcnRlZCB0ZXh0IHdvbid0IGluaGVyaXQgdGhlIG1hcmtzLiBTbyB0aGlzIG1vdmVzIGl0XG4gICAgICAgICAgICAvLyBpbnNpZGUgaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIHN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAhJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7IG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCAhPSAwOykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gb2Zmc2V0IDwgMCA/IG5vZGUubGFzdENoaWxkIDogbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZG9tU2VsZWN0aW9uKCkuY29sbGFwc2UoYmVmb3JlLCBiZWZvcmUubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IHRydWU7XG4gICAgfVxuICAgIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCB0aW1lb3V0Q29tcG9zaXRpb24pO1xufTtcbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbmVuZCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbklEKys7XG4gICAgICAgIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCAyMCk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNjaGVkdWxlQ29tcG9zZUVuZCh2aWV3LCBkZWxheSkge1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICAgIGlmIChkZWxheSA+IC0xKVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGVuZENvbXBvc2l0aW9uKHZpZXcpLCBkZWxheSk7XG59XG5mdW5jdGlvbiBjbGVhckNvbXBvc2l0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSB0aW1lc3RhbXBGcm9tQ3VzdG9tRXZlbnQoKTtcbiAgICB9XG4gICAgd2hpbGUgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5sZW5ndGggPiAwKVxuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMucG9wKCkubWFya1BhcmVudHNEaXJ0eSgpO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwiZXZlbnRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcDtcbn1cbi8qKlxuQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZW5kQ29tcG9zaXRpb24odmlldywgZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmIChhbmRyb2lkICYmIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hpbmdTb29uID49IDApXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICBjbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuICAgIGlmIChmb3JjZVVwZGF0ZSB8fCB2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KSB7XG4gICAgICAgIGxldCBzZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcpO1xuICAgICAgICBpZiAoc2VsICYmICFzZWwuZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgd3JhcCA9IHZpZXcuZG9tLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgIHdyYXAuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGRvbSk7XG4gICAgLy8gRG9uZSBiZWNhdXNlIElFIHdpbGwgZmlyZSBhIHNlbGVjdGlvbmNoYW5nZSBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgIC8vIHRvIGl0cyBzdGFydCB3aGVuIHJlbW92ZUFsbFJhbmdlcyBpcyBjYWxsZWQgYW5kIHRoZSBlZGl0b3Igc3RpbGxcbiAgICAvLyBoYXMgZm9jdXMgKHdoaWNoIHdpbGwgbWVzcyB1cCB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uIHN0YXRlKS5cbiAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3cmFwLnBhcmVudE5vZGUpXG4gICAgICAgICAgICB3cmFwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUEnigJRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoaWUgJiYgaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChpb3MgJiYgd2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuaGFuZGxlcnMuY29weSA9IGVkaXRIYW5kbGVycy5jdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgY3V0ID0gZXZlbnQudHlwZSA9PSBcImN1dFwiO1xuICAgIGlmIChzZWwuZW1wdHkpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBJRSBhbmQgRWRnZSdzIGNsaXBib2FyZCBpbnRlcmZhY2UgaXMgY29tcGxldGVseSBicm9rZW5cbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBzbGljZSA9IHNlbC5jb250ZW50KCksIHsgZG9tLCB0ZXh0IH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSk7XG4gICAgfVxuICAgIGlmIChjdXQpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiY3V0XCIpKTtcbn07XG5mdW5jdGlvbiBzbGljZVNpbmdsZU5vZGUoc2xpY2UpIHtcbiAgICByZXR1cm4gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxID8gc2xpY2UuY29udGVudC5maXJzdENoaWxkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCkge1xuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBwbGFpblRleHQgPSB2aWV3LmlucHV0LnNoaWZ0S2V5IHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgdGFyZ2V0ID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KHBsYWluVGV4dCA/IFwidGV4dGFyZWFcIiA6IFwiZGl2XCIpKTtcbiAgICBpZiAoIXBsYWluVGV4dClcbiAgICAgICAgdGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICBpZiAodGFyZ2V0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgICAgICBpZiAocGxhaW5UZXh0KVxuICAgICAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUsIG51bGwsIHZpZXcuaW5wdXQuc2hpZnRLZXksIGV2ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudGV4dENvbnRlbnQsIHRhcmdldC5pbm5lckhUTUwsIHZpZXcuaW5wdXQuc2hpZnRLZXksIGV2ZW50KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCBldmVudCkge1xuICAgIGxldCBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwcmVmZXJQbGFpbiwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlUGFzdGVcIiwgZiA9PiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBTbGljZS5lbXB0eSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNpbmdsZU5vZGUgPSBzbGljZVNpbmdsZU5vZGUoc2xpY2UpO1xuICAgIGxldCB0ciA9IHNpbmdsZU5vZGVcbiAgICAgICAgPyB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNpbmdsZU5vZGUsIHZpZXcuaW5wdXQuc2hpZnRLZXkpXG4gICAgICAgIDogdmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInBhc3RlXCIsIHRydWUpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwicGFzdGVcIikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZWRpdEhhbmRsZXJzLnBhc3RlID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICAvLyBIYW5kbGluZyBwYXN0ZSBmcm9tIEphdmFTY3JpcHQgZHVyaW5nIGNvbXBvc2l0aW9uIGlzIHZlcnkgcG9vcmx5XG4gICAgLy8gaGFuZGxlZCBieSBicm93c2Vycywgc28gYXMgYSBkb2RneSBidXQgcHJlZmVyYWJsZSBrbHVkZ2UsIHdlIGp1c3RcbiAgICAvLyBsZXQgdGhlIGJyb3dzZXIgZG8gaXRzIG5hdGl2ZSB0aGluZyB0aGVyZSwgZXhjZXB0IG9uIEFuZHJvaWQsXG4gICAgLy8gd2hlcmUgdGhlIGVkaXRvciBpcyBhbG1vc3QgYWx3YXlzIGNvbXBvc2luZy5cbiAgICBpZiAodmlldy5jb21wb3NpbmcgJiYgIWFuZHJvaWQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGlmIChkYXRhICYmIGRvUGFzdGUodmlldywgZGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSwgZGF0YS5nZXREYXRhKFwidGV4dC9odG1sXCIpLCB2aWV3LmlucHV0LnNoaWZ0S2V5LCBldmVudCkpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWxzZVxuICAgICAgICBjYXB0dXJlUGFzdGUodmlldywgZXZlbnQpO1xufTtcbmNsYXNzIERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihzbGljZSwgbW92ZSkge1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMubW92ZSA9IG1vdmU7XG4gICAgfVxufVxuY29uc3QgZHJhZ0NvcHlNb2RpZmllciA9IG1hYyA/IFwiYWx0S2V5XCIgOiBcImN0cmxLZXlcIjtcbmhhbmRsZXJzLmRyYWdzdGFydCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IG1vdXNlRG93biA9IHZpZXcuaW5wdXQubW91c2VEb3duO1xuICAgIGlmIChtb3VzZURvd24pXG4gICAgICAgIG1vdXNlRG93bi5kb25lKCk7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHBvcyA9IHNlbC5lbXB0eSA/IG51bGwgOiB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKHBvcyAmJiBwb3MucG9zID49IHNlbC5mcm9tICYmIHBvcy5wb3MgPD0gKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gPyBzZWwudG8gLSAxIDogc2VsLnRvKSkgO1xuICAgIGVsc2UgaWYgKG1vdXNlRG93biAmJiBtb3VzZURvd24ubWlnaHREcmFnKSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIG1vdXNlRG93bi5taWdodERyYWcucG9zKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZXZlbnQudGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUgJiYgZGVzYyAhPSB2aWV3LmRvY1ZpZXcpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBkZXNjLnBvc0JlZm9yZSkpKTtcbiAgICB9XG4gICAgbGV0IHNsaWNlID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uY29udGVudCgpLCB7IGRvbSwgdGV4dCB9ID0gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoYnJva2VuQ2xpcGJvYXJkQVBJID8gXCJUZXh0XCIgOiBcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy8xMTU2XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgaWYgKCFicm9rZW5DbGlwYm9hcmRBUEkpXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB2aWV3LmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKHNsaWNlLCAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0pO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICBsZXQgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuZHJhZ2dpbmcgPT0gZHJhZ2dpbmcpXG4gICAgICAgICAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICB9LCA1MCk7XG59O1xuZWRpdEhhbmRsZXJzLmRyYWdvdmVyID0gZWRpdEhhbmRsZXJzLmRyYWdlbnRlciA9IChfLCBlKSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XG5lZGl0SGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBldmVudFBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIWV2ZW50UG9zKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRtb3VzZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZXZlbnRQb3MucG9zKTtcbiAgICBsZXQgc2xpY2UgPSBkcmFnZ2luZyAmJiBkcmFnZ2luZy5zbGljZTtcbiAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9wbGFpblwiKSwgYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9odG1sXCIpLCBmYWxzZSwgJG1vdXNlKTtcbiAgICB9XG4gICAgbGV0IG1vdmUgPSAhIShkcmFnZ2luZyAmJiAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl0pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRHJvcFwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5LCBtb3ZlKSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgaW5zZXJ0UG9zID0gc2xpY2UgPyBkcm9wUG9pbnQodmlldy5zdGF0ZS5kb2MsICRtb3VzZS5wb3MsIHNsaWNlKSA6ICRtb3VzZS5wb3M7XG4gICAgaWYgKGluc2VydFBvcyA9PSBudWxsKVxuICAgICAgICBpbnNlcnRQb3MgPSAkbW91c2UucG9zO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgaWYgKG1vdmUpXG4gICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgIGxldCBwb3MgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgIGxldCBpc05vZGUgPSBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDE7XG4gICAgbGV0IGJlZm9yZUluc2VydCA9IHRyLmRvYztcbiAgICBpZiAoaXNOb2RlKVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKHBvcywgcG9zLCBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIGVsc2VcbiAgICAgICAgdHIucmVwbGFjZVJhbmdlKHBvcywgcG9zLCBzbGljZSk7XG4gICAgaWYgKHRyLmRvYy5lcShiZWZvcmVJbnNlcnQpKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmIChpc05vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSAmJlxuICAgICAgICAkcG9zLm5vZGVBZnRlciAmJiAkcG9zLm5vZGVBZnRlci5zYW1lTWFya3VwKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBlbmQgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgICAgICB0ci5tYXBwaW5nLm1hcHNbdHIubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4gZW5kID0gbmV3VG8pO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkcG9zLCB0ci5kb2MucmVzb2x2ZShlbmQpKSk7XG4gICAgfVxuICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiZHJvcFwiKSk7XG59O1xuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IERhdGUubm93KCk7XG4gICAgaWYgKCF2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3Lmhhc0ZvY3VzKCkgJiYgIXZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxufTtcbmhhbmRsZXJzLmJsdXIgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmICh2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ICYmIHZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGRvIG1vcmUgd2l0aCBiZWZvcmVpbnB1dCBldmVudHMsIGJ1dCBzdXBwb3J0XG4gICAgLy8gaXMgc28gc3BvdHR5IHRoYXQgSSdtIHN0aWxsIHdhaXRpbmcgdG8gc2VlIHdoZXJlIHRoZXkgYXJlIGdvaW5nLlxuICAgIC8vIFZlcnkgc3BlY2lmaWMgaGFjayB0byBkZWFsIHdpdGggYmFja3NwYWNlIHNvbWV0aW1lcyBmYWlsaW5nIG9uXG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2hlbiBhZnRlciBhbiB1bmVkaXRhYmxlIG5vZGUuXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgICAgIGxldCB7IGRvbUNoYW5nZUNvdW50IH0gPSB2aWV3LmlucHV0O1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50ICE9IGRvbUNoYW5nZUNvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRXZlbnQgYWxyZWFkeSBoYWQgc29tZSBlZmZlY3RcbiAgICAgICAgICAgIC8vIFRoaXMgYnVnIHRlbmRzIHRvIGNsb3NlIHRoZSB2aXJ0dWFsIGtleWJvYXJkLCBzbyB3ZSByZWZvY3VzXG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAvLyBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIGJhY2tzcGFjZSBiZWhhdmlvciB3aGVuIG5vIGNvbW1hbmQgaGFuZGxlZCBpdFxuICAgICAgICAgICAgaWYgKCRjdXJzb3IgJiYgJGN1cnNvci5wb3MgPiAwKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGUoJGN1cnNvci5wb3MgLSAxLCAkY3Vyc29yLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59O1xuLy8gTWFrZSBzdXJlIGFsbCBoYW5kbGVycyBnZXQgcmVnaXN0ZXJlZFxuZm9yIChsZXQgcHJvcCBpbiBlZGl0SGFuZGxlcnMpXG4gICAgaGFuZGxlcnNbcHJvcF0gPSBlZGl0SGFuZGxlcnNbcHJvcF07XG5cbmZ1bmN0aW9uIGNvbXBhcmVPYmpzKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvRE9NLCBzcGVjKSB7XG4gICAgICAgIHRoaXMudG9ET00gPSB0b0RPTTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgICAgIHRoaXMuc2lkZSA9IHRoaXMuc3BlYy5zaWRlIHx8IDA7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgeyBwb3MsIGRlbGV0ZWQgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKHBvcyAtIG9mZnNldCwgcG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFR5cGUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zcGVjLmtleSAmJiB0aGlzLnNwZWMua2V5ID09IG90aGVyLnNwZWMua2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9ET00gPT0gb3RoZXIudG9ET00gJiYgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSkpO1xuICAgIH1cbiAgICBkZXN0cm95KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3kobm9kZSk7XG4gICAgfVxufVxuY2xhc3MgSW5saW5lVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlU3RhcnQgPyAtMSA6IDEpIC0gb2Zmc2V0O1xuICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChzcGFuLnRvICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlRW5kID8gMSA6IC0xKSAtIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGZyb20gPj0gdG8gPyBudWxsIDogbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChfLCBzcGFuKSB7IHJldHVybiBzcGFuLmZyb20gPCBzcGFuLnRvOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIElubGluZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpcyhzcGFuKSB7IHJldHVybiBzcGFuLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuY2xhc3MgTm9kZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi50byArIG9sZE9mZnNldCwgLTEpO1xuICAgICAgICBpZiAodG8uZGVsZXRlZCB8fCB0by5wb3MgPD0gZnJvbS5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20ucG9zIC0gb2Zmc2V0LCB0by5wb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChub2RlLCBzcGFuKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoc3Bhbi5mcm9tKSwgY2hpbGQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPT0gc3Bhbi5mcm9tICYmICEoY2hpbGQgPSBub2RlLmNoaWxkKGluZGV4KSkuaXNUZXh0ICYmIG9mZnNldCArIGNoaWxkLm5vZGVTaXplID09IHNwYW4udG87XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBOb2RlVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuLyoqXG5EZWNvcmF0aW9uIG9iamVjdHMgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSB2aWV3IHRocm91Z2ggdGhlXG5bYGRlY29yYXRpb25zYCBwcm9wXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5kZWNvcmF0aW9ucykuIFRoZXkgY29tZSBpblxuc2V2ZXJhbCB2YXJpYW50c+KAlHNlZSB0aGUgc3RhdGljIG1lbWJlcnMgb2YgdGhpcyBjbGFzcyBmb3IgZGV0YWlscy5cbiovXG5jbGFzcyBEZWNvcmF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24uIFdpbGwgYmUgdGhlIHNhbWUgYXMgYGZyb21gIGZvciBbd2lkZ2V0XG4gICAgZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ed2lkZ2V0KS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuZXEob3RoZXIudHlwZSkgJiYgdGhpcy5mcm9tICsgb2Zmc2V0ID09IG90aGVyLmZyb20gJiYgdGhpcy50byArIG9mZnNldCA9PSBvdGhlci50bztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5tYXAobWFwcGluZywgdGhpcywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGUgdGhhdCdzIHNob3duIGluXG4gICAgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3VcbiAgICBkZWxheSByZW5kZXJpbmcgdGhlIHdpZGdldCBieSBwYXNzaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAgY2FsbGVkIHdoZW4gdGhlIHdpZGdldCBpcyBhY3R1YWxseSBkcmF3biBpbiBhIHZpZXcsIGJ1dCB5b3UgY2FuXG4gICAgYWxzbyBkaXJlY3RseSBwYXNzIGEgRE9NIG5vZGUuIGBnZXRQb3NgIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlXG4gICAgd2lkZ2V0J3MgY3VycmVudCBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQocG9zLCB0b0RPTSwgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24ocG9zLCBwb3MsIG5ldyBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYW4gaW5saW5lIGRlY29yYXRpb24sIHdoaWNoIGFkZHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG9cbiAgICBlYWNoIGlubGluZSBub2RlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgc3RhdGljIGlubGluZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgSW5saW5lVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgbm9kZSBkZWNvcmF0aW9uLiBgZnJvbWAgYW5kIGB0b2Agc2hvdWxkIHBvaW50IHByZWNpc2VseVxuICAgIGJlZm9yZSBhbmQgYWZ0ZXIgYSBub2RlIGluIHRoZSBkb2N1bWVudC4gVGhhdCBub2RlLCBhbmQgb25seSB0aGF0XG4gICAgbm9kZSwgd2lsbCByZWNlaXZlIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc3RhdGljIG5vZGUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IE5vZGVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgdGhpcyBkZWNvcmF0aW9uLiBDYW4gYmUgdXNlZnVsXG4gICAgaWYgeW91J3ZlIHN0b3JlZCBleHRyYSBpbmZvcm1hdGlvbiBpbiB0aGF0IG9iamVjdC5cbiAgICAqL1xuICAgIGdldCBzcGVjKCkgeyByZXR1cm4gdGhpcy50eXBlLnNwZWM7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG59XG5jb25zdCBub25lID0gW10sIG5vU3BlYyA9IHt9O1xuLyoqXG5BIGNvbGxlY3Rpb24gb2YgW2RlY29yYXRpb25zXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKSwgb3JnYW5pemVkIGluIHN1Y2hcbmEgd2F5IHRoYXQgdGhlIGRyYXdpbmcgYWxnb3JpdGhtIGNhbiBlZmZpY2llbnRseSB1c2UgYW5kIGNvbXBhcmVcbnRoZW0uIFRoaXMgaXMgYSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJl4oCUaXQgaXMgbm90IG1vZGlmaWVkLFxudXBkYXRlcyBjcmVhdGUgYSBuZXcgdmFsdWUuXG4qL1xuY2xhc3MgRGVjb3JhdGlvblNldCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbCwgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsLmxlbmd0aCA/IGxvY2FsIDogbm9uZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuIDogbm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGRlY29yYXRpb25zLCB1c2luZyB0aGUgc3RydWN0dXJlIG9mIHRoZSBnaXZlblxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0aW9ucy5sZW5ndGggPyBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIGRvYywgMCwgbm9TcGVjKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCB3aGljaCB0b3VjaCB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICAoaW5jbHVkaW5nIGRlY29yYXRpb25zIHRoYXQgc3RhcnQgb3IgZW5kIGRpcmVjdGx5IGF0IHRoZVxuICAgIGJvdW5kYXJpZXMpIGFuZCBtYXRjaCB0aGUgZ2l2ZW4gcHJlZGljYXRlIG9uIHRoZWlyIHNwZWMuIFdoZW5cbiAgICBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgb21pdHRlZCwgYWxsIGRlY29yYXRpb25zIGluIHRoZSBzZXQgYXJlXG4gICAgY29uc2lkZXJlZC4gV2hlbiBgcHJlZGljYXRlYCBpc24ndCBnaXZlbiwgYWxsIGRlY29yYXRpb25zIGFyZVxuICAgIGFzc3VtZWQgdG8gbWF0Y2guXG4gICAgKi9cbiAgICBmaW5kKHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZmluZElubmVyKHN0YXJ0ID09IG51bGwgPyAwIDogc3RhcnQsIGVuZCA9PSBudWxsID8gMWU5IDogZW5kLCByZXN1bHQsIDAsIHByZWRpY2F0ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmRJbm5lcihzdGFydCwgZW5kLCByZXN1bHQsIG9mZnNldCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBlbmQgJiYgc3Bhbi50byA+PSBzdGFydCAmJiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoc3Bhbi5zcGVjKSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Bhbi5jb3B5KHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPCBlbmQgJiYgdGhpcy5jaGlsZHJlbltpICsgMV0gPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE9mZiA9IHRoaXMuY2hpbGRyZW5baV0gKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDJdLmZpbmRJbm5lcihzdGFydCAtIGNoaWxkT2ZmLCBlbmQgLSBjaGlsZE9mZiwgcmVzdWx0LCBvZmZzZXQgKyBjaGlsZE9mZiwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBpbiByZXNwb25zZSB0byBhIGNoYW5nZSBpbiB0aGVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nLCBkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkgfHwgbWFwcGluZy5tYXBzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcElubmVyKG1hcHBpbmcsIGRvYywgMCwgMCwgb3B0aW9ucyB8fCBub1NwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcElubmVyKG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBuZXdMb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAmJiBtYXBwZWQudHlwZS52YWxpZChub2RlLCBtYXBwZWQpKVxuICAgICAgICAgICAgICAgIChuZXdMb2NhbCB8fCAobmV3TG9jYWwgPSBbXSkpLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZSh0aGlzLmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBtYXBDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBuZXdMb2NhbCB8fCBbXSwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3TG9jYWwgPyBuZXcgRGVjb3JhdGlvblNldChuZXdMb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSkgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBhcnJheSBvZiBkZWNvcmF0aW9ucyB0byB0aGUgb25lcyBpbiB0aGUgc2V0LFxuICAgIHByb2R1Y2luZyBhIG5ldyBzZXQuIE5lZWRzIGFjY2VzcyB0byB0aGUgY3VycmVudCBkb2N1bWVudCB0b1xuICAgIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgdHJlZSBzdHJ1Y3R1cmUuXG4gICAgKi9cbiAgICBhZGQoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICBpZiAoIWRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICAgIGFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4sIGNoaWxkSW5kZXggPSAwO1xuICAgICAgICBkb2MuZm9yRWFjaCgoY2hpbGROb2RlLCBjaGlsZE9mZnNldCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJhc2VPZmZzZXQgPSBjaGlsZE9mZnNldCArIG9mZnNldCwgZm91bmQ7XG4gICAgICAgICAgICBpZiAoIShmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoZGVjb3JhdGlvbnMsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltjaGlsZEluZGV4XSA8IGNoaWxkT2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXggKz0gMztcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltjaGlsZEluZGV4XSA9PSBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0gPSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0uYWRkSW5uZXIoY2hpbGROb2RlLCBmb3VuZCwgYmFzZU9mZnNldCArIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZE9mZnNldCwgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUsIGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBiYXNlT2Zmc2V0ICsgMSwgbm9TcGVjKSk7XG4gICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbG9jYWwgPSBtb3ZlU3BhbnMoY2hpbGRJbmRleCA/IHdpdGhvdXROdWxscyhkZWNvcmF0aW9ucykgOiBkZWNvcmF0aW9ucywgLW9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWxvY2FsW2ldLnR5cGUudmFsaWQoZG9jLCBsb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5sZW5ndGggPyB0aGlzLmxvY2FsLmNvbmNhdChsb2NhbCkuc29ydChieVBvcykgOiB0aGlzLmxvY2FsLCBjaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHNldCB0aGF0IGNvbnRhaW5zIHRoZSBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCwgbWludXNcbiAgICB0aGUgb25lcyBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gICAgKi9cbiAgICByZW1vdmUoZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKGRlY29yYXRpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICByZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGxvY2FsID0gdGhpcy5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZvdW5kO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBjaGlsZHJlbltpXSArIG9mZnNldCwgdG8gPSBjaGlsZHJlbltpICsgMV0gKyBvZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgc3BhbjsgaiA8IGRlY29yYXRpb25zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA+IGZyb20gJiYgc3Bhbi50byA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9uc1tqXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWQgPSBjaGlsZHJlbltpICsgMl0ucmVtb3ZlSW5uZXIoZm91bmQsIGZyb20gKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gcmVtb3ZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICAgICAgICBpIC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNwYW4gPSBkZWNvcmF0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2FsLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsW2pdLmVxKHNwYW4sIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLmxvY2FsLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbiAmJiBsb2NhbCA9PSB0aGlzLmxvY2FsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBsb2NhbC5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWwsIGNoaWxkcmVuKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvckNoaWxkKG9mZnNldCwgbm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5lbXB0eTtcbiAgICAgICAgbGV0IGNoaWxkLCBsb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baSArIDJdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBvZmZzZXQgKyAxLCBlbmQgPSBzdGFydCArIG5vZGUuY29udGVudC5zaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkZWMgPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKGRlYy5mcm9tIDwgZW5kICYmIGRlYy50byA+IHN0YXJ0ICYmIChkZWMudHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChzdGFydCwgZGVjLmZyb20pIC0gc3RhcnQsIHRvID0gTWF0aC5taW4oZW5kLCBkZWMudG8pIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsIHx8IChsb2NhbCA9IFtdKSkucHVzaChkZWMuY29weShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgbGV0IGxvY2FsU2V0ID0gbmV3IERlY29yYXRpb25TZXQobG9jYWwuc29ydChieVBvcyksIG5vbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkID8gbmV3IERlY29yYXRpb25Hcm91cChbbG9jYWxTZXQsIGNoaWxkXSkgOiBsb2NhbFNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gb3RoZXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uU2V0KSB8fFxuICAgICAgICAgICAgdGhpcy5sb2NhbC5sZW5ndGggIT0gb3RoZXIubG9jYWwubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPSBvdGhlci5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2NhbFtpXS5lcShvdGhlci5sb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSAhPSBvdGhlci5jaGlsZHJlbltpXSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDFdICE9IG90aGVyLmNoaWxkcmVuW2kgKyAxXSB8fFxuICAgICAgICAgICAgICAgICF0aGlzLmNoaWxkcmVuW2kgKyAyXS5lcShvdGhlci5jaGlsZHJlbltpICsgMl0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZU92ZXJsYXAodGhpcy5sb2NhbHNJbm5lcihub2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9jYWxzSW5uZXIobm9kZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBub25lO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50IHx8ICF0aGlzLmxvY2FsLnNvbWUoSW5saW5lVHlwZS5pcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMubG9jYWxbaV0udHlwZSBpbnN0YW5jZW9mIElubGluZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubG9jYWxbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIGRlY29yYXRpb25zLlxuKi9cbkRlY29yYXRpb25TZXQuZW1wdHkgPSBuZXcgRGVjb3JhdGlvblNldChbXSwgW10pO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5EZWNvcmF0aW9uU2V0LnJlbW92ZU92ZXJsYXAgPSByZW1vdmVPdmVybGFwO1xuY29uc3QgZW1wdHkgPSBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuLy8gQW4gYWJzdHJhY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGNvZGUgZGVhbGluZyB3aXRoIGRlY29yYXRpb25zIHRvXG4vLyB0cmVhdCBtdWx0aXBsZSBEZWNvcmF0aW9uU2V0IG9iamVjdHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBvYmplY3Rcbi8vIHdpdGggKGEgc3Vic2V0IG9mKSB0aGUgc2FtZSBpbnRlcmZhY2UuXG5jbGFzcyBEZWNvcmF0aW9uR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKG1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIGRvYykge1xuICAgICAgICBjb25zdCBtYXBwZWREZWNvcyA9IHRoaXMubWVtYmVycy5tYXAobWVtYmVyID0+IG1lbWJlci5tYXAobWFwcGluZywgZG9jLCBub1NwZWMpKTtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKG1hcHBlZERlY29zKTtcbiAgICB9XG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWVtYmVyc1tpXS5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQuY29uY2F0KHJlc3VsdC5tZW1iZXJzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApIHx8XG4gICAgICAgICAgICBvdGhlci5tZW1iZXJzLmxlbmd0aCAhPSB0aGlzLm1lbWJlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5tZW1iZXJzW2ldLmVxKG90aGVyLm1lbWJlcnNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIGxldCByZXN1bHQsIHNvcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxzID0gdGhpcy5tZW1iZXJzW2ldLmxvY2Fsc0lubmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFsb2NhbHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsb2NhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxvY2Fsc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlbW92ZU92ZXJsYXAoc29ydGVkID8gcmVzdWx0IDogcmVzdWx0LnNvcnQoYnlQb3MpKSA6IG5vbmU7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbiBzZXRzLCBvciByZXR1cm5cbiAgICAvLyBhIHNpbmdsZSBzZXQgd2hlbiBwb3NzaWJsZS5cbiAgICBzdGF0aWMgZnJvbShtZW1iZXJzKSB7XG4gICAgICAgIHN3aXRjaCAobWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGVtcHR5O1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbWVtYmVyc1swXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBuZXcgRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMuZXZlcnkobSA9PiBtIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgPyBtZW1iZXJzIDpcbiAgICAgICAgICAgICAgICBtZW1iZXJzLnJlZHVjZSgociwgbSkgPT4gci5jb25jYXQobSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQgPyBtIDogbS5tZW1iZXJzKSwgW10pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBvbGRDaGlsZHJlbi5zbGljZSgpO1xuICAgIC8vIE1hcmsgdGhlIGNoaWxkcmVuIHRoYXQgYXJlIGRpcmVjdGx5IHRvdWNoZWQgYnkgY2hhbmdlcywgYW5kXG4gICAgLy8gbW92ZSB0aG9zZSB0aGF0IGFyZSBhZnRlciB0aGUgY2hhbmdlcy5cbiAgICBmb3IgKGxldCBpID0gMCwgYmFzZU9mZnNldCA9IG9sZE9mZnNldDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbW92ZWQgPSAwO1xuICAgICAgICBtYXBwaW5nLm1hcHNbaV0uZm9yRWFjaCgob2xkU3RhcnQsIG9sZEVuZCwgbmV3U3RhcnQsIG5ld0VuZCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRTaXplID0gKG5ld0VuZCAtIG5ld1N0YXJ0KSAtIChvbGRFbmQgLSBvbGRTdGFydCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGNoaWxkcmVuW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kIDwgMCB8fCBvbGRTdGFydCA+IGVuZCArIGJhc2VPZmZzZXQgLSBtb3ZlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY2hpbGRyZW5baV0gKyBiYXNlT2Zmc2V0IC0gbW92ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEVuZCA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSBvbGRTdGFydCA8PSBzdGFydCA/IC0yIDogLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0ID49IG9mZnNldCAmJiBkU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSArPSBkU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdICs9IGRTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdmVkICs9IGRTaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgYmFzZU9mZnNldCA9IG1hcHBpbmcubWFwc1tpXS5tYXAoYmFzZU9mZnNldCwgLTEpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBjaGlsZCBub2RlcyB0aGF0IHN0aWxsIGNvcnJlc3BvbmQgdG8gYSBzaW5nbGUgbm9kZSxcbiAgICAvLyByZWN1cnNpdmVseSBjYWxsIG1hcElubmVyIG9uIHRoZW0gYW5kIHVwZGF0ZSB0aGVpciBwb3NpdGlvbnMuXG4gICAgbGV0IG11c3RSZWJ1aWxkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHsgLy8gVG91Y2hlZCBub2Rlc1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMikge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAob2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQpLCBmcm9tTG9jYWwgPSBmcm9tIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGZyb21Mb2NhbCA8IDAgfHwgZnJvbUxvY2FsID49IG5vZGUuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTXVzdCByZWFkIG9sZENoaWxkcmVuIGJlY2F1c2UgY2hpbGRyZW4gd2FzIHRhZ2dlZCB3aXRoIC0xXG4gICAgICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpICsgMV0gKyBvbGRPZmZzZXQsIC0xKSwgdG9Mb2NhbCA9IHRvIC0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldDogY2hpbGRPZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoZnJvbUxvY2FsKTtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE9mZnNldCA9PSBmcm9tTG9jYWwgJiYgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUgPT0gdG9Mb2NhbCkge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGlsZHJlbltpICsgMl1cbiAgICAgICAgICAgICAgICAgICAgLm1hcElubmVyKG1hcHBpbmcsIGNoaWxkTm9kZSwgZnJvbSArIDEsIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCAhPSBlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IGZyb21Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gdG9Mb2NhbDtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAvLyBSZW1haW5pbmcgY2hpbGRyZW4gbXVzdCBiZSBjb2xsZWN0ZWQgYW5kIHJlYnVpbHQgaW50byB0aGUgYXBwcm9wcmlhdGUgc3RydWN0dXJlXG4gICAgaWYgKG11c3RSZWJ1aWxkKSB7XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IG1hcEFuZEdhdGhlclJlbWFpbmluZ0RlY29yYXRpb25zKGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKTtcbiAgICAgICAgbGV0IGJ1aWx0ID0gYnVpbGRUcmVlKGRlY29yYXRpb25zLCBub2RlLCAwLCBvcHRpb25zKTtcbiAgICAgICAgbmV3TG9jYWwgPSBidWlsdC5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpICsgMV0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDMpO1xuICAgICAgICAgICAgICAgIGkgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgYnVpbHQuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVpbHQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICB3aGlsZSAoaiA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltqXSA8IGZyb20pXG4gICAgICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDAsIGJ1aWx0LmNoaWxkcmVuW2ldLCBidWlsdC5jaGlsZHJlbltpICsgMV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uU2V0KG5ld0xvY2FsLnNvcnQoYnlQb3MpLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBtb3ZlU3BhbnMoc3BhbnMsIG9mZnNldCkge1xuICAgIGlmICghb2Zmc2V0IHx8ICFzcGFucy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBzcGFucztcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHNwYW5zW2ldO1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRGVjb3JhdGlvbihzcGFuLmZyb20gKyBvZmZzZXQsIHNwYW4udG8gKyBvZmZzZXQsIHNwYW4udHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBkZWNvcmF0aW9ucywgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAvLyBHYXRoZXIgYWxsIGRlY29yYXRpb25zIGZyb20gdGhlIHJlbWFpbmluZyBtYXJrZWQgY2hpbGRyZW5cbiAgICBmdW5jdGlvbiBnYXRoZXIoc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBzZXQubG9jYWxbaV0ubWFwKG1hcHBpbmcsIG9mZnNldCwgb2xkT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKHNldC5sb2NhbFtpXS5zcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGdhdGhlcihzZXQuY2hpbGRyZW5baSArIDJdLCBzZXQuY2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA9PSAtMSlcbiAgICAgICAgICAgIGdhdGhlcihjaGlsZHJlbltpICsgMl0sIG9sZENoaWxkcmVuW2ldICsgb2xkT2Zmc2V0ICsgMSk7XG4gICAgcmV0dXJuIGRlY29yYXRpb25zO1xufVxuZnVuY3Rpb24gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZW5kID0gb2Zmc2V0ICsgbm9kZS5ub2RlU2l6ZSwgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChzcGFuID0gc3BhbnNbaV0pICYmIHNwYW4uZnJvbSA+IG9mZnNldCAmJiBzcGFuLnRvIDwgZW5kKSB7XG4gICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgc3BhbnNbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIHdpdGhvdXROdWxscyhhcnJheSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYXJyYXlbaV0gIT0gbnVsbClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQnVpbGQgdXAgYSB0cmVlIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBzZXQgb2YgZGVjb3JhdGlvbnMuIGBvZmZzZXRgXG4vLyBpcyBhIGJhc2Ugb2Zmc2V0IHRoYXQgc2hvdWxkIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgYGZyb21gIGFuZCBgdG9gXG4vLyBwb3NpdGlvbnMgaW4gdGhlIHNwYW5zIChzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gYWxsb2NhdGUgbmV3IHNwYW5zXG4vLyBmb3IgcmVjdXJzaXZlIGNhbGxzKS5cbmZ1bmN0aW9uIGJ1aWxkVHJlZShzcGFucywgbm9kZSwgb2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIGhhc051bGxzID0gZmFsc2U7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZE5vZGUsIGxvY2FsU3RhcnQpID0+IHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGFrZVNwYW5zRm9yTm9kZShzcGFucywgY2hpbGROb2RlLCBsb2NhbFN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICBoYXNOdWxscyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc3VidHJlZSA9IGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBvZmZzZXQgKyBsb2NhbFN0YXJ0ICsgMSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3VidHJlZSAhPSBlbXB0eSlcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGxvY2FsU3RhcnQsIGxvY2FsU3RhcnQgKyBjaGlsZE5vZGUubm9kZVNpemUsIHN1YnRyZWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGxvY2FscyA9IG1vdmVTcGFucyhoYXNOdWxscyA/IHdpdGhvdXROdWxscyhzcGFucykgOiBzcGFucywgLW9mZnNldCkuc29ydChieVBvcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghbG9jYWxzW2ldLnR5cGUudmFsaWQobm9kZSwgbG9jYWxzW2ldKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZShsb2NhbHNbaV0uc3BlYyk7XG4gICAgICAgICAgICBsb2NhbHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbG9jYWxzLmxlbmd0aCB8fCBjaGlsZHJlbi5sZW5ndGggPyBuZXcgRGVjb3JhdGlvblNldChsb2NhbHMsIGNoaWxkcmVuKSA6IGVtcHR5O1xufVxuLy8gVXNlZCB0byBzb3J0IGRlY29yYXRpb25zIHNvIHRoYXQgb25lcyB3aXRoIGEgbG93IHN0YXJ0IHBvc2l0aW9uXG4vLyBjb21lIGZpcnN0LCBhbmQgd2l0aGluIGEgc2V0IHdpdGggdGhlIHNhbWUgc3RhcnQgcG9zaXRpb24sIHRob3NlXG4vLyB3aXRoIGFuIHNtYWxsZXIgZW5kIHBvc2l0aW9uIGNvbWUgZmlyc3QuXG5mdW5jdGlvbiBieVBvcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEuZnJvbSAtIGIuZnJvbSB8fCBhLnRvIC0gYi50bztcbn1cbi8vIFNjYW4gYSBzb3J0ZWQgYXJyYXkgb2YgZGVjb3JhdGlvbnMgZm9yIHBhcnRpYWxseSBvdmVybGFwcGluZyBzcGFucyxcbi8vIGFuZCBzcGxpdCB0aG9zZSBzbyB0aGF0IG9ubHkgZnVsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGxlZnQgKHRvXG4vLyBtYWtlIHN1YnNlcXVlbnQgcmVuZGVyaW5nIGVhc2llcikuIFdpbGwgcmV0dXJuIHRoZSBpbnB1dCBhcnJheSBpZlxuLy8gbm8gcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zIGFyZSBmb3VuZCAodGhlIGNvbW1vbiBjYXNlKS5cbmZ1bmN0aW9uIHJlbW92ZU92ZXJsYXAoc3BhbnMpIHtcbiAgICBsZXQgd29ya2luZyA9IHNwYW5zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ya2luZy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IHNwYW4gPSB3b3JraW5nW2ldO1xuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IHNwYW4udG8pXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB3b3JraW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB3b3JraW5nW2pdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPT0gc3Bhbi5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvICE9IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9sbG93ZWQgYnkgYSBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgbGFyZ2VyIHNwYW4uIFNwbGl0IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYW4uXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2pdID0gbmV4dC5jb3B5KG5leHQuZnJvbSwgc3Bhbi50byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqICsgMSwgbmV4dC5jb3B5KHNwYW4udG8sIG5leHQudG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmZyb20gPCBzcGFuLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2luZyA9PSBzcGFucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gc3BhbnMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbmQgb2YgdGhpcyBvbmUgb3ZlcmxhcHMgd2l0aCBhIHN1YnNlcXVlbnQgc3Bhbi4gU3BsaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1tpXSA9IHNwYW4uY29weShzcGFuLmZyb20sIG5leHQuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBaGVhZCh3b3JraW5nLCBqLCBzcGFuLmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29ya2luZztcbn1cbmZ1bmN0aW9uIGluc2VydEFoZWFkKGFycmF5LCBpLCBkZWNvKSB7XG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGggJiYgYnlQb3MoZGVjbywgYXJyYXlbaV0pID4gMClcbiAgICAgICAgaSsrO1xuICAgIGFycmF5LnNwbGljZShpLCAwLCBkZWNvKTtcbn1cbi8vIEdldCB0aGUgZGVjb3JhdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IHByb3BzIG9mIGEgdmlldy5cbmZ1bmN0aW9uIHZpZXdEZWNvcmF0aW9ucyh2aWV3KSB7XG4gICAgbGV0IGZvdW5kID0gW107XG4gICAgdmlldy5zb21lUHJvcChcImRlY29yYXRpb25zXCIsIGYgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZih2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgIT0gZW1wdHkpXG4gICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgaWYgKHZpZXcuY3Vyc29yV3JhcHBlcilcbiAgICAgICAgZm91bmQucHVzaChEZWNvcmF0aW9uU2V0LmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgW3ZpZXcuY3Vyc29yV3JhcHBlci5kZWNvXSkpO1xuICAgIHJldHVybiBEZWNvcmF0aW9uR3JvdXAuZnJvbShmb3VuZCk7XG59XG5cbmNvbnN0IG9ic2VydmVPcHRpb25zID0ge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWVcbn07XG4vLyBJRTExIGhhcyB2ZXJ5IGJyb2tlbiBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHdlIGFsc28gbGlzdGVuIHRvIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZFxuY29uc3QgdXNlQ2hhckRhdGEgPSBpZSAmJiBpZV92ZXJzaW9uIDw9IDExO1xuY2xhc3MgU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIHNldChzZWwpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgIH1cbiAgICBlcShzZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbC5hbmNob3JOb2RlID09IHRoaXMuYW5jaG9yTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09IHRoaXMuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlID09IHRoaXMuZm9jdXNOb2RlICYmIHNlbC5mb2N1c09mZnNldCA9PSB0aGlzLmZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoYW5kbGVET01DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5oYW5kbGVET01DaGFuZ2UgPSBoYW5kbGVET01DaGFuZ2U7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyICYmXG4gICAgICAgICAgICBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIHRleHQgbm9kZSBhZnRlciBhIEJSIG5vZGUpIGNhbGwgdGhlIG9ic2VydmVyIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00sIHdoaWNoIHdpbGwgY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBQcm9zZU1pcnJvciB0byBtaXNzIHRoZSBjaGFuZ2UgKHNlZSAjOTMwKVxuICAgICAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBlLnRhcmdldCwgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsIG9sZFZhbHVlOiBlLnByZXZWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBmbHVzaFNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA8IDApXG4gICAgICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTsgdGhpcy5mbHVzaCgpOyB9LCAyMCk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoaW5nU29vbiA+IC0xKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZmx1c2hpbmdTb29uKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gLTE7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy52aWV3LmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICAgICAgdGhpcy5jb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICBsZXQgdGFrZSA9IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIGlmICh0YWtlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRha2VbaV0pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuZmx1c2goKSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ub3duZXJEb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBzdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKSB7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlLCA1MCk7XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIWhhc0ZvY3VzQW5kU2VsZWN0aW9uKHRoaXMudmlldykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcylcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpO1xuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy52aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAvLyBTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUVcbiAgICAgICAgICAgIGlmIChzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgc2V0Q3VyU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHRoaXMudmlldy5kb21TZWxlY3Rpb25SYW5nZSgpKTtcbiAgICB9XG4gICAgaWdub3JlU2VsZWN0aW9uQ2hhbmdlKHNlbCkge1xuICAgICAgICBpZiAoIXNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGFuY2VzdG9ycyA9IG5ldyBTZXQsIGNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5mb2N1c05vZGU7IHNjYW47IHNjYW4gPSBwYXJlbnROb2RlKHNjYW4pKVxuICAgICAgICAgICAgYW5jZXN0b3JzLmFkZChzY2FuKTtcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IHNlbC5hbmNob3JOb2RlOyBzY2FuOyBzY2FuID0gcGFyZW50Tm9kZShzY2FuKSlcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnMuaGFzKHNjYW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc2NhbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBjb250YWluZXIgJiYgdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5pZ25vcmVNdXRhdGlvbih7XG4gICAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgICAgdGFyZ2V0OiBjb250YWluZXIubm9kZVR5cGUgPT0gMyA/IGNvbnRhaW5lci5wYXJlbnROb2RlIDogY29udGFpbmVyXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGlmICghdmlldy5kb2NWaWV3IHx8IHRoaXMuZmx1c2hpbmdTb29uID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtdXRhdGlvbnMgPSB0aGlzLm9ic2VydmVyID8gdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpIDogW107XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbXV0YXRpb25zID0gdGhpcy5xdWV1ZS5jb25jYXQobXV0YXRpb25zKTtcbiAgICAgICAgICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgbmV3U2VsID0gIXRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzICYmICF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSAmJiBoYXNGb2N1c0FuZFNlbGVjdGlvbih2aWV3KSAmJiAhdGhpcy5pZ25vcmVTZWxlY3Rpb25DaGFuZ2Uoc2VsKTtcbiAgICAgICAgbGV0IGZyb20gPSAtMSwgdG8gPSAtMSwgdHlwZU92ZXIgPSBmYWxzZSwgYWRkZWQgPSBbXTtcbiAgICAgICAgaWYgKHZpZXcuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVnaXN0ZXJNdXRhdGlvbihtdXRhdGlvbnNbaV0sIGFkZGVkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBmcm9tIDwgMCA/IHJlc3VsdC5mcm9tIDogTWF0aC5taW4ocmVzdWx0LmZyb20sIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB0byA9IHRvIDwgMCA/IHJlc3VsdC50byA6IE1hdGgubWF4KHJlc3VsdC50bywgdG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGVPdmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2Vja28gJiYgYWRkZWQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IGJycyA9IGFkZGVkLmZpbHRlcihuID0+IG4ubm9kZU5hbWUgPT0gXCJCUlwiKTtcbiAgICAgICAgICAgIGlmIChicnMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgYSA9IGJyc1swXSwgYiA9IGJyc1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoYS5wYXJlbnROb2RlICYmIGEucGFyZW50Tm9kZS5wYXJlbnROb2RlID09IGIucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGEucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlYWRTZWwgPSBudWxsO1xuICAgICAgICAvLyBJZiBpdCBsb29rcyBsaWtlIHRoZSBicm93c2VyIGhhcyByZXNldCB0aGUgc2VsZWN0aW9uIHRvIHRoZVxuICAgICAgICAvLyBzdGFydCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgZm9jdXMsIHJlc3RvcmUgdGhlIHNlbGVjdGlvbiBmcm9tXG4gICAgICAgIC8vIHRoZSBzdGF0ZVxuICAgICAgICBpZiAoZnJvbSA8IDAgJiYgbmV3U2VsICYmIHZpZXcuaW5wdXQubGFzdEZvY3VzID4gRGF0ZS5ub3coKSAtIDIwMCAmJlxuICAgICAgICAgICAgTWF0aC5tYXgodmlldy5pbnB1dC5sYXN0VG91Y2gsIHZpZXcuaW5wdXQubGFzdENsaWNrLnRpbWUpIDwgRGF0ZS5ub3coKSAtIDMwMCAmJlxuICAgICAgICAgICAgc2VsZWN0aW9uQ29sbGFwc2VkKHNlbCkgJiYgKHJlYWRTZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcpKSAmJlxuICAgICAgICAgICAgcmVhZFNlbC5lcShTZWxlY3Rpb24ubmVhcih2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKDApLCAxKSkpIHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdEZvY3VzID0gMDtcbiAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uLnNldChzZWwpO1xuICAgICAgICAgICAgdmlldy5zY3JvbGxUb1NlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyb20gPiAtMSB8fCBuZXdTZWwpIHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2aWV3LmRvY1ZpZXcubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICBjaGVja0NTUyh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRE9NQ2hhbmdlKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3LmRvY1ZpZXcuZGlydHkpXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSlcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3Rlck11dGF0aW9uKG11dCwgYWRkZWQpIHtcbiAgICAgICAgLy8gSWdub3JlIG11dGF0aW9ucyBpbnNpZGUgbm9kZXMgdGhhdCB3ZXJlIGFscmVhZHkgbm90ZWQgYXMgaW5zZXJ0ZWRcbiAgICAgICAgaWYgKGFkZGVkLmluZGV4T2YobXV0LnRhcmdldCkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZGVzYyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKG11dC50YXJnZXQpO1xuICAgICAgICBpZiAobXV0LnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIgJiZcbiAgICAgICAgICAgIChkZXNjID09IHRoaXMudmlldy5kb2NWaWV3IHx8IG11dC5hdHRyaWJ1dGVOYW1lID09IFwiY29udGVudGVkaXRhYmxlXCIgfHxcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHNvbWV0aW1lcyBmaXJlcyBzcHVyaW91cyBldmVudHMgZm9yIG51bGwvZW1wdHkgc3R5bGVzXG4gICAgICAgICAgICAgICAgKG11dC5hdHRyaWJ1dGVOYW1lID09IFwic3R5bGVcIiAmJiAhbXV0Lm9sZFZhbHVlICYmICFtdXQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFkZXNjIHx8IGRlc2MuaWdub3JlTXV0YXRpb24obXV0KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobXV0LnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXQuYWRkZWROb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKG11dC5hZGRlZE5vZGVzW2ldKTtcbiAgICAgICAgICAgIGlmIChkZXNjLmNvbnRlbnRET00gJiYgZGVzYy5jb250ZW50RE9NICE9IGRlc2MuZG9tICYmICFkZXNjLmNvbnRlbnRET00uY29udGFpbnMobXV0LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NCZWZvcmUsIHRvOiBkZXNjLnBvc0FmdGVyIH07XG4gICAgICAgICAgICBsZXQgcHJldiA9IG11dC5wcmV2aW91c1NpYmxpbmcsIG5leHQgPSBtdXQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXQuYWRkZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJRTExIGdpdmVzIHVzIGluY29ycmVjdCBuZXh0L3ByZXYgc2libGluZ3MgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnRpb25zLCBzbyBpZiB0aGVyZSBhcmUgYWRkZWQgbm9kZXMsIHJlY29tcHV0ZSB0aG9zZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcHJldmlvdXNTaWJsaW5nLCBuZXh0U2libGluZyB9ID0gbXV0LmFkZGVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIHByZXZpb3VzU2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0U2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBuZXh0U2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gcHJldiAmJiBwcmV2LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgocHJldikgKyAxIDogMDtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgZnJvbU9mZnNldCwgLTEpO1xuICAgICAgICAgICAgbGV0IHRvT2Zmc2V0ID0gbmV4dCAmJiBuZXh0LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgobmV4dCkgOiBtdXQudGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHRvID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgdG9PZmZzZXQsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIsIHRvOiBkZXNjLnBvc0F0RW5kICsgZGVzYy5ib3JkZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gXCJjaGFyYWN0ZXJEYXRhXCJcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogZGVzYy5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBkZXNjLnBvc0F0RW5kLFxuICAgICAgICAgICAgICAgIC8vIEFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgZm9yIGEgdGV4dCBjaGFuZ2UgdGhhdCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gYW55IHRleHQuIE1hcmsgdGhlIGRvbSBjaGFuZ2UgdG8gZmFsbCBiYWNrIHRvIGFzc3VtaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiB3YXMgdHlwZWQgb3ZlciB3aXRoIGFuIGlkZW50aWNhbCB2YWx1ZSBpZiBpdCBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGZpbmQgYW5vdGhlciBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgdHlwZU92ZXI6IG11dC50YXJnZXQubm9kZVZhbHVlID09IG11dC5vbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBjc3NDaGVja2VkID0gbmV3IFdlYWtNYXAoKTtcbmxldCBjc3NDaGVja1dhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tDU1Modmlldykge1xuICAgIGlmIChjc3NDaGVja2VkLmhhcyh2aWV3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNzc0NoZWNrZWQuc2V0KHZpZXcsIG51bGwpO1xuICAgIGlmIChbJ25vcm1hbCcsICdub3dyYXAnLCAncHJlLWxpbmUnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLndoaXRlU3BhY2UpICE9PSAtMSkge1xuICAgICAgICB2aWV3LnJlcXVpcmVzR2Vja29IYWNrTm9kZSA9IGdlY2tvO1xuICAgICAgICBpZiAoY3NzQ2hlY2tXYXJuZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGVbXCJ3YXJuXCJdKFwiUHJvc2VNaXJyb3IgZXhwZWN0cyB0aGUgQ1NTIHdoaXRlLXNwYWNlIHByb3BlcnR5IHRvIGJlIHNldCwgcHJlZmVyYWJseSB0byAncHJlLXdyYXAnLiBJdCBpcyByZWNvbW1lbmRlZCB0byBsb2FkIHN0eWxlL3Byb3NlbWlycm9yLmNzcyBmcm9tIHRoZSBwcm9zZW1pcnJvci12aWV3IHBhY2thZ2UuXCIpO1xuICAgICAgICBjc3NDaGVja1dhcm5lZCA9IHRydWU7XG4gICAgfVxufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWdcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDE0IGZpeFxuZnVuY3Rpb24gc2FmYXJpU2hhZG93U2VsZWN0aW9uUmFuZ2Uodmlldykge1xuICAgIGxldCBmb3VuZDtcbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIyKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd1Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdOKAlHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbmRlbnRcIik7XG4gICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIGxldCBhbmNob3JOb2RlID0gZm91bmQuc3RhcnRDb250YWluZXIsIGFuY2hvck9mZnNldCA9IGZvdW5kLnN0YXJ0T2Zmc2V0O1xuICAgIGxldCBmb2N1c05vZGUgPSBmb3VuZC5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gZm91bmQuZW5kT2Zmc2V0O1xuICAgIGxldCBjdXJyZW50QW5jaG9yID0gdmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IpO1xuICAgIC8vIFNpbmNlIHN1Y2ggYSByYW5nZSBkb2Vzbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gYW5jaG9yIGFuZCBoZWFkLFxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXG4gICAgLy8gY3VycmVudCBhbmNob3IuXG4gICAgaWYgKGlzRXF1aXZhbGVudFBvc2l0aW9uKGN1cnJlbnRBbmNob3Iubm9kZSwgY3VycmVudEFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuXG4vLyBOb3RlIHRoYXQgYWxsIHJlZmVyZW5jaW5nIGFuZCBwYXJzaW5nIGlzIGRvbmUgd2l0aCB0aGVcbi8vIHN0YXJ0LW9mLW9wZXJhdGlvbiBzZWxlY3Rpb24gYW5kIGRvY3VtZW50LCBzaW5jZSB0aGF0J3MgdGhlIG9uZVxuLy8gdGhhdCB0aGUgRE9NIHJlcHJlc2VudHMuIElmIGFueSBjaGFuZ2VzIGNhbWUgaW4gaW4gdGhlIG1lYW50aW1lLFxuLy8gdGhlIG1vZGlmaWNhdGlvbiBpcyBtYXBwZWQgb3ZlciB0aG9zZSBiZWZvcmUgaXQgaXMgYXBwbGllZCwgaW5cbi8vIHJlYWRET01DaGFuZ2UuXG5mdW5jdGlvbiBwYXJzZUJldHdlZW4odmlldywgZnJvbV8sIHRvXykge1xuICAgIGxldCB7IG5vZGU6IHBhcmVudCwgZnJvbU9mZnNldCwgdG9PZmZzZXQsIGZyb20sIHRvIH0gPSB2aWV3LmRvY1ZpZXcucGFyc2VSYW5nZShmcm9tXywgdG9fKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBmaW5kO1xuICAgIGxldCBhbmNob3IgPSBkb21TZWwuYW5jaG9yTm9kZTtcbiAgICBpZiAoYW5jaG9yICYmIHZpZXcuZG9tLmNvbnRhaW5zKGFuY2hvci5ub2RlVHlwZSA9PSAxID8gYW5jaG9yIDogYW5jaG9yLnBhcmVudE5vZGUpKSB7XG4gICAgICAgIGZpbmQgPSBbeyBub2RlOiBhbmNob3IsIG9mZnNldDogZG9tU2VsLmFuY2hvck9mZnNldCB9XTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25Db2xsYXBzZWQoZG9tU2VsKSlcbiAgICAgICAgICAgIGZpbmQucHVzaCh7IG5vZGU6IGRvbVNlbC5mb2N1c05vZGUsIG9mZnNldDogZG9tU2VsLmZvY3VzT2Zmc2V0IH0pO1xuICAgIH1cbiAgICAvLyBXb3JrIGFyb3VuZCBpc3N1ZSBpbiBDaHJvbWUgd2hlcmUgYmFja3NwYWNpbmcgc29tZXRpbWVzIHJlcGxhY2VzXG4gICAgLy8gdGhlIGRlbGV0ZWQgY29udGVudCB3aXRoIGEgcmFuZG9tIEJSIG5vZGUgKGlzc3VlcyAjNzk5LCAjODMxKVxuICAgIGlmIChjaHJvbWUgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gOCkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0b09mZnNldDsgb2ZmID4gZnJvbU9mZnNldDsgb2ZmLS0pIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gcGFyZW50LmNoaWxkTm9kZXNbb2ZmIC0gMV0sIGRlc2MgPSBub2RlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgIWRlc2MpIHtcbiAgICAgICAgICAgICAgICB0b09mZnNldCA9IG9mZjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCBkZXNjLnNpemUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXJ0RG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgbGV0IHBhcnNlciA9IHZpZXcuc29tZVByb3AoXCJkb21QYXJzZXJcIikgfHwgRE9NUGFyc2VyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgIGxldCAkZnJvbSA9IHN0YXJ0RG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHNlbCA9IG51bGwsIGRvYyA9IHBhcnNlci5wYXJzZShwYXJlbnQsIHtcbiAgICAgICAgdG9wTm9kZTogJGZyb20ucGFyZW50LFxuICAgICAgICB0b3BNYXRjaDogJGZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4KCkpLFxuICAgICAgICB0b3BPcGVuOiB0cnVlLFxuICAgICAgICBmcm9tOiBmcm9tT2Zmc2V0LFxuICAgICAgICB0bzogdG9PZmZzZXQsXG4gICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJGZyb20ucGFyZW50LnR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiID8gXCJmdWxsXCIgOiB0cnVlLFxuICAgICAgICBmaW5kUG9zaXRpb25zOiBmaW5kLFxuICAgICAgICBydWxlRnJvbU5vZGUsXG4gICAgICAgIGNvbnRleHQ6ICRmcm9tXG4gICAgfSk7XG4gICAgaWYgKGZpbmQgJiYgZmluZFswXS5wb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgYW5jaG9yID0gZmluZFswXS5wb3MsIGhlYWQgPSBmaW5kWzFdICYmIGZpbmRbMV0ucG9zO1xuICAgICAgICBpZiAoaGVhZCA9PSBudWxsKVxuICAgICAgICAgICAgaGVhZCA9IGFuY2hvcjtcbiAgICAgICAgc2VsID0geyBhbmNob3I6IGFuY2hvciArIGZyb20sIGhlYWQ6IGhlYWQgKyBmcm9tIH07XG4gICAgfVxuICAgIHJldHVybiB7IGRvYywgc2VsLCBmcm9tLCB0byB9O1xufVxuZnVuY3Rpb24gcnVsZUZyb21Ob2RlKGRvbSkge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgaWYgKGRlc2MpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MucGFyc2VSdWxlKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgLy8gU2FmYXJpIHJlcGxhY2VzIHRoZSBsaXN0IGl0ZW0gb3IgdGFibGUgY2VsbCB3aXRoIGEgQlJcbiAgICAgICAgLy8gZGlyZWN0bHkgaW4gdGhlIGxpc3Qgbm9kZSAoPyEpIGlmIHlvdSBkZWxldGUgdGhlIGxhc3RcbiAgICAgICAgLy8gY2hhcmFjdGVyIGluIGEgbGlzdCBpdGVtIG9yIHRhYmxlIGNlbGwgKCM3MDgsICM4NjIpXG4gICAgICAgIGlmIChzYWZhcmkgJiYgL14odWx8b2wpJC9pLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICBsZXQgc2tpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBza2lwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSk7XG4gICAgICAgICAgICByZXR1cm4geyBza2lwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9tLnBhcmVudE5vZGUubGFzdENoaWxkID09IGRvbSB8fCBzYWZhcmkgJiYgL14odHJ8dGFibGUpJC9pLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkb20ubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiBkb20uZ2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiKSkge1xuICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBpc0lubGluZSA9IC9eKGF8YWJicnxhY3JvbnltfGJ8YmRbaW9dfGJpZ3xicnxidXR0b258Y2l0ZXxjb2RlfGRhdGEobGlzdCk/fGRlbHxkZm58ZW18aXxpbnN8a2JkfGxhYmVsfG1hcHxtYXJrfG1ldGVyfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNtYWxsfHNwYW58c3Ryb25nfHN1W2JwXXx0aW1lfHV8dHR8dmFyKSQvaTtcbmZ1bmN0aW9uIHJlYWRET01DaGFuZ2UodmlldywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZE5vZGVzKSB7XG4gICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGxldCBvcmlnaW4gPSB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwID8gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luIDogbnVsbDtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldywgb3JpZ2luKTtcbiAgICAgICAgaWYgKG5ld1NlbCAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24uZXEobmV3U2VsKSkge1xuICAgICAgICAgICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmXG4gICAgICAgICAgICAgICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gMTMgJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lICYmXG4gICAgICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3U2VsKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcInBvaW50ZXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW4gPT0gXCJrZXlcIilcbiAgICAgICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgaWYgKHZpZXcuY29tcG9zaW5nKVxuICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQpO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgJGJlZm9yZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgbGV0IHNoYXJlZCA9ICRiZWZvcmUuc2hhcmVkRGVwdGgodG8pO1xuICAgIGZyb20gPSAkYmVmb3JlLmJlZm9yZShzaGFyZWQgKyAxKTtcbiAgICB0byA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUodG8pLmFmdGVyKHNoYXJlZCArIDEpO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcGFyc2UgPSBwYXJzZUJldHdlZW4odmlldywgZnJvbSwgdG8pO1xuICAgIGxldCBkb2MgPSB2aWV3LnN0YXRlLmRvYywgY29tcGFyZSA9IGRvYy5zbGljZShwYXJzZS5mcm9tLCBwYXJzZS50byk7XG4gICAgbGV0IHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZTtcbiAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkXG4gICAgaWYgKHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDggJiYgRGF0ZS5ub3coKSAtIDEwMCA8IHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lKSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnJlZFBvcyA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcInN0YXJ0XCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBudWxsO1xuICAgIGxldCBjaGFuZ2UgPSBmaW5kRGlmZihjb21wYXJlLmNvbnRlbnQsIHBhcnNlLmRvYy5jb250ZW50LCBwYXJzZS5mcm9tLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpO1xuICAgIGlmICgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSB8fCBhbmRyb2lkKSAmJlxuICAgICAgICBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVUeXBlID09IDEgJiYgIWlzSW5saW5lLnRlc3Qobi5ub2RlTmFtZSkpICYmXG4gICAgICAgICghY2hhbmdlIHx8IGNoYW5nZS5lbmRBID49IGNoYW5nZS5lbmRCKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVPdmVyICYmIHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSAmJiBzZWwuJGhlYWQuc2FtZVBhcmVudChzZWwuJGFuY2hvcikgJiZcbiAgICAgICAgICAgICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgICAgICAgY2hhbmdlID0geyBzdGFydDogc2VsLmZyb20sIGVuZEE6IHNlbC50bywgZW5kQjogc2VsLnRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdmlldy5zdGF0ZS5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldy5jb21wb3NpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgdmlldy5pbnB1dC5jb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENocm9tZSBzb21ldGltZXMgbGVhdmVzIHRoZSBjdXJzb3IgYmVmb3JlIHRoZSBpbnNlcnRlZCB0ZXh0IHdoZW5cbiAgICAvLyBjb21wb3NpbmcgYWZ0ZXIgYSBjdXJzb3Igd3JhcHBlci4gVGhpcyBtb3ZlcyBpdCBmb3J3YXJkLlxuICAgIGlmIChjaHJvbWUgJiYgdmlldy5jdXJzb3JXcmFwcGVyICYmIHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yID09IHZpZXcuY3Vyc29yV3JhcHBlci5kZWNvLmZyb20gJiZcbiAgICAgICAgcGFyc2Uuc2VsLmhlYWQgPT0gcGFyc2Uuc2VsLmFuY2hvcikge1xuICAgICAgICBsZXQgc2l6ZSA9IGNoYW5nZS5lbmRCIC0gY2hhbmdlLnN0YXJ0O1xuICAgICAgICBwYXJzZS5zZWwgPSB7IGFuY2hvcjogcGFyc2Uuc2VsLmFuY2hvciArIHNpemUsIGhlYWQ6IHBhcnNlLnNlbC5hbmNob3IgKyBzaXplIH07XG4gICAgfVxuICAgIHZpZXcuaW5wdXQuZG9tQ2hhbmdlQ291bnQrKztcbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgb3ZlcndyaXRpbmcgYSBzZWxlY3Rpb24gYnkgdHlwaW5nIG1hdGNoZXNcbiAgICAvLyB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBzZWxlY3RlZCBjb250ZW50LCBjcmVhdGluZyBhIGNoYW5nZVxuICAgIC8vIHRoYXQncyBzbWFsbGVyIHRoYW4gd2hhdCB3YXMgYWN0dWFsbHkgb3ZlcndyaXR0ZW4uXG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJlxuICAgICAgICBjaGFuZ2Uuc3RhcnQgPT0gY2hhbmdlLmVuZEIgJiZcbiAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjaGFuZ2Uuc3RhcnQgPiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICYmIGNoYW5nZS5zdGFydCA8PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tICsgMiAmJlxuICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+PSBwYXJzZS5mcm9tKSB7XG4gICAgICAgICAgICBjaGFuZ2Uuc3RhcnQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS5lbmRBIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiYgY2hhbmdlLmVuZEEgPj0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8PSBwYXJzZS50bykge1xuICAgICAgICAgICAgY2hhbmdlLmVuZEIgKz0gKHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gY2hhbmdlLmVuZEEpO1xuICAgICAgICAgICAgY2hhbmdlLmVuZEEgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJRTExIHdpbGwgaW5zZXJ0IGEgbm9uLWJyZWFraW5nIHNwYWNlIF9haGVhZF8gb2YgdGhlIHNwYWNlIGFmdGVyXG4gICAgLy8gdGhlIGN1cnNvciBzcGFjZSB3aGVuIGFkZGluZyBhIHNwYWNlIGJlZm9yZSBhbm90aGVyIHNwYWNlLiBXaGVuXG4gICAgLy8gdGhhdCBoYXBwZW5lZCwgYWRqdXN0IHRoZSBjaGFuZ2UgdG8gY292ZXIgdGhlIHNwYWNlIGluc3RlYWQuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0ICsgMSAmJlxuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2Uuc3RhcnQgJiYgY2hhbmdlLnN0YXJ0ID4gcGFyc2UuZnJvbSAmJlxuICAgICAgICBwYXJzZS5kb2MudGV4dEJldHdlZW4oY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSAtIDEsIGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gKyAxKSA9PSBcIiBcXHUwMGEwXCIpIHtcbiAgICAgICAgY2hhbmdlLnN0YXJ0LS07XG4gICAgICAgIGNoYW5nZS5lbmRBLS07XG4gICAgICAgIGNoYW5nZS5lbmRCLS07XG4gICAgfVxuICAgIGxldCAkZnJvbSA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgbGV0ICRmcm9tQSA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCk7XG4gICAgbGV0IGlubGluZUNoYW5nZSA9ICRmcm9tLnNhbWVQYXJlbnQoJHRvKSAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkZnJvbUEuZW5kKCkgPj0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IG5leHRTZWw7XG4gICAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIHRoZSBlZmZlY3Qgb2YgcHJlc3NpbmcgRW50ZXIgKG9yIHdhcyByZWNvcmRlZFxuICAgIC8vIGFzIGJlaW5nIGFuIGlPUyBlbnRlciBwcmVzcyksIGp1c3QgZGlzcGF0Y2ggYW4gRW50ZXIga2V5IGluc3RlYWQuXG4gICAgaWYgKCgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSAmJlxuICAgICAgICAoIWlubGluZUNoYW5nZSB8fCBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVOYW1lID09IFwiRElWXCIgfHwgbi5ub2RlTmFtZSA9PSBcIlBcIikpKSB8fFxuICAgICAgICAoIWlubGluZUNoYW5nZSAmJiAkZnJvbS5wb3MgPCBwYXJzZS5kb2MuY29udGVudC5zaXplICYmXG4gICAgICAgICAgICAobmV4dFNlbCA9IFNlbGVjdGlvbi5maW5kRnJvbShwYXJzZS5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSwgMSwgdHJ1ZSkpICYmXG4gICAgICAgICAgICBuZXh0U2VsLmhlYWQgPT0gJHRvLnBvcykpICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpKSB7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTYW1lIGZvciBiYWNrc3BhY2VcbiAgICBpZiAodmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yID4gY2hhbmdlLnN0YXJ0ICYmXG4gICAgICAgIGxvb2tzTGlrZUpvaW4oZG9jLCBjaGFuZ2Uuc3RhcnQsIGNoYW5nZS5lbmRBLCAkZnJvbSwgJHRvKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoOCwgXCJCYWNrc3BhY2VcIikpKSkge1xuICAgICAgICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUpXG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpOyAvLyAjODIwXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBvY2Nhc2lvbmFsbHksIGR1cmluZyBjb21wb3NpdGlvbiwgZGVsZXRlIHRoZVxuICAgIC8vIGVudGlyZSBjb21wb3NpdGlvbiBhbmQgdGhlbiBpbW1lZGlhdGVseSBpbnNlcnQgaXQgYWdhaW4uIFRoaXMgaXNcbiAgICAvLyB1c2VkIHRvIGRldGVjdCB0aGF0IHNpdHVhdGlvbi5cbiAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0KVxuICAgICAgICB2aWV3LmlucHV0Lmxhc3RBbmRyb2lkRGVsZXRlID0gRGF0ZS5ub3coKTtcbiAgICAvLyBUaGlzIHRyaWVzIHRvIGRldGVjdCBBbmRyb2lkIHZpcnR1YWwga2V5Ym9hcmRcbiAgICAvLyBlbnRlci1hbmQtcGljay1zdWdnZXN0aW9uIGFjdGlvbi4gVGhhdCBzb21ldGltZXMgKHNlZSBpc3N1ZVxuICAgIC8vICMxMDU5KSBmaXJzdCBmaXJlcyBhIERPTSBtdXRhdGlvbiwgYmVmb3JlIG1vdmluZyB0aGUgc2VsZWN0aW9uIHRvXG4gICAgLy8gdGhlIG5ld2x5IGNyZWF0ZWQgYmxvY2suIEFuZCB0aGVuLCBiZWNhdXNlIFByb3NlTWlycm9yIGNsZWFucyB1cFxuICAgIC8vIHRoZSBET00gc2VsZWN0aW9uLCBpdCBnaXZlcyB1cCBtb3ZpbmcgdGhlIHNlbGVjdGlvbiBlbnRpcmVseSxcbiAgICAvLyBsZWF2aW5nIHRoZSBjdXJzb3IgaW4gdGhlIHdyb25nIHBsYWNlLiBXaGVuIHRoYXQgaGFwcGVucywgd2UgZHJvcFxuICAgIC8vIHRoZSBuZXcgcGFyYWdyYXBoIGZyb20gdGhlIGluaXRpYWwgY2hhbmdlLCBhbmQgZmlyZSBhIHNpbXVsYXRlZFxuICAgIC8vIGVudGVyIGtleSBhZnRlcndhcmRzLlxuICAgIGlmIChhbmRyb2lkICYmICFpbmxpbmVDaGFuZ2UgJiYgJGZyb20uc3RhcnQoKSAhPSAkdG8uc3RhcnQoKSAmJiAkdG8ucGFyZW50T2Zmc2V0ID09IDAgJiYgJGZyb20uZGVwdGggPT0gJHRvLmRlcHRoICYmXG4gICAgICAgIHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yID09IHBhcnNlLnNlbC5oZWFkICYmIHBhcnNlLnNlbC5oZWFkID09IGNoYW5nZS5lbmRBKSB7XG4gICAgICAgIGNoYW5nZS5lbmRCIC09IDI7XG4gICAgICAgICR0byA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKTsgfSk7XG4gICAgICAgIH0sIDIwKTtcbiAgICB9XG4gICAgbGV0IGNoRnJvbSA9IGNoYW5nZS5zdGFydCwgY2hUbyA9IGNoYW5nZS5lbmRBO1xuICAgIGxldCB0ciwgc3RvcmVkTWFya3MsIG1hcmtDaGFuZ2U7XG4gICAgaWYgKGlubGluZUNoYW5nZSkge1xuICAgICAgICBpZiAoJGZyb20ucG9zID09ICR0by5wb3MpIHsgLy8gRGVsZXRpb25cbiAgICAgICAgICAgIC8vIElFMTEgc29tZXRpbWVzIHdlaXJkbHkgbW92ZXMgdGhlIERPTSBzZWxlY3Rpb24gYXJvdW5kIGFmdGVyXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBvdXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSB0ZXh0YmxvY2tcbiAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICRmcm9tLnBhcmVudE9mZnNldCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNlbGVjdGlvblRvRE9NKHZpZXcpLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHIuZGVsZXRlKGNoRnJvbSwgY2hUbyk7XG4gICAgICAgICAgICBzdG9yZWRNYXJrcyA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCkubWFya3NBY3Jvc3MoZG9jLnJlc29sdmUoY2hhbmdlLmVuZEEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggLy8gQWRkaW5nIG9yIHJlbW92aW5nIGEgbWFya1xuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2UuZW5kQiAmJlxuICAgICAgICAgICAgKG1hcmtDaGFuZ2UgPSBpc01hcmtDaGFuZ2UoJGZyb20ucGFyZW50LmNvbnRlbnQuY3V0KCRmcm9tLnBhcmVudE9mZnNldCwgJHRvLnBhcmVudE9mZnNldCksICRmcm9tQS5wYXJlbnQuY29udGVudC5jdXQoJGZyb21BLnBhcmVudE9mZnNldCwgY2hhbmdlLmVuZEEgLSAkZnJvbUEuc3RhcnQoKSkpKSkge1xuICAgICAgICAgICAgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgICAgICAgICAgaWYgKG1hcmtDaGFuZ2UudHlwZSA9PSBcImFkZFwiKVxuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoY2hGcm9tLCBjaFRvLCBtYXJrQ2hhbmdlLm1hcmspO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsoY2hGcm9tLCBjaFRvLCBtYXJrQ2hhbmdlLm1hcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRmcm9tLnBhcmVudC5jaGlsZCgkZnJvbS5pbmRleCgpKS5pc1RleHQgJiYgJGZyb20uaW5kZXgoKSA9PSAkdG8uaW5kZXgoKSAtICgkdG8udGV4dE9mZnNldCA/IDAgOiAxKSkge1xuICAgICAgICAgICAgLy8gQm90aCBwb3NpdGlvbnMgaW4gdGhlIHNhbWUgdGV4dCBub2RlIC0tIHNpbXBseSBpbnNlcnQgdGV4dFxuICAgICAgICAgICAgbGV0IHRleHQgPSAkZnJvbS5wYXJlbnQudGV4dEJldHdlZW4oJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlVGV4dElucHV0XCIsIGYgPT4gZih2aWV3LCBjaEZyb20sIGNoVG8sIHRleHQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0ciA9IHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0LCBjaEZyb20sIGNoVG8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghdHIpXG4gICAgICAgIHRyID0gdmlldy5zdGF0ZS50ci5yZXBsYWNlKGNoRnJvbSwgY2hUbywgcGFyc2UuZG9jLnNsaWNlKGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20sIGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSkpO1xuICAgIGlmIChwYXJzZS5zZWwpIHtcbiAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdHIuZG9jLCBwYXJzZS5zZWwpO1xuICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIHNvbWV0aW1lcywgZHVyaW5nIGNvbXBvc2l0aW9uLCByZXBvcnQgdGhlXG4gICAgICAgIC8vIHNlbGVjdGlvbiBpbiB0aGUgd3JvbmcgcGxhY2UuIElmIGl0IGxvb2tzIGxpa2UgdGhhdCBpc1xuICAgICAgICAvLyBoYXBwZW5pbmcsIGRvbid0IHVwZGF0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAvLyBFZGdlIGp1c3QgZG9lc24ndCBtb3ZlIHRoZSBjdXJzb3IgZm9yd2FyZCB3aGVuIHlvdSBzdGFydCB0eXBpbmdcbiAgICAgICAgLy8gaW4gYW4gZW1wdHkgYmxvY2sgb3IgYmV0d2VlbiBiciBub2Rlcy5cbiAgICAgICAgaWYgKHNlbCAmJiAhKGNocm9tZSAmJiBhbmRyb2lkICYmIHZpZXcuY29tcG9zaW5nICYmIHNlbC5lbXB0eSAmJlxuICAgICAgICAgICAgKGNoYW5nZS5zdGFydCAhPSBjaGFuZ2UuZW5kQiB8fCB2aWV3LmlucHV0Lmxhc3RBbmRyb2lkRGVsZXRlIDwgRGF0ZS5ub3coKSAtIDEwMCkgJiZcbiAgICAgICAgICAgIChzZWwuaGVhZCA9PSBjaEZyb20gfHwgc2VsLmhlYWQgPT0gdHIubWFwcGluZy5tYXAoY2hUbykgLSAxKSB8fFxuICAgICAgICAgICAgaWUgJiYgc2VsLmVtcHR5ICYmIHNlbC5oZWFkID09IGNoRnJvbSkpXG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICB9XG4gICAgaWYgKHN0b3JlZE1hcmtzKVxuICAgICAgICB0ci5lbnN1cmVNYXJrcyhzdG9yZWRNYXJrcyk7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKVxuICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgdmlldy5pbnB1dC5jb21wb3NpdGlvbklEKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCBkb2MsIHBhcnNlZFNlbCkge1xuICAgIGlmIChNYXRoLm1heChwYXJzZWRTZWwuYW5jaG9yLCBwYXJzZWRTZWwuaGVhZCkgPiBkb2MuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuYW5jaG9yKSwgZG9jLnJlc29sdmUocGFyc2VkU2VsLmhlYWQpKTtcbn1cbi8vIEdpdmVuIHR3byBzYW1lLWxlbmd0aCwgbm9uLWVtcHR5IGZyYWdtZW50cyBvZiBpbmxpbmUgY29udGVudCxcbi8vIGRldGVybWluZSB3aGV0aGVyIHRoZSBmaXJzdCBjb3VsZCBiZSBjcmVhdGVkIGZyb20gdGhlIHNlY29uZCBieVxuLy8gcmVtb3Zpbmcgb3IgYWRkaW5nIGEgc2luZ2xlIG1hcmsgdHlwZS5cbmZ1bmN0aW9uIGlzTWFya0NoYW5nZShjdXIsIHByZXYpIHtcbiAgICBsZXQgY3VyTWFya3MgPSBjdXIuZmlyc3RDaGlsZC5tYXJrcywgcHJldk1hcmtzID0gcHJldi5maXJzdENoaWxkLm1hcmtzO1xuICAgIGxldCBhZGRlZCA9IGN1ck1hcmtzLCByZW1vdmVkID0gcHJldk1hcmtzLCB0eXBlLCBtYXJrLCB1cGRhdGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2TWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgIGFkZGVkID0gcHJldk1hcmtzW2ldLnJlbW92ZUZyb21TZXQoYWRkZWQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlbW92ZWQgPSBjdXJNYXJrc1tpXS5yZW1vdmVGcm9tU2V0KHJlbW92ZWQpO1xuICAgIGlmIChhZGRlZC5sZW5ndGggPT0gMSAmJiByZW1vdmVkLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIG1hcmsgPSBhZGRlZFswXTtcbiAgICAgICAgdHlwZSA9IFwiYWRkXCI7XG4gICAgICAgIHVwZGF0ZSA9IChub2RlKSA9PiBub2RlLm1hcmsobWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFkZGVkLmxlbmd0aCA9PSAwICYmIHJlbW92ZWQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgbWFyayA9IHJlbW92ZWRbMF07XG4gICAgICAgIHR5cGUgPSBcInJlbW92ZVwiO1xuICAgICAgICB1cGRhdGUgPSAobm9kZSkgPT4gbm9kZS5tYXJrKG1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHVwZGF0ZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICB1cGRhdGVkLnB1c2godXBkYXRlKHByZXYuY2hpbGQoaSkpKTtcbiAgICBpZiAoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKS5lcShjdXIpKVxuICAgICAgICByZXR1cm4geyBtYXJrLCB0eXBlIH07XG59XG5mdW5jdGlvbiBsb29rc0xpa2VKb2luKG9sZCwgc3RhcnQsIGVuZCwgJG5ld1N0YXJ0LCAkbmV3RW5kKSB7XG4gICAgaWYgKCEkbmV3U3RhcnQucGFyZW50LmlzVGV4dGJsb2NrIHx8XG4gICAgICAgIC8vIFRoZSBjb250ZW50IG11c3QgaGF2ZSBzaHJ1bmtcbiAgICAgICAgZW5kIC0gc3RhcnQgPD0gJG5ld0VuZC5wb3MgLSAkbmV3U3RhcnQucG9zIHx8XG4gICAgICAgIC8vIG5ld0VuZCBtdXN0IHBvaW50IGRpcmVjdGx5IGF0IG9yIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGJsb2NrIHRoYXQgbmV3U3RhcnQgcG9pbnRzIGludG9cbiAgICAgICAgc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRuZXdTdGFydCwgdHJ1ZSwgZmFsc2UpIDwgJG5ld0VuZC5wb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHN0YXJ0ID0gb2xkLnJlc29sdmUoc3RhcnQpO1xuICAgIC8vIFN0YXJ0IG11c3QgYmUgYXQgdGhlIGVuZCBvZiBhIGJsb2NrXG4gICAgaWYgKCRzdGFydC5wYXJlbnRPZmZzZXQgPCAkc3RhcnQucGFyZW50LmNvbnRlbnQuc2l6ZSB8fCAhJHN0YXJ0LnBhcmVudC5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkbmV4dCA9IG9sZC5yZXNvbHZlKHNraXBDbG9zaW5nQW5kT3BlbmluZygkc3RhcnQsIHRydWUsIHRydWUpKTtcbiAgICAvLyBUaGUgbmV4dCB0ZXh0YmxvY2sgbXVzdCBzdGFydCBiZWZvcmUgZW5kIGFuZCBlbmQgbmVhciBpdFxuICAgIGlmICghJG5leHQucGFyZW50LmlzVGV4dGJsb2NrIHx8ICRuZXh0LnBvcyA+IGVuZCB8fFxuICAgICAgICBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5leHQsIHRydWUsIGZhbHNlKSA8IGVuZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFRoZSBmcmFnbWVudHMgYWZ0ZXIgdGhlIGpvaW4gcG9pbnQgbXVzdCBtYXRjaFxuICAgIHJldHVybiAkbmV3U3RhcnQucGFyZW50LmNvbnRlbnQuY3V0KCRuZXdTdGFydC5wYXJlbnRPZmZzZXQpLmVxKCRuZXh0LnBhcmVudC5jb250ZW50KTtcbn1cbmZ1bmN0aW9uIHNraXBDbG9zaW5nQW5kT3BlbmluZygkcG9zLCBmcm9tRW5kLCBtYXlPcGVuKSB7XG4gICAgbGV0IGRlcHRoID0gJHBvcy5kZXB0aCwgZW5kID0gZnJvbUVuZCA/ICRwb3MuZW5kKCkgOiAkcG9zLnBvcztcbiAgICB3aGlsZSAoZGVwdGggPiAwICYmIChmcm9tRW5kIHx8ICRwb3MuaW5kZXhBZnRlcihkZXB0aCkgPT0gJHBvcy5ub2RlKGRlcHRoKS5jaGlsZENvdW50KSkge1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgICBlbmQrKztcbiAgICAgICAgZnJvbUVuZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobWF5T3Blbikge1xuICAgICAgICBsZXQgbmV4dCA9ICRwb3Mubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkcG9zLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgIW5leHQuaXNMZWFmKSB7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIGZpbmREaWZmKGEsIGIsIHBvcywgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IHN0YXJ0ID0gYS5maW5kRGlmZlN0YXJ0KGIsIHBvcyk7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB7IGE6IGVuZEEsIGI6IGVuZEIgfSA9IGEuZmluZERpZmZFbmQoYiwgcG9zICsgYS5zaXplLCBwb3MgKyBiLnNpemUpO1xuICAgIGlmIChwcmVmZXJyZWRTaWRlID09IFwiZW5kXCIpIHtcbiAgICAgICAgbGV0IGFkanVzdCA9IE1hdGgubWF4KDAsIHN0YXJ0IC0gTWF0aC5taW4oZW5kQSwgZW5kQikpO1xuICAgICAgICBwcmVmZXJyZWRQb3MgLT0gZW5kQSArIGFkanVzdCAtIHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZW5kQSA8IHN0YXJ0ICYmIGEuc2l6ZSA8IGIuc2l6ZSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBzdGFydCAmJiBwcmVmZXJyZWRQb3MgPj0gZW5kQSA/IHN0YXJ0IC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgc3RhcnQgLT0gbW92ZTtcbiAgICAgICAgZW5kQiA9IHN0YXJ0ICsgKGVuZEIgLSBlbmRBKTtcbiAgICAgICAgZW5kQSA9IHN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIGlmIChlbmRCIDwgc3RhcnQpIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gc3RhcnQgJiYgcHJlZmVycmVkUG9zID49IGVuZEIgPyBzdGFydCAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIHN0YXJ0IC09IG1vdmU7XG4gICAgICAgIGVuZEEgPSBzdGFydCArIChlbmRBIC0gZW5kQik7XG4gICAgICAgIGVuZEIgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZEEsIGVuZEIgfTtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3NlcmlhbGl6ZUZvckNsaXBib2FyZCA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZDtcbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19wYXJzZUZyb21DbGlwYm9hcmQgPSBwYXJzZUZyb21DbGlwYm9hcmQ7XG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fZW5kQ29tcG9zaXRpb24gPSBlbmRDb21wb3NpdGlvbjtcbi8qKlxuQW4gZWRpdG9yIHZpZXcgbWFuYWdlcyB0aGUgRE9NIHN0cnVjdHVyZSB0aGF0IHJlcHJlc2VudHMgYW5cbmVkaXRhYmxlIGRvY3VtZW50LiBJdHMgc3RhdGUgYW5kIGJlaGF2aW9yIGFyZSBkZXRlcm1pbmVkIGJ5IGl0c1xuW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EaXJlY3RFZGl0b3JQcm9wcykuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdmlldy4gYHBsYWNlYCBtYXkgYmUgYSBET00gbm9kZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkXG4gICAgYmUgYXBwZW5kZWQgdG8sIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHBsYWNlIGl0IGludG8gdGhlIGRvY3VtZW50LFxuICAgIG9yIGFuIG9iamVjdCB3aG9zZSBgbW91bnRgIHByb3BlcnR5IGhvbGRzIHRoZSBub2RlIHRvIHVzZSBhcyB0aGVcbiAgICBkb2N1bWVudCBjb250YWluZXIuIElmIGl0IGlzIGBudWxsYCwgdGhlIGVkaXRvciB3aWxsIG5vdCBiZVxuICAgIGFkZGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlLCBwcm9wcykge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEtsdWRnZSB1c2VkIHRvIHdvcmsgYXJvdW5kIGEgQ2hyb21lIGJ1ZyBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya0N1cnNvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgSW5wdXRTdGF0ZTtcbiAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpblZpZXdzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhIGhhY2sgbm9kZSBpcyBuZWVkZWQgaW4gRmlyZWZveCB0byBwcmV2ZW50IHRoZVxuICAgICAgICBbc3BhY2UgaXMgZWF0ZW4gaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Qcm9zZU1pcnJvci9wcm9zZW1pcnJvci9pc3N1ZXMvNjUxKVxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZW4gZWRpdG9yIGNvbnRlbnQgaXMgYmVpbmcgZHJhZ2dlZCwgdGhpcyBvYmplY3QgY29udGFpbnNcbiAgICAgICAgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRyYWdnZWQgc2xpY2UgYW5kIHdoZXRoZXIgaXQgaXMgYmVpbmdcbiAgICAgICAgY29waWVkIG9yIG1vdmVkLiBBdCBhbnkgb3RoZXIgdGltZSwgaXQgaXMgbnVsbC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBwcm9wcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucyB8fCBbXTtcbiAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZG9tID0gKHBsYWNlICYmIHBsYWNlLm1vdW50KSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpZiAocGxhY2UpIHtcbiAgICAgICAgICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZClcbiAgICAgICAgICAgICAgICBwbGFjZS5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGxhY2UgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHBsYWNlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYWNlLm1vdW50KVxuICAgICAgICAgICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGdldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB1cGRhdGVDdXJzb3JXcmFwcGVyKHRoaXMpO1xuICAgICAgICB0aGlzLm5vZGVWaWV3cyA9IGJ1aWxkTm9kZVZpZXdzKHRoaXMpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyh0aGlzLnN0YXRlLmRvYywgY29tcHV0ZURvY0RlY28odGhpcyksIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMsIChmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKSA9PiByZWFkRE9NQ2hhbmdlKHRoaXMsIGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICBpbml0SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSG9sZHMgYHRydWVgIHdoZW4gYVxuICAgIFtjb21wb3NpdGlvbl0oaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3VpZXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHMpXG4gICAgaXMgYWN0aXZlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXQuY29tcG9zaW5nOyB9XG4gICAgLyoqXG4gICAgVGhlIHZpZXcncyBjdXJyZW50IFtwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMpLlxuICAgICovXG4gICAgZ2V0IHByb3BzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvcHMuc3RhdGUgIT0gdGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLl9wcm9wcztcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcHNbbmFtZV0gPSBwcmV2W25hbWVdO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3J3MgcHJvcHMuIFdpbGwgaW1tZWRpYXRlbHkgY2F1c2UgYW4gdXBkYXRlIHRvXG4gICAgdGhlIERPTS5cbiAgICAqL1xuICAgIHVwZGF0ZShwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuaGFuZGxlRE9NRXZlbnRzICE9IHRoaXMuX3Byb3BzLmhhbmRsZURPTUV2ZW50cylcbiAgICAgICAgICAgIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgbGV0IHByZXZQcm9wcyA9IHRoaXMuX3Byb3BzO1xuICAgICAgICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAgICAgICBpZiAocHJvcHMucGx1Z2lucykge1xuICAgICAgICAgICAgcHJvcHMucGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RQbHVnaW5zID0gcHJvcHMucGx1Z2lucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlSW5uZXIocHJvcHMuc3RhdGUsIHByZXZQcm9wcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBieSB1cGRhdGluZyBleGlzdGluZyBwcm9wcyBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0XG4gICAgZ2l2ZW4gYXMgYXJndW1lbnQuIEVxdWl2YWxlbnQgdG8gYHZpZXcudXBkYXRlKE9iamVjdC5hc3NpZ24oe30sXG4gICAgdmlldy5wcm9wcywgcHJvcHMpKWAuXG4gICAgKi9cbiAgICBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuX3Byb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHRoaXMuX3Byb3BzW25hbWVdO1xuICAgICAgICB1cGRhdGVkLnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wcylcbiAgICAgICAgICAgIHVwZGF0ZWRbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICAgICAgdGhpcy51cGRhdGUodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgZWRpdG9yJ3MgYHN0YXRlYCBwcm9wLCB3aXRob3V0IHRvdWNoaW5nIGFueSBvZiB0aGVcbiAgICBvdGhlciBwcm9wcy5cbiAgICAqL1xuICAgIHVwZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihzdGF0ZSwgdGhpcy5fcHJvcHMpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCBwcmV2UHJvcHMpIHtcbiAgICAgICAgbGV0IHByZXYgPSB0aGlzLnN0YXRlLCByZWRyYXcgPSBmYWxzZSwgdXBkYXRlU2VsID0gZmFsc2U7XG4gICAgICAgIC8vIFdoZW4gc3RvcmVkIG1hcmtzIGFyZSBhZGRlZCwgc3RvcCBjb21wb3NpdGlvbiwgc28gdGhhdCB0aGV5IGNhblxuICAgICAgICAvLyBiZSBkaXNwbGF5ZWQuXG4gICAgICAgIGlmIChzdGF0ZS5zdG9yZWRNYXJrcyAmJiB0aGlzLmNvbXBvc2luZykge1xuICAgICAgICAgICAgY2xlYXJDb21wb3NpdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBsZXQgcGx1Z2luc0NoYW5nZWQgPSBwcmV2LnBsdWdpbnMgIT0gc3RhdGUucGx1Z2lucyB8fCB0aGlzLl9wcm9wcy5wbHVnaW5zICE9IHByZXZQcm9wcy5wbHVnaW5zO1xuICAgICAgICBpZiAocGx1Z2luc0NoYW5nZWQgfHwgdGhpcy5fcHJvcHMucGx1Z2lucyAhPSBwcmV2UHJvcHMucGx1Z2lucyB8fCB0aGlzLl9wcm9wcy5ub2RlVmlld3MgIT0gcHJldlByb3BzLm5vZGVWaWV3cykge1xuICAgICAgICAgICAgbGV0IG5vZGVWaWV3cyA9IGJ1aWxkTm9kZVZpZXdzKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWROb2RlVmlld3Mobm9kZVZpZXdzLCB0aGlzLm5vZGVWaWV3cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVWaWV3cyA9IG5vZGVWaWV3cztcbiAgICAgICAgICAgICAgICByZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbHVnaW5zQ2hhbmdlZCB8fCBwcmV2UHJvcHMuaGFuZGxlRE9NRXZlbnRzICE9IHRoaXMuX3Byb3BzLmhhbmRsZURPTUV2ZW50cykge1xuICAgICAgICAgICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBnZXRFZGl0YWJsZSh0aGlzKTtcbiAgICAgICAgdXBkYXRlQ3Vyc29yV3JhcHBlcih0aGlzKTtcbiAgICAgICAgbGV0IGlubmVyRGVjbyA9IHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgb3V0ZXJEZWNvID0gY29tcHV0ZURvY0RlY28odGhpcyk7XG4gICAgICAgIGxldCBzY3JvbGwgPSBwcmV2LnBsdWdpbnMgIT0gc3RhdGUucGx1Z2lucyAmJiAhcHJldi5kb2MuZXEoc3RhdGUuZG9jKSA/IFwicmVzZXRcIlxuICAgICAgICAgICAgOiBzdGF0ZS5zY3JvbGxUb1NlbGVjdGlvbiA+IHByZXYuc2Nyb2xsVG9TZWxlY3Rpb24gPyBcInRvIHNlbGVjdGlvblwiIDogXCJwcmVzZXJ2ZVwiO1xuICAgICAgICBsZXQgdXBkYXRlRG9jID0gcmVkcmF3IHx8ICF0aGlzLmRvY1ZpZXcubWF0Y2hlc05vZGUoc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgIGlmICh1cGRhdGVEb2MgfHwgIXN0YXRlLnNlbGVjdGlvbi5lcShwcmV2LnNlbGVjdGlvbikpXG4gICAgICAgICAgICB1cGRhdGVTZWwgPSB0cnVlO1xuICAgICAgICBsZXQgb2xkU2Nyb2xsUG9zID0gc2Nyb2xsID09IFwicHJlc2VydmVcIiAmJiB1cGRhdGVTZWwgJiYgdGhpcy5kb20uc3R5bGUub3ZlcmZsb3dBbmNob3IgPT0gbnVsbCAmJiBzdG9yZVNjcm9sbFBvcyh0aGlzKTtcbiAgICAgICAgaWYgKHVwZGF0ZVNlbCkge1xuICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBhbiBpc3N1ZSBpbiBDaHJvbWUsIElFLCBhbmQgRWRnZSB3aGVyZSBjaGFuZ2luZ1xuICAgICAgICAgICAgLy8gdGhlIERPTSBhcm91bmQgYW4gYWN0aXZlIHNlbGVjdGlvbiBwdXRzIGl0IGludG8gYSBicm9rZW5cbiAgICAgICAgICAgIC8vIHN0YXRlIHdoZXJlIHRoZSB0aGluZyB0aGUgdXNlciBzZWVzIGRpZmZlcnMgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiByZXBvcnRlZCBieSB0aGUgU2VsZWN0aW9uIG9iamVjdCAoIzcxMCwgIzk3MyxcbiAgICAgICAgICAgIC8vICMxMDExLCAjMTAxMywgIzEwMzUpLlxuICAgICAgICAgICAgbGV0IGZvcmNlU2VsVXBkYXRlID0gdXBkYXRlRG9jICYmIChpZSB8fCBjaHJvbWUpICYmICF0aGlzLmNvbXBvc2luZyAmJlxuICAgICAgICAgICAgICAgICFwcmV2LnNlbGVjdGlvbi5lbXB0eSAmJiAhc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHByZXYuc2VsZWN0aW9uLCBzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZURvYykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIHRoYXQgdGhlIHNlbGVjdGlvbiBwb2ludHMgaW50byBpcyB3cml0dGVuIHRvLFxuICAgICAgICAgICAgICAgIC8vIENocm9tZSBzb21ldGltZXMgc3RhcnRzIG1pc3JlcG9ydGluZyB0aGUgc2VsZWN0aW9uLCBzbyB0aGlzXG4gICAgICAgICAgICAgICAgLy8gdHJhY2tzIHRoYXQgYW5kIGZvcmNlcyBhIHNlbGVjdGlvbiByZXNldCB3aGVuIG91ciB1cGRhdGVcbiAgICAgICAgICAgICAgICAvLyBkaWQgd3JpdGUgdG8gdGhlIG5vZGUuXG4gICAgICAgICAgICAgICAgbGV0IGNocm9tZUtsdWRnZSA9IGNocm9tZSA/ICh0aGlzLnRyYWNrV3JpdGVzID0gdGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpLmZvY3VzTm9kZSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZWRyYXcgfHwgIXRoaXMuZG9jVmlldy51cGRhdGUoc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZU91dGVyRGVjbyhbXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMuZG9tLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNocm9tZUtsdWRnZSAmJiAhdGhpcy50cmFja1dyaXRlcylcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VTZWxVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV29yayBhcm91bmQgZm9yIGFuIGlzc3VlIHdoZXJlIGFuIHVwZGF0ZSBhcnJpdmluZyByaWdodCBiZXR3ZWVuXG4gICAgICAgICAgICAvLyBhIERPTSBzZWxlY3Rpb24gY2hhbmdlIGFuZCB0aGUgXCJzZWxlY3Rpb25jaGFuZ2VcIiBldmVudCBmb3IgaXRcbiAgICAgICAgICAgIC8vIGNhbiBjYXVzZSBhIHNwdXJpb3VzIERPTSBzZWxlY3Rpb24gdXBkYXRlLCBkaXNydXB0aW5nIG1vdXNlXG4gICAgICAgICAgICAvLyBkcmFnIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIGlmIChmb3JjZVNlbFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAgICEodGhpcy5pbnB1dC5tb3VzZURvd24gJiYgdGhpcy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmVxKHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9ySW5SaWdodFBsYWNlKHRoaXMpKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMsIGZvcmNlU2VsVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bmNOb2RlU2VsZWN0aW9uKHRoaXMsIHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpblZpZXdzKHByZXYpO1xuICAgICAgICBpZiAoc2Nyb2xsID09IFwicmVzZXRcIikge1xuICAgICAgICAgICAgdGhpcy5kb20uc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY3JvbGwgPT0gXCJ0byBzZWxlY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZFNjcm9sbFBvcykge1xuICAgICAgICAgICAgcmVzZXRTY3JvbGxQb3Mob2xkU2Nyb2xsUG9zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjcm9sbFRvU2VsZWN0aW9uKCkge1xuICAgICAgICBsZXQgc3RhcnRET00gPSB0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkuZm9jdXNOb2RlO1xuICAgICAgICBpZiAodGhpcy5zb21lUHJvcChcImhhbmRsZVNjcm9sbFRvU2VsZWN0aW9uXCIsIGYgPT4gZih0aGlzKSkpIDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5kb2NWaWV3LmRvbUFmdGVyUG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmZyb20pO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0aGlzLmNvb3Jkc0F0UG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmhlYWQsIDEpLCBzdGFydERPTSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveVBsdWdpblZpZXdzKCkge1xuICAgICAgICBsZXQgdmlldztcbiAgICAgICAgd2hpbGUgKHZpZXcgPSB0aGlzLnBsdWdpblZpZXdzLnBvcCgpKVxuICAgICAgICAgICAgaWYgKHZpZXcuZGVzdHJveSlcbiAgICAgICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2luVmlld3MocHJldlN0YXRlKSB7XG4gICAgICAgIGlmICghcHJldlN0YXRlIHx8IHByZXZTdGF0ZS5wbHVnaW5zICE9IHRoaXMuc3RhdGUucGx1Z2lucyB8fCB0aGlzLmRpcmVjdFBsdWdpbnMgIT0gdGhpcy5wcmV2RGlyZWN0UGx1Z2lucykge1xuICAgICAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IHRoaXMuZGlyZWN0UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuc3RhdGUucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpblZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpblZpZXcgPSB0aGlzLnBsdWdpblZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5WaWV3LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luVmlldy51cGRhdGUodGhpcywgcHJldlN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzb21lUHJvcChwcm9wTmFtZSwgZikge1xuICAgICAgICBsZXQgcHJvcCA9IHRoaXMuX3Byb3BzICYmIHRoaXMuX3Byb3BzW3Byb3BOYW1lXSwgdmFsdWU7XG4gICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRpcmVjdFBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gdGhpcy5kaXJlY3RQbHVnaW5zW2ldLnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBsdWdpbnMgPSB0aGlzLnN0YXRlLnBsdWdpbnM7XG4gICAgICAgIGlmIChwbHVnaW5zKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwbHVnaW5zW2ldLnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGUgdmlldyBoYXMgZm9jdXMuXG4gICAgKi9cbiAgICBoYXNGb2N1cygpIHtcbiAgICAgICAgLy8gV29yayBhcm91bmQgSUUgbm90IGhhbmRsaW5nIGZvY3VzIGNvcnJlY3RseSBpZiByZXNpemUgaGFuZGxlcyBhcmUgc2hvd24uXG4gICAgICAgIC8vIElmIHRoZSBjdXJzb3IgaXMgaW5zaWRlIGFuIGVsZW1lbnQgd2l0aCByZXNpemUgaGFuZGxlcywgYWN0aXZlRWxlbWVudFxuICAgICAgICAvLyB3aWxsIGJlIHRoYXQgZWxlbWVudCBpbnN0ZWFkIG9mIHRoaXMuZG9tLlxuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIC8vIElmIGFjdGl2ZUVsZW1lbnQgaXMgd2l0aGluIHRoaXMuZG9tLCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBzZXR0aW5nIGBjb250ZW50ZWRpdGFibGVgIHRvIGZhbHNlIGluIGJldHdlZW4sIHRyZWF0IGl0IGFzIGZvY3VzZWQuXG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKG5vZGUgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKG5vZGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICYmIHRoaXMuZG9tICE9IG5vZGUgJiYgdGhpcy5kb20uY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gJ2ZhbHNlJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb207XG4gICAgfVxuICAgIC8qKlxuICAgIEZvY3VzIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmxlKVxuICAgICAgICAgICAgZm9jdXNQcmV2ZW50U2Nyb2xsKHRoaXMuZG9tKTtcbiAgICAgICAgc2VsZWN0aW9uVG9ET00odGhpcyk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBkb2N1bWVudCByb290IGluIHdoaWNoIHRoZSBlZGl0b3IgZXhpc3RzLiBUaGlzIHdpbGxcbiAgICB1c3VhbGx5IGJlIHRoZSB0b3AtbGV2ZWwgYGRvY3VtZW50YCwgYnV0IG1pZ2h0IGJlIGEgW3NoYWRvd1xuICAgIERPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvV2ViX0NvbXBvbmVudHMvU2hhZG93X0RPTSlcbiAgICByb290IGlmIHRoZSBlZGl0b3IgaXMgaW5zaWRlIG9uZS5cbiAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fcm9vdDtcbiAgICAgICAgaWYgKGNhY2hlZCA9PSBudWxsKVxuICAgICAgICAgICAgZm9yIChsZXQgc2VhcmNoID0gdGhpcy5kb20ucGFyZW50Tm9kZTsgc2VhcmNoOyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubm9kZVR5cGUgPT0gOSB8fCAoc2VhcmNoLm5vZGVUeXBlID09IDExICYmIHNlYXJjaC5ob3N0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlYXJjaC5nZXRTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VhcmNoKS5nZXRTZWxlY3Rpb24gPSAoKSA9PiBzZWFyY2gub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QgPSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkIHx8IGRvY3VtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBHaXZlbiBhIHBhaXIgb2Ygdmlld3BvcnQgY29vcmRpbmF0ZXMsIHJldHVybiB0aGUgZG9jdW1lbnRcbiAgICBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZW0uIE1heSByZXR1cm4gbnVsbCBpZiB0aGUgZ2l2ZW5cbiAgICBjb29yZGluYXRlcyBhcmVuJ3QgaW5zaWRlIG9mIHRoZSBlZGl0b3IuIFdoZW4gYW4gb2JqZWN0IGlzXG4gICAgcmV0dXJuZWQsIGl0cyBgcG9zYCBwcm9wZXJ0eSBpcyB0aGUgcG9zaXRpb24gbmVhcmVzdCB0byB0aGVcbiAgICBjb29yZGluYXRlcywgYW5kIGl0cyBgaW5zaWRlYCBwcm9wZXJ0eSBob2xkcyB0aGUgcG9zaXRpb24gb2YgdGhlXG4gICAgaW5uZXIgbm9kZSB0aGF0IHRoZSBwb3NpdGlvbiBmYWxscyBpbnNpZGUgb2YsIG9yIC0xIGlmIGl0IGlzIGF0XG4gICAgdGhlIHRvcCBsZXZlbCwgbm90IGluIGFueSBub2RlLlxuICAgICovXG4gICAgcG9zQXRDb29yZHMoY29vcmRzKSB7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSB2aWV3cG9ydCByZWN0YW5nbGUgYXQgYSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBgbGVmdGAgYW5kIGByaWdodGAgd2lsbCBiZSB0aGUgc2FtZSBudW1iZXIsIGFzIHRoaXMgcmV0dXJucyBhXG4gICAgZmxhdCBjdXJzb3ItaXNoIHJlY3RhbmdsZS4gSWYgdGhlIHBvc2l0aW9uIGlzIGJldHdlZW4gdHdvIHRoaW5nc1xuICAgIHRoYXQgYXJlbid0IGRpcmVjdGx5IGFkamFjZW50LCBgc2lkZWAgZGV0ZXJtaW5lcyB3aGljaCBlbGVtZW50XG4gICAgaXMgdXNlZC4gV2hlbiA8IDAsIHRoZSBlbGVtZW50IGJlZm9yZSB0aGUgcG9zaXRpb24gaXMgdXNlZCxcbiAgICBvdGhlcndpc2UgdGhlIGVsZW1lbnQgYWZ0ZXIuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNBdFBvcyh0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICBwb3NpdGlvbi4gV2hlbiBgc2lkZWAgaXMgbmVnYXRpdmUsIGZpbmQgdGhlIHBvc2l0aW9uIGFzIGNsb3NlIGFzXG4gICAgcG9zc2libGUgdG8gdGhlIGNvbnRlbnQgYmVmb3JlIHRoZSBwb3NpdGlvbi4gV2hlbiBwb3NpdGl2ZSxcbiAgICBwcmVmZXIgcG9zaXRpb25zIGNsb3NlIHRvIHRoZSBjb250ZW50IGFmdGVyIHRoZSBwb3NpdGlvbi4gV2hlblxuICAgIHplcm8sIHByZWZlciBhcyBzaGFsbG93IGEgcG9zaXRpb24gYXMgcG9zc2libGUuXG4gICAgXG4gICAgTm90ZSB0aGF0IHlvdSBzaG91bGQgKipub3QqKiBtdXRhdGUgdGhlIGVkaXRvcidzIGludGVybmFsIERPTSxcbiAgICBvbmx5IGluc3BlY3QgaXQgKGFuZCBldmVuIHRoYXQgaXMgdXN1YWxseSBub3QgbmVjZXNzYXJ5KS5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBub2RlIHRoYXQgcmVwcmVzZW50cyB0aGUgZG9jdW1lbnQgbm9kZSBhZnRlciB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbi4gTWF5IHJldHVybiBgbnVsbGAgd2hlbiB0aGUgcG9zaXRpb24gZG9lc24ndCBwb2ludFxuICAgIGluIGZyb250IG9mIGEgbm9kZSBvciBpZiB0aGUgbm9kZSBpcyBpbnNpZGUgYW4gb3BhcXVlIG5vZGUgdmlldy5cbiAgICBcbiAgICBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGFibGUgdG8gY2FsbCB0aGluZ3MgbGlrZVxuICAgIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG9uIHRoYXQgRE9NIG5vZGUuIERvICoqbm90KiogbXV0YXRlIHRoZVxuICAgIGVkaXRvciBET00gZGlyZWN0bHksIG9yIGFkZCBzdHlsaW5nIHRoaXMgd2F5LCBzaW5jZSB0aGF0IHdpbGwgYmVcbiAgICBpbW1lZGlhdGVseSBvdmVycmlkZW4gYnkgdGhlIGVkaXRvciBhcyBpdCByZWRyYXdzIHRoZSBub2RlLlxuICAgICovXG4gICAgbm9kZURPTShwb3MpIHtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmRvY1ZpZXcuZGVzY0F0KHBvcyk7XG4gICAgICAgIHJldHVybiBkZXNjID8gZGVzYy5ub2RlRE9NIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byBhIGdpdmVuIERPTVxuICAgIHBvc2l0aW9uLiAoV2hlbmV2ZXIgcG9zc2libGUsIGl0IGlzIHByZWZlcmFibGUgdG8gaW5zcGVjdCB0aGVcbiAgICBkb2N1bWVudCBzdHJ1Y3R1cmUgZGlyZWN0bHksIHJhdGhlciB0aGFuIHBva2luZyBhcm91bmQgaW4gdGhlXG4gICAgRE9NLCBidXQgc29tZXRpbWVz4oCUZm9yIGV4YW1wbGUgd2hlbiBpbnRlcnByZXRpbmcgYW4gZXZlbnRcbiAgICB0YXJnZXTigJR5b3UgZG9uJ3QgaGF2ZSBhIGNob2ljZS4pXG4gICAgXG4gICAgVGhlIGBiaWFzYCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gaW5mbHVlbmNlIHdoaWNoIHNpZGUgb2YgYSBET01cbiAgICBub2RlIHRvIHVzZSB3aGVuIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgYSBsZWFmIG5vZGUuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQsIGJpYXMgPSAtMSkge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJET00gcG9zaXRpb24gbm90IGluc2lkZSB0aGUgZWRpdG9yXCIpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIG91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jayB3aGVuXG4gICAgbW92aW5nIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLiBXaGVuLCBmb3IgZXhhbXBsZSwgZ2l2ZW4gYFwibGVmdFwiYCxcbiAgICBpdCB3aWxsIHJldHVybiB0cnVlIGlmIG1vdmluZyBsZWZ0IGZyb20gdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgcG9zaXRpb24gd291bGQgbGVhdmUgdGhhdCBwb3NpdGlvbidzIHBhcmVudCB0ZXh0YmxvY2suIFdpbGwgYXBwbHlcbiAgICB0byB0aGUgdmlldydzIGN1cnJlbnQgc3RhdGUgYnkgZGVmYXVsdCwgYnV0IGl0IGlzIHBvc3NpYmxlIHRvXG4gICAgcGFzcyBhIGRpZmZlcmVudCBzdGF0ZS5cbiAgICAqL1xuICAgIGVuZE9mVGV4dGJsb2NrKGRpciwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGVuZE9mVGV4dGJsb2NrKHRoaXMsIHN0YXRlIHx8IHRoaXMuc3RhdGUsIGRpcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biB0aGUgZWRpdG9yJ3MgcGFzdGUgbG9naWMgd2l0aCB0aGUgZ2l2ZW4gSFRNTCBzdHJpbmcuIFRoZVxuICAgIGBldmVudGAsIGlmIGdpdmVuLCB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICBbYGhhbmRsZVBhc3RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuaGFuZGxlUGFzdGUpIGhvb2suXG4gICAgKi9cbiAgICBwYXN0ZUhUTUwoaHRtbCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFzdGUodGhpcywgXCJcIiwgaHRtbCwgZmFsc2UsIGV2ZW50IHx8IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIHRoZSBlZGl0b3IncyBwYXN0ZSBsb2dpYyB3aXRoIHRoZSBnaXZlbiBwbGFpbi10ZXh0IGlucHV0LlxuICAgICovXG4gICAgcGFzdGVUZXh0KHRleHQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkb1Bhc3RlKHRoaXMsIHRleHQsIG51bGwsIHRydWUsIGV2ZW50IHx8IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgZWRpdG9yIGZyb20gdGhlIERPTSBhbmQgZGVzdHJveXMgYWxsIFtub2RlXG4gICAgdmlld3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KS5cbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5kb2NWaWV3KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZXN0cm95SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGUodGhpcy5zdGF0ZS5kb2MsIFtdLCB2aWV3RGVjb3JhdGlvbnModGhpcyksIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kb20udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgdHJ1ZSB3aGVuIHRoZSB2aWV3IGhhcyBiZWVuXG4gICAgW2Rlc3Ryb3llZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kZXN0cm95KSAoYW5kIHRodXMgc2hvdWxkIG5vdCBiZVxuICAgIHVzZWQgYW55bW9yZSkuXG4gICAgKi9cbiAgICBnZXQgaXNEZXN0cm95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcgPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNlZCBmb3IgdGVzdGluZy5cbiAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBEaXNwYXRjaCBhIHRyYW5zYWN0aW9uLiBXaWxsIGNhbGxcbiAgICBbYGRpc3BhdGNoVHJhbnNhY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5EaXJlY3RFZGl0b3JQcm9wcy5kaXNwYXRjaFRyYW5zYWN0aW9uKVxuICAgIHdoZW4gZ2l2ZW4sIGFuZCBvdGhlcndpc2UgZGVmYXVsdHMgdG8gYXBwbHlpbmcgdGhlIHRyYW5zYWN0aW9uIHRvXG4gICAgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGNhbGxpbmdcbiAgICBbYHVwZGF0ZVN0YXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy51cGRhdGVTdGF0ZSkgd2l0aCB0aGUgcmVzdWx0LlxuICAgIFRoaXMgbWV0aG9kIGlzIGJvdW5kIHRvIHRoZSB2aWV3IGluc3RhbmNlLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgIGVhc2lseSBwYXNzZWQgYXJvdW5kLlxuICAgICovXG4gICAgZGlzcGF0Y2godHIpIHtcbiAgICAgICAgbGV0IGRpc3BhdGNoVHJhbnNhY3Rpb24gPSB0aGlzLl9wcm9wcy5kaXNwYXRjaFRyYW5zYWN0aW9uO1xuICAgICAgICBpZiAoZGlzcGF0Y2hUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB0cik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5zdGF0ZS5hcHBseSh0cikpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbVNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICByZXR1cm4gc2FmYXJpICYmIHRoaXMucm9vdC5ub2RlVHlwZSA9PT0gMTEgJiYgZGVlcEFjdGl2ZUVsZW1lbnQodGhpcy5kb20ub3duZXJEb2N1bWVudCkgPT0gdGhpcy5kb21cbiAgICAgICAgICAgID8gc2FmYXJpU2hhZG93U2VsZWN0aW9uUmFuZ2UodGhpcykgOiB0aGlzLmRvbVNlbGVjdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbVNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlRG9jRGVjbyh2aWV3KSB7XG4gICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBhdHRycy5jbGFzcyA9IFwiUHJvc2VNaXJyb3JcIjtcbiAgICBhdHRycy5jb250ZW50ZWRpdGFibGUgPSBTdHJpbmcodmlldy5lZGl0YWJsZSk7XG4gICAgYXR0cnMudHJhbnNsYXRlID0gXCJub1wiO1xuICAgIHZpZXcuc29tZVByb3AoXCJhdHRyaWJ1dGVzXCIsIHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICBmb3IgKGxldCBhdHRyIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIgPT0gXCJjbGFzc1wiKVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5jbGFzcyArPSBcIiBcIiArIHZhbHVlW2F0dHJdO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyID09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5zdHlsZSA9IChhdHRycy5zdHlsZSA/IGF0dHJzLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbHVlW2F0dHJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYXR0cnNbYXR0cl0gJiYgYXR0ciAhPSBcImNvbnRlbnRlZGl0YWJsZVwiICYmIGF0dHIgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRyc1thdHRyXSA9IFN0cmluZyh2YWx1ZVthdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtEZWNvcmF0aW9uLm5vZGUoMCwgdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplLCBhdHRycyldO1xufVxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gICAgaWYgKHZpZXcubWFya0N1cnNvcikge1xuICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3Itc2VwYXJhdG9yXCI7XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcImFsdFwiLCBcIlwiKTtcbiAgICAgICAgdmlldy5jdXJzb3JXcmFwcGVyID0geyBkb20sIGRlY286IERlY29yYXRpb24ud2lkZ2V0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQsIGRvbSwgeyByYXc6IHRydWUsIG1hcmtzOiB2aWV3Lm1hcmtDdXJzb3IgfSkgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuY3Vyc29yV3JhcHBlciA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RWRpdGFibGUodmlldykge1xuICAgIHJldHVybiAhdmlldy5zb21lUHJvcChcImVkaXRhYmxlXCIsIHZhbHVlID0+IHZhbHVlKHZpZXcuc3RhdGUpID09PSBmYWxzZSk7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZChzZWwxLCBzZWwyKSB7XG4gICAgbGV0IGRlcHRoID0gTWF0aC5taW4oc2VsMS4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDEuaGVhZCksIHNlbDIuJGFuY2hvci5zaGFyZWREZXB0aChzZWwyLmhlYWQpKTtcbiAgICByZXR1cm4gc2VsMS4kYW5jaG9yLnN0YXJ0KGRlcHRoKSAhPSBzZWwyLiRhbmNob3Iuc3RhcnQoZGVwdGgpO1xufVxuZnVuY3Rpb24gYnVpbGROb2RlVmlld3Modmlldykge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZ1bmN0aW9uIGFkZChvYmopIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBvYmopXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHByb3ApKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gICAgdmlldy5zb21lUHJvcChcIm5vZGVWaWV3c1wiLCBhZGQpO1xuICAgIHZpZXcuc29tZVByb3AoXCJtYXJrVmlld3NcIiwgYWRkKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2hhbmdlZE5vZGVWaWV3cyhhLCBiKSB7XG4gICAgbGV0IG5BID0gMCwgbkIgPSAwO1xuICAgIGZvciAobGV0IHByb3AgaW4gYSkge1xuICAgICAgICBpZiAoYVtwcm9wXSAhPSBiW3Byb3BdKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIG5BKys7XG4gICAgfVxuICAgIGZvciAobGV0IF8gaW4gYilcbiAgICAgICAgbkIrKztcbiAgICByZXR1cm4gbkEgIT0gbkI7XG59XG5mdW5jdGlvbiBjaGVja1N0YXRlQ29tcG9uZW50KHBsdWdpbikge1xuICAgIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSB8fCBwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiB8fCBwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQbHVnaW5zIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgdmlldyBtdXN0IG5vdCBoYXZlIGEgc3RhdGUgY29tcG9uZW50XCIpO1xufVxuXG5leHBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0LCBFZGl0b3JWaWV3LCBfX2VuZENvbXBvc2l0aW9uLCBfX3BhcnNlRnJvbUNsaXBib2FyZCwgX19zZXJpYWxpemVGb3JDbGlwYm9hcmQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/prosemirror-view/dist/index.js\n')},"./node_modules/w3c-keyname/index.es.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base: function() { return /* binding */ base; },\n/* harmony export */   keyName: function() { return /* binding */ keyName; },\n/* harmony export */   shift: function() { return /* binding */ shift; }\n/* harmony export */ });\nvar base = {\n  8: "Backspace",\n  9: "Tab",\n  10: "Enter",\n  12: "NumLock",\n  13: "Enter",\n  16: "Shift",\n  17: "Control",\n  18: "Alt",\n  20: "CapsLock",\n  27: "Escape",\n  32: " ",\n  33: "PageUp",\n  34: "PageDown",\n  35: "End",\n  36: "Home",\n  37: "ArrowLeft",\n  38: "ArrowUp",\n  39: "ArrowRight",\n  40: "ArrowDown",\n  44: "PrintScreen",\n  45: "Insert",\n  46: "Delete",\n  59: ";",\n  61: "=",\n  91: "Meta",\n  92: "Meta",\n  106: "*",\n  107: "+",\n  108: ",",\n  109: "-",\n  110: ".",\n  111: "/",\n  144: "NumLock",\n  145: "ScrollLock",\n  160: "Shift",\n  161: "Shift",\n  162: "Control",\n  163: "Control",\n  164: "Alt",\n  165: "Alt",\n  173: "-",\n  186: ";",\n  187: "=",\n  188: ",",\n  189: "-",\n  190: ".",\n  191: "/",\n  192: "`",\n  219: "[",\n  220: "\\\\",\n  221: "]",\n  222: "\'"\n}\n\nvar shift = {\n  48: ")",\n  49: "!",\n  50: "@",\n  51: "#",\n  52: "$",\n  53: "%",\n  54: "^",\n  55: "&",\n  56: "*",\n  57: "(",\n  59: ":",\n  61: "+",\n  173: "_",\n  186: ":",\n  187: "+",\n  188: "<",\n  189: "_",\n  190: ">",\n  191: "?",\n  192: "~",\n  219: "{",\n  220: "|",\n  221: "}",\n  222: "\\""\n}\n\nvar chrome = typeof navigator != "undefined" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar gecko = typeof navigator != "undefined" && /Gecko\\/\\d+/.test(navigator.userAgent)\nvar mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != "undefined" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\nvar brokenModifierNames = mac || chrome && +chrome[1] < 57\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = "F" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn\'t have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nfunction keyName(event) {\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    ie && event.shiftKey && event.key && event.key.length == 1 ||\n    event.key == "Unidentified"\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || "Unidentified"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == "Esc") name = "Escape"\n  if (name == "Del") name = "Delete"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == "Left") name = "ArrowLeft"\n  if (name == "Up") name = "ArrowUp"\n  if (name == "Right") name = "ArrowRight"\n  if (name == "Down") name = "ArrowDown"\n  return name\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdzNjLWtleW5hbWUvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvamVjdC1ndWxwLy4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmVzLmpzPzY1Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIlxufVxuXG5leHBvcnQgdmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiXG59XG5cbnZhciBjaHJvbWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0Nocm9tZVxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVxudmFyIGdlY2tvID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9HZWNrb1xcL1xcZCsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXG52YXIgYnJva2VuTW9kaWZpZXJOYW1lcyA9IG1hYyB8fCBjaHJvbWUgJiYgK2Nocm9tZVsxXSA8IDU3XG5cbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykgYmFzZVs0OCArIGldID0gYmFzZVs5NiArIGldID0gU3RyaW5nKGkpXG5cbi8vIFRoZSBmdW5jdGlvbiBrZXlzXG5mb3IgKHZhciBpID0gMTsgaSA8PSAyNDsgaSsrKSBiYXNlW2kgKyAxMTFdID0gXCJGXCIgKyBpXG5cbi8vIEFuZCB0aGUgYWxwaGFiZXRpYyBrZXlzXG5mb3IgKHZhciBpID0gNjU7IGkgPD0gOTA7IGkrKykge1xuICBiYXNlW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMzIpXG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxufVxuXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXG5mb3IgKHZhciBjb2RlIGluIGJhc2UpIGlmICghc2hpZnQuaGFzT3duUHJvcGVydHkoY29kZSkpIHNoaWZ0W2NvZGVdID0gYmFzZVtjb2RlXVxuXG5leHBvcnQgZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xuICB2YXIgaWdub3JlS2V5ID0gYnJva2VuTW9kaWZpZXJOYW1lcyAmJiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSkgfHxcbiAgICBpZSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PSAxIHx8XG4gICAgZXZlbnQua2V5ID09IFwiVW5pZGVudGlmaWVkXCJcbiAgdmFyIG5hbWUgPSAoIWlnbm9yZUtleSAmJiBldmVudC5rZXkpIHx8XG4gICAgKGV2ZW50LnNoaWZ0S2V5ID8gc2hpZnQgOiBiYXNlKVtldmVudC5rZXlDb2RlXSB8fFxuICAgIGV2ZW50LmtleSB8fCBcIlVuaWRlbnRpZmllZFwiXG4gIC8vIEVkZ2Ugc29tZXRpbWVzIHByb2R1Y2VzIHdyb25nIG5hbWVzIChJc3N1ZSAjMylcbiAgaWYgKG5hbWUgPT0gXCJFc2NcIikgbmFtZSA9IFwiRXNjYXBlXCJcbiAgaWYgKG5hbWUgPT0gXCJEZWxcIikgbmFtZSA9IFwiRGVsZXRlXCJcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvODg2MDU3MS9cbiAgaWYgKG5hbWUgPT0gXCJMZWZ0XCIpIG5hbWUgPSBcIkFycm93TGVmdFwiXG4gIGlmIChuYW1lID09IFwiVXBcIikgbmFtZSA9IFwiQXJyb3dVcFwiXG4gIGlmIChuYW1lID09IFwiUmlnaHRcIikgbmFtZSA9IFwiQXJyb3dSaWdodFwiXG4gIGlmIChuYW1lID09IFwiRG93blwiKSBuYW1lID0gXCJBcnJvd0Rvd25cIlxuICByZXR1cm4gbmFtZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/w3c-keyname/index.es.js\n')}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var n=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g](n,n.exports,__webpack_require__),n.exports}__webpack_require__.d=function(g,I){for(var n in I)__webpack_require__.o(I,n)&&!__webpack_require__.o(g,n)&&Object.defineProperty(g,n,{enumerable:!0,get:I[n]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(g){if("object"==typeof window)return window}}(),__webpack_require__.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},__webpack_require__.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./source/js/pages/catalog.page.js")})();